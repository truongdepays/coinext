"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateKeyPair = generateKeyPair;
exports.generatePublicKey = generatePublicKey;
exports.sign = sign;
exports.aggregateSignatures = aggregateSignatures;
exports.aggregatePubkeys = aggregatePubkeys;
exports.verify = verify;
exports.verifyAggregate = verifyAggregate;
exports.verifyMultiple = verifyMultiple;
Object.defineProperty(exports, "Keypair", {
  enumerable: true,
  get: function get() {
    return _keypair.Keypair;
  }
});
Object.defineProperty(exports, "PrivateKey", {
  enumerable: true,
  get: function get() {
    return _privateKey.PrivateKey;
  }
});
Object.defineProperty(exports, "PublicKey", {
  enumerable: true,
  get: function get() {
    return _publicKey.PublicKey;
  }
});
Object.defineProperty(exports, "Signature", {
  enumerable: true,
  get: function get() {
    return _signature.Signature;
  }
});
Object.defineProperty(exports, "initBLS", {
  enumerable: true,
  get: function get() {
    return _context.init;
  }
});
exports.default = void 0;

var _keypair = require("./keypair");

var _privateKey = require("./privateKey");

var _publicKey = require("./publicKey");

var _signature = require("./signature");

var _constants = require("./constants");

var _assert = _interopRequireDefault(require("assert"));

var _context = require("./context");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBuffer(input) {
  return Buffer.from(input.buffer, input.byteOffset, input.length);
}
/**
 * Generates new secret and public key
 */


function generateKeyPair() {
  return _keypair.Keypair.generate();
}
/**
 * Generates public key from given secret.
 * @param {BLSSecretKey} secretKey
 */


function generatePublicKey(secretKey) {
  (0, _assert.default)(secretKey, "secretKey is null or undefined");
  const keypair = new _keypair.Keypair(_privateKey.PrivateKey.fromBytes(toBuffer(secretKey)));
  return keypair.publicKey.toBytesCompressed();
}
/**
 * Signs given message using secret key.
 * @param secretKey
 * @param messageHash
 */


function sign(secretKey, messageHash) {
  (0, _assert.default)(secretKey, "secretKey is null or undefined");
  (0, _assert.default)(messageHash, "messageHash is null or undefined");

  const privateKey = _privateKey.PrivateKey.fromBytes(toBuffer(secretKey));

  return privateKey.signMessage(toBuffer(messageHash)).toBytesCompressed();
}
/**
 * Compines all given signature into one.
 * @param signatures
 */


function aggregateSignatures(signatures) {
  (0, _assert.default)(signatures && signatures.length > 0, "signatures is null or undefined or empty array");
  return _signature.Signature.aggregate(signatures.map(signature => {
    return _signature.Signature.fromCompressedBytes(signature);
  })).toBytesCompressed();
}
/**
 * Combines all given public keys into single one
 * @param publicKeys
 */


function aggregatePubkeys(publicKeys) {
  (0, _assert.default)(publicKeys, "publicKeys is null or undefined");

  if (publicKeys.length === 0) {
    return Buffer.alloc(_constants.PUBLIC_KEY_LENGTH);
  }

  return publicKeys.map(p => _publicKey.PublicKey.fromBytes(toBuffer(p))).reduce((agg, pubKey) => agg.add(pubKey)).toBytesCompressed();
}
/**
 * Verifies if signature is message signed with given public key.
 * @param publicKey
 * @param messageHash
 * @param signature
 */


function verify(publicKey, messageHash, signature) {
  (0, _assert.default)(publicKey, "publicKey is null or undefined");
  (0, _assert.default)(messageHash, "messageHash is null or undefined");
  (0, _assert.default)(signature, "signature is null or undefined");

  try {
    return _publicKey.PublicKey.fromBytes(publicKey).verifyMessage(_signature.Signature.fromCompressedBytes(toBuffer(signature)), toBuffer(messageHash));
  } catch (e) {
    return false;
  }
}
/**
 * Verifies if aggregated signature is same message signed with given public keys.
 * @param publicKeys
 * @param messageHash
 * @param signature
 */


function verifyAggregate(publicKeys, messageHash, signature) {
  (0, _assert.default)(publicKeys, "publicKey is null or undefined");
  (0, _assert.default)(messageHash, "messageHash is null or undefined");
  (0, _assert.default)(signature, "signature is null or undefined");

  try {
    return _signature.Signature.fromCompressedBytes(signature).verifyAggregate(publicKeys.map(pubkey => _publicKey.PublicKey.fromBytes(pubkey)), messageHash);
  } catch (e) {
    return false;
  }
}
/**
 * Verifies if signature is list of message signed with corresponding public key.
 * @param publicKeys
 * @param messageHashes
 * @param signature
 * @param fast Check if all messages are different
 */


function verifyMultiple(publicKeys, messageHashes, signature, fast = false) {
  (0, _assert.default)(publicKeys, "publicKey is null or undefined");
  (0, _assert.default)(messageHashes, "messageHash is null or undefined");
  (0, _assert.default)(signature, "signature is null or undefined");

  if (publicKeys.length === 0 || publicKeys.length != messageHashes.length) {
    return false;
  }

  try {
    return _signature.Signature.fromCompressedBytes(toBuffer(signature)).verifyMultiple(publicKeys.map(key => _publicKey.PublicKey.fromBytes(toBuffer(key))), messageHashes.map(m => toBuffer(m)), fast);
  } catch (e) {
    return false;
  }
}

var _default = {
  generateKeyPair,
  generatePublicKey,
  sign,
  aggregateSignatures,
  aggregatePubkeys,
  verify,
  verifyAggregate,
  verifyMultiple
};
exports.default = _default;