import { BitGoRequest } from './api';
import * as utxolib from '@bitgo/utxo-lib';
import { EnvironmentName } from '@bitgo/sdk-core';
import { AccessTokenOptions, IRequestTracer, PingOptions, AuthenticateOptions, CalculateHmacSubjectOptions, CalculateRequestHeadersOptions, CalculateRequestHmacOptions, ProcessedAuthenticationOptions, RequestHeaders, VerifyResponseInfo, VerifyResponseOptions, BitGoAPIOptions, DecryptOptions, EncryptOptions, User, BitGoJson, VerifyPasswordOptions, TokenIssuanceResponse, TokenIssuance, RemoveAccessTokenOptions, AddAccessTokenOptions, GetUserOptions, UnlockOptions, ExtendTokenOptions, GetSharingKeyOptions } from './types';
export declare abstract class BitGoAPI {
    protected static _constants: any;
    protected static _constantsExpire: any;
    protected static _testnetWarningMessage: boolean;
    readonly env: EnvironmentName;
    protected readonly _baseUrl: string;
    protected readonly _baseApiUrl: string;
    protected readonly _baseApiUrlV2: string;
    protected readonly _env: EnvironmentName;
    protected readonly _authVersion: Exclude<BitGoAPIOptions['authVersion'], undefined>;
    protected _hmacVerification: boolean;
    protected readonly _proxy?: string;
    protected _user?: User;
    protected _extensionKey?: utxolib.ECPair.ECPairInterface;
    protected _reqId?: IRequestTracer;
    protected _token?: string;
    protected _version: string;
    protected _userAgent?: string;
    protected _ecdhXprv?: string;
    protected _refreshToken?: string;
    protected readonly _clientId?: string;
    protected readonly _clientSecret?: string;
    protected _validate: boolean;
    constructor(params?: BitGoAPIOptions);
    /**
     * Return the current BitGo environment
     */
    getEnv(): EnvironmentName;
    /**
     * Return the current auth version used for requests to the BitGo server
     */
    getAuthVersion(): number;
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    private requestPatch;
    get(url: string): BitGoRequest;
    post(url: string): BitGoRequest;
    put(url: string): BitGoRequest;
    del(url: string): BitGoRequest;
    patch(url: string): BitGoRequest;
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    calculateHMAC(key: string, message: string): string;
    /**
     * Calculate the subject string that is to be HMAC'ed for a HTTP request or response
     * @param urlPath request url, including query params
     * @param text request body text
     * @param timestamp request timestamp from `Date.now()`
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @param method request method
     * @returns {string}
     */
    calculateHMACSubject({ urlPath, text, timestamp, statusCode, method }: CalculateHmacSubjectOptions): string;
    /**
     * Calculate the HMAC for an HTTP request
     */
    calculateRequestHMAC({ url: urlPath, text, timestamp, token, method }: CalculateRequestHmacOptions): string;
    /**
     * Calculate request headers with HMAC
     */
    calculateRequestHeaders({ url, text, token, method }: CalculateRequestHeadersOptions): RequestHeaders;
    /**
     * Verify the HMAC for an HTTP response
     */
    verifyResponse({ url: urlPath, statusCode, text, timestamp, token, hmac, method, }: VerifyResponseOptions): VerifyResponseInfo;
    /**
     * Fetch useful constant values from the BitGo server.
     * These values do change infrequently, so they need to be fetched,
     * but are unlikely to change during the lifetime of a BitGo object,
     * so they can safely cached.
     */
    fetchConstants(): Promise<any>;
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    url(path: string, version?: number): string;
    /**
     * Create a url for calling BitGo microservice APIs
     */
    microservicesUrl(path: string): string;
    /**
     * Gets the version of the BitGoJS package
     */
    version(): string;
    /**
     * Test connectivity to the server
     * @param params
     */
    ping({ reqId }?: PingOptions): Promise<any>;
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    setRequestTracer(reqTracer: IRequestTracer): void;
    /**
     * Utility function to encrypt locally.
     */
    encrypt(params: EncryptOptions): string;
    /**
     * Decrypt an encrypted string locally.
     */
    decrypt(params: DecryptOptions): string;
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    toJSON(): BitGoJson;
    /**
     * Get the current user
     */
    user(): User | undefined;
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    fromJSON(json: BitGoJson): void;
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    preprocessAuthenticationParams({ username, password, otp, forceSMS, extensible, trust, }: AuthenticateOptions): ProcessedAuthenticationOptions;
    /**
     * Synchronous method for activating an access token.
     */
    authenticateWithAccessToken({ accessToken }: AccessTokenOptions): void;
    /**
     * Login to the bitgo platform.
     */
    authenticate(params: AuthenticateOptions): Promise<any>;
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    handleTokenIssuance(responseBody: TokenIssuanceResponse, password?: string): TokenIssuance;
    /**
     */
    verifyPassword(params?: VerifyPasswordOptions): Promise<any>;
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    clear(): void;
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    refreshToken(params?: {
        refreshToken?: string;
    }): Promise<any>;
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    listAccessTokens(): Promise<any>;
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    addAccessToken(params: AddAccessTokenOptions): Promise<any>;
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     */
    removeAccessToken({ id, label }: RemoveAccessTokenOptions): Promise<any>;
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    generateRandomPassword(numWords?: number): string;
    /**
     * Logout of BitGo
     */
    logout(): Promise<any>;
    /**
     * Get a user by ID (name/email only)
     * @param id
     *
     * @deprecated
     */
    getUser({ id }: GetUserOptions): Promise<any>;
    /**
     * Get the current logged in user
     */
    me(): Promise<any>;
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     */
    unlock({ otp, duration }: UnlockOptions): Promise<any>;
    /**
     * Lock the session
     */
    lock(): Promise<any>;
    /**
     * Get the current session
     */
    session(): Promise<any>;
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    sendOTP(params?: {
        forceSMS?: boolean;
    }): Promise<any>;
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     */
    extendToken(params?: ExtendTokenOptions): Promise<any>;
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     */
    getSharingKey({ email }: GetSharingKeyOptions): Promise<any>;
    /**
     *
     */
    getValidate(): boolean;
    /**
     *
     */
    setValidate(validate: boolean): void;
}
//# sourceMappingURL=bitgoAPI.d.ts.map