"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitGoAPI = void 0;
const _ = require("lodash");
const bip32 = require("bip32");
const secp256k1 = require("secp256k1");
const bs58 = require("bs58");
const bitcoinMessage = require("bitcoinjs-message");
const api_1 = require("./api");
const debug_1 = require("debug");
const superagent = require("superagent");
const urlLib = require("url");
const crypto_1 = require("crypto");
const utxolib = require("@bitgo/utxo-lib");
const sdk_core_1 = require("@bitgo/sdk-core");
const util_1 = require("./util");
const sjcl = require("@bitgo/sjcl");
const pjson = require("../package.json");
const encrypt_1 = require("./encrypt");
const bip32path_1 = require("./bip32path");
const debug = debug_1.default('bitgo:api');
if (!((_a = process) === null || _a === void 0 ? void 0 : _a.browser)) {
    debug('enabling superagent-proxy wrapper');
    require('superagent-proxy')(superagent);
}
const patchedRequestMethods = ['get', 'post', 'put', 'del', 'patch'];
class BitGoAPI {
    constructor(params = {}) {
        this._authVersion = 2;
        this._hmacVerification = true;
        this._version = pjson.version;
        if (!sdk_core_1.common.validateParams(params, [], [
            'accessToken',
            'userAgent',
            'customRootURI',
            'customBitcoinNetwork',
            'serverXpub',
            'stellarFederationServerUrl',
        ]) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        let env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            // for branch deploys, we want to be able to specify custom endpoints while still
            // maintaining the name of specified the environment
            env = params.env === 'branch' ? 'branch' : 'custom';
            if (params.customRootURI) {
                sdk_core_1.common.Environments[env].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                sdk_core_1.common.Environments[env].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                sdk_core_1.common.Environments[env].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                sdk_core_1.common.Environments[env].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                sdk_core_1.common.Environments[env].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        if (params.authVersion !== undefined) {
            this._authVersion = params.authVersion;
        }
        // if this env is an alias, swap it out with the equivalent supported environment
        if (env in sdk_core_1.AliasEnvironments) {
            env = sdk_core_1.AliasEnvironments[env];
        }
        if (env === 'custom' && _.isUndefined(sdk_core_1.common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (sdk_core_1.common.Environments[env]) {
                this._baseUrl = sdk_core_1.common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: prod, test, dev, latest');
            }
        }
        else {
            env = 'test';
            if (!BitGoAPI._testnetWarningMessage) {
                BitGoAPI._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = sdk_core_1.common.Environments[env].uri;
        }
        this._env = this.env = env;
        if (params.etherscanApiToken) {
            sdk_core_1.common.Environments[env].etherscanApiToken = params.etherscanApiToken;
        }
        sdk_core_1.common.setNetwork(sdk_core_1.common.Environments[env].network);
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._token = params.accessToken;
        this._userAgent = params.userAgent || 'BitGoJS/' + this.version();
        this._reqId = undefined;
        this._refreshToken = params.refreshToken;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        if (!params.hmacVerification && params.hmacVerification !== undefined) {
            if (sdk_core_1.common.Environments[env].hmacVerificationEnforced) {
                throw new Error(`Cannot disable request HMAC verification in environment ${this.getEnv()}`);
            }
            debug('HMAC verification explicitly disabled by constructor option');
            this._hmacVerification = params.hmacVerification;
        }
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        // capture outer stack so we have useful debug information if fetch constants fails
        const e = new Error();
        // Kick off first load of constants
        this.fetchConstants().catch((err) => {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * Return the current BitGo environment
     */
    getEnv() {
        return this._env;
    }
    /**
     * Return the current auth version used for requests to the BitGo server
     */
    getAuthVersion() {
        return this._authVersion;
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    requestPatch(method, url) {
        let req = superagent[method](url);
        if (this._proxy) {
            debug('proxying request through %s', this._proxy);
            req = req.proxy(this._proxy);
        }
        const originalThen = req.then.bind(req);
        req.then = (onfulfilled, onrejected) => {
            var _a, _b;
            // intercept a request before it's submitted to the server for v2 authentication (based on token)
            if (this._version) {
                // TODO - decide where to get version
                req.set('BitGo-SDK-Version', this._version);
            }
            if (!_.isUndefined(this._reqId)) {
                req.set('Request-ID', this._reqId.toString());
                // increment after setting the header so the sequence numbers start at 0
                this._reqId.inc();
                // request ids must be set before each request instead of being kept
                // inside the bitgo object. This is to prevent reentrancy issues where
                // multiple simultaneous requests could cause incorrect reqIds to be used
                delete this._reqId;
            }
            // prevent IE from caching requests
            req.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
            if (!process.browser && this._userAgent) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', this._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            // if there is no token, and we're not logged in, the request cannot be v2 authenticated
            req.isV2Authenticated = true;
            req.authenticationToken = this._token;
            // some of the older tokens appear to be only 40 characters long
            if ((this._token && this._token.length !== 67 && this._token.indexOf('v2x') !== 0) || req.forceV1Auth) {
                // use the old method
                req.isV2Authenticated = false;
                req.set('Authorization', 'Bearer ' + this._token);
                debug('sending v1 %s request to %s with token %s', method, url, (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
                return originalThen(onfulfilled).catch(onrejected);
            }
            req.set('BitGo-Auth-Version', this._authVersion === 3 ? '3.0' : '2.0');
            if (this._token) {
                const data = api_1.serializeRequestData(req);
                api_1.setRequestQueryString(req);
                const requestProperties = this.calculateRequestHeaders({
                    url: req.url,
                    token: this._token,
                    method,
                    text: data || '',
                });
                req.set('Auth-Timestamp', requestProperties.timestamp.toString());
                // we're not sending the actual token, but only its hash
                req.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                debug('sending v2 %s request to %s with token %s', method, url, (_b = this._token) === null || _b === void 0 ? void 0 : _b.substr(0, 8));
                // set the HMAC
                req.set('HMAC', requestProperties.hmac);
            }
            /**
             * Verify the response before calling the original onfulfilled handler,
             * and make sure onrejected is called if a verification error is encountered
             */
            const newOnFulfilled = onfulfilled
                ? (response) => {
                    // HMAC verification is only allowed to be skipped in certain environments.
                    // This is checked in the constructor, but checking it again at request time
                    // will help prevent against tampering of this property after the object is created
                    if (!this._hmacVerification && !sdk_core_1.common.Environments[this.getEnv()].hmacVerificationEnforced) {
                        return onfulfilled(response);
                    }
                    const verifiedResponse = api_1.verifyResponse(this, this._token, method, req, response);
                    return onfulfilled(verifiedResponse);
                }
                : null;
            return originalThen(newOnFulfilled).catch(onrejected);
        };
        return api_1.toBitgoRequest(req);
    }
    get(url) {
        return this.requestPatch('get', url);
    }
    post(url) {
        return this.requestPatch('post', url);
    }
    put(url) {
        return this.requestPatch('put', url);
    }
    del(url) {
        return this.requestPatch('del', url);
    }
    patch(url) {
        return this.requestPatch('patch', url);
    }
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    calculateHMAC(key, message) {
        return crypto_1.createHmac('sha256', key).update(message).digest('hex');
    }
    /**
     * Calculate the subject string that is to be HMAC'ed for a HTTP request or response
     * @param urlPath request url, including query params
     * @param text request body text
     * @param timestamp request timestamp from `Date.now()`
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @param method request method
     * @returns {string}
     */
    calculateHMACSubject({ urlPath, text, timestamp, statusCode, method }) {
        const urlDetails = urlLib.parse(urlPath);
        const queryPath = urlDetails.query && urlDetails.query.length > 0 ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            if (this._authVersion === 3) {
                return [method.toUpperCase(), timestamp, queryPath, statusCode, text].join('|');
            }
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        if (this._authVersion === 3) {
            return [method.toUpperCase(), timestamp, '3.0', queryPath, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    }
    /**
     * Calculate the HMAC for an HTTP request
     */
    calculateRequestHMAC({ url: urlPath, text, timestamp, token, method }) {
        const signatureSubject = this.calculateHMACSubject({ urlPath, text, timestamp, method });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    }
    /**
     * Calculate request headers with HMAC
     */
    calculateRequestHeaders({ url, text, token, method }) {
        const timestamp = Date.now();
        const hmac = this.calculateRequestHMAC({ url, text, timestamp, token, method });
        // calculate the SHA256 hash of the token
        const hashDigest = sjcl.hash.sha256.hash(token);
        const tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac,
            timestamp,
            tokenHash,
        };
    }
    /**
     * Verify the HMAC for an HTTP response
     */
    verifyResponse({ url: urlPath, statusCode, text, timestamp, token, hmac, method, }) {
        const signatureSubject = this.calculateHMACSubject({
            urlPath,
            text,
            timestamp,
            statusCode,
            method,
        });
        // calculate the HMAC
        const expectedHmac = this.calculateHMAC(token, signatureSubject);
        // determine if the response is still within the validity window (5 minute window)
        const now = Date.now();
        const isInResponseValidityWindow = timestamp >= now - 1000 * 60 * 5 && timestamp <= now;
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac,
            signatureSubject,
            isInResponseValidityWindow,
            verificationTime: now,
        };
    }
    /**
     * Fetch useful constant values from the BitGo server.
     * These values do change infrequently, so they need to be fetched,
     * but are unlikely to change during the lifetime of a BitGo object,
     * so they can safely cached.
     */
    async fetchConstants() {
        var _a, _b;
        const env = this.getEnv();
        if (!BitGoAPI._constants) {
            BitGoAPI._constants = {};
        }
        if (!BitGoAPI._constantsExpire) {
            BitGoAPI._constantsExpire = {};
        }
        if (BitGoAPI._constants[env] && BitGoAPI._constantsExpire[env] && new Date() < BitGoAPI._constantsExpire[env]) {
            return BitGoAPI._constants[env];
        }
        // client constants call cannot be authenticated using the normal HMAC validation
        // scheme, so we need to use a raw superagent instance to do this request.
        // Proxy settings must still be respected however
        const resultPromise = superagent.get(this.url('/client/constants'));
        const result = await (this._proxy ? resultPromise.proxy(this._proxy) : resultPromise);
        BitGoAPI._constants[env] = result.body.constants;
        if (((_a = result.body) === null || _a === void 0 ? void 0 : _a.ttl) && typeof ((_b = result.body) === null || _b === void 0 ? void 0 : _b.ttl) === 'number') {
            BitGoAPI._constantsExpire[env] = new Date(new Date().getTime() + result.body.ttl * 1000);
        }
        return BitGoAPI._constants[env];
    }
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    url(path, version = 1) {
        const baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    }
    /**
     * Create a url for calling BitGo microservice APIs
     */
    microservicesUrl(path) {
        return this._baseUrl + path;
    }
    /**
     * Gets the version of the BitGoJS package
     */
    version() {
        return this._version;
    }
    /**
     * Test connectivity to the server
     * @param params
     */
    ping({ reqId } = {}) {
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping')).result();
    }
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    setRequestTracer(reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    }
    /**
     * Utility function to encrypt locally.
     */
    encrypt(params) {
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot encrypt without password`);
        }
        return encrypt_1.encrypt(params.password, params.input);
    }
    /**
     * Decrypt an encrypted string locally.
     */
    decrypt(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot decrypt without password`);
        }
        try {
            return encrypt_1.decrypt(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes("ccm: tag doesn't match")) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    }
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    toJSON() {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
            ecdhXprv: this._ecdhXprv,
        };
    }
    /**
     * Get the current user
     */
    user() {
        return this._user;
    }
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    fromJSON(json) {
        this._user = json.user;
        this._token = json.token;
        this._ecdhXprv = json.ecdhXprv;
        if (json.extensionKey) {
            const network = sdk_core_1.common.Environments[this.getEnv()].network;
            this._extensionKey = utxolib.ECPair.fromWIF(json.extensionKey, utxolib.networks[network]);
        }
    }
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    preprocessAuthenticationParams({ username, password, otp, forceSMS, extensible, trust, }) {
        if (!_.isString(username)) {
            throw new Error('expected string username');
        }
        if (!_.isString(password)) {
            throw new Error('expected string password');
        }
        const lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        const hmacPassword = this.calculateHMAC(lowerName, password);
        const authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = util_1.makeRandomKey();
            authParams.extensible = true;
            authParams.extensionAddress = util_1.getAddressP2PKH(this._extensionKey);
        }
        return authParams;
    }
    /**
     * Synchronous method for activating an access token.
     */
    authenticateWithAccessToken({ accessToken }) {
        debug('now authenticating with access token %s', accessToken.substring(0, 8));
        this._token = accessToken;
    }
    /**
     * Login to the bitgo platform.
     */
    async authenticate(params) {
        try {
            if (!_.isObject(params)) {
                throw new Error('required object params');
            }
            if (!_.isString(params.password)) {
                throw new Error('expected string password');
            }
            const forceV1Auth = !!params.forceV1Auth;
            const authParams = this.preprocessAuthenticationParams(params);
            const password = params.password;
            if (this._token) {
                return new Error('already logged in');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/session');
            const request = this.post(authUrl);
            if (forceV1Auth) {
                request.forceV1Auth = true;
                // tell the server that the client was forced to downgrade the authentication protocol
                authParams.forceV1Auth = true;
                debug('forcing v1 auth for call to authenticate');
            }
            const response = await request.send(authParams);
            // extract body and user information
            const body = response.body;
            this._user = body.user;
            if (body.access_token) {
                this._token = body.access_token;
                // if the downgrade was forced, adding a warning message might be prudent
            }
            else {
                // check the presence of an encrypted ECDH xprv
                // if not present, legacy account
                const encryptedXprv = body.encryptedECDHXprv;
                if (!encryptedXprv) {
                    throw new Error('Keychain needs encryptedXprv property');
                }
                const responseDetails = this.handleTokenIssuance(response.body, password);
                this._token = responseDetails.token;
                this._ecdhXprv = responseDetails.ecdhXprv;
                // verify the response's authenticity
                api_1.verifyResponse(this, responseDetails.token, 'post', request, response);
                // add the remaining component for easier access
                response.body.access_token = this._token;
            }
            return api_1.handleResponseResult()(response);
        }
        catch (e) {
            api_1.handleResponseError(e);
        }
    }
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    handleTokenIssuance(responseBody, password) {
        // make sure the response body contains the necessary properties
        sdk_core_1.common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        const environment = this._env;
        const environmentConfig = sdk_core_1.common.Environments[environment];
        const serverXpub = environmentConfig.serverXpub;
        let ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password,
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        const clientHDNode = bip32.fromBase58(ecdhXprv);
        const serverHDNode = bip32.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        const derivationPath = bip32path_1.sanitizeLegacyPath(responseBody.derivationPath);
        const clientDerivedNode = clientHDNode.derivePath(derivationPath);
        const serverDerivedNode = serverHDNode.derivePath(derivationPath);
        const publicKey = serverDerivedNode.publicKey;
        const secretKey = clientDerivedNode.privateKey;
        if (!secretKey) {
            throw new Error('no client private Key');
        }
        const secret = Buffer.from(
        // FIXME(BG-34386): we should use `secp256k1.ecdh()` in the future
        //                  see discussion here https://github.com/bitcoin-core/secp256k1/issues/352
        secp256k1.publicKeyTweakMul(publicKey, secretKey)).toString('hex');
        // decrypt token with symmetric ECDH key
        let response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret,
                }),
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    }
    /**
     */
    verifyPassword(params = {}) {
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        const hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword')).send({ password: hmacPassword }).result('valid');
    }
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    clear() {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    }
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    async refreshToken(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['refreshToken']);
        const refreshToken = params.refreshToken || this._refreshToken;
        if (!refreshToken) {
            throw new Error('Must provide refresh token or have authenticated with Oauth before');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const body = await this.post(this._baseUrl + '/oauth/token')
            .send({
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        return body;
    }
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    async listAccessTokens() {
        return this.get(this.url('/user/accesstoken')).send().result('accessTokens');
    }
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    async addAccessToken(params) {
        var _a;
        try {
            if (!_.isString(params.label)) {
                throw new Error('required string label');
            }
            // check non-string params
            if (params.duration) {
                if (!_.isNumber(params.duration) || params.duration < 0) {
                    throw new Error('duration must be a non-negative number');
                }
            }
            if (params.ipRestrict) {
                if (!_.isArray(params.ipRestrict)) {
                    throw new Error('ipRestrict must be an array');
                }
                _.forEach(params.ipRestrict, (ipAddr) => {
                    if (!_.isString(ipAddr)) {
                        throw new Error('ipRestrict must be an array of IP address strings');
                    }
                });
            }
            if (params.txValueLimit) {
                if (!_.isNumber(params.txValueLimit)) {
                    throw new Error('txValueLimit must be a number');
                }
                if (params.txValueLimit < 0) {
                    throw new Error('txValueLimit must be a non-negative number');
                }
            }
            if (params.scope && params.scope.length > 0) {
                if (!_.isArray(params.scope)) {
                    throw new Error('scope must be an array');
                }
            }
            else {
                throw new Error('must specify scope for token');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/accesstoken');
            const request = this.post(authUrl);
            if (!this._ecdhXprv) {
                // without a private key, the user cannot decrypt the new access token the server will send
                request.forceV1Auth = true;
                debug('forcing v1 auth for adding access token using token %s', (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
            }
            const response = await request.send(params);
            if (request.forceV1Auth) {
                response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                return api_1.handleResponseResult()(response);
            }
            // verify the authenticity of the server's response before proceeding any further
            api_1.verifyResponse(this, this._token, 'post', request, response);
            const responseDetails = this.handleTokenIssuance(response.body);
            response.body.token = responseDetails.token;
            return api_1.handleResponseResult()(response);
        }
        catch (e) {
            api_1.handleResponseError(e);
        }
    }
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     */
    async removeAccessToken({ id, label }) {
        if ((!id && !label) || (id && label)) {
            throw new Error('must provide exactly one of id or label');
        }
        if (id) {
            return this.del(this.url(`/user/accesstoken/${id}`))
                .send()
                .result();
        }
        const tokens = await this.listAccessTokens();
        if (!tokens) {
            throw new Error('token with this label does not exist');
        }
        const matchingTokens = _.filter(tokens, { label });
        if (matchingTokens.length > 1) {
            throw new Error('ambiguous call: multiple tokens matching this label');
        }
        if (matchingTokens.length === 0) {
            throw new Error('token with this label does not exist');
        }
        return this.del(this.url(`/user/accesstoken/${matchingTokens[0].id}`))
            .send()
            .result();
    }
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    generateRandomPassword(numWords = 5) {
        const bytes = sjcl.codec.bytes.fromBits(sjcl.random.randomWords(numWords));
        return bs58.encode(bytes);
    }
    /**
     * Logout of BitGo
     */
    async logout() {
        const result = await this.get(this.url('/user/logout')).result();
        this.clear();
        return result;
    }
    /**
     * Get a user by ID (name/email only)
     * @param id
     *
     * @deprecated
     */
    async getUser({ id }) {
        if (!_.isString(id)) {
            throw new Error('expected string id');
        }
        return this.get(this.url(`/user/${id}`)).result('user');
    }
    /**
     * Get the current logged in user
     */
    async me() {
        return this.getUser({ id: 'me' });
    }
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     */
    async unlock({ otp, duration }) {
        if (otp && !_.isString(otp)) {
            throw new Error('expected string or undefined otp');
        }
        return this.post(this.url('/user/unlock')).send({ otp, duration }).result();
    }
    /**
     * Lock the session
     */
    async lock() {
        return this.post(this.url('/user/lock')).result();
    }
    /**
     * Get the current session
     */
    async session() {
        return this.get(this.url('/user/session')).result('session');
    }
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    async sendOTP(params = {}) {
        return this.post(this.url('/user/sendotp')).send(params).result();
    }
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     */
    async extendToken(params = {}) {
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        const timestamp = Date.now();
        const duration = params.duration;
        const message = timestamp + '|' + this._token + '|' + duration;
        const privateKey = this._extensionKey.privateKey;
        if (!privateKey) {
            throw new Error('no privateKey on extensionKey');
        }
        const isCompressed = this._extensionKey.compressed;
        const prefix = utxolib.networks.bitcoin.messagePrefix;
        const signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result();
    }
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     */
    async getSharingKey({ email }) {
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey')).send({ email }).result();
    }
    /**
     *
     */
    getValidate() {
        return this._validate;
    }
    /**
     *
     */
    setValidate(validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    }
}
exports.BitGoAPI = BitGoAPI;
BitGoAPI._testnetWarningMessage = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z29BUEkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z29BUEkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3QixvREFBb0Q7QUFDcEQsK0JBUWU7QUFDZixpQ0FBNkI7QUFDN0IseUNBQXlDO0FBQ3pDLDhCQUE4QjtBQUM5QixtQ0FBb0M7QUFDcEMsMkNBQTJDO0FBQzNDLDhDQUE2RTtBQUM3RSxpQ0FBd0Q7QUFDeEQsb0NBQW9DO0FBNEJwQyx5Q0FBMEM7QUFDMUMsdUNBQTZDO0FBQzdDLDJDQUFpRDtBQUVqRCxNQUFNLEtBQUssR0FBRyxlQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFcEMsSUFBSSxDQUFDLENBQUEsTUFBQyxPQUFlLDBDQUFFLE9BQU8sQ0FBQSxFQUFFO0lBQzlCLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0lBQzNDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0NBQ3pDO0FBRUQsTUFBTSxxQkFBcUIsR0FBRyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLENBQVUsQ0FBQztBQUU5RSxNQUFzQixRQUFRO0lBd0I1QixZQUFZLFNBQTBCLEVBQUU7UUFmckIsaUJBQVksR0FBdUQsQ0FBQyxDQUFDO1FBQzlFLHNCQUFpQixHQUFHLElBQUksQ0FBQztRQU16QixhQUFRLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQVNqQyxJQUNFLENBQUMsaUJBQU0sQ0FBQyxjQUFjLENBQ3BCLE1BQU0sRUFDTixFQUFFLEVBQ0Y7WUFDRSxhQUFhO1lBQ2IsV0FBVztZQUNYLGVBQWU7WUFDZixzQkFBc0I7WUFDdEIsWUFBWTtZQUNaLDRCQUE0QjtTQUM3QixDQUNGO1lBQ0QsQ0FBQyxNQUFNLENBQUMsYUFBYSxJQUFJLENBQUMs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QUMsQ0FBQztTQUMxQztRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQzFFLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVyxDQUFDLFFBQWlCO1FBQzNCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNyQztRQUNELElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQzVCLENBQUM7O0FBempDSCw0QkEwakNDO0FBdmpDa0IsK0JBQXNCLEdBQUcsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxIGZyb20gJ3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0ICogYXMgYml0Y29pbk1lc3NhZ2UgZnJvbSAnYml0Y29pbmpzLW1lc3NhZ2UnO1xuaW1wb3J0IHtcbiAgQml0R29SZXF1ZXN0LFxuICBoYW5kbGVSZXNwb25zZUVycm9yLFxuICBoYW5kbGVSZXNwb25zZVJlc3VsdCxcbiAgc2VyaWFsaXplUmVxdWVzdERhdGEsXG4gIHNldFJlcXVlc3RRdWVyeVN0cmluZyxcbiAgdG9CaXRnb1JlcXVlc3QsXG4gIHZlcmlmeVJlc3BvbnNlLFxufSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHVybExpYiBmcm9tICd1cmwnO1xuaW1wb3J0IHsgY3JlYXRlSG1hYyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBBbGlhc0Vudmlyb25tZW50cywgY29tbW9uLCBFbnZpcm9ubWVudE5hbWUgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzc1AyUEtILCBtYWtlUmFuZG9tS2V5IH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCAqIGFzIHNqY2wgZnJvbSAnQGJpdGdvL3NqY2wnO1xuaW1wb3J0IHtcbiAgQWNjZXNzVG9rZW5PcHRpb25zLFxuICBJUmVxdWVzdFRyYWNlcixcbiAgUGluZ09wdGlvbnMsXG4gIEF1dGhlbnRpY2F0ZU9wdGlvbnMsXG4gIENhbGN1bGF0ZUhtYWNTdWJqZWN0T3B0aW9ucyxcbiAgQ2FsY3VsYXRlUmVxdWVzdEhlYWRlcnNPcHRpb25zLFxuICBDYWxjdWxhdGVSZXF1ZXN0SG1hY09wdGlvbnMsXG4gIFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyxcbiAgUmVxdWVzdEhlYWRlcnMsXG4gIFZlcmlmeVJlc3BvbnNlSW5mbyxcbiAgVmVyaWZ5UmVzcG9uc2VPcHRpb25zLFxuICBCaXRHb0FQSU9wdGlvbnMsXG4gIERlY3J5cHRPcHRpb25zLFxuICBFbmNyeXB0T3B0aW9ucyxcbiAgVXNlcixcbiAgQml0R29Kc29uLFxuICBWZXJpZnlQYXNzd29yZE9wdGlvbnMsXG4gIFRva2VuSXNzdWFuY2VSZXNwb25zZSxcbiAgVG9rZW5Jc3N1YW5jZSxcbiAgUmVtb3ZlQWNjZXNzVG9rZW5PcHRpb25zLFxuICBBZGRBY2Nlc3NUb2tlbk9wdGlvbnMsXG4gIEdldFVzZXJPcHRpb25zLFxuICBVbmxvY2tPcHRpb25zLFxuICBFeHRlbmRUb2tlbk9wdGlvbnMsXG4gIEdldFNoYXJpbmdLZXlPcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBwanNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuaW1wb3J0IHsgZGVjcnlwdCwgZW5jcnlwdCB9IGZyb20gJy4vZW5jcnlwdCc7XG5pbXBvcnQgeyBzYW5pdGl6ZUxlZ2FjeVBhdGggfSBmcm9tICcuL2JpcDMycGF0aCc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOmFwaScpO1xuXG5pZiAoIShwcm9jZXNzIGFzIGFueSk/LmJyb3dzZXIpIHtcbiAgZGVidWcoJ2VuYWJsaW5nIHN1cGVyYWdlbnQtcHJveHkgd3JhcHBlcicpO1xuICByZXF1aXJlKCdzdXBlcmFnZW50LXByb3h5Jykoc3VwZXJhZ2VudCk7XG59XG5cbmNvbnN0IHBhdGNoZWRSZXF1ZXN0TWV0aG9kcyA9IFsnZ2V0JywgJ3Bvc3QnLCAncHV0JywgJ2RlbCcsICdwYXRjaCddIGFzIGNvbnN0O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQml0R29BUEkge1xuICBwcm90ZWN0ZWQgc3RhdGljIF9jb25zdGFudHM6IGFueTtcbiAgcHJvdGVjdGVkIHN0YXRpYyBfY29uc3RhbnRzRXhwaXJlOiBhbnk7XG4gIHByb3RlY3RlZCBzdGF0aWMgX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IGZhbHNlO1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudE5hbWU7XG4gIHByb3RlY3RlZCByZWFkb25seSBfYmFzZVVybDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2Jhc2VBcGlVcmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9iYXNlQXBpVXJsVjI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnY6IEVudmlyb25tZW50TmFtZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9hdXRoVmVyc2lvbjogRXhjbHVkZTxCaXRHb0FQSU9wdGlvbnNbJ2F1dGhWZXJzaW9uJ10sIHVuZGVmaW5lZD4gPSAyO1xuICBwcm90ZWN0ZWQgX2htYWNWZXJpZmljYXRpb24gPSB0cnVlO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3Byb3h5Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3VzZXI/OiBVc2VyO1xuICBwcm90ZWN0ZWQgX2V4dGVuc2lvbktleT86IHV0eG9saWIuRUNQYWlyLkVDUGFpckludGVyZmFjZTtcbiAgcHJvdGVjdGVkIF9yZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xuICBwcm90ZWN0ZWQgX3Rva2VuPzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZlcnNpb24gPSBwanNvbi52ZXJzaW9uO1xuICBwcm90ZWN0ZWQgX3VzZXJBZ2VudD86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9lY2RoWHBydj86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9yZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50SWQ/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQml0R29BUElPcHRpb25zID0ge30pIHtcbiAgICBpZiAoXG4gICAgICAhY29tbW9uLnZhbGlkYXRlUGFyYW1zKFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIFtdLFxuICAgICAgICBbXG4gICAgICAgICAgJ2FjY2Vzc1Rva2VuJyxcbiAgICAgICAgICAndXNlckFnZW50JyxcbiAgICAgICAgICAnY3VzdG9tUm9vdFVSSScsXG4gICAgICAgICAgJ2N1c3RvbUJpdGNvaW5OZXR3b3JrJyxcbiAgICAgICAgICAnc2VydmVyWHB1YicsXG4gICAgICAgICAgJ3N0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsJyxcbiAgICAgICAgXVxuICAgICAgKSB8fFxuICAgICAgKHBhcmFtcy51c2VQcm9kdWN0aW9uICYmICFfLmlzQm9vbGVhbihwYXJhbXMudXNlUHJvZHVjdGlvbikpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSBvcGVyYXRlIG9uIHRoZSB0ZXN0IHNlcnZlci5cbiAgICAvLyBEZXByZWNhdGUgdXNlUHJvZHVjdGlvbiBpbiB0aGUgZnV0dXJlXG4gICAgbGV0IGVudjogRW52aXJvbm1lbnROYW1lO1xuXG4gICAgaWYgKHBhcmFtcy51c2VQcm9kdWN0aW9uKSB7XG4gICAgICBpZiAocGFyYW1zLmVudiAmJiBwYXJhbXMuZW52ICE9PSAncHJvZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgdXNlIHVzZVByb2R1Y3Rpb24gd2hlbiBlbnY9JyArIHBhcmFtcy5lbnYpO1xuICAgICAgfVxuICAgICAgZW52ID0gJ3Byb2QnO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBwYXJhbXMuY3VzdG9tUm9vdFVSSSB8fFxuICAgICAgcGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrIHx8XG4gICAgICBwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3MgfHxcbiAgICAgIHBhcmFtcy5zZXJ2ZXJYcHViIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fUk9PVF9VUkkgfHxcbiAgICAgIHByb2Nlc3MuZW52LkJJVEdPX0NVU1RPTV9CSVRDT0lOX05FVFdPUktcbiAgICApIHtcbiAgICAgIC8vIGZvciBicmFuY2ggZGVwbG95cywgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHNwZWNpZnkgY3VzdG9tIGVuZHBvaW50cyB3aGlsZSBzdGlsbFxuICAgICAgLy8gbWFpbnRhaW5pbmcgdGhlIG5hbWUgb2Ygc3BlY2lmaWVkIHRoZSBlbnZpcm9ubWVudFxuICAgICAgZW52ID0gcGFyYW1zLmVudiA9PT0gJ2JyYW5jaCcgPyAnYnJhbmNoJyA6ICdjdXN0b20nO1xuICAgICAgaWYgKHBhcmFtcy5jdXN0b21Sb290VVJJKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmkgPSBwYXJhbXMuY3VzdG9tUm9vdFVSSTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tQml0Y29pbk5ldHdvcmspIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLm5ldHdvcmsgPSBwYXJhbXMuY3VzdG9tQml0Y29pbk5ldHdvcms7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzKSB7XG4gICAgICAgIChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0gYXMgYW55KS5jdXN0b21TaWduaW5nQWRkcmVzcyA9IHBhcmFtcy5jdXN0b21TaWduaW5nQWRkcmVzcztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuc2VydmVyWHB1Yikge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0uc2VydmVyWHB1YiA9IHBhcmFtcy5zZXJ2ZXJYcHViO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0uc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwgPSBwYXJhbXMuc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgfHwgKHByb2Nlc3MuZW52LkJJVEdPX0VOViBhcyBFbnZpcm9ubWVudE5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYXV0aFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fYXV0aFZlcnNpb24gPSBwYXJhbXMuYXV0aFZlcnNpb247XG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBlbnYgaXMgYW4gYWxpYXMsIHN3YXAgaXQgb3V0IHdpdGggdGhlIGVxdWl2YWxlbnQgc3VwcG9ydGVkIGVudmlyb25tZW50XG4gICAgaWYgKGVudiBpbiBBbGlhc0Vudmlyb25tZW50cykge1xuICAgICAgZW52ID0gQWxpYXNFbnZpcm9ubWVudHNbZW52XTtcbiAgICB9XG5cbiAgICBpZiAoZW52ID09PSAnY3VzdG9tJyAmJiBfLmlzVW5kZWZpbmVkKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdtdXN0IHVzZSAtLWN1c3RvbXJvb3R1cmkgb3Igc2V0IHRoZSBCSVRHT19DVVNUT01fUk9PVF9VUkkgZW52aXJvbm1lbnQgdmFyaWFibGUgd2hlbiB1c2luZyB0aGUgY3VzdG9tIGVudmlyb25tZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZW52KSB7XG4gICAgICBpZiAoY29tbW9uLkVudmlyb25tZW50c1tlbnZdKSB7XG4gICAgICAgIHRoaXMuX2Jhc2VVcmwgPSBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVudmlyb25tZW50ICcgKyBlbnYgKyAnLiBTdXBwb3J0ZWQgZW52aXJvbm1lbnRzOiBwcm9kLCB0ZXN0LCBkZXYsIGxhdGVzdCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnYgPSAndGVzdCc7XG4gICAgICBpZiAoIUJpdEdvQVBJLl90ZXN0bmV0V2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgQml0R29BUEkuX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCdCaXRHbyBTREsgZW52IG5vdCBzZXQgLSBkZWZhdWx0aW5nIHRvIHRlc3QgYXQgdGVzdC5iaXRnby5jb20uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9iYXNlVXJsID0gY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaTtcbiAgICB9XG4gICAgdGhpcy5fZW52ID0gdGhpcy5lbnYgPSBlbnY7XG5cbiAgICBpZiAocGFyYW1zLmV0aGVyc2NhbkFwaVRva2VuKSB7XG4gICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0uZXRoZXJzY2FuQXBpVG9rZW4gPSBwYXJhbXMuZXRoZXJzY2FuQXBpVG9rZW47XG4gICAgfVxuXG4gICAgY29tbW9uLnNldE5ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLm5ldHdvcmspO1xuXG4gICAgdGhpcy5fYmFzZUFwaVVybCA9IHRoaXMuX2Jhc2VVcmwgKyAnL2FwaS92MSc7XG4gICAgdGhpcy5fYmFzZUFwaVVybFYyID0gdGhpcy5fYmFzZVVybCArICcvYXBpL3YyJztcbiAgICB0aGlzLl90b2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSBwYXJhbXMudXNlckFnZW50IHx8ICdCaXRHb0pTLycgKyB0aGlzLnZlcnNpb24oKTtcbiAgICB0aGlzLl9yZXFJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBwYXJhbXMucmVmcmVzaFRva2VuO1xuICAgIHRoaXMuX2NsaWVudElkID0gcGFyYW1zLmNsaWVudElkO1xuICAgIHRoaXMuX2NsaWVudFNlY3JldCA9IHBhcmFtcy5jbGllbnRTZWNyZXQ7XG5cbiAgICAvLyB3aGV0aGVyIHRvIHBlcmZvcm0gZXh0cmEgY2xpZW50LXNpZGUgdmFsaWRhdGlvbiBmb3Igc29tZSB0aGluZ3MsIHN1Y2ggYXNcbiAgICAvLyBhZGRyZXNzIHZhbGlkYXRpb24gb3Igc2lnbmF0dXJlIHZhbGlkYXRpb24uIGRlZmF1bHRzIHRvIHRydWUsIGJ1dCBjYW4gYmVcbiAgICAvLyB0dXJuZWQgb2ZmIGJ5IHNldHRpbmcgdG8gZmFsc2UuIGNhbiBhbHNvIGJlIG92ZXJyaWRkZW4gaW5kaXZpZHVhbGx5IGluIHRoZVxuICAgIC8vIGZ1bmN0aW9ucyB0aGF0IHVzZSBpdC5cbiAgICB0aGlzLl92YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcblxuICAgIGlmICghcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gJiYgcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5obWFjVmVyaWZpY2F0aW9uRW5mb3JjZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGlzYWJsZSByZXF1ZXN0IEhNQUMgdmVyaWZpY2F0aW9uIGluIGVudmlyb25tZW50ICR7dGhpcy5nZXRFbnYoKX1gKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdITUFDIHZlcmlmaWNhdGlvbiBleHBsaWNpdGx5IGRpc2FibGVkIGJ5IGNvbnN0cnVjdG9yIG9wdGlvbicpO1xuICAgICAgdGhpcy5faG1hY1ZlcmlmaWNhdGlvbiA9IHBhcmFtcy5obWFjVmVyaWZpY2F0aW9uO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5wcm94eSAmJiBwcm9jZXNzLmVudi5CSVRHT19VU0VfUFJPWFkpIHtcbiAgICAgIHBhcmFtcy5wcm94eSA9IHByb2Nlc3MuZW52LkJJVEdPX1VTRV9QUk9YWTtcbiAgICB9XG5cbiAgICBpZiAoKHByb2Nlc3MgYXMgYW55KS5icm93c2VyICYmIHBhcmFtcy5wcm94eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgdXNlIGh0dHBzIHByb3h5IHBhcmFtcyB3aGlsZSBpbiBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJveHkgPSBwYXJhbXMucHJveHk7XG5cbiAgICAvLyBjYXB0dXJlIG91dGVyIHN0YWNrIHNvIHdlIGhhdmUgdXNlZnVsIGRlYnVnIGluZm9ybWF0aW9uIGlmIGZldGNoIGNvbnN0YW50cyBmYWlsc1xuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoKTtcblxuICAgIC8vIEtpY2sgb2ZmIGZpcnN0IGxvYWQgb2YgY29uc3RhbnRzXG4gICAgdGhpcy5mZXRjaENvbnN0YW50cygpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFuIGVycm9yIGRvZXMgbm90IHRlcm1pbmF0ZSB0aGUgZW50aXJlIHNjcmlwdFxuICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gZmV0Y2ggaW5pdGlhbCBjbGllbnQgY29uc3RhbnRzIGZyb20gQml0R28nKTtcbiAgICAgICAgZGVidWcoZS5zdGFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IEJpdEdvIGVudmlyb25tZW50XG4gICAqL1xuICBnZXRFbnYoKTogRW52aXJvbm1lbnROYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZW52O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBhdXRoIHZlcnNpb24gdXNlZCBmb3IgcmVxdWVzdHMgdG8gdGhlIEJpdEdvIHNlcnZlclxuICAgKi9cbiAgZ2V0QXV0aFZlcnNpb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aFZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHBhdGNoaW5nIGZ1bmN0aW9uIHdoaWNoIGNhbiBhcHBseSBvdXIgYXV0aG9yaXphdGlvblxuICAgKiBoZWFkZXJzIHRvIGFueSBvdXRib3VuZCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqL1xuICBwcml2YXRlIHJlcXVlc3RQYXRjaChtZXRob2Q6IHR5cGVvZiBwYXRjaGVkUmVxdWVzdE1ldGhvZHNbbnVtYmVyXSwgdXJsOiBzdHJpbmcpIHtcbiAgICBsZXQgcmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0ID0gc3VwZXJhZ2VudFttZXRob2RdKHVybCk7XG4gICAgaWYgKHRoaXMuX3Byb3h5KSB7XG4gICAgICBkZWJ1ZygncHJveHlpbmcgcmVxdWVzdCB0aHJvdWdoICVzJywgdGhpcy5fcHJveHkpO1xuICAgICAgcmVxID0gcmVxLnByb3h5KHRoaXMuX3Byb3h5KTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnaW5hbFRoZW4gPSByZXEudGhlbi5iaW5kKHJlcSk7XG4gICAgcmVxLnRoZW4gPSAob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpID0+IHtcbiAgICAgIC8vIGludGVyY2VwdCBhIHJlcXVlc3QgYmVmb3JlIGl0J3Mgc3VibWl0dGVkIHRvIHRoZSBzZXJ2ZXIgZm9yIHYyIGF1dGhlbnRpY2F0aW9uIChiYXNlZCBvbiB0b2tlbilcbiAgICAgIGlmICh0aGlzLl92ZXJzaW9uKSB7XG4gICAgICAgIC8vIFRPRE8gLSBkZWNpZGUgd2hlcmUgdG8gZ2V0IHZlcnNpb25cbiAgICAgICAgcmVxLnNldCgnQml0R28tU0RLLVZlcnNpb24nLCB0aGlzLl92ZXJzaW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMuX3JlcUlkKSkge1xuICAgICAgICByZXEuc2V0KCdSZXF1ZXN0LUlEJywgdGhpcy5fcmVxSWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGFmdGVyIHNldHRpbmcgdGhlIGhlYWRlciBzbyB0aGUgc2VxdWVuY2UgbnVtYmVycyBzdGFydCBhdCAwXG4gICAgICAgIHRoaXMuX3JlcUlkLmluYygpO1xuXG4gICAgICAgIC8vIHJlcXVlc3QgaWRzIG11c3QgYmUgc2V0IGJlZm9yZSBlYWNoIHJlcXVlc3QgaW5zdGVhZCBvZiBiZWluZyBrZXB0XG4gICAgICAgIC8vIGluc2lkZSB0aGUgYml0Z28gb2JqZWN0LiBUaGlzIGlzIHRvIHByZXZlbnQgcmVlbnRyYW5jeSBpc3N1ZXMgd2hlcmVcbiAgICAgICAgLy8gbXVsdGlwbGUgc2ltdWx0YW5lb3VzIHJlcXVlc3RzIGNvdWxkIGNhdXNlIGluY29ycmVjdCByZXFJZHMgdG8gYmUgdXNlZFxuICAgICAgICBkZWxldGUgdGhpcy5fcmVxSWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXZlbnQgSUUgZnJvbSBjYWNoaW5nIHJlcXVlc3RzXG4gICAgICByZXEuc2V0KCdJZi1Nb2RpZmllZC1TaW5jZScsICdNb24sIDI2IEp1bCAxOTk3IDA1OjAwOjAwIEdNVCcpO1xuXG4gICAgICBpZiAoIShwcm9jZXNzIGFzIGFueSkuYnJvd3NlciAmJiB0aGlzLl91c2VyQWdlbnQpIHtcbiAgICAgICAgLy8gSWYgbm90IGluIHRoZSBicm93c2VyLCBzZXQgdGhlIFVzZXItQWdlbnQuIEJyb3dzZXJzIGRvbid0IGFsbG93XG4gICAgICAgIC8vIHNldHRpbmcgb2YgVXNlci1BZ2VudCwgc28gd2UgbXVzdCBkaXNhYmxlIHRoaXMgd2hlbiBydW4gaW4gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIgKGJyb3dzZXJpZnkgc2V0cyBwcm9jZXNzLmJyb3dzZXIpLlxuICAgICAgICByZXEuc2V0KCdVc2VyLUFnZW50JywgdGhpcy5fdXNlckFnZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgdG8ganVzdCBhYm92ZSA1IG1pbnV0ZXMgYnkgZGVmYXVsdFxuICAgICAgcmVxLnRpbWVvdXQoKHByb2Nlc3MuZW52LkJJVEdPX1RJTUVPVVQgYXMgYW55KSAqIDEwMDAgfHwgMzA1ICogMTAwMCk7XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHRva2VuLCBhbmQgd2UncmUgbm90IGxvZ2dlZCBpbiwgdGhlIHJlcXVlc3QgY2Fubm90IGJlIHYyIGF1dGhlbnRpY2F0ZWRcbiAgICAgIHJlcS5pc1YyQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICByZXEuYXV0aGVudGljYXRpb25Ub2tlbiA9IHRoaXMuX3Rva2VuO1xuICAgICAgLy8gc29tZSBvZiB0aGUgb2xkZXIgdG9rZW5zIGFwcGVhciB0byBiZSBvbmx5IDQwIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgaWYgKCh0aGlzLl90b2tlbiAmJiB0aGlzLl90b2tlbi5sZW5ndGggIT09IDY3ICYmIHRoaXMuX3Rva2VuLmluZGV4T2YoJ3YyeCcpICE9PSAwKSB8fCByZXEuZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBvbGQgbWV0aG9kXG4gICAgICAgIHJlcS5pc1YyQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLl90b2tlbik7XG4gICAgICAgIGRlYnVnKCdzZW5kaW5nIHYxICVzIHJlcXVlc3QgdG8gJXMgd2l0aCB0b2tlbiAlcycsIG1ldGhvZCwgdXJsLCB0aGlzLl90b2tlbj8uc3Vic3RyKDAsIDgpKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVGhlbihvbmZ1bGZpbGxlZCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZXQoJ0JpdEdvLUF1dGgtVmVyc2lvbicsIHRoaXMuX2F1dGhWZXJzaW9uID09PSAzID8gJzMuMCcgOiAnMi4wJyk7XG5cbiAgICAgIGlmICh0aGlzLl90b2tlbikge1xuICAgICAgICBjb25zdCBkYXRhID0gc2VyaWFsaXplUmVxdWVzdERhdGEocmVxKTtcbiAgICAgICAgc2V0UmVxdWVzdFF1ZXJ5U3RyaW5nKHJlcSk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFByb3BlcnRpZXMgPSB0aGlzLmNhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzKHtcbiAgICAgICAgICB1cmw6IHJlcS51cmwsXG4gICAgICAgICAgdG9rZW46IHRoaXMuX3Rva2VuLFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICB0ZXh0OiBkYXRhIHx8ICcnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVxLnNldCgnQXV0aC1UaW1lc3RhbXAnLCByZXF1ZXN0UHJvcGVydGllcy50aW1lc3RhbXAudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgLy8gd2UncmUgbm90IHNlbmRpbmcgdGhlIGFjdHVhbCB0b2tlbiwgYnV0IG9ubHkgaXRzIGhhc2hcbiAgICAgICAgcmVxLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHJlcXVlc3RQcm9wZXJ0aWVzLnRva2VuSGFzaCk7XG4gICAgICAgIGRlYnVnKCdzZW5kaW5nIHYyICVzIHJlcXVlc3QgdG8gJXMgd2l0aCB0b2tlbiAlcycsIG1ldGhvZCwgdXJsLCB0aGlzLl90b2tlbj8uc3Vic3RyKDAsIDgpKTtcblxuICAgICAgICAvLyBzZXQgdGhlIEhNQUNcbiAgICAgICAgcmVxLnNldCgnSE1BQycsIHJlcXVlc3RQcm9wZXJ0aWVzLmhtYWMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFZlcmlmeSB0aGUgcmVzcG9uc2UgYmVmb3JlIGNhbGxpbmcgdGhlIG9yaWdpbmFsIG9uZnVsZmlsbGVkIGhhbmRsZXIsXG4gICAgICAgKiBhbmQgbWFrZSBzdXJlIG9ucmVqZWN0ZWQgaXMgY2FsbGVkIGlmIGEgdmVyaWZpY2F0aW9uIGVycm9yIGlzIGVuY291bnRlcmVkXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IG5ld09uRnVsZmlsbGVkID0gb25mdWxmaWxsZWRcbiAgICAgICAgPyAocmVzcG9uc2U6IHN1cGVyYWdlbnQuUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vIEhNQUMgdmVyaWZpY2F0aW9uIGlzIG9ubHkgYWxsb3dlZCB0byBiZSBza2lwcGVkIGluIGNlcnRhaW4gZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBjaGVja2VkIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGNoZWNraW5nIGl0IGFnYWluIGF0IHJlcXVlc3QgdGltZVxuICAgICAgICAgICAgLy8gd2lsbCBoZWxwIHByZXZlbnQgYWdhaW5zdCB0YW1wZXJpbmcgb2YgdGhpcyBwcm9wZXJ0eSBhZnRlciB0aGUgb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIGlmICghdGhpcy5faG1hY1ZlcmlmaWNhdGlvbiAmJiAhY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5obWFjVmVyaWZpY2F0aW9uRW5mb3JjZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uZnVsZmlsbGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRSZXNwb25zZSA9IHZlcmlmeVJlc3BvbnNlKHRoaXMsIHRoaXMuX3Rva2VuLCBtZXRob2QsIHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG9uZnVsZmlsbGVkKHZlcmlmaWVkUmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsVGhlbihuZXdPbkZ1bGZpbGxlZCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfTtcbiAgICByZXR1cm4gdG9CaXRnb1JlcXVlc3QocmVxKTtcbiAgfVxuXG4gIGdldCh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdnZXQnLCB1cmwpO1xuICB9XG4gIHBvc3QodXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgncG9zdCcsIHVybCk7XG4gIH1cbiAgcHV0KHVybDogc3RyaW5nKTogQml0R29SZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGF0Y2goJ3B1dCcsIHVybCk7XG4gIH1cbiAgZGVsKHVybDogc3RyaW5nKTogQml0R29SZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGF0Y2goJ2RlbCcsIHVybCk7XG4gIH1cbiAgcGF0Y2godXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgncGF0Y2gnLCB1cmwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgSE1BQyBmb3IgdGhlIGdpdmVuIGtleSBhbmQgbWVzc2FnZVxuICAgKiBAcGFyYW0ga2V5IHtTdHJpbmd9IC0gdGhlIGtleSB0byB1c2UgZm9yIHRoZSBITUFDXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtTdHJpbmd9IC0gdGhlIGFjdHVhbCBtZXNzYWdlIHRvIEhNQUNcbiAgICogQHJldHVybnMgeyp9IC0gdGhlIHJlc3VsdCBvZiB0aGUgSE1BQyBvcGVyYXRpb25cbiAgICovXG4gIGNhbGN1bGF0ZUhNQUMoa2V5OiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzdWJqZWN0IHN0cmluZyB0aGF0IGlzIHRvIGJlIEhNQUMnZWQgZm9yIGEgSFRUUCByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB1cmxQYXRoIHJlcXVlc3QgdXJsLCBpbmNsdWRpbmcgcXVlcnkgcGFyYW1zXG4gICAqIEBwYXJhbSB0ZXh0IHJlcXVlc3QgYm9keSB0ZXh0XG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgcmVxdWVzdCB0aW1lc3RhbXAgZnJvbSBgRGF0ZS5ub3coKWBcbiAgICogQHBhcmFtIHN0YXR1c0NvZGUgT25seSBzZXQgZm9yIEhUVFAgcmVzcG9uc2VzLCBsZWF2ZSBibGFuayBmb3IgcmVxdWVzdHNcbiAgICogQHBhcmFtIG1ldGhvZCByZXF1ZXN0IG1ldGhvZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY2FsY3VsYXRlSE1BQ1N1YmplY3QoeyB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIHN0YXR1c0NvZGUsIG1ldGhvZCB9OiBDYWxjdWxhdGVIbWFjU3ViamVjdE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybERldGFpbHMgPSB1cmxMaWIucGFyc2UodXJsUGF0aCk7XG4gICAgY29uc3QgcXVlcnlQYXRoID0gdXJsRGV0YWlscy5xdWVyeSAmJiB1cmxEZXRhaWxzLnF1ZXJ5Lmxlbmd0aCA+IDAgPyB1cmxEZXRhaWxzLnBhdGggOiB1cmxEZXRhaWxzLnBhdGhuYW1lO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChzdGF0dXNDb2RlKSAmJiBfLmlzSW50ZWdlcihzdGF0dXNDb2RlKSAmJiBfLmlzRmluaXRlKHN0YXR1c0NvZGUpKSB7XG4gICAgICBpZiAodGhpcy5fYXV0aFZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIFttZXRob2QudG9VcHBlckNhc2UoKSwgdGltZXN0YW1wLCBxdWVyeVBhdGgsIHN0YXR1c0NvZGUsIHRleHRdLmpvaW4oJ3wnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdGltZXN0YW1wLCBxdWVyeVBhdGgsIHN0YXR1c0NvZGUsIHRleHRdLmpvaW4oJ3wnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2F1dGhWZXJzaW9uID09PSAzKSB7XG4gICAgICByZXR1cm4gW21ldGhvZC50b1VwcGVyQ2FzZSgpLCB0aW1lc3RhbXAsICczLjAnLCBxdWVyeVBhdGgsIHRleHRdLmpvaW4oJ3wnKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgdGV4dF0uam9pbignfCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgSE1BQyBmb3IgYW4gSFRUUCByZXF1ZXN0XG4gICAqL1xuICBjYWxjdWxhdGVSZXF1ZXN0SE1BQyh7IHVybDogdXJsUGF0aCwgdGV4dCwgdGltZXN0YW1wLCB0b2tlbiwgbWV0aG9kIH06IENhbGN1bGF0ZVJlcXVlc3RIbWFjT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3QoeyB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIG1ldGhvZCB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgSE1BQ1xuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUhNQUModG9rZW4sIHNpZ25hdHVyZVN1YmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSByZXF1ZXN0IGhlYWRlcnMgd2l0aCBITUFDXG4gICAqL1xuICBjYWxjdWxhdGVSZXF1ZXN0SGVhZGVycyh7IHVybCwgdGV4dCwgdG9rZW4sIG1ldGhvZCB9OiBDYWxjdWxhdGVSZXF1ZXN0SGVhZGVyc09wdGlvbnMpOiBSZXF1ZXN0SGVhZGVycyB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBobWFjID0gdGhpcy5jYWxjdWxhdGVSZXF1ZXN0SE1BQyh7IHVybCwgdGV4dCwgdGltZXN0YW1wLCB0b2tlbiwgbWV0aG9kIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBTSEEyNTYgaGFzaCBvZiB0aGUgdG9rZW5cbiAgICBjb25zdCBoYXNoRGlnZXN0ID0gc2pjbC5oYXNoLnNoYTI1Ni5oYXNoKHRva2VuKTtcbiAgICBjb25zdCB0b2tlbkhhc2ggPSBzamNsLmNvZGVjLmhleC5mcm9tQml0cyhoYXNoRGlnZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaG1hYyxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIHRva2VuSGFzaCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgSE1BQyBmb3IgYW4gSFRUUCByZXNwb25zZVxuICAgKi9cbiAgdmVyaWZ5UmVzcG9uc2Uoe1xuICAgIHVybDogdXJsUGF0aCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHRleHQsXG4gICAgdGltZXN0YW1wLFxuICAgIHRva2VuLFxuICAgIGhtYWMsXG4gICAgbWV0aG9kLFxuICB9OiBWZXJpZnlSZXNwb25zZU9wdGlvbnMpOiBWZXJpZnlSZXNwb25zZUluZm8ge1xuICAgIGNvbnN0IHNpZ25hdHVyZVN1YmplY3QgPSB0aGlzLmNhbGN1bGF0ZUhNQUNTdWJqZWN0KHtcbiAgICAgIHVybFBhdGgsXG4gICAgICB0ZXh0LFxuICAgICAgdGltZXN0YW1wLFxuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIG1ldGhvZCxcbiAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgSE1BQ1xuICAgIGNvbnN0IGV4cGVjdGVkSG1hYyA9IHRoaXMuY2FsY3VsYXRlSE1BQyh0b2tlbiwgc2lnbmF0dXJlU3ViamVjdCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIHJlc3BvbnNlIGlzIHN0aWxsIHdpdGhpbiB0aGUgdmFsaWRpdHkgd2luZG93ICg1IG1pbnV0ZSB3aW5kb3cpXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBpc0luUmVzcG9uc2VWYWxpZGl0eVdpbmRvdyA9IHRpbWVzdGFtcCA+PSBub3cgLSAxMDAwICogNjAgKiA1ICYmIHRpbWVzdGFtcCA8PSBub3c7XG5cbiAgICAvLyB2ZXJpZnkgdGhlIEhNQUMgYW5kIHRpbWVzdGFtcFxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBleHBlY3RlZEhtYWMgPT09IGhtYWMsXG4gICAgICBleHBlY3RlZEhtYWMsXG4gICAgICBzaWduYXR1cmVTdWJqZWN0LFxuICAgICAgaXNJblJlc3BvbnNlVmFsaWRpdHlXaW5kb3csXG4gICAgICB2ZXJpZmljYXRpb25UaW1lOiBub3csXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB1c2VmdWwgY29uc3RhbnQgdmFsdWVzIGZyb20gdGhlIEJpdEdvIHNlcnZlci5cbiAgICogVGhlc2UgdmFsdWVzIGRvIGNoYW5nZSBpbmZyZXF1ZW50bHksIHNvIHRoZXkgbmVlZCB0byBiZSBmZXRjaGVkLFxuICAgKiBidXQgYXJlIHVubGlrZWx5IHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGEgQml0R28gb2JqZWN0LFxuICAgKiBzbyB0aGV5IGNhbiBzYWZlbHkgY2FjaGVkLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hDb25zdGFudHMoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBlbnYgPSB0aGlzLmdldEVudigpO1xuXG4gICAgaWYgKCFCaXRHb0FQSS5fY29uc3RhbnRzKSB7XG4gICAgICBCaXRHb0FQSS5fY29uc3RhbnRzID0ge307XG4gICAgfVxuICAgIGlmICghQml0R29BUEkuX2NvbnN0YW50c0V4cGlyZSkge1xuICAgICAgQml0R29BUEkuX2NvbnN0YW50c0V4cGlyZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChCaXRHb0FQSS5fY29uc3RhbnRzW2Vudl0gJiYgQml0R29BUEkuX2NvbnN0YW50c0V4cGlyZVtlbnZdICYmIG5ldyBEYXRlKCkgPCBCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlW2Vudl0pIHtcbiAgICAgIHJldHVybiBCaXRHb0FQSS5fY29uc3RhbnRzW2Vudl07XG4gICAgfVxuXG4gICAgLy8gY2xpZW50IGNvbnN0YW50cyBjYWxsIGNhbm5vdCBiZSBhdXRoZW50aWNhdGVkIHVzaW5nIHRoZSBub3JtYWwgSE1BQyB2YWxpZGF0aW9uXG4gICAgLy8gc2NoZW1lLCBzbyB3ZSBuZWVkIHRvIHVzZSBhIHJhdyBzdXBlcmFnZW50IGluc3RhbmNlIHRvIGRvIHRoaXMgcmVxdWVzdC5cbiAgICAvLyBQcm94eSBzZXR0aW5ncyBtdXN0IHN0aWxsIGJlIHJlc3BlY3RlZCBob3dldmVyXG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IHN1cGVyYWdlbnQuZ2V0KHRoaXMudXJsKCcvY2xpZW50L2NvbnN0YW50cycpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAodGhpcy5fcHJveHkgPyByZXN1bHRQcm9taXNlLnByb3h5KHRoaXMuX3Byb3h5KSA6IHJlc3VsdFByb21pc2UpO1xuICAgIEJpdEdvQVBJLl9jb25zdGFudHNbZW52XSA9IHJlc3VsdC5ib2R5LmNvbnN0YW50cztcblxuICAgIGlmIChyZXN1bHQuYm9keT8udHRsICYmIHR5cGVvZiByZXN1bHQuYm9keT8udHRsID09PSAnbnVtYmVyJykge1xuICAgICAgQml0R29BUEkuX2NvbnN0YW50c0V4cGlyZVtlbnZdID0gbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAocmVzdWx0LmJvZHkudHRsIGFzIG51bWJlcikgKiAxMDAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQml0R29BUEkuX2NvbnN0YW50c1tlbnZdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHVybCBmb3IgY2FsbGluZyBCaXRHbyBwbGF0Zm9ybSBBUElzXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqL1xuICB1cmwocGF0aDogc3RyaW5nLCB2ZXJzaW9uID0gMSk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZVVybCA9IHZlcnNpb24gPT09IDIgPyB0aGlzLl9iYXNlQXBpVXJsVjIgOiB0aGlzLl9iYXNlQXBpVXJsO1xuICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1cmwgZm9yIGNhbGxpbmcgQml0R28gbWljcm9zZXJ2aWNlIEFQSXNcbiAgICovXG4gIG1pY3Jvc2VydmljZXNVcmwocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVVybCArIHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyc2lvbiBvZiB0aGUgQml0R29KUyBwYWNrYWdlXG4gICAqL1xuICB2ZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBjb25uZWN0aXZpdHkgdG8gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBwaW5nKHsgcmVxSWQgfTogUGluZ09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKHJlcUlkKSB7XG4gICAgICB0aGlzLl9yZXFJZCA9IHJlcUlkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3BpbmcnKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcmVxdWVzdCB0cmFjZXIgdG8gcHJvdmlkZSByZXF1ZXN0IElEcyBkdXJpbmcgbXVsdGktcmVxdWVzdCB3b3JrZmxvd3NcbiAgICovXG4gIHNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyOiBJUmVxdWVzdFRyYWNlcik6IHZvaWQge1xuICAgIGlmIChyZXFUcmFjZXIpIHtcbiAgICAgIHRoaXMuX3JlcUlkID0gcmVxVHJhY2VyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGVuY3J5cHQgbG9jYWxseS5cbiAgICovXG4gIGVuY3J5cHQocGFyYW1zOiBFbmNyeXB0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpbnB1dCcsICdwYXNzd29yZCddLCBbXSk7XG4gICAgaWYgKCFwYXJhbXMucGFzc3dvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY3J5cHQgd2l0aG91dCBwYXNzd29yZGApO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCBhbiBlbmNyeXB0ZWQgc3RyaW5nIGxvY2FsbHkuXG4gICAqL1xuICBkZWNyeXB0KHBhcmFtczogRGVjcnlwdE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lucHV0JywgJ3Bhc3N3b3JkJ10sIFtdKTtcbiAgICBpZiAoIXBhcmFtcy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjcnlwdCB3aXRob3V0IHBhc3N3b3JkYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY2NtOiB0YWcgZG9lc24ndCBtYXRjaFwiKSkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gJ3Bhc3N3b3JkIGVycm9yIC0gJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoaXMgQml0R28gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIENhdXRpb246IGNvbnRhaW5zIHNlbnNpdGl2ZSBkYXRhXG4gICAqL1xuICB0b0pTT04oKTogQml0R29Kc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjogdGhpcy5fdXNlcixcbiAgICAgIHRva2VuOiB0aGlzLl90b2tlbixcbiAgICAgIGV4dGVuc2lvbktleTogdGhpcy5fZXh0ZW5zaW9uS2V5ID8gdGhpcy5fZXh0ZW5zaW9uS2V5LnRvV0lGKCkgOiB1bmRlZmluZWQsXG4gICAgICBlY2RoWHBydjogdGhpcy5fZWNkaFhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlclxuICAgKi9cbiAgdXNlcigpOiBVc2VyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gc2VyaWFsaXplZCBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE92ZXJ3cml0ZXMgdGhlIHByb3BlcnRpZXMgb24gdGhlIGN1cnJlbnQgQml0R28gb2JqZWN0IHdpdGhcbiAgICogdGhvc2Ugb2YgdGhlIGRlc2VyaWFsemVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGpzb25cbiAgICovXG4gIGZyb21KU09OKGpzb246IEJpdEdvSnNvbik6IHZvaWQge1xuICAgIHRoaXMuX3VzZXIgPSBqc29uLnVzZXI7XG4gICAgdGhpcy5fdG9rZW4gPSBqc29uLnRva2VuO1xuICAgIHRoaXMuX2VjZGhYcHJ2ID0ganNvbi5lY2RoWHBydjtcbiAgICBpZiAoanNvbi5leHRlbnNpb25LZXkpIHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSB1dHhvbGliLkVDUGFpci5mcm9tV0lGKFxuICAgICAgICBqc29uLmV4dGVuc2lvbktleSxcbiAgICAgICAgdXR4b2xpYi5uZXR3b3Jrc1tuZXR3b3JrXSBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmtcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHVzZXJuYW1lLCBwYXNzd29yZCBhbmQgb3RwIGludG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXJuYW1lIGFuZCBoYXNoZWQgcGFzc3dvcmQsIHJlYWR5IHRvXG4gICAqIHNlbmQgdG8gYml0Z28gZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgcHJlcHJvY2Vzc0F1dGhlbnRpY2F0aW9uUGFyYW1zKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBvdHAsXG4gICAgZm9yY2VTTVMsXG4gICAgZXh0ZW5zaWJsZSxcbiAgICB0cnVzdCxcbiAgfTogQXV0aGVudGljYXRlT3B0aW9ucyk6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHVzZXJuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgdXNlcm5hbWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvd2VyTmFtZSA9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXNzd29yZCBITUFDIHNvIHdlIGRvbid0IHNlbmQgY2xlYXItdGV4dCBwYXNzd29yZHNcbiAgICBjb25zdCBobWFjUGFzc3dvcmQgPSB0aGlzLmNhbGN1bGF0ZUhNQUMobG93ZXJOYW1lLCBwYXNzd29yZCk7XG5cbiAgICBjb25zdCBhdXRoUGFyYW1zOiBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBlbWFpbDogbG93ZXJOYW1lLFxuICAgICAgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCxcbiAgICAgIGZvcmNlU01TOiAhIWZvcmNlU01TLFxuICAgIH07XG5cbiAgICBpZiAob3RwKSB7XG4gICAgICBhdXRoUGFyYW1zLm90cCA9IG90cDtcbiAgICAgIGlmICh0cnVzdCkge1xuICAgICAgICBhdXRoUGFyYW1zLnRydXN0ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaWJsZSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uS2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgIGF1dGhQYXJhbXMuZXh0ZW5zaW9uQWRkcmVzcyA9IGdldEFkZHJlc3NQMlBLSCh0aGlzLl9leHRlbnNpb25LZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBhdXRoUGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIG1ldGhvZCBmb3IgYWN0aXZhdGluZyBhbiBhY2Nlc3MgdG9rZW4uXG4gICAqL1xuICBhdXRoZW50aWNhdGVXaXRoQWNjZXNzVG9rZW4oeyBhY2Nlc3NUb2tlbiB9OiBBY2Nlc3NUb2tlbk9wdGlvbnMpOiB2b2lkIHtcbiAgICBkZWJ1Zygnbm93IGF1dGhlbnRpY2F0aW5nIHdpdGggYWNjZXNzIHRva2VuICVzJywgYWNjZXNzVG9rZW4uc3Vic3RyaW5nKDAsIDgpKTtcbiAgICB0aGlzLl90b2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ2luIHRvIHRoZSBiaXRnbyBwbGF0Zm9ybS5cbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZShwYXJhbXM6IEF1dGhlbnRpY2F0ZU9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIG9iamVjdCBwYXJhbXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9yY2VWMUF1dGggPSAhIXBhcmFtcy5mb3JjZVYxQXV0aDtcbiAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSB0aGlzLnByZXByb2Nlc3NBdXRoZW50aWNhdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG5cbiAgICAgIGlmICh0aGlzLl90b2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdhbHJlYWR5IGxvZ2dlZCBpbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gdGhpcy5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvc2Vzc2lvbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKGZvcmNlVjFBdXRoKSB7XG4gICAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICAvLyB0ZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgY2xpZW50IHdhcyBmb3JjZWQgdG8gZG93bmdyYWRlIHRoZSBhdXRoZW50aWNhdGlvbiBwcm90b2NvbFxuICAgICAgICBhdXRoUGFyYW1zLmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgICAgZGVidWcoJ2ZvcmNpbmcgdjEgYXV0aCBmb3IgY2FsbCB0byBhdXRoZW50aWNhdGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBzdXBlcmFnZW50LlJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKGF1dGhQYXJhbXMpO1xuICAgICAgLy8gZXh0cmFjdCBib2R5IGFuZCB1c2VyIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgIHRoaXMuX3VzZXIgPSBib2R5LnVzZXI7XG5cbiAgICAgIGlmIChib2R5LmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aGlzLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAvLyBpZiB0aGUgZG93bmdyYWRlIHdhcyBmb3JjZWQsIGFkZGluZyBhIHdhcm5pbmcgbWVzc2FnZSBtaWdodCBiZSBwcnVkZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgYW4gZW5jcnlwdGVkIEVDREggeHBydlxuICAgICAgICAvLyBpZiBub3QgcHJlc2VudCwgbGVnYWN5IGFjY291bnRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkWHBydiA9IGJvZHkuZW5jcnlwdGVkRUNESFhwcnY7XG4gICAgICAgIGlmICghZW5jcnlwdGVkWHBydikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5Y2hhaW4gbmVlZHMgZW5jcnlwdGVkWHBydiBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZXRhaWxzID0gdGhpcy5oYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlLmJvZHksIHBhc3N3b3JkKTtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG4gICAgICAgIHRoaXMuX2VjZGhYcHJ2ID0gcmVzcG9uc2VEZXRhaWxzLmVjZGhYcHJ2O1xuXG4gICAgICAgIC8vIHZlcmlmeSB0aGUgcmVzcG9uc2UncyBhdXRoZW50aWNpdHlcbiAgICAgICAgdmVyaWZ5UmVzcG9uc2UodGhpcywgcmVzcG9uc2VEZXRhaWxzLnRva2VuLCAncG9zdCcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHJlbWFpbmluZyBjb21wb25lbnQgZm9yIGVhc2llciBhY2Nlc3NcbiAgICAgICAgcmVzcG9uc2UuYm9keS5hY2Nlc3NfdG9rZW4gPSB0aGlzLl90b2tlbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZVJlc3BvbnNlUmVzdWx0PGFueT4oKShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlUmVzcG9uc2VFcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlQm9keSBSZXNwb25zZSBib2R5IG9iamVjdFxuICAgKiBAcGFyYW0gcGFzc3dvcmQgUGFzc3dvcmQgZm9yIHRoZSBzeW1tZXRyaWMgZGVjcnlwdGlvblxuICAgKi9cbiAgaGFuZGxlVG9rZW5Jc3N1YW5jZShyZXNwb25zZUJvZHk6IFRva2VuSXNzdWFuY2VSZXNwb25zZSwgcGFzc3dvcmQ/OiBzdHJpbmcpOiBUb2tlbklzc3VhbmNlIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIHJlc3BvbnNlIGJvZHkgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHJlc3BvbnNlQm9keSwgWydkZXJpdmF0aW9uUGF0aCddLCBbJ2VuY3J5cHRlZEVDREhYcHJ2J10pO1xuXG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSB0aGlzLl9lbnY7XG4gICAgY29uc3QgZW52aXJvbm1lbnRDb25maWcgPSBjb21tb24uRW52aXJvbm1lbnRzW2Vudmlyb25tZW50XTtcbiAgICBjb25zdCBzZXJ2ZXJYcHViID0gZW52aXJvbm1lbnRDb25maWcuc2VydmVyWHB1YjtcbiAgICBsZXQgZWNkaFhwcnYgPSB0aGlzLl9lY2RoWHBydjtcbiAgICBpZiAoIWVjZGhYcHJ2KSB7XG4gICAgICBpZiAoIXBhc3N3b3JkIHx8ICFyZXNwb25zZUJvZHkuZW5jcnlwdGVkRUNESFhwcnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlY2RoWHBydiBwcm9wZXJ0eSBtdXN0IGJlIHNldCBvciBwYXNzd29yZCBhbmQgZW5jcnlwdGVkIGVuY3J5cHRlZEVDREhYcHJ2IG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGVjZGhYcHJ2ID0gdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogcmVzcG9uc2VCb2R5LmVuY3J5cHRlZEVDREhYcHJ2LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGUuZXJyb3JDb2RlID0gJ2VjZGhfeHBydl9kZWNyeXB0aW9uX2ZhaWx1cmUnO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBlbmNyeXB0ZWRFQ0RIWHBydi4nKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3QgSEROb2RlIG9iamVjdHMgZm9yIGNsaWVudCdzIHhwcnYgYW5kIHNlcnZlcidzIHhwdWJcbiAgICBjb25zdCBjbGllbnRIRE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGVjZGhYcHJ2KTtcbiAgICBjb25zdCBzZXJ2ZXJIRE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KHNlcnZlclhwdWIpO1xuXG4gICAgLy8gQklQMzIgZGVyaXZhdGlvbiBwYXRoIGlzIGFwcGxpZWQgdG8gYm90aCBjbGllbnQgYW5kIHNlcnZlciBtYXN0ZXIga2V5c1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gc2FuaXRpemVMZWdhY3lQYXRoKHJlc3BvbnNlQm9keS5kZXJpdmF0aW9uUGF0aCk7XG4gICAgY29uc3QgY2xpZW50RGVyaXZlZE5vZGUgPSBjbGllbnRIRE5vZGUuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCk7XG4gICAgY29uc3Qgc2VydmVyRGVyaXZlZE5vZGUgPSBzZXJ2ZXJIRE5vZGUuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCk7XG5cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZXJ2ZXJEZXJpdmVkTm9kZS5wdWJsaWNLZXk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gY2xpZW50RGVyaXZlZE5vZGUucHJpdmF0ZUtleTtcbiAgICBpZiAoIXNlY3JldEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBjbGllbnQgcHJpdmF0ZSBLZXknKTtcbiAgICB9XG4gICAgY29uc3Qgc2VjcmV0ID0gQnVmZmVyLmZyb20oXG4gICAgICAvLyBGSVhNRShCRy0zNDM4Nik6IHdlIHNob3VsZCB1c2UgYHNlY3AyNTZrMS5lY2RoKClgIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgc2VlIGRpc2N1c3Npb24gaGVyZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi1jb3JlL3NlY3AyNTZrMS9pc3N1ZXMvMzUyXG4gICAgICBzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwocHVibGljS2V5LCBzZWNyZXRLZXkpXG4gICAgKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICAvLyBkZWNyeXB0IHRva2VuIHdpdGggc3ltbWV0cmljIEVDREgga2V5XG4gICAgbGV0IHJlc3BvbnNlOiBUb2tlbklzc3VhbmNlO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgdG9rZW46IHRoaXMuZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHJlc3BvbnNlQm9keS5lbmNyeXB0ZWRUb2tlbixcbiAgICAgICAgICBwYXNzd29yZDogc2VjcmV0LFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5lcnJvckNvZGUgPSAndG9rZW5fZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHRva2VuLicpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9lY2RoWHBydikge1xuICAgICAgcmVzcG9uc2UuZWNkaFhwcnYgPSBlY2RoWHBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqL1xuICB2ZXJpZnlQYXNzd29yZChwYXJhbXM6IFZlcmlmeVBhc3N3b3JkT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdXNlciB8fCAhdGhpcy5fdXNlci51c2VybmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBjdXJyZW50IHVzZXInKTtcbiAgICB9XG4gICAgY29uc3QgaG1hY1Bhc3N3b3JkID0gdGhpcy5jYWxjdWxhdGVITUFDKHRoaXMuX3VzZXIudXNlcm5hbWUsIHBhcmFtcy5wYXNzd29yZCk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci92ZXJpZnlwYXNzd29yZCcpKS5zZW5kKHsgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCB9KS5yZXN1bHQoJ3ZhbGlkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGFsbCBzdGF0ZSBmcm9tIHRoaXMgQml0R28gb2JqZWN0LCBlZmZlY3RpdmVseSBsb2dnaW5nIG91dCB0aGUgY3VycmVudCB1c2VyLlxuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogYXJlIHRoZXJlIGFueSBvdGhlciBmaWVsZHMgd2hpY2ggc2hvdWxkIGJlIGNsZWFyZWQ/XG4gICAgdGhpcy5fdXNlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b2tlbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZWNkaFhwcnYgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHJlZnJlc2ggdG9rZW4gdG8gZ2V0IG5ldyBhY2Nlc3MgdG9rZW4uXG4gICAqIElmIHRoZSByZWZyZXNoIHRva2VuIGlzIG51bGwvZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIHN0b3JlZCB0b2tlbiBmcm9tIGF1dGhcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hUb2tlbihwYXJhbXM6IHsgcmVmcmVzaFRva2VuPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsncmVmcmVzaFRva2VuJ10pO1xuXG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gcGFyYW1zLnJlZnJlc2hUb2tlbiB8fCB0aGlzLl9yZWZyZXNoVG9rZW47XG5cbiAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgcmVmcmVzaCB0b2tlbiBvciBoYXZlIGF1dGhlbnRpY2F0ZWQgd2l0aCBPYXV0aCBiZWZvcmUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudElkIHx8ICF0aGlzLl9jbGllbnRTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBjbGllbnQgaWQgYW5kIHNlY3JldCBzZXQgZmlyc3QgdG8gdXNlIHRoaXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgdGhpcy5wb3N0KHRoaXMuX2Jhc2VVcmwgKyAnL29hdXRoL3Rva2VuJylcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5fY2xpZW50SWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG4gICAgdGhpcy5fdG9rZW4gPSBib2R5LmFjY2Vzc190b2tlbjtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogbGlzdEFjY2Vzc1Rva2Vuc1xuICAgKiBHZXQgaW5mb3JtYXRpb24gb24gYWxsIG9mIHRoZSBCaXRHbyBhY2Nlc3MgdG9rZW5zIG9uIHRoZSB1c2VyXG4gICAqIEByZXR1cm4ge1xuICAgKiAgaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqICBsYWJlbDogPHRoZSB1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiAgdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogIGVudGVycHJpc2UgPGlkIG9mIHRoZSBlbnRlcnByaXNlIHRoaXMgdG9rZW4gaXMgdmFsaWQgZm9yPlxuICAgKiAgY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiAgc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiAgY3JlYXRlZDogPGRhdGUgdGhlIHRva2VuIHdhcyBjcmVhdGVkPlxuICAgKiAgZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiAgb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogIGlzRXh0ZW5zaWJsZTogPGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgdG9rZW4gY2FuIGJlIGV4dGVuZGVkPlxuICAgKiAgZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmVjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiAgdW5sb2NrOiA8aW5mbyBmb3IgYWN0aW9ucyB0aGF0IHJlcXVpcmUgYW4gdW5sb2NrIGJlZm9yZSBmaXJpbmc+XG4gICAqIH1cbiAgICovXG4gIGFzeW5jIGxpc3RBY2Nlc3NUb2tlbnMoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL2FjY2Vzc3Rva2VuJykpLnNlbmQoKS5yZXN1bHQoJ2FjY2Vzc1Rva2VucycpO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZEFjY2Vzc1Rva2VuXG4gICAqIEFkZCBhIEJpdEdvIEFQSSBBY2Nlc3MgVG9rZW4gdG8gdGhlIGN1cnJlbnQgdXNlciBhY2NvdW50XG4gICAqIEBwYXJhbSBwYXJhbXMge1xuICAgKiAgICBvdHA6IChyZXF1aXJlZCkgPHZhbGlkIG90cCBjb2RlPlxuICAgKiAgICBsYWJlbDogKHJlcXVpcmVkKSA8bGFiZWwgZm9yIHRoZSB0b2tlbj5cbiAgICogICAgZHVyYXRpb246IDxsZW5ndGggb2YgdGltZSBpbiBzZWNvbmRzIHRoZSB0b2tlbiB3aWxsIGJlIHZhbGlkIGZvcj5cbiAgICogICAgaXBSZXN0cmljdDogPGFycmF5IG9mIElQIGFkZHJlc3Mgc3RyaW5ncyB0byB3aGl0ZWxpc3Q+XG4gICAqICAgIHR4VmFsdWVMaW1pdDogPG51bWJlciBvZiBvdXRnb2luZyBzYXRvc2hpcyBhbGxvd2VkIG9uIHRoaXMgdG9rZW4+XG4gICAqICAgIHNjb3BlOiAocmVxdWlyZWQpIDxhdXRob3JpemF0aW9uIHNjb3BlIG9mIHRoZSByZXF1ZXN0ZWQgdG9rZW4+XG4gICAqIH1cbiAgICogQHJldHVybiB7XG4gICAqICAgIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiAgICB0b2tlbjogPGFjY2VzcyB0b2tlbiBoZXggc3RyaW5nIHRvIGJlIHVzZWQgZm9yIEJpdEdvIEFQSSByZXF1ZXN0IHZlcmlmaWNhdGlvbj5cbiAgICogICAgbGFiZWw6IDx1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiAgICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgICBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogICAgY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiAgICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICAgIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogICAgZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiAgICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgICBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogICAgZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmVjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiAgICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgYXN5bmMgYWRkQWNjZXNzVG9rZW4ocGFyYW1zOiBBZGRBY2Nlc3NUb2tlbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmxhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBsYWJlbCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBub24tc3RyaW5nIHBhcmFtc1xuICAgICAgaWYgKHBhcmFtcy5kdXJhdGlvbikge1xuICAgICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmR1cmF0aW9uKSB8fCBwYXJhbXMuZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXJhdGlvbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmlwUmVzdHJpY3QpIHtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmlwUmVzdHJpY3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcFJlc3RyaWN0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBfLmZvckVhY2gocGFyYW1zLmlwUmVzdHJpY3QsIChpcEFkZHIpID0+IHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoaXBBZGRyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcFJlc3RyaWN0IG11c3QgYmUgYW4gYXJyYXkgb2YgSVAgYWRkcmVzcyBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMudHhWYWx1ZUxpbWl0KSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudHhWYWx1ZUxpbWl0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHhWYWx1ZUxpbWl0IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnR4VmFsdWVMaW1pdCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4VmFsdWVMaW1pdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNjb3BlICYmIHBhcmFtcy5zY29wZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5zY29wZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Njb3BlIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgc2NvcGUgZm9yIHRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dGhVcmwgPSB0aGlzLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvYXV0aC92MS9hY2Nlc3N0b2tlbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKCF0aGlzLl9lY2RoWHBydikge1xuICAgICAgICAvLyB3aXRob3V0IGEgcHJpdmF0ZSBrZXksIHRoZSB1c2VyIGNhbm5vdCBkZWNyeXB0IHRoZSBuZXcgYWNjZXNzIHRva2VuIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kXG4gICAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICBkZWJ1ZygnZm9yY2luZyB2MSBhdXRoIGZvciBhZGRpbmcgYWNjZXNzIHRva2VuIHVzaW5nIHRva2VuICVzJywgdGhpcy5fdG9rZW4/LnN1YnN0cigwLCA4KSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKHBhcmFtcyk7XG4gICAgICBpZiAocmVxdWVzdC5mb3JjZVYxQXV0aCkge1xuICAgICAgICAocmVzcG9uc2UgYXMgYW55KS5ib2R5Lndhcm5pbmcgPSAnQSBwcm90b2NvbCBkb3duZ3JhZGUgaGFzIG9jY3VycmVkIGJlY2F1c2UgdGhpcyBpcyBhIGxlZ2FjeSBhY2NvdW50Lic7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZVJlc3VsdCgpKHJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gdmVyaWZ5IHRoZSBhdXRoZW50aWNpdHkgb2YgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGJlZm9yZSBwcm9jZWVkaW5nIGFueSBmdXJ0aGVyXG4gICAgICB2ZXJpZnlSZXNwb25zZSh0aGlzLCB0aGlzLl90b2tlbiwgJ3Bvc3QnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRGV0YWlscyA9IHRoaXMuaGFuZGxlVG9rZW5Jc3N1YW5jZShyZXNwb25zZS5ib2R5KTtcbiAgICAgIHJlc3BvbnNlLmJvZHkudG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG5cbiAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZVJlc3VsdCgpKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVSZXNwb25zZUVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHBpcmUgdGltZSBvZiBhbiBhY2Nlc3MgdG9rZW4gbWF0Y2hpbmcgZWl0aGVyIHRoZSBpZCBvciBsYWJlbCB0byB0aGUgY3VycmVudCBkYXRlLCBlZmZlY3RpdmVseSBkZWxldGluZyBpdFxuICAgKlxuICAgKiBQYXJhbXM6XG4gICAqIGlkOiA8aWQgb2YgdGhlIGFjY2VzcyB0b2tlbiB0byBiZSBkZWxldGVkPlxuICAgKiBsYWJlbDogPGxhYmVsIG9mIHRoZSBhY2Nlc3MgdG9rZW4gdG8gYmUgZGVsZXRlZD5cbiAgICpcbiAgICogUmV0dXJuczpcbiAgICogaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqIGxhYmVsOiA8dXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lKmNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZW1vdmVBY2Nlc3NUb2tlbih7IGlkLCBsYWJlbCB9OiBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICgoIWlkICYmICFsYWJlbCkgfHwgKGlkICYmIGxhYmVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgb2YgaWQgb3IgbGFiZWwnKTtcbiAgICB9XG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWwodGhpcy51cmwoYC91c2VyL2FjY2Vzc3Rva2VuLyR7aWR9YCkpXG4gICAgICAgIC5zZW5kKClcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHRoaXMubGlzdEFjY2Vzc1Rva2VucygpO1xuXG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gd2l0aCB0aGlzIGxhYmVsIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2hpbmdUb2tlbnMgPSBfLmZpbHRlcih0b2tlbnMsIHsgbGFiZWwgfSk7XG4gICAgaWYgKG1hdGNoaW5nVG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYW1iaWd1b3VzIGNhbGw6IG11bHRpcGxlIHRva2VucyBtYXRjaGluZyB0aGlzIGxhYmVsJyk7XG4gICAgfVxuICAgIGlmIChtYXRjaGluZ1Rva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gd2l0aCB0aGlzIGxhYmVsIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVsKHRoaXMudXJsKGAvdXNlci9hY2Nlc3N0b2tlbi8ke21hdGNoaW5nVG9rZW5zWzBdLmlkfWApKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIHBhc3N3b3JkXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9IG51bVdvcmRzICAgICBOdW1iZXIgb2YgMzItYml0IHdvcmRzXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9ICAgICAgICAgIGJhc2U1OCByYW5kb20gcGFzc3dvcmRcbiAgICovXG4gIGdlbmVyYXRlUmFuZG9tUGFzc3dvcmQobnVtV29yZHMgPSA1KTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlcyA9IHNqY2wuY29kZWMuYnl0ZXMuZnJvbUJpdHMoc2pjbC5yYW5kb20ucmFuZG9tV29yZHMobnVtV29yZHMpKTtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUoYnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ291dCBvZiBCaXRHb1xuICAgKi9cbiAgYXN5bmMgbG9nb3V0KCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL2xvZ291dCcpKS5yZXN1bHQoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB1c2VyIGJ5IElEIChuYW1lL2VtYWlsIG9ubHkpXG4gICAqIEBwYXJhbSBpZFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcih7IGlkIH06IEdldFVzZXJPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoYC91c2VyLyR7aWR9YCkpLnJlc3VsdCgndXNlcicpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXJcbiAgICovXG4gIGFzeW5jIG1lKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VXNlcih7IGlkOiAnbWUnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9jayB0aGUgc2Vzc2lvbiBieSBwcm92aWRpbmcgT1RQXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvdHAgUmVxdWlyZWQgT1RQIGNvZGUgZm9yIHRoZSBhY2NvdW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRGVzaXJlZCBkdXJhdGlvbiBvZiB0aGUgdW5sb2NrIGluIHNlY29uZHMgKGRlZmF1bHQ9NjAwLCBtYXg9MzYwMCkuXG4gICAqL1xuICBhc3luYyB1bmxvY2soeyBvdHAsIGR1cmF0aW9uIH06IFVubG9ja09wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChvdHAgJiYgIV8uaXNTdHJpbmcob3RwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIG90cCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci91bmxvY2snKSkuc2VuZCh7IG90cCwgZHVyYXRpb24gfSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9jayB0aGUgc2Vzc2lvblxuICAgKi9cbiAgYXN5bmMgbG9jaygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2xvY2snKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICovXG4gIGFzeW5jIHNlc3Npb24oKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL3Nlc3Npb24nKSkucmVzdWx0KCdzZXNzaW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIHB1c2gvc21zIGZvciB0aGUgT1RQIGNvZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZm9yY2VTTVMgSWYgc2V0IHRvIHRydWUsIHdpbGwgdXNlIFNNUyB0byBzZW5kIHRoZSBPVFAgdG8gdGhlIHVzZXIgZXZlbiBpZiB0aGV5IGhhdmUgb3RoZXIgMkZBIG1ldGhvZCBzZXQgdXAuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBzZW5kT1RQKHBhcmFtczogeyBmb3JjZVNNUz86IGJvb2xlYW4gfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9zZW5kb3RwJykpLnNlbmQocGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdG9rZW4sIHByb3ZpZGVkIHRoZSBjdXJyZW50IHRva2VuIGlzIGV4dGVuZGFibGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIGR1cmF0aW9uOiBkdXJhdGlvbiBpbiBzZWNvbmRzIGJ5IHdoaWNoIHRvIGV4dGVuZCB0aGUgdG9rZW4sIHN0YXJ0aW5nIGF0IHRoZSBjdXJyZW50IHRpbWVcbiAgICovXG4gIGFzeW5jIGV4dGVuZFRva2VuKHBhcmFtczogRXh0ZW5kVG9rZW5PcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgX2V4dGVuc2lvbktleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgY29uc3QgbWVzc2FnZSA9IHRpbWVzdGFtcCArICd8JyArIHRoaXMuX3Rva2VuICsgJ3wnICsgZHVyYXRpb247XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHRoaXMuX2V4dGVuc2lvbktleS5wcml2YXRlS2V5O1xuICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBwcml2YXRlS2V5IG9uIGV4dGVuc2lvbktleScpO1xuICAgIH1cbiAgICBjb25zdCBpc0NvbXByZXNzZWQgPSB0aGlzLl9leHRlbnNpb25LZXkuY29tcHJlc3NlZDtcbiAgICBjb25zdCBwcmVmaXggPSB1dHhvbGliLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCwgcHJlZml4KS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9leHRlbmR0b2tlbicpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnNldCgndGltZXN0YW1wJywgdGltZXN0YW1wLnRvU3RyaW5nKCkpXG4gICAgICAuc2V0KCdzaWduYXR1cmUnLCBzaWduYXR1cmUpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEga2V5IGZvciBzaGFyaW5nIGEgd2FsbGV0IHdpdGggYSB1c2VyXG4gICAqIEBwYXJhbSBlbWFpbCBlbWFpbCBvZiB1c2VyIHRvIHNoYXJlIHdhbGxldCB3aXRoXG4gICAqL1xuICBhc3luYyBnZXRTaGFyaW5nS2V5KHsgZW1haWwgfTogR2V0U2hhcmluZ0tleU9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhlbWFpbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGVtYWlsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvc2hhcmluZ2tleScpKS5zZW5kKHsgZW1haWwgfSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGdldFZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2V0VmFsaWRhdGUodmFsaWRhdGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIH1cbn1cbiJdfQ==