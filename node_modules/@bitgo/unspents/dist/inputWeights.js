"use strict";
/**
 * Defines input sizes for BitGo signature scripts.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inputComponentsP2shP2pk = exports.inputComponentsP2trScriptSpendLevel2 = exports.inputComponentsP2trScriptSpendLevel1 = exports.inputComponentsP2trKeySpend = exports.inputComponentsP2wsh = exports.inputComponentsP2shP2wsh = exports.inputComponentsP2sh = exports.getInputComponentsWeight = exports.getInputWeight = exports.getInputByteLength = exports.varSliceSize = void 0;
const varuint_bitcoin_1 = __importDefault(require("varuint-bitcoin"));
function varSliceSize(someScript) {
    const length = someScript.length;
    return varuint_bitcoin_1.default.encodingLength(length) + length;
}
exports.varSliceSize = varSliceSize;
function vectorSize(someVector) {
    const length = someVector.length;
    return (varuint_bitcoin_1.default.encodingLength(length) +
        someVector.reduce((sum, witness) => {
            return sum + varSliceSize(witness);
        }, 0));
}
function getInputByteLength(input, allowWitness) {
    return (40 /* inputId(32), index(4), nSequence(4) */ +
        varSliceSize(input.script) +
        (allowWitness ? vectorSize(input.witness) : 0));
}
exports.getInputByteLength = getInputByteLength;
function getInputWeight(input) {
    return 3 * getInputByteLength(input, false) + getInputByteLength(input, true);
}
exports.getInputWeight = getInputWeight;
function getInputComponentsWeight(c) {
    const scriptSize = c.script.reduce((a, b) => a + b, 0);
    return getInputWeight({
        script: { length: scriptSize },
        witness: c.witness.map((v) => ({ length: v })),
    });
}
exports.getInputComponentsWeight = getInputComponentsWeight;
const opSize = 1;
const op0Size = opSize;
const opPushSize = opSize;
const opCheckSigVerifySize = opSize;
const opCheckSigSize = opSize;
const ecdsaSignatureSize = 72;
const schnorrPubkeySize = 32;
const schnorrSignatureNoSighashSize = 64;
const p2msPubScriptSize = 105;
const p2wshPubScriptSize = 34;
const p2pkPubScriptSize = 35;
function p2trScriptSpend(level) {
    return [
        schnorrSignatureNoSighashSize,
        schnorrSignatureNoSighashSize,
        opPushSize + schnorrPubkeySize + opCheckSigSize + opPushSize + schnorrPubkeySize + opCheckSigVerifySize,
        /* header byte */ 1 + /* inner key */ 32 + /* inner leaf */ 32 * level,
    ];
}
function p2msSigScriptSize(witness) {
    return [
        witness ? 0 : op0Size,
        (witness ? 0 : opPushSize) + ecdsaSignatureSize,
        (witness ? 0 : opPushSize) + ecdsaSignatureSize,
        (witness ? 0 : /* OP_PUSHDATA2 */ opPushSize + 1) + p2msPubScriptSize,
    ];
}
exports.inputComponentsP2sh = {
    script: p2msSigScriptSize(false),
    witness: [],
};
exports.inputComponentsP2shP2wsh = {
    script: [opSize + p2wshPubScriptSize],
    witness: p2msSigScriptSize(true),
};
exports.inputComponentsP2wsh = {
    script: [],
    witness: p2msSigScriptSize(true),
};
// See: https://murchandamus.medium.com/2-of-3-multisig-inputs-using-pay-to-taproot-d5faf2312ba3
exports.inputComponentsP2trKeySpend = {
    script: [],
    witness: [schnorrSignatureNoSighashSize],
};
exports.inputComponentsP2trScriptSpendLevel1 = {
    script: [],
    witness: p2trScriptSpend(1),
};
exports.inputComponentsP2trScriptSpendLevel2 = {
    script: [],
    witness: p2trScriptSpend(2),
};
exports.inputComponentsP2shP2pk = {
    script: [opPushSize + ecdsaSignatureSize, opPushSize + p2pkPubScriptSize],
    witness: [],
};
//# sourceMappingURL=inputWeights.js.map