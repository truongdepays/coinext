"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodesByType = exports.CodesByPurpose = exports.CodeGroup = exports.isValid = exports.ChainType = exports.Purpose = exports.UnspentType = exports.ErrorInvalidCode = void 0;
const tcomb = __importStar(require("tcomb"));
class ErrorInvalidCode extends Error {
    constructor(code) {
        super(`invalid code ${code}`);
    }
}
exports.ErrorInvalidCode = ErrorInvalidCode;
var UnspentType;
(function (UnspentType) {
    UnspentType["p2pkh"] = "p2pkh";
    UnspentType["p2sh"] = "p2sh";
    UnspentType["p2shP2wsh"] = "p2shP2wsh";
    UnspentType["p2wpkh"] = "p2wpkh";
    UnspentType["p2wsh"] = "p2wsh";
    UnspentType["p2tr"] = "p2tr";
})(UnspentType = exports.UnspentType || (exports.UnspentType = {}));
const UnspentTypeTcomb = tcomb.enums.of(Object.keys(UnspentType));
var Purpose;
(function (Purpose) {
    Purpose["internal"] = "internal";
    Purpose["external"] = "external";
})(Purpose = exports.Purpose || (exports.Purpose = {}));
const PurposeTcomb = tcomb.enums.of(Object.keys(Purpose));
const codeList = Object.freeze([
    [0, UnspentType.p2sh, Purpose.external],
    [10, UnspentType.p2shP2wsh, Purpose.external],
    [20, UnspentType.p2wsh, Purpose.external],
    [30, UnspentType.p2tr, Purpose.external],
    [1, UnspentType.p2sh, Purpose.internal],
    [11, UnspentType.p2shP2wsh, Purpose.internal],
    [21, UnspentType.p2wsh, Purpose.internal],
    [31, UnspentType.p2tr, Purpose.internal],
].map(([id, type, purpose]) => Object.freeze({ id, type, purpose })));
exports.ChainType = tcomb.irreducible('ChainType', (n) => exports.isValid(n));
const forType = (u) => {
    // Do tcomb type checking in js projects that use this lib
    if (!UnspentTypeTcomb.is(u)) {
        throw new Error(`invalid unspent type: ${u}`);
    }
    return new CodesByPurpose(u);
};
const typeForCode = (c) => {
    const code = codeList.find(({ id }) => id === c);
    if (!code) {
        throw new ErrorInvalidCode(c);
    }
    return code.type;
};
const isValid = (c) => codeList.some(({ id }) => id === c);
exports.isValid = isValid;
const throwIfUndefined = (v) => {
    if (v === undefined) {
        throw new Error(`expected value to be defined`);
    }
    return v;
};
class CodeGroup {
    constructor(values) {
        this.values = Object.freeze([...values]);
    }
    has(code) {
        if (!exports.isValid(code)) {
            throw new ErrorInvalidCode(code);
        }
        return this.values.includes(code);
    }
}
exports.CodeGroup = CodeGroup;
class CodesByPurpose extends CodeGroup {
    constructor(t) {
        const codeMap = new Map(codeList.filter(({ type }) => type === t).map(({ purpose, id }) => [purpose, id]));
        if (codeMap.size !== 2) {
            throw new Error(`unexpected number of codes for type ${t}`);
        }
        super(codeMap.values());
        this.internal = throwIfUndefined(codeMap.get(Purpose.internal));
        this.external = throwIfUndefined(codeMap.get(Purpose.external));
    }
}
exports.CodesByPurpose = CodesByPurpose;
class CodesByType extends CodeGroup {
    constructor(p) {
        const codeMap = new Map(codeList.filter(({ purpose }) => purpose === p).map(({ type, id }) => [type, id]));
        if (codeMap.size !== 4) {
            throw new Error(`unexpected number of codes`);
        }
        super(codeMap.values());
        this.p2sh = throwIfUndefined(codeMap.get(UnspentType.p2sh));
        this.p2shP2wsh = throwIfUndefined(codeMap.get(UnspentType.p2shP2wsh));
        this.p2wsh = throwIfUndefined(codeMap.get(UnspentType.p2wsh));
        this.p2tr = throwIfUndefined(codeMap.get(UnspentType.p2tr));
    }
}
exports.CodesByType = CodesByType;
const boundHas = (instance) => instance.has.bind(instance);
const p2sh = Object.freeze(new CodesByPurpose(UnspentType.p2sh));
const p2shP2wsh = Object.freeze(new CodesByPurpose(UnspentType.p2shP2wsh));
const p2wsh = Object.freeze(new CodesByPurpose(UnspentType.p2wsh));
const p2tr = Object.freeze(new CodesByPurpose(UnspentType.p2tr));
const external = Object.freeze(new CodesByType(Purpose.external));
const internal = Object.freeze(new CodesByType(Purpose.internal));
const all = Object.freeze(codeList.map(({ id }) => id));
/** @deprecated - use utxolib.bitgo */
exports.default = Object.freeze({
    /* @deprecated: use ChainCodeTcomb */
    ChainType: exports.ChainType,
    /** @deprecated - use utxolib.bitgo */
    ChainCodeTcomb: exports.ChainType,
    /** @deprecated - use utxolib.bitgo */
    PurposeTcomb,
    /** @deprecated - use utxolib.bitgo */
    UnspentTypeTcomb,
    /** @deprecated - use utxolib.bitgo */
    p2sh,
    /** @deprecated - use utxolib.bitgo */
    p2shP2wsh,
    /** @deprecated - use utxolib.bitgo */
    p2wsh,
    /** @deprecated - use utxolib.bitgo */
    p2tr,
    /** @deprecated - use utxolib.bitgo */
    external,
    /** @deprecated - use utxolib.bitgo */
    internal,
    /** @deprecated - use utxolib.bitgo */
    all,
    /** @deprecated - use utxolib.bitgo */
    isP2sh: boundHas(p2sh),
    /** @deprecated - use utxolib.bitgo */
    isP2shP2wsh: boundHas(p2shP2wsh),
    /** @deprecated - use utxolib.bitgo */
    isP2wsh: boundHas(p2wsh),
    /** @deprecated - use utxolib.bitgo */
    isP2tr: boundHas(p2tr),
    /** @deprecated - use utxolib.bitgo */
    isExternal: boundHas(external),
    /** @deprecated - use utxolib.bitgo */
    isInternal: boundHas(internal),
    /** @deprecated - use utxolib.bitgo */
    isValid: exports.isValid,
    /** @deprecated - use utxolib.bitgo */
    forType,
    /** @deprecated - use utxolib.bitgo */
    typeForCode,
});
//# sourceMappingURL=codes.js.map