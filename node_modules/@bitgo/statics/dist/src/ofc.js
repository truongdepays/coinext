"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tofcerc20 = exports.ofcerc20 = exports.tofc = exports.ofc = exports.OfcCoin = void 0;
const base_1 = require("./base");
const networks_1 = require("./networks");
/**
 * OFC (off chain) coins. These are virtual coins used to represent off chain assets on the BitGo platform.
 */
class OfcCoin extends base_1.BaseCoin {
    constructor(options) {
        const { addressCoin, ...baseOptions } = options;
        super(baseOptions);
        this.addressCoin = addressCoin;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL, base_1.CoinFeature.REQUIRES_BIG_NUMBER]);
    }
    disallowedFeatures() {
        return new Set([
            base_1.CoinFeature.UNSPENT_MODEL,
            base_1.CoinFeature.CHILD_PAYS_FOR_PARENT,
            base_1.CoinFeature.PAYGO,
            base_1.CoinFeature.SUPPORTS_TOKENS,
        ]);
    }
}
exports.OfcCoin = OfcCoin;
OfcCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.CUSTODY,
];
/**
 * Factory function for ofc coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofc(name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, 
/** OFC tokens use SECP256K1 under the hood even if the chain doesn't **/
primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
    }));
}
exports.ofc = ofc;
/**
 * Factory function for testnet ofc coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofc(name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
    }));
}
exports.tofc = tofc;
/**
 * Factory function for ofc erc20 coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcerc20(name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'eth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
    }));
}
exports.ofcerc20 = ofcerc20;
/**
 * Factory function for testnet ofc erc20 coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcerc20(name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'teth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
    }));
}
exports.tofcerc20 = tofcerc20;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBb0Y7QUFDcEYseUNBQStEO0FBaUIvRDs7R0FFRztBQUNILE1BQWEsT0FBUSxTQUFRLGVBQVE7SUFVbkMsWUFBWSxPQUE4QjtRQUN4QyxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQ2hELEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0lBRVMsZ0JBQWdCO1FBQ3hCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsRUFBRSxrQkFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRVMsa0JBQWtCO1FBQzFCLE9BQU8sSUFBSSxHQUFHLENBQWM7WUFDMUIsa0JBQVcsQ0FBQyxhQUFhO1lBQ3pCLGtCQUFXLENBQUMscUJBQXFCO1lBQ2pDLGtCQUFXLENBQUMsS0FBSztZQUNqQixrQkFBVyxDQUFDLGVBQWU7U0FDNUIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUEzQkgsMEJBNEJDO0FBM0J3Qix3QkFBZ0IsR0FBRztJQUN4QyxrQkFBVyxDQUFDLGFBQWE7SUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7SUFDL0Isa0JBQVcsQ0FBQyxPQUFPO0NBQ3BCLENBQUM7QUF5Qko7Ozs7Ozs7Ozs7Ozs7O0dBY0c7QUFDSCxTQUFnQixHQUFHLENBQ2pCLElBQVksRUFDWixRQUFnQixFQUNoQixhQUFxQixFQUNyQixLQUFzQixFQUN0QixPQUFpQixlQUFRLENBQUMsTUFBTSxFQUNoQyxXQUEwQixPQUFPLENBQUMsZ0JBQWdCLEVBQ2xELFNBQWlCLEVBQUUsRUFDbkIsU0FBaUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFD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UUFDYixPQUFPO1FBQ1AsS0FBSztRQUNMLElBQUk7UUFDSixXQUFXO1FBQ1gsZUFBZTtLQUNoQixDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUM7QUE5QkQsOEJBOEJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4sIENvaW5GZWF0dXJlLCBDb2luS2luZCwgS2V5Q3VydmUsIFVuZGVybHlpbmdBc3NldCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBCYXNlTmV0d29yaywgTmV0d29ya3MsIE9mY05ldHdvcmsgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBPZmNDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIG5ldHdvcms6IEJhc2VOZXR3b3JrO1xuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0O1xuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXTtcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyO1xuICBpc1Rva2VuOiBib29sZWFuO1xuICBraW5kOiBDb2luS2luZDtcbiAgcHJlZml4Pzogc3RyaW5nO1xuICBzdWZmaXg/OiBzdHJpbmc7XG4gIGFkZHJlc3NDb2luPzogc3RyaW5nO1xuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlO1xufVxuXG4vKipcbiAqIE9GQyAob2ZmIGNoYWluKSBjb2lucy4gVGhlc2UgYXJlIHZpcnR1YWwgY29pbnMgdXNlZCB0byByZXByZXNlbnQgb2ZmIGNoYWluIGFzc2V0cyBvbiB0aGUgQml0R28gcGxhdGZvcm0uXG4gKi9cbmV4cG9ydCBjbGFzcyBPZmNDb2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRkVBVFVSRVMgPSBbXG4gICAgQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCxcbiAgICBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSLFxuICAgIENvaW5GZWF0dXJlLkNVU1RPRFksXG4gIF07XG5cbiAgLy8gSWYgc2V0LCB0aGlzIGNvaW4gaXMgdGhlIG5hdGl2ZSBhZGRyZXNzIGZvcm1hdCBmb3IgdGhpcyB0b2tlbi5cbiAgcHVibGljIHJlYWRvbmx5IGFkZHJlc3NDb2luPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE9mY0NvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWRkcmVzc0NvaW4sIC4uLmJhc2VPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3NDb2luID0gYWRkcmVzc0NvaW47XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsIENvaW5GZWF0dXJlLlJFUVVJUkVTX0JJR19OVU1CRVJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtcbiAgICAgIENvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUwsXG4gICAgICBDb2luRmVhdHVyZS5DSElMRF9QQVlTX0ZPUl9QQVJFTlQsXG4gICAgICBDb2luRmVhdHVyZS5QQVlHTyxcbiAgICAgIENvaW5GZWF0dXJlLlNVUFBPUlRTX1RPS0VOUyxcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmMoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbjogYm9vbGVhbiA9IHRydWUsXG4gIC8qKiBPRkMgdG9rZW5zIHVzZSBTRUNQMjU2SzEgdW5kZXIgdGhlIGhvb2QgZXZlbiBpZiB0aGUgY2hhaW4gZG9lc24ndCAqKi9cbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mYyhcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuOiBib29sZWFuID0gdHJ1ZSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGVyYzIwIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mY2VyYzIwKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW46IGJvb2xlYW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbjogc3RyaW5nID0gJ2V0aCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGVyYzIwIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNlcmMyMChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuOiBib29sZWFuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW46IHN0cmluZyA9ICd0ZXRoJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cbiJdfQ==