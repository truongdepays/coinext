"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tfiatToken = exports.fiatToken = exports.tavaxErc20 = exports.avaxErc20 = exports.tsolToken = exports.solToken = exports.teosToken = exports.eosToken = exports.talgoToken = exports.algoToken = exports.hederaCoin = exports.ttronToken = exports.tronToken = exports.tstellarToken = exports.stellarToken = exports.tceloToken = exports.celoToken = exports.erc20CompatibleAccountCoin = exports.terc1155 = exports.erc1155 = exports.terc721 = exports.erc721 = exports.terc20 = exports.erc20 = exports.account = exports.FiatToken = exports.AvaxERC20Token = exports.SolCoin = exports.EosCoin = exports.AlgoCoin = exports.HederaCoin = exports.StellarCoin = exports.CeloCoin = exports.Erc20CompatibleAccountCoin = exports.TronErc20Coin = exports.Erc1155Coin = exports.Erc721Coin = exports.Erc20Coin = exports.Base58ContractAddressDefinedToken = exports.ContractAddressDefinedToken = exports.AccountCoinToken = exports.AccountCoin = void 0;
const base_1 = require("./base");
const errors_1 = require("./errors");
const networks_1 = require("./networks");
/**
 * Account based coins, such as Ethereum, Stellar, or XRP.
 *
 * These types of coins maintain an "account balance" for each address on the network,
 * as opposed to the unspent transaction output model which maintains a record of all
 * "pieces" of coin which belong to an address.
 */
class AccountCoin extends base_1.BaseCoin {
    constructor(options) {
        super({
            ...options,
            kind: base_1.CoinKind.CRYPTO,
        });
        this.network = options.network;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    }
    disallowedFeatures() {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    }
}
exports.AccountCoin = AccountCoin;
AccountCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.VALUELESS_TRANSFER,
    base_1.CoinFeature.TRANSACTION_DATA,
    base_1.CoinFeature.CUSTODY,
];
class AccountCoinToken extends AccountCoin {
    constructor(options) {
        super({
            ...options,
        });
    }
}
exports.AccountCoinToken = AccountCoinToken;
/**
 * Some blockchains support tokens which are defined by an address at which they have a smart contract deployed.
 * Examples are ERC20 tokens, and the equivalent on other chains.
 */
class ContractAddressDefinedToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        // valid ERC 20 contract addresses are "0x" followed by 40 lowercase hex characters
        if (!options.contractAddress.match(/^0x[a-f0-9]{40}$/)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        this.contractAddress = options.contractAddress;
    }
}
exports.ContractAddressDefinedToken = ContractAddressDefinedToken;
/**
 * ERC20 token addresses are Base58 formatted on some blockchains.
 */
class Base58ContractAddressDefinedToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (!/^[1-9A-HJ-NP-Za-km-z]{34}$/.test(options.contractAddress)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        this.contractAddress = options.contractAddress;
    }
}
exports.Base58ContractAddressDefinedToken = Base58ContractAddressDefinedToken;
/**
 * ERC 20 is a token standard for the Ethereum blockchain. They are similar to other account coins, but have a
 * contract address property which identifies the smart contract which defines the token.
 */
class Erc20Coin extends ContractAddressDefinedToken {
}
exports.Erc20Coin = Erc20Coin;
/**
 * ERC 721 is the non fungible token standard for the Ethereum blockchain.
 *
 * {@link https://eips.ethereum.org/EIPS/eip-721 EIP721}
 */
class Erc721Coin extends ContractAddressDefinedToken {
}
exports.Erc721Coin = Erc721Coin;
/**
 * ERC 1155 is the multi token standard for the Ethereum blockchain.
 *
 * {@link https://eips.ethereum.org/EIPS/eip-1155 EIP1155}
 */
class Erc1155Coin extends ContractAddressDefinedToken {
}
exports.Erc1155Coin = Erc1155Coin;
/**
 * The TRON blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class TronErc20Coin extends Base58ContractAddressDefinedToken {
}
exports.TronErc20Coin = TronErc20Coin;
/**
 * Some blockchains have native coins which also support the ERC20 interface such as CELO.
 */
class Erc20CompatibleAccountCoin extends ContractAddressDefinedToken {
    constructor(options) {
        super({
            ...options,
            // These coins should not be classified as tokens as they are not children of other coins
            isToken: false,
        });
    }
}
exports.Erc20CompatibleAccountCoin = Erc20CompatibleAccountCoin;
/**
 * The CELO blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class CeloCoin extends ContractAddressDefinedToken {
}
exports.CeloCoin = CeloCoin;
/**
 * The Stellar network supports tokens (non-native assets)
 * XLM is also known as the native asset.
 * Stellar tokens work similar to XLM, but the token name is determined by the chain,
 * the token code and the issuer account in the form: (t)xlm:<token>-<issuer>
 */
class StellarCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        const domainPattern = /^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$/;
        if (options.domain !== '' && !options.domain.match(domainPattern)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        this.domain = options.domain;
    }
}
exports.StellarCoin = StellarCoin;
/**
 * The Hedera coin needs a client set with the node account Id.
 * It's an account based coin that needs the node account ID
 * where the transaction will be sent.
 */
class HederaCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.nodeAccountId = options.nodeAccountId;
    }
}
exports.HederaCoin = HederaCoin;
/**
 * The Algo network supports tokens (assets)
 * Algo tokens work similar to native ALGO coin, but the token name is determined by
 * unique asset id on the chain. Internally, BitGo uses token identifiers of the format: (t)algo:<assetId>
 *
 */
class AlgoCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.tokenURL) {
            try {
                new URL(options.tokenURL);
            }
            catch (ex) {
                throw new errors_1.InvalidDomainError(options.name, options.tokenURL);
            }
        }
        this.tokenURL = options.tokenURL;
    }
}
exports.AlgoCoin = AlgoCoin;
/**
 * The Eos network supports tokens
 * Eos tokens work similar to native Eos coin, but the token name is determined by
 * the contractName on the chain.
 *
 */
class EosCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.contractName = options.contractName;
    }
}
exports.EosCoin = EosCoin;
/**
 * The Sol network supports tokens
 * Sol tokens work similar to native SOL coin, but the token name is determined by
 * the tokenAddress on the chain.
 *
 */
class SolCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.tokenAddress = options.tokenAddress;
    }
}
exports.SolCoin = SolCoin;
/**
 * The AVAX C Chain network support tokens
 * AVAX C Chain Tokens are ERC20 coins
 */
class AvaxERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.AvaxERC20Token = AvaxERC20Token;
/**
 * FIAT based tokens, such as USD, EUR, or YEN.
 */
class FiatToken extends base_1.BaseCoin {
    constructor(options) {
        super({
            ...options,
            kind: base_1.CoinKind.FIAT,
        });
        this.network = options.network;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    }
    disallowedFeatures() {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    }
}
exports.FiatToken = FiatToken;
FiatToken.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.VALUELESS_TRANSFER,
    base_1.CoinFeature.TRANSACTION_DATA,
    base_1.CoinFeature.CUSTODY,
];
/**
 * Factory function for account coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function account(name, fullName, network, decimalPlaces, asset, features = AccountCoin.DEFAULT_FEATURES, primaryKeyCurve = base_1.KeyCurve.Secp256k1, prefix = '', suffix = name.toUpperCase(), isToken = false) {
    return Object.freeze(new AccountCoin({
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        primaryKeyCurve,
    }));
}
exports.account = account;
/**
 * Factory function for erc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc20Coin({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.erc20 = erc20;
/**
 * Factory function for testnet erc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Kovan test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function terc20(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.kovan) {
    return erc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.terc20 = terc20;
/**
 * Factory function for erc721 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc721(name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc721Coin({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.ERC721,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.erc721 = erc721;
/**
 * Factory function for testnet erc721 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Goerli test network.
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function terc721(name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.goerli, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return erc721(name, fullName, contractAddress, features, prefix, suffix, network, primaryKeyCurve);
}
exports.terc721 = terc721;
/**
 * Factory function for erc1155 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc1155(name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc1155Coin({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.ERC1155,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.erc1155 = erc1155;
/**
 * Factory function for testnet erc1155 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Goerli test network.
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function terc1155(name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.goerli, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return erc1155(name, fullName, contractAddress, features, prefix, suffix, network, primaryKeyCurve);
}
exports.terc1155 = terc1155;
/**
 * Factory function for ERC20-compatible account coin instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20CompatibleAccountCoin(name, fullName, network, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc20CompatibleAccountCoin({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: false,
        primaryKeyCurve,
    }));
}
exports.erc20CompatibleAccountCoin = erc20CompatibleAccountCoin;
/**
 * Factory function for celo token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to CELO main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function celoToken(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.celo, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new CeloCoin({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.celoToken = celoToken;
/**
 * Factory function for testnet celo token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet CELO network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tceloToken(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.celo) {
    return celoToken(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.tceloToken = tceloToken;
/**
 * Factory function for Stellar token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function stellarToken(name, fullName, decimalPlaces, asset, domain = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.stellar, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new StellarCoin({
        name,
        fullName,
        decimalPlaces,
        asset,
        domain,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.stellarToken = stellarToken;
/**
 * Factory function for testnet Stellar token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tstellarToken(name, fullName, decimalPlaces, asset, domain = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.stellar) {
    return stellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network);
}
exports.tstellarToken = tstellarToken;
/**
 * Factory function for tron token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to TRON main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tronToken(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.trx, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new TronErc20Coin({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.tronToken = tronToken;
/**
 * Factory function for testnet tron token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet TRON network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ttronToken(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.trx, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return tronToken(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.ttronToken = ttronToken;
/**
 * Factory function for Hedera coin instances
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param nodeAccountId node account Id from which the transaction will be sent
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Hedera mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function hederaCoin(name, fullName, network, decimalPlaces, asset, nodeAccountId = '0.0.3', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new HederaCoin({
        name,
        fullName,
        decimalPlaces,
        asset,
        nodeAccountId,
        features,
        prefix,
        suffix,
        network,
        isToken: false,
        primaryKeyCurve,
    }));
}
exports.hederaCoin = hederaCoin;
/**
 * Factory function for ALGO token instances.
 *
 * @param name unique identifier of the token
 * @param alias (optional) alternative identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param tokenURL Optional asset Url for more informationa about the asset
 * See https://developer.algorand.org/docs/reference/transactions/#url
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to ALGO mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function algoToken(name, alias, fullName, decimalPlaces, asset, tokenURL = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.algorand, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new AlgoCoin({
        name,
        alias,
        fullName,
        decimalPlaces,
        asset,
        tokenURL: tokenURL,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.algoToken = algoToken;
/**
 * Factory function for testnet ALGO token instances.
 *
 * @param name unique identifier of the token
 * @param alias (optional) alternative identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param tokenURL Optional asset Url for more informationa about the asset
 * See https://developer.algorand.org/docs/reference/transactions/#url
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Algo testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function talgoToken(name, alias, fullName, decimalPlaces, asset, tokenURL = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.algorand) {
    return algoToken(name, alias, fullName, decimalPlaces, asset, tokenURL, features, prefix, suffix, network);
}
exports.talgoToken = talgoToken;
/**
 * Factory function for eos token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractName Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to EOS main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function eosToken(name, fullName, decimalPlaces, contractName, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.eos, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new EosCoin({
        name,
        fullName,
        network,
        contractName,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.eosToken = eosToken;
/**
 * Factory function for testnet eos token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet EOS network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function teosToken(name, fullName, decimalPlaces, contractName, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.eos) {
    return eosToken(name, fullName, decimalPlaces, contractName, asset, features, prefix, suffix, network);
}
exports.teosToken = teosToken;
/**
 * Factory function for sol token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenAddress Token address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to SOL main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function solToken(name, fullName, decimalPlaces, tokenAddress, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.sol, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new SolCoin({
        name,
        fullName,
        network,
        tokenAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.solToken = solToken;
/**
 * Factory function for testnet sol token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenAddress Token address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet SOL network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 */
function tsolToken(name, fullName, decimalPlaces, tokenAddress, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.sol) {
    return solToken(name, fullName, decimalPlaces, tokenAddress, asset, features, prefix, suffix, network);
}
exports.tsolToken = tsolToken;
/**
 * Factory function for avaxErc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to AvalancheC main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function avaxErc20(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.avalancheC, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new AvaxERC20Token({
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
    }));
}
exports.avaxErc20 = avaxErc20;
/**
 * Factory function for testnet avaxErc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the AvalancheC test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tavaxErc20(name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.avalancheC, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return avaxErc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tavaxErc20 = tavaxErc20;
/**
 * Factory function for FIAT currency instances.
 *
 * @param name unique identifier of the currency
 * @param fullName Complete human-readable name of the currency
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param network Network object for this coin
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function fiatToken(name, fullName, asset, decimalPlaces, network = networks_1.Networks.main.fiat, prefix = '', suffix = name.toUpperCase(), features = FiatToken.DEFAULT_FEATURES, isToken = true, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new FiatToken({
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        primaryKeyCurve,
    }));
}
exports.fiatToken = fiatToken;
/**
 * Factory function for testnet FIAT currency instances.
 *
 * @param name unique identifier of the currency
 * @param fullName Complete human-readable name of the currency
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a currency.
 * @param decimalPlaces Number of decimal places this currency supports (divisibility exponent)
 */
function tfiatToken(name, fullName, asset, decimalPlaces, network = networks_1.Networks.test.fiat) {
    return fiatToken(name, fullName, asset, decimalPlaces, network);
}
exports.tfiatToken = tfiatToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2NvdW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFvRjtBQUNwRixxQ0FBMkU7QUFDM0UseUNBQWlHO0FBZ0JqRzs7Ozs7O0dBTUc7QUFDSCxNQUFhLFdBQVksU0FBUSxlQUFRO0lBV3ZDLFlBQVksT0FBa0M7UUFDNUMsS0FBSyxDQUFDO1lBQ0osR0FBRyxPQUFPO1lBQ1YsSUFBSSxFQUFFLGVBQVEsQ0FBQyxNQUFNO1NBQ3RCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNqQyxDQUFDO0lBRVMsZ0JBQWdCO1FBQ3hCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVTLGtCQUFrQjtRQUMxQixPQUFPLElBQUksR0FBRyxDQUFjLENBQUMsa0JBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7O0FBMUJILGtDQTJCQztBQTFCd0IsNEJBQWdCLEdBQUc7SUFDeEMsa0JBQVcsQ0FBQyxhQUFhO0lBQ3pCLGtCQUFXLENBQUMsbUJBQW1CO0lBQy9CLGtCQUFXLENBQUMsa0JBQWtCO0lBQzlCLGtCQUFXLENBQUMsZ0JBQWdCO0lBQzVCLGtCQUFXLENBQUMsT0FBTztDQUNwQixDQUFDO0FBa0RKLE1BQWEsZ0JBQWlCLFNBQVEsV0FBVztJQUMvQyxZQUFZLE9BQWtDO1FBQzVDLEtBQUssQ0FBQztZQUNKLEdBQUcsT0FBTztTQUNYLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQU5ELDRDQU1DO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSwyQkFBNEIsU0FBUSxnQkFBZ0I7SUFHL0QsWUFBWSxPQUFnQztRQUMxQyxLQUFLLENBQUM7WUFDSixHQUFHLE9BQU87U0FDWCxDQUFDLENBQUM7UUFFSCxtRkFB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USxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQ3pDLE1BQU0sR0FBRyxFQUFFLEVBQ1gsU0FBaUIsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUNuQyxXQUEwQixTQUFTLENBQUMsZ0JBQWdCLEVBQ3BELE9BQU8sR0FBRyxJQUFJLEVBQ2Qsa0JBQTRCLGVBQVEsQ0FBQyxTQUFTO0lBRTlDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FDbEIsSUFBSSxTQUFTLENBQUM7UUFDWixJQUFJO1FBQ0osUUFBUTtRQUNSLE9BQU87UUFDUCxNQUFNO1FBQ04sTUFBTTtRQUNOLFFBQVE7UUFDUixhQUFhO1FBQ2IsT0FBTztRQUNQLEtBQUs7UUFDTCxlQUFlO0tBQ2hCLENBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQztBQTFCRCw4QkEwQkM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBZ0IsVUFBVSxDQUN4QixJQUFZLEVBQ1osUUFBZ0IsRUFDaEIsS0FBc0IsRUFDdEIsYUFBcUIsRUFDckIsVUFBdUIsbUJBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSTtJQUV6QyxPQUFPLFNBQVMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQVJELGdDQVFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4sIENvaW5GZWF0dXJlLCBDb2luS2luZCwgS2V5Q3VydmUsIFVuZGVybHlpbmdBc3NldCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IsIEludmFsaWREb21haW5FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEFjY291bnROZXR3b3JrLCBCYXNlTmV0d29yaywgRXRoZXJldW1OZXR3b3JrLCBOZXR3b3JrcywgVHJvbk5ldHdvcmsgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhbGlhcz86IHN0cmluZztcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQ7XG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdO1xuICBkZWNpbWFsUGxhY2VzOiBudW1iZXI7XG4gIGlzVG9rZW46IGJvb2xlYW47XG4gIHByZWZpeD86IHN0cmluZztcbiAgc3VmZml4Pzogc3RyaW5nO1xuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlO1xufVxuXG4vKipcbiAqIEFjY291bnQgYmFzZWQgY29pbnMsIHN1Y2ggYXMgRXRoZXJldW0sIFN0ZWxsYXIsIG9yIFhSUC5cbiAqXG4gKiBUaGVzZSB0eXBlcyBvZiBjb2lucyBtYWludGFpbiBhbiBcImFjY291bnQgYmFsYW5jZVwiIGZvciBlYWNoIGFkZHJlc3Mgb24gdGhlIG5ldHdvcmssXG4gKiBhcyBvcHBvc2VkIHRvIHRoZSB1bnNwZW50IHRyYW5zYWN0aW9uIG91dHB1dCBtb2RlbCB3aGljaCBtYWludGFpbnMgYSByZWNvcmQgb2YgYWxsXG4gKiBcInBpZWNlc1wiIG9mIGNvaW4gd2hpY2ggYmVsb25nIHRvIGFuIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0ZFQVRVUkVTID0gW1xuICAgIENvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsXG4gICAgQ29pbkZlYXR1cmUuUkVRVUlSRVNfQklHX05VTUJFUixcbiAgICBDb2luRmVhdHVyZS5WQUxVRUxFU1NfVFJBTlNGRVIsXG4gICAgQ29pbkZlYXR1cmUuVFJBTlNBQ1RJT05fREFUQSxcbiAgICBDb2luRmVhdHVyZS5DVVNUT0RZLFxuICBdO1xuXG4gIHB1YmxpYyByZWFkb25seSBuZXR3b3JrOiBBY2NvdW50TmV0d29yaztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGtpbmQ6IENvaW5LaW5kLkNSWVBUTyxcbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yayA9IG9wdGlvbnMubmV0d29yaztcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1aXJlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTF0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpc2FsbG93ZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUxdKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVyYzIwQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZWxsYXJDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGRvbWFpbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlZGVyYUNvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgbm9kZUFjY291bnRJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFsZ29Db2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIHRva2VuVVJMOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW9zQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBjb250cmFjdE5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb2xDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIHRva2VuQWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0QWRkcmVzcyBleHRlbmRzIFN0cmluZyB7XG4gIF9fY29udHJhY3RhZGRyZXNzX3BoYW50b21fXzogbmV2ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pblRva2VuIGV4dGVuZHMgQWNjb3VudENvaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgYmxvY2tjaGFpbnMgc3VwcG9ydCB0b2tlbnMgd2hpY2ggYXJlIGRlZmluZWQgYnkgYW4gYWRkcmVzcyBhdCB3aGljaCB0aGV5IGhhdmUgYSBzbWFydCBjb250cmFjdCBkZXBsb3llZC5cbiAqIEV4YW1wbGVzIGFyZSBFUkMyMCB0b2tlbnMsIGFuZCB0aGUgZXF1aXZhbGVudCBvbiBvdGhlciBjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0QWRkcmVzczogQ29udHJhY3RBZGRyZXNzO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIHZhbGlkIEVSQyAyMCBjb250cmFjdCBhZGRyZXNzZXMgYXJlIFwiMHhcIiBmb2xsb3dlZCBieSA0MCBsb3dlcmNhc2UgaGV4IGNoYXJhY3RlcnNcbiAgICBpZiAoIW9wdGlvbnMuY29udHJhY3RBZGRyZXNzLm1hdGNoKC9eMHhbYS1mMC05XXs0MH0kLykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyBhcyB1bmtub3duIGFzIENvbnRyYWN0QWRkcmVzcztcbiAgfVxufVxuXG4vKipcbiAqIEVSQzIwIHRva2VuIGFkZHJlc3NlcyBhcmUgQmFzZTU4IGZvcm1hdHRlZCBvbiBzb21lIGJsb2NrY2hhaW5zLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZTU4Q29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBjb250cmFjdEFkZHJlc3M6IENvbnRyYWN0QWRkcmVzcztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBpZiAoIS9eWzEtOUEtSEotTlAtWmEta20tel17MzR9JC8udGVzdChvcHRpb25zLmNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyBhcyB1bmtub3duIGFzIENvbnRyYWN0QWRkcmVzcztcbiAgfVxufVxuXG4vKipcbiAqIEVSQyAyMCBpcyBhIHRva2VuIHN0YW5kYXJkIGZvciB0aGUgRXRoZXJldW0gYmxvY2tjaGFpbi4gVGhleSBhcmUgc2ltaWxhciB0byBvdGhlciBhY2NvdW50IGNvaW5zLCBidXQgaGF2ZSBhXG4gKiBjb250cmFjdCBhZGRyZXNzIHByb3BlcnR5IHdoaWNoIGlkZW50aWZpZXMgdGhlIHNtYXJ0IGNvbnRyYWN0IHdoaWNoIGRlZmluZXMgdGhlIHRva2VuLlxuICovXG5leHBvcnQgY2xhc3MgRXJjMjBDb2luIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHt9XG5cbi8qKlxuICogRVJDIDcyMSBpcyB0aGUgbm9uIGZ1bmdpYmxlIHRva2VuIHN0YW5kYXJkIGZvciB0aGUgRXRoZXJldW0gYmxvY2tjaGFpbi5cbiAqXG4gKiB7QGxpbmsgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MjEgRUlQNzIxfVxuICovXG5leHBvcnQgY2xhc3MgRXJjNzIxQ29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7fVxuXG4vKipcbiAqIEVSQyAxMTU1IGlzIHRoZSBtdWx0aSB0b2tlbiBzdGFuZGFyZCBmb3IgdGhlIEV0aGVyZXVtIGJsb2NrY2hhaW4uXG4gKlxuICoge0BsaW5rIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE1NSBFSVAxMTU1fVxuICovXG5leHBvcnQgY2xhc3MgRXJjMTE1NUNvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBUaGUgVFJPTiBibG9ja2NoYWluIHN1cHBvcnRzIHRva2VucyBvZiB0aGUgRVJDMjAgc3RhbmRhcmQgc2ltaWxhciB0byBFVEggRVJDMjAgdG9rZW5zLlxuICovXG5leHBvcnQgY2xhc3MgVHJvbkVyYzIwQ29pbiBleHRlbmRzIEJhc2U1OENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7fVxuXG4vKipcbiAqIFNvbWUgYmxvY2tjaGFpbnMgaGF2ZSBuYXRpdmUgY29pbnMgd2hpY2ggYWxzbyBzdXBwb3J0IHRoZSBFUkMyMCBpbnRlcmZhY2Ugc3VjaCBhcyBDRUxPLlxuICovXG5leHBvcnQgY2xhc3MgRXJjMjBDb21wYXRpYmxlQWNjb3VudENvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyBUaGVzZSBjb2lucyBzaG91bGQgbm90IGJlIGNsYXNzaWZpZWQgYXMgdG9rZW5zIGFzIHRoZXkgYXJlIG5vdCBjaGlsZHJlbiBvZiBvdGhlciBjb2luc1xuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgQ0VMTyBibG9ja2NoYWluIHN1cHBvcnRzIHRva2VucyBvZiB0aGUgRVJDMjAgc3RhbmRhcmQgc2ltaWxhciB0byBFVEggRVJDMjAgdG9rZW5zLlxuICovXG5leHBvcnQgY2xhc3MgQ2Vsb0NvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBUaGUgU3RlbGxhciBuZXR3b3JrIHN1cHBvcnRzIHRva2VucyAobm9uLW5hdGl2ZSBhc3NldHMpXG4gKiBYTE0gaXMgYWxzbyBrbm93biBhcyB0aGUgbmF0aXZlIGFzc2V0LlxuICogU3RlbGxhciB0b2tlbnMgd29yayBzaW1pbGFyIHRvIFhMTSwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnkgdGhlIGNoYWluLFxuICogdGhlIHRva2VuIGNvZGUgYW5kIHRoZSBpc3N1ZXIgYWNjb3VudCBpbiB0aGUgZm9ybTogKHQpeGxtOjx0b2tlbj4tPGlzc3Vlcj5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZWxsYXJDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBkb21haW46IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTdGVsbGFyQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBjb25zdCBkb21haW5QYXR0ZXJuID0gL14oPzpbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT9cXC4pK1thLXowLTldW2EtejAtOS1dezAsNjF9W2EtejAtOV0kLztcbiAgICBpZiAob3B0aW9ucy5kb21haW4gIT09ICcnICYmICFvcHRpb25zLmRvbWFpbi5tYXRjaChkb21haW5QYXR0ZXJuKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREb21haW5FcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuZG9tYWluKTtcbiAgICB9XG5cbiAgICB0aGlzLmRvbWFpbiA9IG9wdGlvbnMuZG9tYWluIGFzIHN0cmluZztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBIZWRlcmEgY29pbiBuZWVkcyBhIGNsaWVudCBzZXQgd2l0aCB0aGUgbm9kZSBhY2NvdW50IElkLlxuICogSXQncyBhbiBhY2NvdW50IGJhc2VkIGNvaW4gdGhhdCBuZWVkcyB0aGUgbm9kZSBhY2NvdW50IElEXG4gKiB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBzZW50LlxuICovXG5leHBvcnQgY2xhc3MgSGVkZXJhQ29pbiBleHRlbmRzIEFjY291bnRDb2luVG9rZW4ge1xuICBwdWJsaWMgbm9kZUFjY291bnRJZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEhlZGVyYUNvaW5Db25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgdGhpcy5ub2RlQWNjb3VudElkID0gb3B0aW9ucy5ub2RlQWNjb3VudElkO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFsZ28gbmV0d29yayBzdXBwb3J0cyB0b2tlbnMgKGFzc2V0cylcbiAqIEFsZ28gdG9rZW5zIHdvcmsgc2ltaWxhciB0byBuYXRpdmUgQUxHTyBjb2luLCBidXQgdGhlIHRva2VuIG5hbWUgaXMgZGV0ZXJtaW5lZCBieVxuICogdW5pcXVlIGFzc2V0IGlkIG9uIHRoZSBjaGFpbi4gSW50ZXJuYWxseSwgQml0R28gdXNlcyB0b2tlbiBpZGVudGlmaWVycyBvZiB0aGUgZm9ybWF0OiAodClhbGdvOjxhc3NldElkPlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEFsZ29Db2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyB0b2tlblVSTDogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBbGdvQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy50b2tlblVSTCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTChvcHRpb25zLnRva2VuVVJMKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRG9tYWluRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLnRva2VuVVJMKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRva2VuVVJMID0gb3B0aW9ucy50b2tlblVSTDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBFb3MgbmV0d29yayBzdXBwb3J0cyB0b2tlbnNcbiAqIEVvcyB0b2tlbnMgd29yayBzaW1pbGFyIHRvIG5hdGl2ZSBFb3MgY29pbiwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnlcbiAqIHRoZSBjb250cmFjdE5hbWUgb24gdGhlIGNoYWluLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEVvc0NvaW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0TmFtZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFb3NDb2luQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIHRoaXMuY29udHJhY3ROYW1lID0gb3B0aW9ucy5jb250cmFjdE5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgU29sIG5ldHdvcmsgc3VwcG9ydHMgdG9rZW5zXG4gKiBTb2wgdG9rZW5zIHdvcmsgc2ltaWxhciB0byBuYXRpdmUgU09MIGNvaW4sIGJ1dCB0aGUgdG9rZW4gbmFtZSBpcyBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgdG9rZW5BZGRyZXNzIG9uIHRoZSBjaGFpbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2xDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyB0b2tlbkFkZHJlc3M6IHN0cmluZztcbiAgY29uc3RydWN0b3Iob3B0aW9uczogU29sQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2VuQWRkcmVzcyA9IG9wdGlvbnMudG9rZW5BZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFWQVggQyBDaGFpbiBuZXR3b3JrIHN1cHBvcnQgdG9rZW5zXG4gKiBBVkFYIEMgQ2hhaW4gVG9rZW5zIGFyZSBFUkMyMCBjb2luc1xuICovXG5leHBvcnQgY2xhc3MgQXZheEVSQzIwVG9rZW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogRklBVCBiYXNlZCB0b2tlbnMsIHN1Y2ggYXMgVVNELCBFVVIsIG9yIFlFTi5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpYXRUb2tlbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0ZFQVRVUkVTID0gW1xuICAgIENvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsXG4gICAgQ29pbkZlYXR1cmUuUkVRVUlSRVNfQklHX05VTUJFUixcbiAgICBDb2luRmVhdHVyZS5WQUxVRUxFU1NfVFJBTlNGRVIsXG4gICAgQ29pbkZlYXR1cmUuVFJBTlNBQ1RJT05fREFUQSxcbiAgICBDb2luRmVhdHVyZS5DVVNUT0RZLFxuICBdO1xuXG4gIHB1YmxpYyByZWFkb25seSBuZXR3b3JrOiBCYXNlTmV0d29yaztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGtpbmQ6IENvaW5LaW5kLkZJQVQsXG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsgPSBvcHRpb25zLm5ldHdvcms7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUxdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtDb2luRmVhdHVyZS5VTlNQRU5UX01PREVMXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBhY2NvdW50IGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjY291bnQoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmssXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIGlzVG9rZW4gPSBmYWxzZVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBBY2NvdW50Q29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgZXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRXRoZXJldW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzIwKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzIwQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBlcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgS292YW4gdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVyYzIwKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmtvdmFuXG4pIHtcbiAgcmV0dXJuIGVyYzIwKG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdEFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGVyYzcyMSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEV0aGVyZXVtIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcmM3MjEoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzcyMUNvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlczogMCxcbiAgICAgIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQuRVJDNzIxLFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgZXJjNzIxIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gR29lcmxpIHRlc3QgbmV0d29yay5cbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXJjNzIxKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MudGVzdC5nb2VybGksXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gZXJjNzIxKG5hbWUsIGZ1bGxOYW1lLCBjb250cmFjdEFkZHJlc3MsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yaywgcHJpbWFyeUtleUN1cnZlKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBlcmMxMTU1IHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRXRoZXJldW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzExNTUoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzExNTVDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXM6IDAsXG4gICAgICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LkVSQzExNTUsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBlcmMxMTU1IHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gR29lcmxpIHRlc3QgbmV0d29yay5cbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXJjMTE1NShcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuZ29lcmxpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIGVyYzExNTUobmFtZSwgZnVsbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrLCBwcmltYXJ5S2V5Q3VydmUpO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEVSQzIwLWNvbXBhdGlibGUgYWNjb3VudCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzIwQ29tcGF0aWJsZUFjY291bnRDb2luKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRXJjMjBDb21wYXRpYmxlQWNjb3VudENvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjZWxvIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIENFTE8gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlbG9Ub2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MubWFpbi5jZWxvLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IENlbG9Db2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgQ0VMTyBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGNlbG9Ub2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MudGVzdC5jZWxvXG4pIHtcbiAgcmV0dXJuIGNlbG9Ub2tlbihuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgY29udHJhY3RBZGRyZXNzLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBTdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBkb21haW4gRG9tYWluIG9mIHRoZSB0b2tlbiBpc3N1ZXIgKHVzZWQgdG8gYWNjZXNzIHRva2VuIGluZm9ybWF0aW9uIGZyb20gdGhlIGlzc3VlcidzIHN0ZWxsYXIudG9tbCBmaWxlKVxuICogU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3N0ZWxsYXItdG9tbC5odG1sXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFN0ZWxsYXIgbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGVsbGFyVG9rZW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBkb21haW4gPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MubWFpbi5zdGVsbGFyLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBTdGVsbGFyQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBkb21haW4sXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIG5ldHdvcmssXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBTdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBkb21haW4gRG9tYWluIG9mIHRoZSB0b2tlbiBpc3N1ZXIgKHVzZWQgdG8gYWNjZXNzIHRva2VuIGluZm9ybWF0aW9uIGZyb20gdGhlIGlzc3VlcidzIHN0ZWxsYXIudG9tbCBmaWxlKVxuICogU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3N0ZWxsYXItdG9tbC5odG1sXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFN0ZWxsYXIgdGVzdG5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRzdGVsbGFyVG9rZW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBkb21haW4gPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5zdGVsbGFyXG4pIHtcbiAgcmV0dXJuIHN0ZWxsYXJUb2tlbihuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgYXNzZXQsIGRvbWFpbiwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0cm9uIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFRST04gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyb25Ub2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogVHJvbk5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLnRyeCxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBUcm9uRXJjMjBDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IHRyb24gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgVFJPTiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR0cm9uVG9rZW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IFRyb25OZXR3b3JrID0gTmV0d29ya3MudGVzdC50cngsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gdHJvblRva2VuKFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEhlZGVyYSBjb2luIGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gbm9kZUFjY291bnRJZCBub2RlIGFjY291bnQgSWQgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBzZW50XG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEhlZGVyYSBtYWlubmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlZGVyYUNvaW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmssXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgbm9kZUFjY291bnRJZCA9ICcwLjAuMycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBIZWRlcmFDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIG5vZGVBY2NvdW50SWQsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIG5ldHdvcmssXG4gICAgICBpc1Rva2VuOiBmYWxzZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEFMR08gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGFsaWFzIChvcHRpb25hbCkgYWx0ZXJuYXRpdmUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSB0b2tlblVSTCBPcHRpb25hbCBhc3NldCBVcmwgZm9yIG1vcmUgaW5mb3JtYXRpb25hIGFib3V0IHRoZSBhc3NldFxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFsZ29yYW5kLm9yZy9kb2NzL3JlZmVyZW5jZS90cmFuc2FjdGlvbnMvI3VybFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBBTEdPIG1haW5uZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxnb1Rva2VuKFxuICBuYW1lOiBzdHJpbmcsXG4gIGFsaWFzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgdG9rZW5VUkwgPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MubWFpbi5hbGdvcmFuZCxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLkVkMjU1MTlcbik6IFJlYWRvbmx5PEFsZ29Db2luPiB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBBbGdvQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgYWxpYXMsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIHRva2VuVVJMOiB0b2tlblVSTCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgbmV0d29yayxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IEFMR08gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGFsaWFzIChvcHRpb25hbCkgYWx0ZXJuYXRpdmUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSB0b2tlblVSTCBPcHRpb25hbCBhc3NldCBVcmwgZm9yIG1vcmUgaW5mb3JtYXRpb25hIGFib3V0IHRoZSBhc3NldFxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFsZ29yYW5kLm9yZy9kb2NzL3JlZmVyZW5jZS90cmFuc2FjdGlvbnMvI3VybFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBBbGdvIHRlc3RuZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWxnb1Rva2VuKFxuICBuYW1lOiBzdHJpbmcsXG4gIGFsaWFzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgdG9rZW5VUkwgPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5hbGdvcmFuZFxuKTogUmVhZG9ubHk8QWxnb0NvaW4+IHtcbiAgcmV0dXJuIGFsZ29Ub2tlbihuYW1lLCBhbGlhcywgZnVsbE5hbWUsIGRlY2ltYWxQbGFjZXMsIGFzc2V0LCB0b2tlblVSTCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBlb3MgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0TmFtZSBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRU9TIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlb3NUb2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0TmFtZTogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmVvcyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBFb3NDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdE5hbWUsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGVvcyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBFT1MgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlb3NUb2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0TmFtZTogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmVvc1xuKSB7XG4gIHJldHVybiBlb3NUb2tlbihuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgY29udHJhY3ROYW1lLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBzb2wgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUb2tlbiBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gU09MIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBhbmQgUkVRVUlSRVNfUkVTRVJWRSBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2xUb2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IFsuLi5BY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLCBDb2luRmVhdHVyZS5SRVFVSVJFU19SRVNFUlZFXSxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uc29sLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBTb2xDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICB0b2tlbkFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IHNvbCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIFRva2VuIGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBTT0wgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBhbmQgUkVRVUlSRVNfUkVTRVJWRSBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRzb2xUb2tlbihcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IFsuLi5BY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLCBDb2luRmVhdHVyZS5SRVFVSVJFU19SRVNFUlZFXSxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3Quc29sXG4pIHtcbiAgcmV0dXJuIHNvbFRva2VuKG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCB0b2tlbkFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGF2YXhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBBdmFsYW5jaGVDIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdmF4RXJjMjAoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MubWFpbi5hdmFsYW5jaGVDLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEF2YXhFUkMyMFRva2VuKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGF2YXhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgQXZhbGFuY2hlQyB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGF2YXhFcmMyMChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmF2YWxhbmNoZUMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gYXZheEVyYzIwKFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEZJQVQgY3VycmVuY3kgaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjdXJyZW5jeVxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGN1cnJlbmN5XG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlhdFRva2VuKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgbmV0d29yazogQmFzZU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmZpYXQsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBGaWF0VG9rZW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRmlhdFRva2VuKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IEZJQVQgY3VycmVuY3kgaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjdXJyZW5jeVxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGN1cnJlbmN5XG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGN1cnJlbmN5LlxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY3VycmVuY3kgc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRmaWF0VG9rZW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBuZXR3b3JrOiBCYXNlTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuZmlhdFxuKSB7XG4gIHJldHVybiBmaWF0VG9rZW4obmFtZSwgZnVsbE5hbWUsIGFzc2V0LCBkZWNpbWFsUGxhY2VzLCBuZXR3b3JrKTtcbn1cbiJdfQ==