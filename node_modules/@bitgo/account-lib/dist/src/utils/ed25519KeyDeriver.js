"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519KeyDeriver = void 0;
/**
 * @prettier
 */
var create_hmac_1 = __importDefault(require("create-hmac"));
/**
 * Heirarchical determinisitic key derivation for the ed25519 elliptic curve,
 * as defined in SLIP-0010.
 *
 * https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0005.md
 * https://github.com/satoshilabs/slips/blob/master/slip-0010.md
 */
var Ed25519KeyDeriver = /** @class */ (function () {
    function Ed25519KeyDeriver() {
    }
    /**
     * Derive a SLIP-0010 key given a path and master key seed.
     *
     * @param path derivation path
     * @param seed key seed
     */
    Ed25519KeyDeriver.derivePath = function (path, seed) {
        var _this = this;
        if (!this.isValidPath(path)) {
            throw new Error('Invalid derivation path');
        }
        var _a = this.getMasterKeyFromSeed(seed), key = _a.key, chainCode = _a.chainCode;
        var segments = path.split('/').slice(1).map(this.replaceDerive);
        return segments.reduce(function (parentKeys, segment) { return _this.CKDPriv(parentKeys, segment + Ed25519KeyDeriver.HARDENED_OFFSET); }, { key: key, chainCode: chainCode });
    };
    /**
     * Generate a SLIP-0010 master key from the entropy seed
     *
     * @param seed master key seed used to recreate master key
     */
    Ed25519KeyDeriver.getMasterKeyFromSeed = function (seed) {
        var hmac = create_hmac_1.default('sha512', Ed25519KeyDeriver.ED25519_CURVE);
        var I = hmac.update(Buffer.from(seed, 'hex')).digest();
        var IL = I.slice(0, 32);
        var IR = I.slice(32);
        return {
            key: IL,
            chainCode: IR,
        };
    };
    /**
     * Calculate a child private key given the parent key, the chain code, and the child index.
     *
     * @param key parent key
     * @param chainCode chain code for parent key
     * @param index index of child to derive
     */
    Ed25519KeyDeriver.CKDPriv = function (_a, index) {
        var key = _a.key, chainCode = _a.chainCode;
        var indexBuffer = Buffer.allocUnsafe(4);
        indexBuffer.writeUInt32BE(index, 0);
        var data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);
        var I = create_hmac_1.default('sha512', chainCode).update(data).digest();
        var IL = I.slice(0, 32);
        var IR = I.slice(32);
        return {
            key: IL,
            chainCode: IR,
        };
    };
    Ed25519KeyDeriver.isValidPath = function (path) {
        if (!Ed25519KeyDeriver.PATH_REGEX.test(path)) {
            return false;
        }
        return !path.split('/').slice(1).map(this.replaceDerive).some(isNaN);
    };
    /**
     * This key derivation code was copied and adapted from:
     * https://github.com/chatch/stellar-hd-wallet/blob/612c12325ca9047dce460016fb7d148f55f575ca/src/hd-key.js
     *
     * There have been some slight modifications to improve typescript support.
     *
     * The original ed25519-hd-key module is licensed under "GPL-3".
     */
    Ed25519KeyDeriver.ED25519_CURVE = 'ed25519 seed';
    Ed25519KeyDeriver.HARDENED_OFFSET = 0x80000000;
    Ed25519KeyDeriver.PATH_REGEX = new RegExp("^m(\\/[0-9]+')+$");
    Ed25519KeyDeriver.replaceDerive = function (val) { return parseInt(val.replace("'", ''), 10); };
    return Ed25519KeyDeriver;
}());
exports.Ed25519KeyDeriver = Ed25519KeyDeriver;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWQyNTUxOUtleURlcml2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvZWQyNTUxOUtleURlcml2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0dBRUc7QUFDSCw0REFBcUM7QUFPckM7Ozs7OztHQU1HO0FBQ0g7SUFBQTtJQTJFQSxDQUFDO0lBN0RDOzs7OztPQUtHO0lBQ1csNEJBQVUsR0FBeEIsVUFBeUIsSUFBWSxFQUFFLElBQVk7UUFBbkQsaUJBVUM7UUFUQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDNUM7UUFDSyxJQUFBLEtBQXFCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsRUFBbEQsR0FBRyxTQUFBLEVBQUUsU0FBUyxlQUFvQyxDQUFDO1FBQzNELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbEUsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUNwQixVQUFDLFVBQVUsRUFBRSxPQUFPLElBQUssT0FBQSxLQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxPQUFPLEdBQUcsaUJBQWlCLENBQUMsZUFBZSxDQUFDLEVBQXJFLENBQXFFLEVBQzlGLEVBQUUsR0FBRyxLQUFBLEVBQUUsU0FBUyxXQUFBLEVBQUUsQ0FDbkIsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ1ksc0NBQW9CLEdBQW5DLFVBQW9DLElBQVk7UUFDOUMsSUFBTSxJQUFJLEdBQUcscUJBQVUsQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbkUsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3pELElBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzFCLElBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkIsT0FBTztZQUNMLEdBQUcsRUFBRSxFQUFFO1lBQ1AsU0FBUyxFQUFFLEVBQUU7U0FDZCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNZLHlCQUFPLEdBQXRCLFVBQXVCLEVBQTZCLEVBQUUsS0FBYTtZQUExQyxHQUFHLFNBQUEsRUFBRSxTQUFTLGVBQUE7UUFDckMsSUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQyxXQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQyxJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDbkUsSUFBTSxDQUFDLEdBQUcscUJBQVUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2hFLElBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzFCLElBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkIsT0FBTztZQUNMLEdBQUcsRUFBRSxFQUFFO1lBQ1AsU0FBUyxFQUFFLEVBQUU7U0FDZCxDQUFDO0lBQ0osQ0FBQztJQUdjLDZCQUFXLEdBQTFCLFVBQTJCLElBQVk7UUFDckMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBekVEOzs7Ozs7O09BT0c7SUFFcUIsK0JBQWEsR0FBRyxjQUFjLENBQUM7SUFDL0IsaUNBQWUsR0FBRyxVQUFVLENBQUM7SUFDN0IsNEJBQVUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBd0RyRCwrQkFBYSxHQUFHLFVBQUMsR0FBVyxJQUFhLE9BQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFsQyxDQUFrQyxDQUFDO0lBTzdGLHdCQUFDO0NBQUEsQUEzRUQsSUEyRUM7QUEzRVksOENBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IGNyZWF0ZUhtYWMgZnJvbSAnY3JlYXRlLWhtYWMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhkS2V5cGFpciB7XG4gIGtleTogQnVmZmVyO1xuICBjaGFpbkNvZGU6IEJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBIZWlyYXJjaGljYWwgZGV0ZXJtaW5pc2l0aWMga2V5IGRlcml2YXRpb24gZm9yIHRoZSBlZDI1NTE5IGVsbGlwdGljIGN1cnZlLFxuICogYXMgZGVmaW5lZCBpbiBTTElQLTAwMTAuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N0ZWxsYXIvc3RlbGxhci1wcm90b2NvbC9ibG9iL21hc3Rlci9lY29zeXN0ZW0vc2VwLTAwMDUubWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iL21hc3Rlci9zbGlwLTAwMTAubWRcbiAqL1xuZXhwb3J0IGNsYXNzIEVkMjU1MTlLZXlEZXJpdmVyIHtcbiAgLyoqXG4gICAqIFRoaXMga2V5IGRlcml2YXRpb24gY29kZSB3YXMgY29waWVkIGFuZCBhZGFwdGVkIGZyb206XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGF0Y2gvc3RlbGxhci1oZC13YWxsZXQvYmxvYi82MTJjMTIzMjVjYTkwNDdkY2U0NjAwMTZmYjdkMTQ4ZjU1ZjU3NWNhL3NyYy9oZC1rZXkuanNcbiAgICpcbiAgICogVGhlcmUgaGF2ZSBiZWVuIHNvbWUgc2xpZ2h0IG1vZGlmaWNhdGlvbnMgdG8gaW1wcm92ZSB0eXBlc2NyaXB0IHN1cHBvcnQuXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBlZDI1NTE5LWhkLWtleSBtb2R1bGUgaXMgbGljZW5zZWQgdW5kZXIgXCJHUEwtM1wiLlxuICAgKi9cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFRDI1NTE5X0NVUlZFID0gJ2VkMjU1MTkgc2VlZCc7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEhBUkRFTkVEX09GRlNFVCA9IDB4ODAwMDAwMDA7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFBBVEhfUkVHRVggPSBuZXcgUmVnRXhwKFwiXm0oXFxcXC9bMC05XSsnKSskXCIpO1xuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBTTElQLTAwMTAga2V5IGdpdmVuIGEgcGF0aCBhbmQgbWFzdGVyIGtleSBzZWVkLlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBkZXJpdmF0aW9uIHBhdGhcbiAgICogQHBhcmFtIHNlZWQga2V5IHNlZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGVyaXZlUGF0aChwYXRoOiBzdHJpbmcsIHNlZWQ6IHN0cmluZyk6IEhkS2V5cGFpciB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRQYXRoKHBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoJyk7XG4gICAgfVxuICAgIGNvbnN0IHsga2V5LCBjaGFpbkNvZGUgfSA9IHRoaXMuZ2V0TWFzdGVyS2V5RnJvbVNlZWQoc2VlZCk7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMSkubWFwKHRoaXMucmVwbGFjZURlcml2ZSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzLnJlZHVjZShcbiAgICAgIChwYXJlbnRLZXlzLCBzZWdtZW50KSA9PiB0aGlzLkNLRFByaXYocGFyZW50S2V5cywgc2VnbWVudCArIEVkMjU1MTlLZXlEZXJpdmVyLkhBUkRFTkVEX09GRlNFVCksXG4gICAgICB7IGtleSwgY2hhaW5Db2RlIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFNMSVAtMDAxMCBtYXN0ZXIga2V5IGZyb20gdGhlIGVudHJvcHkgc2VlZFxuICAgKlxuICAgKiBAcGFyYW0gc2VlZCBtYXN0ZXIga2V5IHNlZWQgdXNlZCB0byByZWNyZWF0ZSBtYXN0ZXIga2V5XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRNYXN0ZXJLZXlGcm9tU2VlZChzZWVkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBobWFjID0gY3JlYXRlSG1hYygnc2hhNTEyJywgRWQyNTUxOUtleURlcml2ZXIuRUQyNTUxOV9DVVJWRSk7XG4gICAgY29uc3QgSSA9IGhtYWMudXBkYXRlKEJ1ZmZlci5mcm9tKHNlZWQsICdoZXgnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgSUwgPSBJLnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBJUiA9IEkuc2xpY2UoMzIpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IElMLFxuICAgICAgY2hhaW5Db2RlOiBJUixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhIGNoaWxkIHByaXZhdGUga2V5IGdpdmVuIHRoZSBwYXJlbnQga2V5LCB0aGUgY2hhaW4gY29kZSwgYW5kIHRoZSBjaGlsZCBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIGtleSBwYXJlbnQga2V5XG4gICAqIEBwYXJhbSBjaGFpbkNvZGUgY2hhaW4gY29kZSBmb3IgcGFyZW50IGtleVxuICAgKiBAcGFyYW0gaW5kZXggaW5kZXggb2YgY2hpbGQgdG8gZGVyaXZlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBDS0RQcml2KHsga2V5LCBjaGFpbkNvZGUgfTogSGRLZXlwYWlyLCBpbmRleDogbnVtYmVyKTogSGRLZXlwYWlyIHtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKTtcbiAgICBjb25zdCBkYXRhID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEsIDApLCBrZXksIGluZGV4QnVmZmVyXSk7XG4gICAgY29uc3QgSSA9IGNyZWF0ZUhtYWMoJ3NoYTUxMicsIGNoYWluQ29kZSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IElMID0gSS5zbGljZSgwLCAzMik7XG4gICAgY29uc3QgSVIgPSBJLnNsaWNlKDMyKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBJTCxcbiAgICAgIGNoYWluQ29kZTogSVIsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlcGxhY2VEZXJpdmUgPSAodmFsOiBzdHJpbmcpOiBudW1iZXIgPT4gcGFyc2VJbnQodmFsLnJlcGxhY2UoXCInXCIsICcnKSwgMTApO1xuICBwcml2YXRlIHN0YXRpYyBpc1ZhbGlkUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAoIUVkMjU1MTlLZXlEZXJpdmVyLlBBVEhfUkVHRVgudGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gIXBhdGguc3BsaXQoJy8nKS5zbGljZSgxKS5tYXAodGhpcy5yZXBsYWNlRGVyaXZlKS5zb21lKGlzTmFOKTtcbiAgfVxufVxuIl19