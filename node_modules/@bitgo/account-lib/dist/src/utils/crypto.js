"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBase58 = exports.bigIntToHex = exports.toHex = exports.isValidBLSPublicKey = exports.isValidBLSPrivateKey = exports.isValidEd25519PublicKey = exports.isValidEd25519SecretKey = exports.isValidEd25519Seed = exports.isValidPrv = exports.isValidPub = exports.isValidXprv = exports.isValidXpub = exports.rawPrvToExtendedKeys = exports.xprvToRawPrv = exports.xpubToUncompressedPub = void 0;
var bip32 = __importStar(require("bip32"));
var bitcoinjs_lib_1 = require("bitcoinjs-lib");
var nacl = __importStar(require("tweetnacl"));
var hex = __importStar(require("@stablelib/hex"));
var bls = __importStar(require("noble-bls12-381"));
var ethereumjs_utils_old_1 = require("ethereumjs-utils-old");
var utils_1 = require("../coin/hbar/utils");
var bs58_1 = __importDefault(require("bs58"));
/**
 * @param {string} xpub - a base-58 encoded extended public key (BIP32)
 * @returns {string} the uncompressed public key in hexadecimal
 */
function xpubToUncompressedPub(xpub) {
    if (!isValidXpub(xpub)) {
        throw new Error('invalid xpub');
    }
    return bitcoinjs_lib_1.ECPair.fromPublicKey(bip32.fromBase58(xpub, bitcoinjs_lib_1.networks.bitcoin).publicKey, {
        compressed: false,
    }).publicKey.toString('hex');
}
exports.xpubToUncompressedPub = xpubToUncompressedPub;
/**
 * @param {string} xprv - base58-encoded extended private key (BIP32)
 * @returns {string} the hex-encoded raw private key
 */
function xprvToRawPrv(xprv) {
    if (!isValidXprv(xprv)) {
        throw new Error('invalid xprv');
    }
    var privateKey = bip32.fromBase58(xprv, bitcoinjs_lib_1.networks.bitcoin).privateKey;
    if (!privateKey) {
        throw new Error('invalid xprv');
    }
    return privateKey.toString('hex');
}
exports.xprvToRawPrv = xprvToRawPrv;
/**
 * @param {string} prv - Private key in hex format to get the extended keys for
 * @returns {ExtendedKeys} xprv and xpub in string format
 */
function rawPrvToExtendedKeys(prv) {
    var hd = bip32.fromPrivateKey(Buffer.from(prv, 'hex'), Buffer.alloc(32));
    return {
        xprv: hd.toBase58(),
        xpub: hd.neutered().toBase58(),
    };
}
exports.rawPrvToExtendedKeys = rawPrvToExtendedKeys;
/**
 * Whether the input is a valid BIP32 xpub or not
 *
 * @param xpub
 */
function isValidXpub(xpub) {
    if (xpub.substr(0, 4) !== 'xpub') {
        // check for xpub formats we don't support, such as tpub
        return false;
    }
    try {
        bip32.fromBase58(xpub, bitcoinjs_lib_1.networks.bitcoin);
    }
    catch (err) {
        return false;
    }
    // if HD generation didn't throw, it is a valid xpub
    return true;
}
exports.isValidXpub = isValidXpub;
/**
 * Whether the input is a valid BIP32 xprv or not
 *
 * @param xprv
 */
function isValidXprv(xprv) {
    if (xprv.substr(0, 4) !== 'xprv') {
        // check for xprv formats we don't support
        return false;
    }
    try {
        bip32.fromBase58(xprv, bitcoinjs_lib_1.networks.bitcoin);
    }
    catch (err) {
        return false;
    }
    // if HD generation didn't throw, it is a valid xprv
    return true;
}
exports.isValidXprv = isValidXprv;
/**
 * Whether the input is a valid secp256k1 public key
 *
 * @param pub
 */
function isValidPub(pub) {
    try {
        bitcoinjs_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidPub = isValidPub;
/**
 * Whether the input is a valid secp256k1 private key
 *
 * @param prv
 */
function isValidPrv(prv) {
    try {
        bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(prv, 'hex'));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidPrv = isValidPrv;
/**
 * Whether the input is a valid ed25519 private key
 *
 * @param {string} prv A hexadecimal private key to validate
 * @returns {boolean} Whether the input is a valid public key or not
 */
function isValidEd25519Seed(prv) {
    try {
        var decodedPrv = utils_1.toUint8Array(prv);
        return decodedPrv.length === nacl.sign.seedLength;
    }
    catch (e) {
        return false;
    }
}
exports.isValidEd25519Seed = isValidEd25519Seed;
/**
 * Whether the input is a valid ed25519 private key
 *
 * @param {string} prv A hexadecimal private key to validate
 * @returns {boolean} Whether the input is a valid public key or not
 */
function isValidEd25519SecretKey(prv) {
    try {
        var decodedPrv = utils_1.toUint8Array(prv);
        return decodedPrv.length === nacl.sign.secretKeyLength;
    }
    catch (e) {
        return false;
    }
}
exports.isValidEd25519SecretKey = isValidEd25519SecretKey;
/**
 * Whether the input is a valid ed25519 public key
 *
 * @param {string} pub A hexadecimal public key to validate
 * @returns {boolean} Whether the input is a valid public key or not
 */
function isValidEd25519PublicKey(pub) {
    try {
        var decodedPub = new Uint8Array(Buffer.from(pub, 'hex'));
        return decodedPub.length === nacl.sign.publicKeyLength;
    }
    catch (e) {
        return false;
    }
}
exports.isValidEd25519PublicKey = isValidEd25519PublicKey;
/**
 * Whether the input is a valid BLS private key
 *
 * @param {string} prv a private key to validate
 * @returns {boolean} Whether the input is a valid private key or not
 */
function isValidBLSPrivateKey(prv) {
    try {
        return bls.Fr.isValid(BigInt(prv));
    }
    catch (e) {
        return false;
    }
}
exports.isValidBLSPrivateKey = isValidBLSPrivateKey;
/**
 * Whether input is a valid BLS public key
 *
 * @param {string} pub the public key to validate
 * @returns {boolean} Whether input is a valid public key or not
 */
function isValidBLSPublicKey(pub) {
    try {
        bls.PointG1.fromCompressedHex(ethereumjs_utils_old_1.stripHexPrefix(pub)).assertValidity();
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isValidBLSPublicKey = isValidBLSPublicKey;
/**
 * Returns an hex string of the given buffer
 *
 * @param {Buffer | Uint8Array} buffer - the buffer to be converted to hex
 * @returns {string} - the hex value
 */
function toHex(buffer) {
    return hex.encode(buffer, true);
}
exports.toHex = toHex;
/**
 * Returns an hex string of the given bigint
 *
 * @param {bigint} bigint - the bigint to be converted to hex
 * @returns {string} - the hex value
 */
function bigIntToHex(bigint) {
    var hex = bigint.toString(16);
    return '0x' + '0'.slice(0, hex.length % 2) + hex;
}
exports.bigIntToHex = bigIntToHex;
/**
 * Check if base58 decoded string is equale to length
 *
 * @param {string} value - string to be checked
 * @param {number} length - expected decoded length
 * @return {boolean} if the string can decoded as base58 and match the expected length
 */
function isBase58(value, length) {
    try {
        return !!value && bs58_1.default.decode(value).length === length;
    }
    catch (e) {
        return false;
    }
}
exports.isBase58 = isBase58;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3V0aWxzL2NyeXB0by50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQStCO0FBQy9CLCtDQUFpRDtBQUNqRCw4Q0FBa0M7QUFDbEMsa0RBQXNDO0FBQ3RDLG1EQUF1QztBQUN2Qyw2REFBc0Q7QUFFdEQsNENBQWtEO0FBQ2xELDhDQUF3QjtBQUV4Qjs7O0dBR0c7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxJQUFZO0lBQ2hELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNqQztJQUNELE9BQU8sc0JBQU0sQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsd0JBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLEVBQUU7UUFDOUUsVUFBVSxFQUFFLEtBQUs7S0FDbEIsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDL0IsQ0FBQztBQVBELHNEQU9DO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLElBQVk7SUFDdkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ2pDO0lBRU8sSUFBQSxVQUFVLEdBQUssS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsd0JBQVEsQ0FBQyxPQUFPLENBQUMsV0FBN0MsQ0FBOEM7SUFDaEUsSUFBSSxDQUFDLFVBQVUsRUFBRTtRQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDakM7SUFDRCxPQUFPLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEMsQ0FBQztB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Q3hDLElBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDaEMsT0FBTyxJQUFJLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDbkQsQ0FBQztBQUhELGtDQUdDO0FBRUQ7Ozs7OztHQU1HO0FBRUgsU0FBZ0IsUUFBUSxDQUFDLEtBQWEsRUFBRSxNQUFjO0lBQ3BELElBQUk7UUFDRixPQUFPLENBQUMsQ0FBQyxLQUFLLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDO0tBQ3hEO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQU5ELDRCQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0IHsgRUNQYWlyLCBuZXR3b3JrcyB9IGZyb20gJ2JpdGNvaW5qcy1saWInO1xuaW1wb3J0ICogYXMgbmFjbCBmcm9tICd0d2VldG5hY2wnO1xuaW1wb3J0ICogYXMgaGV4IGZyb20gJ0BzdGFibGVsaWIvaGV4JztcbmltcG9ydCAqIGFzIGJscyBmcm9tICdub2JsZS1ibHMxMi0zODEnO1xuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICdldGhlcmV1bWpzLXV0aWxzLW9sZCc7XG5pbXBvcnQgeyBFeHRlbmRlZEtleXMgfSBmcm9tICcuLi9jb2luL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IHRvVWludDhBcnJheSB9IGZyb20gJy4uL2NvaW4vaGJhci91dGlscyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30geHB1YiAtIGEgYmFzZS01OCBlbmNvZGVkIGV4dGVuZGVkIHB1YmxpYyBrZXkgKEJJUDMyKVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGluIGhleGFkZWNpbWFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4cHViVG9VbmNvbXByZXNzZWRQdWIoeHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc1ZhbGlkWHB1Yih4cHViKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHViJyk7XG4gIH1cbiAgcmV0dXJuIEVDUGFpci5mcm9tUHVibGljS2V5KGJpcDMyLmZyb21CYXNlNTgoeHB1YiwgbmV0d29ya3MuYml0Y29pbikucHVibGljS2V5LCB7XG4gICAgY29tcHJlc3NlZDogZmFsc2UsXG4gIH0pLnB1YmxpY0tleS50b1N0cmluZygnaGV4Jyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHhwcnYgLSBiYXNlNTgtZW5jb2RlZCBleHRlbmRlZCBwcml2YXRlIGtleSAoQklQMzIpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgaGV4LWVuY29kZWQgcmF3IHByaXZhdGUga2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4cHJ2VG9SYXdQcnYoeHBydjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc1ZhbGlkWHBydih4cHJ2KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHJ2Jyk7XG4gIH1cblxuICBjb25zdCB7IHByaXZhdGVLZXkgfSA9IGJpcDMyLmZyb21CYXNlNTgoeHBydiwgbmV0d29ya3MuYml0Y29pbik7XG4gIGlmICghcHJpdmF0ZUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHJ2Jyk7XG4gIH1cbiAgcmV0dXJuIHByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgLSBQcml2YXRlIGtleSBpbiBoZXggZm9ybWF0IHRvIGdldCB0aGUgZXh0ZW5kZWQga2V5cyBmb3JcbiAqIEByZXR1cm5zIHtFeHRlbmRlZEtleXN9IHhwcnYgYW5kIHhwdWIgaW4gc3RyaW5nIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmF3UHJ2VG9FeHRlbmRlZEtleXMocHJ2OiBzdHJpbmcpOiBFeHRlbmRlZEtleXMge1xuICBjb25zdCBoZCA9IGJpcDMyLmZyb21Qcml2YXRlS2V5KEJ1ZmZlci5mcm9tKHBydiwgJ2hleCcpLCBCdWZmZXIuYWxsb2MoMzIpKTtcbiAgcmV0dXJuIHtcbiAgICB4cHJ2OiBoZC50b0Jhc2U1OCgpLFxuICAgIHhwdWI6IGhkLm5ldXRlcmVkKCkudG9CYXNlNTgoKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIEJJUDMyIHhwdWIgb3Igbm90XG4gKlxuICogQHBhcmFtIHhwdWJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRYcHViKHhwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoeHB1Yi5zdWJzdHIoMCwgNCkgIT09ICd4cHViJykge1xuICAgIC8vIGNoZWNrIGZvciB4cHViIGZvcm1hdHMgd2UgZG9uJ3Qgc3VwcG9ydCwgc3VjaCBhcyB0cHViXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgYmlwMzIuZnJvbUJhc2U1OCh4cHViLCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGlmIEhEIGdlbmVyYXRpb24gZGlkbid0IHRocm93LCBpdCBpcyBhIHZhbGlkIHhwdWJcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBCSVAzMiB4cHJ2IG9yIG5vdFxuICpcbiAqIEBwYXJhbSB4cHJ2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkWHBydih4cHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHhwcnYuc3Vic3RyKDAsIDQpICE9PSAneHBydicpIHtcbiAgICAvLyBjaGVjayBmb3IgeHBydiBmb3JtYXRzIHdlIGRvbid0IHN1cHBvcnRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBiaXAzMi5mcm9tQmFzZTU4KHhwcnYsIG5ldHdvcmtzLmJpdGNvaW4pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaWYgSEQgZ2VuZXJhdGlvbiBkaWRuJ3QgdGhyb3csIGl0IGlzIGEgdmFsaWQgeHBydlxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIHNlY3AyNTZrMSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtIHB1YlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIEVDUGFpci5mcm9tUHVibGljS2V5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIHNlY3AyNTZrMSBwcml2YXRlIGtleVxuICpcbiAqIEBwYXJhbSBwcnZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQcnYocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBFQ1BhaXIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20ocHJ2LCAnaGV4JykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgZWQyNTUxOSBwcml2YXRlIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgQSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgcHVibGljIGtleSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFZDI1NTE5U2VlZChwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWRQcnYgPSB0b1VpbnQ4QXJyYXkocHJ2KTtcbiAgICByZXR1cm4gZGVjb2RlZFBydi5sZW5ndGggPT09IG5hY2wuc2lnbi5zZWVkTGVuZ3RoO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBlZDI1NTE5IHByaXZhdGUga2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBydiBBIGhleGFkZWNpbWFsIHByaXZhdGUga2V5IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBwdWJsaWMga2V5IG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEVkMjU1MTlTZWNyZXRLZXkocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkUHJ2ID0gdG9VaW50OEFycmF5KHBydik7XG4gICAgcmV0dXJuIGRlY29kZWRQcnYubGVuZ3RoID09PSBuYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBlZDI1NTE5IHB1YmxpYyBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHViIEEgaGV4YWRlY2ltYWwgcHVibGljIGtleSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgcHVibGljIGtleSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5KHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZFB1YiA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgICByZXR1cm4gZGVjb2RlZFB1Yi5sZW5ndGggPT09IG5hY2wuc2lnbi5wdWJsaWNLZXlMZW5ndGg7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIEJMUyBwcml2YXRlIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgYSBwcml2YXRlIGtleSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgcHJpdmF0ZSBrZXkgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQkxTUHJpdmF0ZUtleShwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIHJldHVybiBibHMuRnIuaXNWYWxpZChCaWdJbnQocHJ2KSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBXaGV0aGVyIGlucHV0IGlzIGEgdmFsaWQgQkxTIHB1YmxpYyBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHViIHRoZSBwdWJsaWMga2V5IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBpbnB1dCBpcyBhIHZhbGlkIHB1YmxpYyBrZXkgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQkxTUHVibGljS2V5KHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgYmxzLlBvaW50RzEuZnJvbUNvbXByZXNzZWRIZXgoc3RyaXBIZXhQcmVmaXgocHViKSkuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaGV4IHN0cmluZyBvZiB0aGUgZ2l2ZW4gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5fSBidWZmZXIgLSB0aGUgYnVmZmVyIHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoYnVmZmVyOiBCdWZmZXIgfCBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIGhleC5lbmNvZGUoYnVmZmVyLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGhleCBzdHJpbmcgb2YgdGhlIGdpdmVuIGJpZ2ludFxuICpcbiAqIEBwYXJhbSB7YmlnaW50fSBiaWdpbnQgLSB0aGUgYmlnaW50IHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmlnSW50VG9IZXgoYmlnaW50OiBiaWdpbnQpOiBzdHJpbmcge1xuICBjb25zdCBoZXggPSBiaWdpbnQudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gJzB4JyArICcwJy5zbGljZSgwLCBoZXgubGVuZ3RoICUgMikgKyBoZXg7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYmFzZTU4IGRlY29kZWQgc3RyaW5nIGlzIGVxdWFsZSB0byBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBzdHJpbmcgdG8gYmUgY2hlY2tlZFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIGV4cGVjdGVkIGRlY29kZWQgbGVuZ3RoXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiB0aGUgc3RyaW5nIGNhbiBkZWNvZGVkIGFzIGJhc2U1OCBhbmQgbWF0Y2ggdGhlIGV4cGVjdGVkIGxlbmd0aFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2U1OCh2YWx1ZTogc3RyaW5nLCBsZW5ndGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIGJzNTguZGVjb2RlKHZhbHVlKS5sZW5ndGggPT09IGxlbmd0aDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl19