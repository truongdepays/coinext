/// <reference types="node" />
import { Ed25519Curve } from './curves';
import Shamir from './shamir';
import HDTree from './hdTree';
export interface UShare {
    i: number;
    t: number;
    n: number;
    y: string;
    seed: string;
    chaincode: string;
}
export interface YShare {
    i: number;
    j: number;
    y: string;
    u: string;
    chaincode: string;
}
export interface KeyShare {
    uShare: UShare;
    yShares: Record<number, YShare>;
}
export interface PShare {
    i: number;
    t: number;
    n: number;
    y: string;
    u: string;
    prefix: string;
    chaincode: string;
}
export interface JShare {
    i: number;
    j: number;
}
interface KeyCombine {
    pShare: PShare;
    jShares: Record<number, JShare>;
}
interface SubkeyShare {
    pShare: PShare;
    yShares: Record<number, YShare>;
}
export interface XShare {
    i: number;
    y: string;
    u: string;
    r: string;
    R: string;
}
export interface RShare {
    i: number;
    j: number;
    u: string;
    r: string;
    R: string;
}
export interface SignShare {
    xShare: XShare;
    rShares: Record<number, RShare>;
}
export interface GShare {
    i: number;
    y: string;
    gamma: string;
    R: string;
}
interface Signature {
    y: string;
    R: string;
    sigma: string;
}
export default class Eddsa {
    static curve: Ed25519Curve;
    static shamir: Shamir;
    static initialized: boolean;
    static initialize(): Promise<void>;
    hdTree?: HDTree;
    constructor(hdTree?: HDTree);
    keyShare(index: number, threshold: number, numShares: number, seed?: Buffer): KeyShare;
    keyCombine(uShare: UShare, yShares: YShare[]): KeyCombine;
    /**
     * Derives a child public key from common keychain
     *
     * @param commonKeychain - common keychain as a hex string
     * @param path - bip32 path
     * @return {string} public key as a hex string
     */
    deriveUnhardened(commonKeychain: string, path: string): string;
    keyDerive(uShare: UShare, yShares: YShare[], path: string): SubkeyShare;
    signShare(message: Buffer, pShare: PShare, jShares: JShare[]): SignShare;
    sign(message: Buffer, playerShare: XShare, rShares: RShare[], yShares?: YShare[]): GShare;
    signCombine(shares: GShare[]): Signature;
    verify(message: Buffer, signature: Signature): Buffer;
}
export {};
//# sourceMappingURL=tss.d.ts.map