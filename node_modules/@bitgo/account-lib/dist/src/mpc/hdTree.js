"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519BIP32 = void 0;
/**
 * An interface for calculating a subkey in an HD key scheme.
 */
var crypto_1 = require("crypto");
var curves_1 = require("./curves");
var util_1 = require("./util");
// 2^256
var base = BigInt('0x010000000000000000000000000000000000000000000000000000000000000000');
function deriveEd25519Helper(index, chaincode, pk, sk) {
    if (index === void 0) { index = 0; }
    var zmac = crypto_1.createHmac('sha512', util_1.bigIntToBufferBE(chaincode, 32));
    var imac = crypto_1.createHmac('sha512', util_1.bigIntToBufferBE(chaincode, 32));
    var seri = Buffer.alloc(4);
    seri.writeUInt32LE(index, 0);
    if (((index >>> 0) & 0x80000000) === 0) {
        // Normal derivation:
        // Z = HMAC-SHA512(Key = cpar, Data = 0x02 || serP(point(kpar)) || ser32(i)).
        // I = HMAC-SHA512(Key = cpar, Data = 0x03 || serP(point(kpar)) || ser32(i)).
        zmac.update('\x02');
        zmac.update(util_1.bigIntToBufferLE(pk, 32));
        zmac.update(seri);
        imac.update('\x03');
        imac.update(util_1.bigIntToBufferLE(pk, 32));
        imac.update(seri);
    }
    else {
        if (sk === undefined) {
            throw new Error("Can't performed hardened derivation without private key");
        }
        // Hardened derivation:
        // Z = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(left(kpar)) || ser32(i)).
        // I = HMAC-SHA512(Key = cpar, Data = 0x01 || ser256(left(kpar)) || ser32(i)).
        zmac.update('\x00');
        zmac.update(util_1.bigIntToBufferLE(sk, 32));
        zmac.update(seri);
        imac.update('\x01');
        imac.update(util_1.bigIntToBufferLE(sk, 32));
        imac.update(seri);
    }
    return [zmac.digest(), imac.digest()];
}
var Ed25519BIP32 = /** @class */ (function () {
    function Ed25519BIP32() {
    }
    Ed25519BIP32.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!Ed25519BIP32.initialized) return [3 /*break*/, 2];
                        return [4 /*yield*/, curves_1.Ed25519Curve.initialize()];
                    case 1:
                        _a.sent();
                        Ed25519BIP32.initialized = true;
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    Ed25519BIP32.prototype.publicDerive = function (keychain, path) {
        var indices = path
            .replace(/^m\//, '')
            .split('/')
            .map(function (index) { return parseInt(index, 10); });
        function deriveIndex(acc, index) {
            var pk = acc[0], chaincode = acc[1];
            var _a = deriveEd25519Helper(index, chaincode, pk), zout = _a[0], iout = _a[1];
            var zl = zout.slice(0, 32);
            // left = kl + 8 * trunc28(zl)
            var t = BigInt(8) * util_1.bigIntFromBufferLE(zl.slice(0, 28));
            var left = Ed25519BIP32.curve.pointAdd(pk, Ed25519BIP32.curve.basePointMult(t));
            return [left, util_1.bigIntFromBufferBE(iout.slice(32))];
        }
        var subkey = indices.reduce(deriveIndex, deriveIndex([keychain.pk, keychain.chaincode], indices.shift()));
        return { pk: subkey[0], chaincode: subkey[1] };
    };
    Ed25519BIP32.prototype.privateDerive = function (keychain, path) {
        var indices = path
            .replace(/^m\//, '')
            .split('/')
            .map(function (index) { return parseInt(index, 10); });
        function deriveIndex(acc, index) {
            var pk = acc[0], sk = acc[1], prefix = acc[2], chaincode = acc[3];
            var _a = deriveEd25519Helper(index, chaincode, pk, sk), zout = _a[0], iout = _a[1];
            var zl = zout.slice(0, 32);
            var zr = zout.slice(32);
            // left = kl + 8 * trunc28(zl)
            var t = BigInt(8) * util_1.bigIntFromBufferLE(zl.slice(0, 28));
            var left_pk = Ed25519BIP32.curve.pointAdd(pk, Ed25519BIP32.curve.basePointMult(t));
            var left_sk = Ed25519BIP32.curve.scalarAdd(sk, t);
            // right = zr + kr
            var right = (prefix + util_1.bigIntFromBufferBE(zr)) % base;
            return [left_pk, left_sk, right, util_1.bigIntFromBufferBE(iout.slice(32))];
        }
        var _a = indices.reduce(deriveIndex, deriveIndex([keychain.pk, keychain.sk, keychain.prefix, keychain.chaincode], indices.shift())), pk = _a[0], sk = _a[1], prefix = _a[2], chaincode = _a[3];
        return { pk: pk, sk: sk, prefix: prefix, chaincode: chaincode };
    };
    Ed25519BIP32.curve = new curves_1.Ed25519Curve();
    Ed25519BIP32.initialized = false;
    return Ed25519BIP32;
}());
exports.Ed25519BIP32 = Ed25519BIP32;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGRUcmVlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL21wYy9oZFRyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCxpQ0FBb0M7QUFDcEMsbUNBQXdDO0FBQ3hDLCtCQUFvRztBQUVwRyxRQUFRO0FBQ1IsSUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLHNFQUFzRSxDQUFDLENBQUM7QUFzQjVGLFNBQVMsbUJBQW1CLENBQUMsS0FBNkIsRUFBRSxTQUFpQixFQUFFLEVBQVUsRUFBRSxFQUFXO0lBQXpFLHNCQUFBLEVBQUEsU0FBNkI7SUFDeEQsSUFBTSxJQUFJLEdBQUcsbUJBQVUsQ0FBQyxRQUFRLEVBQUUsdUJBQWdCLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkUsSUFBTSxJQUFJLEdBQUcsbUJBQVUsQ0FBQyxRQUFRLEVBQUUsdUJBQWdCLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkUsSUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3QixJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3RDLHFCQUFxQjtRQUNyQiw2RUFBNkU7UUFDN0UsNkVBQTZFO1FBQzdFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxNQUFNLENB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QUNyRixJQUFNLE9BQU8sR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDcEQsa0JBQWtCO1lBQ2xCLElBQU0sS0FBSyxHQUFHLENBQUMsTUFBTSxHQUFHLHlCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQ3ZELE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSx5QkFBa0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RSxDQUFDO1FBQ0ssSUFBQSxLQUE4QixPQUFPLENBQUMsTUFBTSxDQUNoRCxXQUFXLEVBQ1gsV0FBVyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUM5RixFQUhNLEVBQUUsUUFBQSxFQUFFLEVBQUUsUUFBQSxFQUFFLE1BQU0sUUFBQSxFQUFFLFNBQVMsUUFHL0IsQ0FBQztRQUNGLE9BQU8sRUFBRSxFQUFFLElBQUEsRUFBRSxFQUFFLElBQUEsRUFBRSxNQUFNLFFBQUEsRUFBRSxTQUFTLFdBQUEsRUFBRSxDQUFDO0lBQ3ZDLENBQUM7SUFuRE0sa0JBQUssR0FBaUIsSUFBSSxxQkFBWSxFQUFFLENBQUM7SUFDekMsd0JBQVcsR0FBRyxLQUFLLENBQUM7SUFtRDdCLG1CQUFDO0NBQUEsQUFyREQsSUFxREM7QUFyRFksb0NBQVkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIGludGVyZmFjZSBmb3IgY2FsY3VsYXRpbmcgYSBzdWJrZXkgaW4gYW4gSEQga2V5IHNjaGVtZS5cbiAqL1xuaW1wb3J0IHsgY3JlYXRlSG1hYyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBFZDI1NTE5Q3VydmUgfSBmcm9tICcuL2N1cnZlcyc7XG5pbXBvcnQgeyBiaWdJbnRGcm9tQnVmZmVyQkUsIGJpZ0ludFRvQnVmZmVyQkUsIGJpZ0ludEZyb21CdWZmZXJMRSwgYmlnSW50VG9CdWZmZXJMRSB9IGZyb20gJy4vdXRpbCc7XG5cbi8vIDJeMjU2XG5jb25zdCBiYXNlID0gQmlnSW50KCcweDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuXG5pbnRlcmZhY2UgUHJpdmF0ZUtleWNoYWluIHtcbiAgcGs6IGJpZ2ludDtcbiAgc2s6IGJpZ2ludDtcbiAgcHJlZml4OiBiaWdpbnQ7XG4gIGNoYWluY29kZTogYmlnaW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1YmxpY0tleWNoYWluIHtcbiAgcGs6IGJpZ2ludDtcbiAgY2hhaW5jb2RlOiBiaWdpbnQ7XG59XG5cbmludGVyZmFjZSBIRFRyZWUge1xuICBwdWJsaWNEZXJpdmUoa2V5Y2hhaW46IFB1YmxpY0tleWNoYWluLCBwYXRoOiBzdHJpbmcpOiBQdWJsaWNLZXljaGFpbjtcblxuICBwcml2YXRlRGVyaXZlKGtleWNoYWluOiBQcml2YXRlS2V5Y2hhaW4sIHBhdGg6IHN0cmluZyk6IFByaXZhdGVLZXljaGFpbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSERUcmVlO1xuXG5mdW5jdGlvbiBkZXJpdmVFZDI1NTE5SGVscGVyKGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQgPSAwLCBjaGFpbmNvZGU6IGJpZ2ludCwgcGs6IGJpZ2ludCwgc2s/OiBiaWdpbnQpOiBCdWZmZXJbXSB7XG4gIGNvbnN0IHptYWMgPSBjcmVhdGVIbWFjKCdzaGE1MTInLCBiaWdJbnRUb0J1ZmZlckJFKGNoYWluY29kZSwgMzIpKTtcbiAgY29uc3QgaW1hYyA9IGNyZWF0ZUhtYWMoJ3NoYTUxMicsIGJpZ0ludFRvQnVmZmVyQkUoY2hhaW5jb2RlLCAzMikpO1xuICBjb25zdCBzZXJpID0gQnVmZmVyLmFsbG9jKDQpO1xuICBzZXJpLndyaXRlVUludDMyTEUoaW5kZXgsIDApO1xuICBpZiAoKChpbmRleCA+Pj4gMCkgJiAweDgwMDAwMDAwKSA9PT0gMCkge1xuICAgIC8vIE5vcm1hbCBkZXJpdmF0aW9uOlxuICAgIC8vIFogPSBITUFDLVNIQTUxMihLZXkgPSBjcGFyLCBEYXRhID0gMHgwMiB8fCBzZXJQKHBvaW50KGtwYXIpKSB8fCBzZXIzMihpKSkuXG4gICAgLy8gSSA9IEhNQUMtU0hBNTEyKEtleSA9IGNwYXIsIERhdGEgPSAweDAzIHx8IHNlclAocG9pbnQoa3BhcikpIHx8IHNlcjMyKGkpKS5cbiAgICB6bWFjLnVwZGF0ZSgnXFx4MDInKTtcbiAgICB6bWFjLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckxFKHBrLCAzMikpO1xuICAgIHptYWMudXBkYXRlKHNlcmkpO1xuICAgIGltYWMudXBkYXRlKCdcXHgwMycpO1xuICAgIGltYWMudXBkYXRlKGJpZ0ludFRvQnVmZmVyTEUocGssIDMyKSk7XG4gICAgaW1hYy51cGRhdGUoc2VyaSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm1lZCBoYXJkZW5lZCBkZXJpdmF0aW9uIHdpdGhvdXQgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIC8vIEhhcmRlbmVkIGRlcml2YXRpb246XG4gICAgLy8gWiA9IEhNQUMtU0hBNTEyKEtleSA9IGNwYXIsIERhdGEgPSAweDAwIHx8IHNlcjI1NihsZWZ0KGtwYXIpKSB8fCBzZXIzMihpKSkuXG4gICAgLy8gSSA9IEhNQUMtU0hBNTEyKEtleSA9IGNwYXIsIERhdGEgPSAweDAxIHx8IHNlcjI1NihsZWZ0KGtwYXIpKSB8fCBzZXIzMihpKSkuXG4gICAgem1hYy51cGRhdGUoJ1xceDAwJyk7XG4gICAgem1hYy51cGRhdGUoYmlnSW50VG9CdWZmZXJMRShzaywgMzIpKTtcbiAgICB6bWFjLnVwZGF0ZShzZXJpKTtcbiAgICBpbWFjLnVwZGF0ZSgnXFx4MDEnKTtcbiAgICBpbWFjLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckxFKHNrLCAzMikpO1xuICAgIGltYWMudXBkYXRlKHNlcmkpO1xuICB9XG4gIHJldHVybiBbem1hYy5kaWdlc3QoKSwgaW1hYy5kaWdlc3QoKV07XG59XG5cbmV4cG9ydCBjbGFzcyBFZDI1NTE5QklQMzIge1xuICBzdGF0aWMgY3VydmU6IEVkMjU1MTlDdXJ2ZSA9IG5ldyBFZDI1NTE5Q3VydmUoKTtcbiAgc3RhdGljIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFFZDI1NTE5QklQMzIuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IEVkMjU1MTlDdXJ2ZS5pbml0aWFsaXplKCk7XG4gICAgICBFZDI1NTE5QklQMzIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpY0Rlcml2ZShrZXljaGFpbjogUHVibGljS2V5Y2hhaW4sIHBhdGg6IHN0cmluZyk6IFB1YmxpY0tleWNoYWluIHtcbiAgICBjb25zdCBpbmRpY2VzID0gcGF0aFxuICAgICAgLnJlcGxhY2UoL15tXFwvLywgJycpXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLm1hcCgoaW5kZXgpID0+IHBhcnNlSW50KGluZGV4LCAxMCkpO1xuICAgIGZ1bmN0aW9uIGRlcml2ZUluZGV4KGFjYzogYmlnaW50W10sIGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQpOiBiaWdpbnRbXSB7XG4gICAgICBjb25zdCBbcGssIGNoYWluY29kZV0gPSBhY2M7XG4gICAgICBjb25zdCBbem91dCwgaW91dF0gPSBkZXJpdmVFZDI1NTE5SGVscGVyKGluZGV4LCBjaGFpbmNvZGUsIHBrKTtcbiAgICAgIGNvbnN0IHpsID0gem91dC5zbGljZSgwLCAzMik7XG4gICAgICAvLyBsZWZ0ID0ga2wgKyA4ICogdHJ1bmMyOCh6bClcbiAgICAgIGNvbnN0IHQgPSBCaWdJbnQoOCkgKiBiaWdJbnRGcm9tQnVmZmVyTEUoemwuc2xpY2UoMCwgMjgpKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBFZDI1NTE5QklQMzIuY3VydmUucG9pbnRBZGQocGssIEVkMjU1MTlCSVAzMi5jdXJ2ZS5iYXNlUG9pbnRNdWx0KHQpKTtcbiAgICAgIHJldHVybiBbbGVmdCwgYmlnSW50RnJvbUJ1ZmZlckJFKGlvdXQuc2xpY2UoMzIpKV07XG4gICAgfVxuICAgIGNvbnN0IHN1YmtleSA9IGluZGljZXMucmVkdWNlKGRlcml2ZUluZGV4LCBkZXJpdmVJbmRleChba2V5Y2hhaW4ucGssIGtleWNoYWluLmNoYWluY29kZV0sIGluZGljZXMuc2hpZnQoKSkpO1xuICAgIHJldHVybiB7IHBrOiBzdWJrZXlbMF0sIGNoYWluY29kZTogc3Via2V5WzFdIH07XG4gIH1cblxuICBwcml2YXRlRGVyaXZlKGtleWNoYWluOiBQcml2YXRlS2V5Y2hhaW4sIHBhdGg6IHN0cmluZyk6IFByaXZhdGVLZXljaGFpbiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHBhdGhcbiAgICAgIC5yZXBsYWNlKC9ebVxcLy8sICcnKVxuICAgICAgLnNwbGl0KCcvJylcbiAgICAgIC5tYXAoKGluZGV4KSA9PiBwYXJzZUludChpbmRleCwgMTApKTtcbiAgICBmdW5jdGlvbiBkZXJpdmVJbmRleChhY2M6IGJpZ2ludFtdLCBpbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkKTogYmlnaW50W10ge1xuICAgICAgY29uc3QgW3BrLCBzaywgcHJlZml4LCBjaGFpbmNvZGVdID0gYWNjO1xuICAgICAgY29uc3QgW3pvdXQsIGlvdXRdID0gZGVyaXZlRWQyNTUxOUhlbHBlcihpbmRleCwgY2hhaW5jb2RlLCBwaywgc2spO1xuICAgICAgY29uc3QgemwgPSB6b3V0LnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IHpyID0gem91dC5zbGljZSgzMik7XG4gICAgICAvLyBsZWZ0ID0ga2wgKyA4ICogdHJ1bmMyOCh6bClcbiAgICAgIGNvbnN0IHQgPSBCaWdJbnQoOCkgKiBiaWdJbnRGcm9tQnVmZmVyTEUoemwuc2xpY2UoMCwgMjgpKTtcbiAgICAgIGNvbnN0IGxlZnRfcGsgPSBFZDI1NTE5QklQMzIuY3VydmUucG9pbnRBZGQocGssIEVkMjU1MTlCSVAzMi5jdXJ2ZS5iYXNlUG9pbnRNdWx0KHQpKTtcbiAgICAgIGNvbnN0IGxlZnRfc2sgPSBFZDI1NTE5QklQMzIuY3VydmUuc2NhbGFyQWRkKHNrLCB0KTtcbiAgICAgIC8vIHJpZ2h0ID0genIgKyBrclxuICAgICAgY29uc3QgcmlnaHQgPSAocHJlZml4ICsgYmlnSW50RnJvbUJ1ZmZlckJFKHpyKSkgJSBiYXNlO1xuICAgICAgcmV0dXJuIFtsZWZ0X3BrLCBsZWZ0X3NrLCByaWdodCwgYmlnSW50RnJvbUJ1ZmZlckJFKGlvdXQuc2xpY2UoMzIpKV07XG4gICAgfVxuICAgIGNvbnN0IFtwaywgc2ssIHByZWZpeCwgY2hhaW5jb2RlXSA9IGluZGljZXMucmVkdWNlKFxuICAgICAgZGVyaXZlSW5kZXgsXG4gICAgICBkZXJpdmVJbmRleChba2V5Y2hhaW4ucGssIGtleWNoYWluLnNrLCBrZXljaGFpbi5wcmVmaXgsIGtleWNoYWluLmNoYWluY29kZV0sIGluZGljZXMuc2hpZnQoKSksXG4gICAgKTtcbiAgICByZXR1cm4geyBwaywgc2ssIHByZWZpeCwgY2hhaW5jb2RlIH07XG4gIH1cbn1cbiJdfQ==