"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UndelegateBuilder = void 0;
var casper_js_sdk_1 = require("casper-js-sdk");
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var transactionBuilder_1 = require("./transactionBuilder");
var constants_1 = require("./constants");
var utils_1 = require("./utils");
var UndelegateBuilder = /** @class */ (function (_super) {
    __extends(UndelegateBuilder, _super);
    /**
     * Public constructor.
     *
     * @param {CoinConfig} _coinConfig Coin configuration object
     */
    function UndelegateBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._action = constants_1.UNDELEGATE_CONTRACT_ACTION;
        _this._contract = Uint8Array.from(Buffer.from(utils_1.casperContractHexCode, 'hex'));
        return _this;
    }
    /** @inheritdoc */
    UndelegateBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            var args, extraArguments;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._validator = this._validator || constants_1.DELEGATE_VALIDATOR_ACCOUNT;
                        args = this.buildUndelegateParameters();
                        extraArguments = new Map();
                        extraArguments.set(constants_1.TRANSACTION_TYPE, casper_js_sdk_1.CLValueBuilder.string(baseCoin_1.TransactionType[baseCoin_1.TransactionType.StakingUnlock]));
                        extraArguments.set(constants_1.STAKING_TYPE, casper_js_sdk_1.CLValueBuilder.string(baseCoin_1.StakingOperationTypes[baseCoin_1.StakingOperationTypes.UNLOCK]));
                        extraArguments.set(constants_1.DELEGATE_FROM_ADDRESS, casper_js_sdk_1.CLValueBuilder.string(this._source.address));
                        extraArguments.set(constants_1.DELEGATE_VALIDATOR, casper_js_sdk_1.CLValueBuilder.string(this._validator));
                        this._session = {
                            moduleBytes: this._contract,
                            args: casper_js_sdk_1.RuntimeArgs.fromMap(args),
                            extraArguments: extraArguments,
                        };
                        this.transaction.setTransactionType(baseCoin_1.TransactionType.StakingUnlock);
                        return [4 /*yield*/, _super.prototype.buildImplementation.call(this)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** @inheritdoc */
    UndelegateBuilder.prototype.initBuilder = function (tx) {
        _super.prototype.initBuilder.call(this, tx);
        this.transaction.setTransactionType(baseCoin_1.TransactionType.StakingUnlock);
        this.validator(utils_1.getValidatorAddress(tx.casperTx.session));
        this.amount(utils_1.getTransferAmount(tx.casperTx.session));
    };
    /** @inheritdoc */
    UndelegateBuilder.prototype.signImplementation = function (key) {
        if (this._multiSignerKeyPairs.length >= transactionBuilder_1.DEFAULT_M) {
            throw new errors_1.SigningError('A maximum of ' + transactionBuilder_1.DEFAULT_M + ' can sign the transaction.');
        }
        return _super.prototype.signImplementation.call(this, key);
    };
    /**
     * Build args needed to create a session, then we can send this session with the contract
     *
     * @returns {DelegateUndelegateContractArgs} contracts args to create a session
     */
    UndelegateBuilder.prototype.buildUndelegateParameters = function () {
        var delegator = casper_js_sdk_1.CLPublicKey.fromHex(this._source.address);
        var validator = casper_js_sdk_1.CLPublicKey.fromHex(this._validator);
        return {
            action: casper_js_sdk_1.CLValueBuilder.string(this._action),
            delegator: casper_js_sdk_1.CLValueBuilder.publicKey(delegator.value(), delegator.tag),
            validator: casper_js_sdk_1.CLValueBuilder.publicKey(validator.value(), validator.tag),
            amount: casper_js_sdk_1.CLValueBuilder.u512(this._amount),
        };
    };
    // region Transfer fields
    /**
     * Set the destination address where the funds will be sent,
     *
     * @param {string} address the 68 bits address to transfer funds to
     * @returns {UndelegateBuilder} the builder with the new parameter set
     */
    UndelegateBuilder.prototype.validator = function (address) {
        if (!utils_1.isValidAddress(address)) {
            throw new errors_1.InvalidParameterValueError('Invalid address');
        }
        this._validator = address;
        return this;
    };
    /**
     * Set the amount to be transferred
     *
     * @param {string} amount amount to transfer
     * @returns {UndelegateBuilder} the builder with the new parameter set
     */
    UndelegateBuilder.prototype.amount = function (amount) {
        if (!utils_1.isValidDelegateAmount(amount)) {
            throw new errors_1.InvalidParameterValueError('Invalid amount');
        }
        this._amount = amount;
        return this;
    };
    // endregion
    // region Validators
    /**
     * Validate mandatory fields in the class
     *
     * @throws {Error} In case of missing or invalid fields
     */
    UndelegateBuilder.prototype.validateMandatoryFields = function () {
        if (!this._amount) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing amount');
        }
        if (!utils_1.isValidDelegateAmount(this._amount)) {
            throw new errors_1.InvalidParameterValueError('Invalid amount');
        }
        _super.prototype.validateMandatoryFields.call(this);
    };
    return UndelegateBuilder;
}(transactionBuilder_1.TransactionBuilder));
exports.UndelegateBuilder = UndelegateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5kZWxlZ2F0ZUJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9jc3ByL3VuZGVsZWdhdGVCdWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLCtDQUErRjtBQUMvRiw2Q0FBcUc7QUFFckcsd0NBQXFFO0FBQ3JFLDJEQUFxRTtBQUVyRSx5Q0FPcUI7QUFDckIsaUNBTWlCO0FBR2pCO0lBQXVDLHFDQUFrQjtJQU12RDs7OztPQUlHO0lBQ0gsMkJBQVksV0FBaUM7UUFBN0MsWUFDRSxrQkFBTSxXQUFXLENBQUMsU0FHbkI7UUFGQyxLQUFJLENBQUMsT0FBTyxHQUFHLHNDQUEwQixDQUFDO1FBQzFDLEtBQUksQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDZCQUFxQixFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7O0lBQzlFLENBQUM7SUFFRCxrQkFBa0I7SUFDRiwrQ0FBbUIsR0FBbkM7Ozs7Ozt3QkFDRSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksc0NBQTBCLENBQUM7d0JBQzFELElBQUksR0FBRyxJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQzt3QkFDeEMsY0FBYyxHQUFHLElBQUksR0FBRyxFQUFtQixDQUFDO3dCQUVsRCxjQUFjLENBQUMsR0FBRyxDQUFDLDRCQUFnQixFQUFFLDhCQUFjLENBQUMsTUFBTSxDQUFDLDBCQUFlLENBQUMsMEJBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzVHLGNBQWMsQ0FBQyxHQUFHLENBQUMsd0JBQVksRUFBRSw4QkFBYyxDQUFDLE1BQU0sQ0FBQyxnQ0FBcUIsQ0FBQyxnQ0FBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzdH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QyxDQUFDO1NBQ3hEO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsWUFBWTtJQUVaLG9CQUFvQjtJQUVwQjs7OztPQUlHO0lBQ0gsbURBQXVCLEdBQXZCO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDakIsTUFBTSxJQUFJLDhCQUFxQixDQUFDLHFDQUFxQyxDQUFDLENBQUM7U0FDeEU7UUFDRCxJQUFJLENBQUMsNkJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3hDLE1BQU0sSUFBSSxtQ0FBMEIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsaUJBQU0sdUJBQXVCLFdBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUgsd0JBQUM7QUFBRCxDQUFDLEFBdEhELENBQXVDLHVDQUFrQixHQXNIeEQ7QUF0SFksOENBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IENMVmFsdWUsIENMUHVibGljS2V5IGFzIFB1YmxpY0tleSwgUnVudGltZUFyZ3MsIENMVmFsdWVCdWlsZGVyIH0gZnJvbSAnY2FzcGVyLWpzLXNkayc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yLCBTaWduaW5nRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSwgU3Rha2luZ09wZXJhdGlvblR5cGVzIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyLCBERUZBVUxUX00gfSBmcm9tICcuL3RyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fVFlQRSxcbiAgREVMRUdBVEVfVkFMSURBVE9SLFxuICBERUxFR0FURV9GUk9NX0FERFJFU1MsXG4gIFNUQUtJTkdfVFlQRSxcbiAgVU5ERUxFR0FURV9DT05UUkFDVF9BQ1RJT04sXG4gIERFTEVHQVRFX1ZBTElEQVRPUl9BQ0NPVU5ULFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBpc1ZhbGlkRGVsZWdhdGVBbW91bnQsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBnZXRUcmFuc2ZlckFtb3VudCxcbiAgZ2V0VmFsaWRhdG9yQWRkcmVzcyxcbiAgY2FzcGVyQ29udHJhY3RIZXhDb2RlLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IERlbGVnYXRlVW5kZWxlZ2F0ZUNvbnRyYWN0QXJncyB9IGZyb20gJy4vaWZhY2VzJztcblxuZXhwb3J0IGNsYXNzIFVuZGVsZWdhdGVCdWlsZGVyIGV4dGVuZHMgVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBzdHJpbmc7XG4gIHByaXZhdGUgX2FjdGlvbjogc3RyaW5nO1xuICBwcml2YXRlIF9hbW91bnQ6IHN0cmluZztcbiAgcHJpdmF0ZSBfY29udHJhY3Q6IFVpbnQ4QXJyYXk7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtDb2luQ29uZmlnfSBfY29pbkNvbmZpZyBDb2luIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gICAgdGhpcy5fYWN0aW9uID0gVU5ERUxFR0FURV9DT05UUkFDVF9BQ1RJT047XG4gICAgdGhpcy5fY29udHJhY3QgPSBVaW50OEFycmF5LmZyb20oQnVmZmVyLmZyb20oY2FzcGVyQ29udHJhY3RIZXhDb2RlLCAnaGV4JykpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBhc3luYyBidWlsZEltcGxlbWVudGF0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb24+IHtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSB0aGlzLl92YWxpZGF0b3IgfHwgREVMRUdBVEVfVkFMSURBVE9SX0FDQ09VTlQ7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuYnVpbGRVbmRlbGVnYXRlUGFyYW1ldGVycygpO1xuICAgIGNvbnN0IGV4dHJhQXJndW1lbnRzID0gbmV3IE1hcDxzdHJpbmcsIENMVmFsdWU+KCk7XG5cbiAgICBleHRyYUFyZ3VtZW50cy5zZXQoVFJBTlNBQ1RJT05fVFlQRSwgQ0xWYWx1ZUJ1aWxkZXIuc3RyaW5nKFRyYW5zYWN0aW9uVHlwZVtUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9ja10pKTtcbiAgICBleHRyYUFyZ3VtZW50cy5zZXQoU1RBS0lOR19UWVBFLCBDTFZhbHVlQnVpbGRlci5zdHJpbmcoU3Rha2luZ09wZXJhdGlvblR5cGVzW1N0YWtpbmdPcGVyYXRpb25UeXBlcy5VTkxPQ0tdKSk7XG4gICAgZXh0cmFBcmd1bWVudHMuc2V0KERFTEVHQVRFX0ZST01fQUREUkVTUywgQ0xWYWx1ZUJ1aWxkZXIuc3RyaW5nKHRoaXMuX3NvdXJjZS5hZGRyZXNzKSk7XG4gICAgZXh0cmFBcmd1bWVudHMuc2V0KERFTEVHQVRFX1ZBTElEQVRPUiwgQ0xWYWx1ZUJ1aWxkZXIuc3RyaW5nKHRoaXMuX3ZhbGlkYXRvcikpO1xuXG4gICAgdGhpcy5fc2Vzc2lvbiA9IHtcbiAgICAgIG1vZHVsZUJ5dGVzOiB0aGlzLl9jb250cmFjdCxcbiAgICAgIGFyZ3M6IFJ1bnRpbWVBcmdzLmZyb21NYXAoYXJncyksXG4gICAgICBleHRyYUFyZ3VtZW50czogZXh0cmFBcmd1bWVudHMsXG4gICAgfTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uVHlwZShUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9jayk7XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvblR5cGUoVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbmxvY2spO1xuICAgIHRoaXMudmFsaWRhdG9yKGdldFZhbGlkYXRvckFkZHJlc3ModHguY2FzcGVyVHguc2Vzc2lvbikpO1xuICAgIHRoaXMuYW1vdW50KGdldFRyYW5zZmVyQW1vdW50KHR4LmNhc3BlclR4LnNlc3Npb24pKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2lnbkltcGxlbWVudGF0aW9uKGtleTogQmFzZUtleSk6IFRyYW5zYWN0aW9uIHtcbiAgICBpZiAodGhpcy5fbXVsdGlTaWduZXJLZXlQYWlycy5sZW5ndGggPj0gREVGQVVMVF9NKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdBIG1heGltdW0gb2YgJyArIERFRkFVTFRfTSArICcgY2FuIHNpZ24gdGhlIHRyYW5zYWN0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2lnbkltcGxlbWVudGF0aW9uKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYXJncyBuZWVkZWQgdG8gY3JlYXRlIGEgc2Vzc2lvbiwgdGhlbiB3ZSBjYW4gc2VuZCB0aGlzIHNlc3Npb24gd2l0aCB0aGUgY29udHJhY3RcbiAgICpcbiAgICogQHJldHVybnMge0RlbGVnYXRlVW5kZWxlZ2F0ZUNvbnRyYWN0QXJnc30gY29udHJhY3RzIGFyZ3MgdG8gY3JlYXRlIGEgc2Vzc2lvblxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZFVuZGVsZWdhdGVQYXJhbWV0ZXJzKCk6IERlbGVnYXRlVW5kZWxlZ2F0ZUNvbnRyYWN0QXJncyB7XG4gICAgY29uc3QgZGVsZWdhdG9yID0gUHVibGljS2V5LmZyb21IZXgodGhpcy5fc291cmNlLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IFB1YmxpY0tleS5mcm9tSGV4KHRoaXMuX3ZhbGlkYXRvcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBDTFZhbHVlQnVpbGRlci5zdHJpbmcodGhpcy5fYWN0aW9uKSxcbiAgICAgIGRlbGVnYXRvcjogQ0xWYWx1ZUJ1aWxkZXIucHVibGljS2V5KGRlbGVnYXRvci52YWx1ZSgpLCBkZWxlZ2F0b3IudGFnKSxcbiAgICAgIHZhbGlkYXRvcjogQ0xWYWx1ZUJ1aWxkZXIucHVibGljS2V5KHZhbGlkYXRvci52YWx1ZSgpLCB2YWxpZGF0b3IudGFnKSxcbiAgICAgIGFtb3VudDogQ0xWYWx1ZUJ1aWxkZXIudTUxMih0aGlzLl9hbW91bnQpLFxuICAgIH07XG4gIH1cblxuICAvLyByZWdpb24gVHJhbnNmZXIgZmllbGRzXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3Mgd2hlcmUgdGhlIGZ1bmRzIHdpbGwgYmUgc2VudCxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgdGhlIDY4IGJpdHMgYWRkcmVzcyB0byB0cmFuc2ZlciBmdW5kcyB0b1xuICAgKiBAcmV0dXJucyB7VW5kZWxlZ2F0ZUJ1aWxkZXJ9IHRoZSBidWlsZGVyIHdpdGggdGhlIG5ldyBwYXJhbWV0ZXIgc2V0XG4gICAqL1xuICB2YWxpZGF0b3IoYWRkcmVzczogc3RyaW5nKTogdGhpcyB7XG4gICAgaWYgKCFpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgdGhpcy5fdmFsaWRhdG9yID0gYWRkcmVzcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFtb3VudCB0byBiZSB0cmFuc2ZlcnJlZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IGFtb3VudCB0byB0cmFuc2ZlclxuICAgKiBAcmV0dXJucyB7VW5kZWxlZ2F0ZUJ1aWxkZXJ9IHRoZSBidWlsZGVyIHdpdGggdGhlIG5ldyBwYXJhbWV0ZXIgc2V0XG4gICAqL1xuICBhbW91bnQoYW1vdW50OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBpZiAoIWlzVmFsaWREZWxlZ2F0ZUFtb3VudChhbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoJ0ludmFsaWQgYW1vdW50Jyk7XG4gICAgfVxuICAgIHRoaXMuX2Ftb3VudCA9IGFtb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBWYWxpZGF0b3JzXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIG1hbmRhdG9yeSBmaWVsZHMgaW4gdGhlIGNsYXNzXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJbiBjYXNlIG9mIG1pc3Npbmcgb3IgaW52YWxpZCBmaWVsZHNcbiAgICovXG4gIHZhbGlkYXRlTWFuZGF0b3J5RmllbGRzKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fYW1vdW50KSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGFtb3VudCcpO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWREZWxlZ2F0ZUFtb3VudCh0aGlzLl9hbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoJ0ludmFsaWQgYW1vdW50Jyk7XG4gICAgfVxuICAgIHN1cGVyLnZhbGlkYXRlTWFuZGF0b3J5RmllbGRzKCk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG59XG4iXX0=