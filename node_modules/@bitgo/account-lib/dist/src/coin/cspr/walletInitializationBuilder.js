"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletInitializationBuilder = void 0;
var casper_js_sdk_1 = require("casper-js-sdk");
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var transactionBuilder_1 = require("./transactionBuilder");
var utils_1 = require("./utils");
var constants_1 = require("./constants");
var keyPair_1 = require("./keyPair");
var DEFAULT_OWNER_WEIGHT = 1;
var WalletInitializationBuilder = /** @class */ (function (_super) {
    __extends(WalletInitializationBuilder, _super);
    function WalletInitializationBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._owners = [];
        _this._contract = Uint8Array.from(Buffer.from(utils_1.casperContractHexCode, 'hex'));
        return _this;
    }
    // region Base Builder
    /** @inheritdoc */
    WalletInitializationBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            var args, extraArguments, index, ownerPublicKey, ownerAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        args = this.buildWalletParameters();
                        extraArguments = new Map();
                        extraArguments.set(constants_1.TRANSACTION_TYPE, casper_js_sdk_1.CLValueBuilder.string(baseCoin_1.TransactionType[baseCoin_1.TransactionType.WalletInitialization]));
                        for (index = 0; index < this._owners.length; index++) {
                            ownerPublicKey = Buffer.from(this._owners[index].address.value()).toString('hex');
                            ownerAddress = new keyPair_1.KeyPair({ pub: ownerPublicKey }).getAddress();
                            extraArguments.set(constants_1.OWNER_PREFIX + index, casper_js_sdk_1.CLValueBuilder.string(ownerAddress));
                        }
                        this._session = { moduleBytes: this._contract, args: casper_js_sdk_1.RuntimeArgs.fromMap(args), extraArguments: extraArguments };
                        this.transaction.setTransactionType(baseCoin_1.TransactionType.WalletInitialization);
                        return [4 /*yield*/, _super.prototype.buildImplementation.call(this)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Build args needed to create a session, then we can send this session with the contract
     *
     * @returns {WalletInitContractArgs} contracts args to create a session
     */
    WalletInitializationBuilder.prototype.buildWalletParameters = function () {
        var accounts = this._owners.map(function (owner) { return casper_js_sdk_1.CLValueBuilder.byteArray(owner.address.toAccountHash()); });
        var weights = this._owners.map(function (owner) { return casper_js_sdk_1.CLValueBuilder.u8(owner.weight); });
        // set source address weight to zero to disable the master private key from signing.
        accounts.push(casper_js_sdk_1.CLValueBuilder.byteArray(casper_js_sdk_1.CLPublicKey.fromHex(this._source.address).toAccountHash()));
        weights.push(casper_js_sdk_1.CLValueBuilder.u8(0));
        return {
            action: casper_js_sdk_1.CLValueBuilder.string(constants_1.WALLET_INITIALIZATION_CONTRACT_ACTION),
            // This typo is on purpose since the contract we use for multisig wallet initialization expect this argument to be written like this.
            deployment_thereshold: casper_js_sdk_1.CLValueBuilder.u8(transactionBuilder_1.DEFAULT_N),
            key_management_threshold: casper_js_sdk_1.CLValueBuilder.u8(transactionBuilder_1.DEFAULT_M),
            accounts: casper_js_sdk_1.CLValueBuilder.list(accounts),
            weights: casper_js_sdk_1.CLValueBuilder.list(weights),
        };
    };
    /** @inheritdoc */
    WalletInitializationBuilder.prototype.initBuilder = function (tx) {
        _super.prototype.initBuilder.call(this, tx);
        this.transaction.setTransactionType(baseCoin_1.TransactionType.WalletInitialization);
        for (var ownerIndex = 0; ownerIndex < transactionBuilder_1.DEFAULT_M; ownerIndex++) {
            var ownerCLValue = tx.casperTx.session.getArgByName(constants_1.OWNER_PREFIX + ownerIndex);
            this.owner(ownerCLValue.value());
        }
    };
    // endregion
    // region Common builder methods
    /**
     * Set one of the owners of the multisig wallet.
     *
     * @param {string} address The public key of the owner's account
     * @returns {WalletInitializationBuilder} This wallet initialization builder
     */
    WalletInitializationBuilder.prototype.owner = function (address) {
        if (this._owners.length >= transactionBuilder_1.DEFAULT_M) {
            throw new errors_1.BuildTransactionError('A maximum of ' + transactionBuilder_1.DEFAULT_M + ' owners can be set for a multisig wallet');
        }
        this.validateAddress({ address: address });
        for (var _i = 0, _a = this._owners; _i < _a.length; _i++) {
            var _owner = _a[_i];
            if (address.substr(0, 2) + Buffer.from(_owner.address.value()).toString('hex') === address) {
                throw new errors_1.BuildTransactionError('Duplicated owner: ' + address);
            }
        }
        this._owners.push({ address: casper_js_sdk_1.CLPublicKey.fromHex(address), weight: DEFAULT_OWNER_WEIGHT });
        return this;
    };
    // endregion
    // region Validators
    WalletInitializationBuilder.prototype.validateMandatoryFields = function () {
        if (this._owners.length === 0) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing wallet owners');
        }
        if (this._owners.length !== transactionBuilder_1.DEFAULT_M) {
            throw new errors_1.BuildTransactionError("Invalid transaction: wrong number of owners -- required: " + transactionBuilder_1.DEFAULT_M + ", found: " + this._owners.length);
        }
        _super.prototype.validateMandatoryFields.call(this);
    };
    return WalletInitializationBuilder;
}(transactionBuilder_1.TransactionBuilder));
exports.WalletInitializationBuilder = WalletInitializationBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vY3Nwci93YWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsK0NBQXlHO0FBQ3pHLDZDQUEyRDtBQUMzRCx3Q0FBOEM7QUFDOUMsMkRBQWdGO0FBR2hGLGlDQUFnRDtBQUNoRCx5Q0FBb0c7QUFDcEcscUNBQW9DO0FBRXBDLElBQU0sb0JBQW9CLEdBQUcsQ0FBQyxDQUFDO0FBQy9CO0lBQWlELCtDQUFrQjtJQUlqRSxxQ0FBWSxXQUFpQztRQUE3QyxZQUNFLGtCQUFNLFdBQVcsQ0FBQyxTQUVuQjtRQU5PLGFBQU8sR0FBWSxFQUFFLENBQUM7UUFLNUIsS0FBSSxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsNkJBQXFCLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzs7SUFDOUUsQ0FBQztJQUVELHNCQUFzQjtJQUN0QixrQkFBa0I7SUFDRix5REFBbUIsR0FBbkM7Ozs7Ozt3QkFDUSxJQUFJLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7d0JBQ3BDLGNBQWMsR0FBRyxJQUFJLEdBQUcsRUFBbUIsQ0FBQzt3QkFFbEQsY0FBYyxDQUFDLEdBQUcsQ0FBQyw0QkFBZ0IsRUFBRSw4QkFBYyxDQUFDLE1BQU0sQ0FBQywwQkFBZSxDQUFDLDBCQUFlLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ25ILEtBQVMsS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUU7NEJBQ2xELGNBQWMsR0FBRyxNQUFNLENBQUMsSUFB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QUM7U0FDSDtRQUNELGlCQUFNLHVCQUF1QixXQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVILGtDQUFDO0FBQUQsQ0FBQyxBQW5HRCxDQUFpRCx1Q0FBa0IsR0FtR2xFO0FBbkdZLGtFQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBDTFZhbHVlLCBDTFB1YmxpY0tleSBhcyBQdWJsaWNLZXksIFJ1bnRpbWVBcmdzLCBDTFZhbHVlQnVpbGRlciwgQ0xTdHJpbmcgfSBmcm9tICdjYXNwZXItanMtc2RrJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciB9IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbkJ1aWxkZXIsIERFRkFVTFRfTSwgREVGQVVMVF9OIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IE93bmVyLCBXYWxsZXRJbml0Q29udHJhY3RBcmdzIH0gZnJvbSAnLi9pZmFjZXMnO1xuaW1wb3J0IHsgY2FzcGVyQ29udHJhY3RIZXhDb2RlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBPV05FUl9QUkVGSVgsIFRSQU5TQUNUSU9OX1RZUEUsIFdBTExFVF9JTklUSUFMSVpBVElPTl9DT05UUkFDVF9BQ1RJT04gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcblxuY29uc3QgREVGQVVMVF9PV05FUl9XRUlHSFQgPSAxO1xuZXhwb3J0IGNsYXNzIFdhbGxldEluaXRpYWxpemF0aW9uQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByaXZhdGUgX293bmVyczogT3duZXJbXSA9IFtdO1xuICBwcml2YXRlIF9jb250cmFjdDogVWludDhBcnJheTtcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gICAgdGhpcy5fY29udHJhY3QgPSBVaW50OEFycmF5LmZyb20oQnVmZmVyLmZyb20oY2FzcGVyQ29udHJhY3RIZXhDb2RlLCAnaGV4JykpO1xuICB9XG5cbiAgLy8gcmVnaW9uIEJhc2UgQnVpbGRlclxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmJ1aWxkV2FsbGV0UGFyYW1ldGVycygpO1xuICAgIGNvbnN0IGV4dHJhQXJndW1lbnRzID0gbmV3IE1hcDxzdHJpbmcsIENMVmFsdWU+KCk7XG5cbiAgICBleHRyYUFyZ3VtZW50cy5zZXQoVFJBTlNBQ1RJT05fVFlQRSwgQ0xWYWx1ZUJ1aWxkZXIuc3RyaW5nKFRyYW5zYWN0aW9uVHlwZVtUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb25dKSk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX293bmVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IG93bmVyUHVibGljS2V5ID0gQnVmZmVyLmZyb20odGhpcy5fb3duZXJzW2luZGV4XS5hZGRyZXNzLnZhbHVlKCkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IG93bmVyQWRkcmVzcyA9IG5ldyBLZXlQYWlyKHsgcHViOiBvd25lclB1YmxpY0tleSB9KS5nZXRBZGRyZXNzKCk7XG4gICAgICBleHRyYUFyZ3VtZW50cy5zZXQoT1dORVJfUFJFRklYICsgaW5kZXgsIENMVmFsdWVCdWlsZGVyLnN0cmluZyhvd25lckFkZHJlc3MpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXNzaW9uID0geyBtb2R1bGVCeXRlczogdGhpcy5fY29udHJhY3QsIGFyZ3M6IFJ1bnRpbWVBcmdzLmZyb21NYXAoYXJncyksIGV4dHJhQXJndW1lbnRzOiBleHRyYUFyZ3VtZW50cyB9O1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb25UeXBlKFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbik7XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhcmdzIG5lZWRlZCB0byBjcmVhdGUgYSBzZXNzaW9uLCB0aGVuIHdlIGNhbiBzZW5kIHRoaXMgc2Vzc2lvbiB3aXRoIHRoZSBjb250cmFjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7V2FsbGV0SW5pdENvbnRyYWN0QXJnc30gY29udHJhY3RzIGFyZ3MgdG8gY3JlYXRlIGEgc2Vzc2lvblxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZFdhbGxldFBhcmFtZXRlcnMoKTogV2FsbGV0SW5pdENvbnRyYWN0QXJncyB7XG4gICAgY29uc3QgYWNjb3VudHMgPSB0aGlzLl9vd25lcnMubWFwKChvd25lcikgPT4gQ0xWYWx1ZUJ1aWxkZXIuYnl0ZUFycmF5KG93bmVyLmFkZHJlc3MudG9BY2NvdW50SGFzaCgpKSk7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRoaXMuX293bmVycy5tYXAoKG93bmVyKSA9PiBDTFZhbHVlQnVpbGRlci51OChvd25lci53ZWlnaHQpKTtcblxuICAgIC8vIHNldCBzb3VyY2UgYWRkcmVzcyB3ZWlnaHQgdG8gemVybyB0byBkaXNhYmxlIHRoZSBtYXN0ZXIgcHJpdmF0ZSBrZXkgZnJvbSBzaWduaW5nLlxuICAgIGFjY291bnRzLnB1c2goQ0xWYWx1ZUJ1aWxkZXIuYnl0ZUFycmF5KFB1YmxpY0tleS5mcm9tSGV4KHRoaXMuX3NvdXJjZS5hZGRyZXNzKS50b0FjY291bnRIYXNoKCkpKTtcbiAgICB3ZWlnaHRzLnB1c2goQ0xWYWx1ZUJ1aWxkZXIudTgoMCkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogQ0xWYWx1ZUJ1aWxkZXIuc3RyaW5nKFdBTExFVF9JTklUSUFMSVpBVElPTl9DT05UUkFDVF9BQ1RJT04pLFxuICAgICAgLy8gVGhpcyB0eXBvIGlzIG9uIHB1cnBvc2Ugc2luY2UgdGhlIGNvbnRyYWN0IHdlIHVzZSBmb3IgbXVsdGlzaWcgd2FsbGV0IGluaXRpYWxpemF0aW9uIGV4cGVjdCB0aGlzIGFyZ3VtZW50IHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzLlxuICAgICAgZGVwbG95bWVudF90aGVyZXNob2xkOiBDTFZhbHVlQnVpbGRlci51OChERUZBVUxUX04pLFxuICAgICAga2V5X21hbmFnZW1lbnRfdGhyZXNob2xkOiBDTFZhbHVlQnVpbGRlci51OChERUZBVUxUX00pLFxuICAgICAgYWNjb3VudHM6IENMVmFsdWVCdWlsZGVyLmxpc3QoYWNjb3VudHMpLFxuICAgICAgd2VpZ2h0czogQ0xWYWx1ZUJ1aWxkZXIubGlzdCh3ZWlnaHRzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHN1cGVyLmluaXRCdWlsZGVyKHR4KTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uVHlwZShUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24pO1xuICAgIGZvciAobGV0IG93bmVySW5kZXggPSAwOyBvd25lckluZGV4IDwgREVGQVVMVF9NOyBvd25lckluZGV4KyspIHtcbiAgICAgIGNvbnN0IG93bmVyQ0xWYWx1ZSA9IHR4LmNhc3BlclR4LnNlc3Npb24uZ2V0QXJnQnlOYW1lKE9XTkVSX1BSRUZJWCArIG93bmVySW5kZXgpIGFzIENMU3RyaW5nO1xuICAgICAgdGhpcy5vd25lcihvd25lckNMVmFsdWUudmFsdWUoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIENvbW1vbiBidWlsZGVyIG1ldGhvZHNcbiAgLyoqXG4gICAqIFNldCBvbmUgb2YgdGhlIG93bmVycyBvZiB0aGUgbXVsdGlzaWcgd2FsbGV0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyBUaGUgcHVibGljIGtleSBvZiB0aGUgb3duZXIncyBhY2NvdW50XG4gICAqIEByZXR1cm5zIHtXYWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXJ9IFRoaXMgd2FsbGV0IGluaXRpYWxpemF0aW9uIGJ1aWxkZXJcbiAgICovXG4gIG93bmVyKGFkZHJlc3M6IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICh0aGlzLl9vd25lcnMubGVuZ3RoID49IERFRkFVTFRfTSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQSBtYXhpbXVtIG9mICcgKyBERUZBVUxUX00gKyAnIG93bmVycyBjYW4gYmUgc2V0IGZvciBhIG11bHRpc2lnIHdhbGxldCcpO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyh7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgZm9yIChjb25zdCBfb3duZXIgb2YgdGhpcy5fb3duZXJzKSB7XG4gICAgICBpZiAoYWRkcmVzcy5zdWJzdHIoMCwgMikgKyBCdWZmZXIuZnJvbShfb3duZXIuYWRkcmVzcy52YWx1ZSgpKS50b1N0cmluZygnaGV4JykgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignRHVwbGljYXRlZCBvd25lcjogJyArIGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX293bmVycy5wdXNoKHsgYWRkcmVzczogUHVibGljS2V5LmZyb21IZXgoYWRkcmVzcyksIHdlaWdodDogREVGQVVMVF9PV05FUl9XRUlHSFQgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFZhbGlkYXRvcnNcbiAgdmFsaWRhdGVNYW5kYXRvcnlGaWVsZHMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX293bmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3Npbmcgd2FsbGV0IG93bmVycycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcnMubGVuZ3RoICE9PSBERUZBVUxUX00pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uOiB3cm9uZyBudW1iZXIgb2Ygb3duZXJzIC0tIHJlcXVpcmVkOiAke0RFRkFVTFRfTX0sIGZvdW5kOiAke3RoaXMuX293bmVycy5sZW5ndGh9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHN1cGVyLnZhbGlkYXRlTWFuZGF0b3J5RmllbGRzKCk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG59XG4iXX0=