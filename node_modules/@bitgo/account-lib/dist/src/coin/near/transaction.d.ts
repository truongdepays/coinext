/// <reference types="node" />
import { BaseTransaction, TransactionType } from '../baseCoin';
import { BaseKey } from '../baseCoin/iface';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { TransactionExplanation, TxData } from './iface';
import { KeyPair } from './keyPair';
import * as nearAPI from 'near-api-js';
export declare class Transaction extends BaseTransaction {
    private _nearTransaction;
    private _nearSignedTransaction;
    constructor(coinConfig: Readonly<CoinConfig>);
    get nearTransaction(): nearAPI.transactions.Transaction;
    set nearTransaction(tx: nearAPI.transactions.Transaction);
    /** @inheritdoc */
    canSign(key: BaseKey): boolean;
    /** @inheritdoc */
    toBroadcastFormat(): string;
    /** @inheritdoc */
    toJson(): TxData;
    /**
     * Set the transaction type.
     *
     * @param {TransactionType} transactionType The transaction type to be set.
     */
    setTransactionType(transactionType: TransactionType): void;
    /**
     * Sets this transaction payload
     *
     * @param rawTransaction
     */
    fromRawTransaction(rawTx: string): void;
    /**
     * Sign this transaction
     *
     * @param {KeyPair} signer key
     */
    sign(signer: KeyPair): void;
    /**
     * set transaction type by staking contract method names.
     * @param methodName method name to match and set the transaction type
     */
    private setTypeByStakingMethod;
    /**
     * Check if method is allowed on Near account-lib implementation.
     * This method should check on all contracts added to Near.
     * @param methodName contract call method name to check if its allowed.
     */
    private validateMethodAllowed;
    /**
     * Build input and output field for this transaction
     *
     */
    loadInputsAndOutputs(): void;
    /**
     * Returns a complete explanation for a transfer transaction
     * @param {TxData} json The transaction data in json format
     * @param {TransactionExplanation} explanationResult The transaction explanation to be completed
     * @returns {TransactionExplanation}
     */
    explainTransferTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    /**
     * Returns a complete explanation for a staking activate transaction
     * @param {TxData} json The transaction data in json format
     * @param {TransactionExplanation} explanationResult The transaction explanation to be completed
     * @returns {TransactionExplanation}
     */
    explainStakingActivateTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    /**
     * Returns a complete explanation for a staking withdraw transaction
     * @param {TxData} json The transaction data in json format
     * @param {TransactionExplanation} explanationResult The transaction explanation to be completed
     * @returns {TransactionExplanation}
     */
    explainStakingWithdrawTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    /** @inheritdoc */
    explainTransaction(): TransactionExplanation;
    private getTransactionHash;
    get signablePayload(): Buffer;
    /**
     * Constructs a signed payload using construct.signTx
     * This method will be called during the build step if a TSS signature
     * is added and will set the signTransaction which is the txHex that will be broadcasted
     * As well as add the signature used to sign to the signature array in hex format
     *
     * @param {Buffer} signature The signature to be added to a near transaction
     */
    constructSignedPayload(signature: Buffer): void;
    /** @inheritdoc **/
    get signature(): string[];
}
//# sourceMappingURL=transaction.d.ts.map