"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var transaction_1 = require("./transaction");
var nearAPI = __importStar(require("near-api-js"));
var errors_2 = require("./errors");
var utils_1 = __importDefault(require("./utils"));
var assert_1 = __importDefault(require("assert"));
var keyPair_1 = require("./keyPair");
var hex = __importStar(require("@stablelib/hex"));
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    function TransactionBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._signatures = []; // only support single sig for now
        _this._transaction = new transaction_1.Transaction(_coinConfig);
        return _this;
    }
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     */
    TransactionBuilder.prototype.initBuilder = function (tx) {
        this._transaction = tx;
        var nearTransaction = tx.nearTransaction;
        this._sender = nearTransaction.signerId;
        this._nonce = nearTransaction.nonce;
        this._receiverId = nearTransaction.receiverId;
        this._publicKey = hex.encode(nearTransaction.publicKey.data);
        this._recentBlockHash = nearAPI.utils.serialize.base_encode(nearTransaction.blockHash);
        this._actions = nearTransaction.actions;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        this.validateRawTransaction(rawTransaction);
        this.buildImplementation();
        return this.transaction;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                this.transaction.nearTransaction = this.buildNearTransaction();
                if (this._signer) {
                    this.transaction.sign(this._signer);
                }
                if (((_a = this._signatures) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    this.transaction.constructSignedPayload(this._signatures[0].signature);
                }
                this.transaction.loadInputsAndOutputs();
                return [2 /*return*/, this.transaction];
            });
        });
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        this._signer = new keyPair_1.KeyPair({ prv: key.key });
        return this._transaction;
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        // region Getters and Setters
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: false,
        configurable: true
    });
    // endregion
    // region Validators
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address, addressFormat) {
        if (!utils_1.default.isValidAddress(address.address)) {
            throw new errors_2.AddressValidationError(address.address);
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch (_a) {
            throw new errors_1.BuildTransactionError("Key validation failed");
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        try {
            nearAPI.utils.serialize.deserialize(nearAPI.transactions.SCHEMA, nearAPI.transactions.SignedTransaction, rawTransaction);
        }
        catch (_a) {
            try {
                nearAPI.utils.serialize.deserialize(nearAPI.transactions.SCHEMA, nearAPI.transactions.Transaction, rawTransaction);
            }
            catch (_b) {
                throw new errors_1.BuildTransactionError('invalid raw transaction');
            }
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        if (!transaction.nearTransaction) {
            return;
        }
        this.validateAddress({ address: transaction.nearTransaction.signerId });
        this.validateAddress({ address: transaction.nearTransaction.receiverId });
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThan(0)) {
            throw new errors_1.BuildTransactionError('Value cannot be less than zero');
        }
    };
    // endregion
    /**
     * Sets the public key and the address of the sender of this transaction.
     *
     * @param {string} address the account that is sending this transaction
     * @param {string} pubKey the public key that is sending this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.sender = function (address, pubKey) {
        if (!address || !utils_1.default.isValidAddress(address.toString())) {
            throw new errors_1.BuildTransactionError('Invalid or missing address, got: ' + address);
        }
        if (!pubKey || !utils_1.default.isValidPublicKey(pubKey)) {
            throw new errors_1.BuildTransactionError('Invalid or missing pubKey, got: ' + pubKey);
        }
        this._sender = address;
        this._publicKey = pubKey;
        return this;
    };
    /**
     * Sets the account Id of the receiver of this transaction.
     *
     * @param {string} accountId the account id of the account that is receiving this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.receiverId = function (accountId) {
        utils_1.default.isValidAddress(accountId);
        this._receiverId = accountId;
        return this;
    };
    /**
     * Set the nonce
     *
     * @param {number} nonce - number that can be only used once
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.nonce = function (nonce) {
        if (nonce < 0) {
            throw new errors_1.BuildTransactionError("Invalid nonce: " + nonce);
        }
        this._nonce = nonce;
        return this;
    };
    /**
     * Sets the blockHash of this transaction.
     *
     * @param {string} blockHash the blockHash of this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.recentBlockHash = function (blockHash) {
        if (!utils_1.default.isValidBlockId(blockHash)) {
            throw new errors_1.BuildTransactionError("Invalid blockHash " + blockHash);
        }
        this._recentBlockHash = blockHash;
        return this;
    };
    /**
     * Sets the list of actions of this transaction.
     *
     * @param {nearAPI.transactions.Action[]} value the the list of actions
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.actions = function (value) {
        this._actions = value;
        return this;
    };
    /**
     * Builds the NEAR transaction.
     *
     * @return {Transaction} near sdk transaction
     */
    TransactionBuilder.prototype.buildNearTransaction = function () {
        assert_1.default(this._sender, new errors_1.BuildTransactionError('sender is required before building'));
        assert_1.default(this._recentBlockHash, new errors_1.BuildTransactionError('recent blockhash is required before building'));
        var tx = nearAPI.transactions.createTransaction(this._sender, nearAPI.utils.PublicKey.fromString(nearAPI.utils.serialize.base_encode(hex.decode(this._publicKey))), this._receiverId, this._nonce, this._actions, nearAPI.utils.serialize.base_decode(this._recentBlockHash));
        return tx;
    };
    /** @inheritDoc */
    TransactionBuilder.prototype.addSignature = function (publicKey, signature) {
        this._signatures.push({ publicKey: publicKey, signature: signature });
    };
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vbmVhci90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHdDQUFnRTtBQUNoRSw2Q0FBMkQ7QUFFM0QsNkNBQTRDO0FBQzVDLG1EQUF1QztBQUN2QyxtQ0FBa0Q7QUFDbEQsa0RBQTRCO0FBQzVCLGtEQUE0QjtBQUM1QixxQ0FBb0M7QUFDcEMsa0RBQXNDO0FBQ3RDO0lBQWlELHNDQUFzQjtJQVlyRSw0QkFBWSxXQUFpQztRQUE3QyxZQUNFLGtCQUFNLFdBQVcsQ0FBQyxTQUVuQjtRQU5PLGlCQUFXLEdBQTBCLEVBQUUsQ0FBQyxDQUFDLGtDQUFrQztRQUtqRixLQUFJLENBQUMsWUFBWSxHQUFHLElBQUkseUJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7SUFDbkQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx3Q0FBVyxHQUFYLFVBQVksRUFBZTtRQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFNLGVBQWUsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDO1FBQzNDLElBQUksQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQztRQUN4QyxJQUFJLENBQUMsTUFBTSxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUM7UUFDcEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxlQUFlLENBQUMsVUFBVSxDQUFDO1FBQzlDLElBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLFNB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QUMvQyxJQUFJLENBQUMsT0FBTyxFQUNaLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUNwRyxJQUFJLENBQUMsV0FBVyxFQUNoQixJQUFJLENBQUMsTUFBTSxFQUNYLElBQUksQ0FBQyxRQUFRLEVBQ2IsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUMzRCxDQUFDO1FBRUYsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLHlDQUFZLEdBQVosVUFBYSxTQUF3QixFQUFFLFNBQWlCO1FBQ3RELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsU0FBUyxXQUFBLEVBQUUsU0FBUyxXQUFBLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFDSCx5QkFBQztBQUFELENBQUMsQUE5TkQsQ0FBaUQsaUNBQXNCLEdBOE50RTtBQTlOcUIsZ0RBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIsIEludGVyZmFjZSB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciB9IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBCYXNlQWRkcmVzcywgQmFzZUtleSwgUHVibGljS2V5IGFzIEJhc2VQdWJsaWNLZXkgfSBmcm9tICcuLi9iYXNlQ29pbi9pZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBBZGRyZXNzVmFsaWRhdGlvbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgKiBhcyBoZXggZnJvbSAnQHN0YWJsZWxpYi9oZXgnO1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYW5zYWN0aW9uQnVpbGRlciBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcml2YXRlIF90cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247XG5cbiAgcHJpdmF0ZSBfc2VuZGVyOiBzdHJpbmc7XG4gIHByaXZhdGUgX3B1YmxpY0tleTogc3RyaW5nO1xuICBwcml2YXRlIF9yZWNlaXZlcklkOiBzdHJpbmc7XG4gIHByaXZhdGUgX25vbmNlOiBudW1iZXI7XG4gIHByaXZhdGUgX3JlY2VudEJsb2NrSGFzaDogc3RyaW5nO1xuICBwcml2YXRlIF9zaWduZXI6IEtleVBhaXI7XG4gIHByaXZhdGUgX3NpZ25hdHVyZXM6IEludGVyZmFjZS5TaWduYXR1cmVbXSA9IFtdOyAvLyBvbmx5IHN1cHBvcnQgc2luZ2xlIHNpZyBmb3Igbm93XG4gIHByb3RlY3RlZCBfYWN0aW9uczogbmVhckFQSS50cmFuc2FjdGlvbnMuQWN0aW9uW107XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBidWlsZGVyIGZpZWxkcyB1c2luZyB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvbiBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHR4IHRoZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHR4O1xuICAgIGNvbnN0IG5lYXJUcmFuc2FjdGlvbiA9IHR4Lm5lYXJUcmFuc2FjdGlvbjtcbiAgICB0aGlzLl9zZW5kZXIgPSBuZWFyVHJhbnNhY3Rpb24uc2lnbmVySWQ7XG4gICAgdGhpcy5fbm9uY2UgPSBuZWFyVHJhbnNhY3Rpb24ubm9uY2U7XG4gICAgdGhpcy5fcmVjZWl2ZXJJZCA9IG5lYXJUcmFuc2FjdGlvbi5yZWNlaXZlcklkO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGhleC5lbmNvZGUobmVhclRyYW5zYWN0aW9uLnB1YmxpY0tleS5kYXRhKTtcbiAgICB0aGlzLl9yZWNlbnRCbG9ja0hhc2ggPSBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5iYXNlX2VuY29kZShuZWFyVHJhbnNhY3Rpb24uYmxvY2tIYXNoKTtcbiAgICB0aGlzLl9hY3Rpb25zID0gbmVhclRyYW5zYWN0aW9uLmFjdGlvbnM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogVHJhbnNhY3Rpb24ge1xuICAgIHRoaXMudmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5idWlsZEltcGxlbWVudGF0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIHRoaXMudHJhbnNhY3Rpb24ubmVhclRyYW5zYWN0aW9uID0gdGhpcy5idWlsZE5lYXJUcmFuc2FjdGlvbigpO1xuICAgIGlmICh0aGlzLl9zaWduZXIpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb24uc2lnbih0aGlzLl9zaWduZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2lnbmF0dXJlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbi5jb25zdHJ1Y3RTaWduZWRQYXlsb2FkKHRoaXMuX3NpZ25hdHVyZXNbMF0uc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2FjdGlvbi5sb2FkSW5wdXRzQW5kT3V0cHV0cygpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIHRoaXMuX3NpZ25lciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8vIHJlZ2lvbiBHZXR0ZXJzIGFuZCBTZXR0ZXJzXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uKCk6IFRyYW5zYWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIHNldCB0cmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFZhbGlkYXRvcnNcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBCYXNlQWRkcmVzcywgYWRkcmVzc0Zvcm1hdD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEFkZHJlc3NWYWxpZGF0aW9uRXJyb3IoYWRkcmVzcy5hZGRyZXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVLZXkoa2V5OiBCYXNlS2V5KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgS2V5IHZhbGlkYXRpb24gZmFpbGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IGFueSk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5kZXNlcmlhbGl6ZShcbiAgICAgICAgbmVhckFQSS50cmFuc2FjdGlvbnMuU0NIRU1BLFxuICAgICAgICBuZWFyQVBJLnRyYW5zYWN0aW9ucy5TaWduZWRUcmFuc2FjdGlvbixcbiAgICAgICAgcmF3VHJhbnNhY3Rpb24sXG4gICAgICApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmVhckFQSS51dGlscy5zZXJpYWxpemUuZGVzZXJpYWxpemUoXG4gICAgICAgICAgbmVhckFQSS50cmFuc2FjdGlvbnMuU0NIRU1BLFxuICAgICAgICAgIG5lYXJBUEkudHJhbnNhY3Rpb25zLlRyYW5zYWN0aW9uLFxuICAgICAgICAgIHJhd1RyYW5zYWN0aW9uLFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ2ludmFsaWQgcmF3IHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbi5uZWFyVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoeyBhZGRyZXNzOiB0cmFuc2FjdGlvbi5uZWFyVHJhbnNhY3Rpb24uc2lnbmVySWQgfSk7XG4gICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoeyBhZGRyZXNzOiB0cmFuc2FjdGlvbi5uZWFyVHJhbnNhY3Rpb24ucmVjZWl2ZXJJZCB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUuaXNMZXNzVGhhbigwKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVmFsdWUgY2Fubm90IGJlIGxlc3MgdGhhbiB6ZXJvJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHB1YmxpYyBrZXkgYW5kIHRoZSBhZGRyZXNzIG9mIHRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgdGhlIGFjY291bnQgdGhhdCBpcyBzZW5kaW5nIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YktleSB0aGUgcHVibGljIGtleSB0aGF0IGlzIHNlbmRpbmcgdGhpcyB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSBUaGlzIHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIHB1YmxpYyBzZW5kZXIoYWRkcmVzczogc3RyaW5nLCBwdWJLZXk6IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICghYWRkcmVzcyB8fCAhdXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcy50b1N0cmluZygpKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBvciBtaXNzaW5nIGFkZHJlc3MsIGdvdDogJyArIGFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAoIXB1YktleSB8fCAhdXRpbHMuaXNWYWxpZFB1YmxpY0tleShwdWJLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIG9yIG1pc3NpbmcgcHViS2V5LCBnb3Q6ICcgKyBwdWJLZXkpO1xuICAgIH1cbiAgICB0aGlzLl9zZW5kZXIgPSBhZGRyZXNzO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IHB1YktleTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhY2NvdW50IElkIG9mIHRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIHRoZSBhY2NvdW50IGlkIG9mIHRoZSBhY2NvdW50IHRoYXQgaXMgcmVjZWl2aW5nIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwdWJsaWMgcmVjZWl2ZXJJZChhY2NvdW50SWQ6IHN0cmluZyk6IHRoaXMge1xuICAgIHV0aWxzLmlzVmFsaWRBZGRyZXNzKGFjY291bnRJZCk7XG4gICAgdGhpcy5fcmVjZWl2ZXJJZCA9IGFjY291bnRJZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG5vbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub25jZSAtIG51bWJlciB0aGF0IGNhbiBiZSBvbmx5IHVzZWQgb25jZVxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSBUaGlzIHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIHB1YmxpYyBub25jZShub25jZTogbnVtYmVyKTogdGhpcyB7XG4gICAgaWYgKG5vbmNlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBub25jZTogJHtub25jZX1gKTtcbiAgICB9XG4gICAgdGhpcy5fbm9uY2UgPSBub25jZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBibG9ja0hhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrSGFzaCB0aGUgYmxvY2tIYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwdWJsaWMgcmVjZW50QmxvY2tIYXNoKGJsb2NrSGFzaDogc3RyaW5nKTogdGhpcyB7XG4gICAgaWYgKCF1dGlscy5pc1ZhbGlkQmxvY2tJZChibG9ja0hhc2gpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIGJsb2NrSGFzaCAke2Jsb2NrSGFzaH1gKTtcbiAgICB9XG4gICAgdGhpcy5fcmVjZW50QmxvY2tIYXNoID0gYmxvY2tIYXNoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpc3Qgb2YgYWN0aW9ucyBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge25lYXJBUEkudHJhbnNhY3Rpb25zLkFjdGlvbltdfSB2YWx1ZSB0aGUgdGhlIGxpc3Qgb2YgYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSBUaGlzIHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIHByb3RlY3RlZCBhY3Rpb25zKHZhbHVlOiBuZWFyQVBJLnRyYW5zYWN0aW9ucy5BY3Rpb25bXSk6IHRoaXMge1xuICAgIHRoaXMuX2FjdGlvbnMgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQnVpbGRzIHRoZSBORUFSIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gbmVhciBzZGsgdHJhbnNhY3Rpb25cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZE5lYXJUcmFuc2FjdGlvbigpOiBuZWFyQVBJLnRyYW5zYWN0aW9ucy5UcmFuc2FjdGlvbiB7XG4gICAgYXNzZXJ0KHRoaXMuX3NlbmRlciwgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignc2VuZGVyIGlzIHJlcXVpcmVkIGJlZm9yZSBidWlsZGluZycpKTtcbiAgICBhc3NlcnQodGhpcy5fcmVjZW50QmxvY2tIYXNoLCBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdyZWNlbnQgYmxvY2toYXNoIGlzIHJlcXVpcmVkIGJlZm9yZSBidWlsZGluZycpKTtcblxuICAgIGNvbnN0IHR4ID0gbmVhckFQSS50cmFuc2FjdGlvbnMuY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICB0aGlzLl9zZW5kZXIsXG4gICAgICBuZWFyQVBJLnV0aWxzLlB1YmxpY0tleS5mcm9tU3RyaW5nKG5lYXJBUEkudXRpbHMuc2VyaWFsaXplLmJhc2VfZW5jb2RlKGhleC5kZWNvZGUodGhpcy5fcHVibGljS2V5KSkpLFxuICAgICAgdGhpcy5fcmVjZWl2ZXJJZCxcbiAgICAgIHRoaXMuX25vbmNlLFxuICAgICAgdGhpcy5fYWN0aW9ucyxcbiAgICAgIG5lYXJBUEkudXRpbHMuc2VyaWFsaXplLmJhc2VfZGVjb2RlKHRoaXMuX3JlY2VudEJsb2NrSGFzaCksXG4gICAgKTtcblxuICAgIHJldHVybiB0eDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBhZGRTaWduYXR1cmUocHVibGljS2V5OiBCYXNlUHVibGljS2V5LCBzaWduYXR1cmU6IEJ1ZmZlcik6IHZvaWQge1xuICAgIHRoaXMuX3NpZ25hdHVyZXMucHVzaCh7IHB1YmxpY0tleSwgc2lnbmF0dXJlIH0pO1xuICB9XG59XG4iXX0=