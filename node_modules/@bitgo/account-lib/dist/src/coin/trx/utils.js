"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHex = exports.isValidRawTransactionFormat = exports.isValidTxJsonString = exports.decodeAccountPermissionUpdateContract = exports.decodeTriggerSmartContract = exports.decodeTransferContract = exports.isValidHex = exports.decodeRawTransaction = exports.decodeTransaction = exports.getRawAddressFromPubKey = exports.signString = exports.signTransaction = exports.getBase58AddressFromHex = exports.getBase58AddressFromByteArray = exports.getAddressFromPriKey = exports.getPubKeyFromPriKey = exports.getHexAddressFromBase58Address = exports.verifySignature = exports.getHexAddressFromByteArray = exports.getByteArrayFromHexAddress = exports.isBase58Address = void 0;
var assert_1 = __importDefault(require("assert"));
var hex = __importStar(require("@stablelib/hex"));
var tronweb = __importStar(require("tronweb"));
var tron_1 = require("../../../resources/trx/protobuf/tron");
var errors_1 = require("../baseCoin/errors");
var enum_1 = require("./enum");
/**
 * @param address
 */
function isBase58Address(address) {
    return tronweb.utils.crypto.isAddressValid(address);
}
exports.isBase58Address = isBase58Address;
/**
 * @param str
 */
function getByteArrayFromHexAddress(str) {
    return tronweb.utils.code.hexStr2byteArray(str.replace('0x', ''));
}
exports.getByteArrayFromHexAddress = getByteArrayFromHexAddress;
/**
 * @param arr
 */
function getHexAddressFromByteArray(arr) {
    return tronweb.utils.code.byteArray2hexStr(arr);
}
exports.getHexAddressFromByteArray = getHexAddressFromByteArray;
/**
 * @param messageToVerify
 * @param base58Address
 * @param sigHex
 * @param useTronHeader
 */
function verifySignature(messageToVerify, base58Address, sigHex, useTronHeader) {
    if (useTronHeader === void 0) { useTronHeader = true; }
    if (!isValidHex(sigHex)) {
        throw new errors_1.UtilsError('signature is not in a valid format, needs to be hexadecimal');
    }
    if (!isValidHex(messageToVerify)) {
        throw new errors_1.UtilsError('message is not in a valid format, needs to be hexadecimal');
    }
    if (!isBase58Address(base58Address)) {
        throw new errors_1.UtilsError('address needs to be base58 encoded');
    }
    return tronweb.Trx.verifySignature(messageToVerify, base58Address, sigHex, useTronHeader);
}
exports.verifySignature = verifySignature;
/**
 * @param base58
 */
function getHexAddressFromBase58Address(base58) {
    // pulled from: https://github.com/TRON-US/tronweb/blob/dcb8efa36a5ebb65c4dab3626e90256a453f3b0d/src/utils/help.js#L17
    // but they don't surface this call in index.js
    var bytes = tronweb.utils.crypto.decodeBase58Address(base58);
    return getHexAddressFromByteArray(bytes);
}
exports.getHexAddressFromBase58Address = getHexAddressFromBase58Address;
/**
 * @param privateKey
 */
function getPubKeyFromPriKey(privateKey) {
    return tronweb.utils.crypto.getPubKeyFromPriKey(privateKey);
}
exports.getPubKeyFromPriKey = getPubKeyFromPriKey;
/**
 * @param privateKey
 */
function getAddressFromPriKey(privateKey) {
    return tronweb.utils.crypto.getAddressFromPriKey(privateKey);
}
exports.getAddressFromPriKey = getAddressFromPriKey;
/**
 * @param address
 */
function getBase58AddressFromByteArray(address) {
    return tronweb.utils.crypto.getBase58CheckAddress(address);
}
exports.getBase58AddressFromByteArray = getBase58AddressFromByteArray;
/**
 * @param hex
 */
function getBase58AddressFromHex(hex) {
    var arr = getByteArrayFromHexAddress(hex);
    return getBase58AddressFromByteArray(arr);
}
exports.getBase58AddressFromHex = getBase58AddressFromHex;
/**
 * @param privateKey
 * @param transaction
 */
function signTransaction(privateKey, transaction) {
    return tronweb.utils.crypto.signTransaction(privateKey, transaction);
}
exports.signTransaction = signTransaction;
/**
 * @param message
 * @param privateKey
 * @param useTronHeader
 */
function signString(message, privateKey, useTronHeader) {
    if (useTronHeader === void 0) { useTronHeader = true; }
    return tronweb.Trx.signString(message, privateKey, useTronHeader);
}
exports.signString = signString;
/**
 * @param pubBytes
 */
function getRawAddressFromPubKey(pubBytes) {
    return tronweb.utils.crypto.computeAddress(pubBytes);
}
exports.getRawAddressFromPubKey = getRawAddressFromPubKey;
/**
 * Decodes a hex encoded transaction in its protobuf representation.
 *
 * @param hexString raw_data_hex field from tron transactions
 */
function decodeTransaction(hexString) {
    var rawTransaction = decodeRawTransaction(hexString);
    // there should not be multiple contracts in this data
    if (rawTransaction.contracts.length !== 1) {
        throw new errors_1.UtilsError('Number of contracts is greater than 1.');
    }
    var contract;
    var contractType;
    // ensure the contract type is supported
    switch (rawTransaction.contracts[0].parameter.type_url) {
        case 'type.googleapis.com/protocol.TransferContract':
            contractType = enum_1.ContractType.Transfer;
            contract = exports.decodeTransferContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.AccountPermissionUpdateContract':
            contractType = enum_1.ContractType.AccountPermissionUpdate;
            contract = exports.decodeAccountPermissionUpdateContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.TriggerSmartContract':
            contractType = enum_1.ContractType.TriggerSmartContract;
            contract = exports.decodeTriggerSmartContract(rawTransaction.contracts[0].parameter.value);
            break;
        default:
            throw new errors_1.UtilsError('Unsupported contract type');
    }
    return {
        contractType: contractType,
        contract: contract,
        expiration: rawTransaction.expiration,
        timestamp: rawTransaction.timestamp,
        ref_block_bytes: rawTransaction.blockBytes,
        ref_block_hash: rawTransaction.blockHash,
        fee_limit: +rawTransaction.feeLimit,
    };
}
exports.decodeTransaction = decodeTransaction;
/**
 * Decodes a transaction's raw field from a base64 encoded string. This is a protobuf representation.
 *
 * @param hexString this is the raw hexadecimal encoded string. Doc found in the following link.
 * @example
 * @see {@link https://github.com/BitGo/bitgo-account-lib/blob/5f282588701778a4421c75fa61f42713f56e95b9/resources/trx/protobuf/tron.proto#L319}
 */
function decodeRawTransaction(hexString) {
    var bytes = Buffer.from(hexString, 'hex');
    var raw;
    try {
        // we need to decode our raw_data_hex field first
        raw = tron_1.protocol.Transaction.raw.decode(bytes);
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the initial raw_data_hex from the serialized tx.');
    }
    return {
        expiration: Number(raw.expiration),
        timestamp: Number(raw.timestamp),
        contracts: raw.contract,
        blockBytes: toHex(raw.refBlockBytes),
        feeLimit: raw.feeLimit,
        blockHash: toHex(raw.refBlockHash),
    };
}
exports.decodeRawTransaction = decodeRawTransaction;
/**
 * Indicates whether the passed string is a safe hex string for tron's purposes.
 *
 * @param hex A valid hex string must be a string made of numbers and characters and has an even length.
 */
function isValidHex(hex) {
    return /^(0x)?([0-9a-f]{2})+$/i.test(hex);
}
exports.isValidHex = isValidHex;
/** Deserialize the segment of the txHex which corresponds with the details of the transfer
 *
 * @param transferHex is the value property of the "parameter" field of contractList[0]
 * */
function decodeTransferContract(transferHex) {
    var contractBytes = Buffer.from(transferHex, 'base64');
    var transferContract;
    try {
        transferContract = tron_1.protocol.TransferContract.decode(contractBytes);
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the transfer contract in the transaction.');
    }
    if (!transferContract.ownerAddress) {
        throw new errors_1.UtilsError('Owner address does not exist in this transfer contract.');
    }
    if (!transferContract.toAddress) {
        throw new errors_1.UtilsError('Destination address does not exist in this transfer contract.');
    }
    if (!transferContract.hasOwnProperty('amount')) {
        throw new errors_1.UtilsError('Amount does not exist in this transfer contract.');
    }
    // deserialize attributes
    var owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.ownerAddress, 'base64').toString('hex')));
    var to_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.toAddress, 'base64').toString('hex')));
    var amount = transferContract.amount;
    return [
        {
            parameter: {
                value: {
                    amount: Number(amount),
                    owner_address: owner_address,
                    to_address: to_address,
                },
            },
        },
    ];
}
exports.decodeTransferContract = decodeTransferContract;
/**
 * Deserialize the segment of the txHex corresponding with trigger smart contract
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeTriggerSmartContract(base64) {
    var contractCallDecoded;
    try {
        contractCallDecoded = tron_1.protocol.TriggerSmartContract.decode(Buffer.from(base64, 'base64')).toJSON();
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the contract call in the transaction.');
    }
    if (!contractCallDecoded.ownerAddress) {
        throw new errors_1.UtilsError('Owner address does not exist in this contract call.');
    }
    if (!contractCallDecoded.contractAddress) {
        throw new errors_1.UtilsError('Destination contract address does not exist in this contract call.');
    }
    if (!contractCallDecoded.data) {
        throw new errors_1.UtilsError('Data does not exist in this contract call.');
    }
    // deserialize attributes
    var owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(contractCallDecoded.ownerAddress, 'base64').toString('hex')));
    var contract_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(contractCallDecoded.contractAddress, 'base64').toString('hex')));
    var data = contractCallDecoded.data;
    return [
        {
            parameter: {
                value: {
                    data: data,
                    owner_address: owner_address,
                    contract_address: contract_address,
                },
            },
        },
    ];
}
exports.decodeTriggerSmartContract = decodeTriggerSmartContract;
/**
 * Deserialize the segment of the txHex corresponding with the details of the contract which updates
 * account permission
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeAccountPermissionUpdateContract(base64) {
    var accountUpdateContract = tron_1.protocol.AccountPermissionUpdateContract.decode(Buffer.from(base64, 'base64')).toJSON();
    assert_1.default(accountUpdateContract.ownerAddress);
    assert_1.default(accountUpdateContract.owner);
    assert_1.default(accountUpdateContract.hasOwnProperty('actives'));
    var ownerAddress = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(accountUpdateContract.ownerAddress, 'base64').toString('hex')));
    var owner = createPermission(accountUpdateContract.owner);
    var witness = undefined;
    if (accountUpdateContract.witness) {
        witness = createPermission(accountUpdateContract.witness);
    }
    var activeList = accountUpdateContract.actives.map(function (active) { return createPermission(active); });
    return {
        ownerAddress: ownerAddress,
        owner: owner,
        witness: witness,
        actives: activeList,
    };
}
exports.decodeAccountPermissionUpdateContract = decodeAccountPermissionUpdateContract;
/**
 * @param raw
 */
function createPermission(raw) {
    var permissionType;
    var permission = raw.permissionName.toLowerCase().trim();
    if (permission === 'owner') {
        permissionType = enum_1.PermissionType.Owner;
    }
    else if (permission === 'witness') {
        permissionType = enum_1.PermissionType.Witness;
    }
    else if (permission.substr(0, 6) === 'active') {
        permissionType = enum_1.PermissionType.Active;
    }
    else {
        throw new errors_1.UtilsError('Permission type not parseable.');
    }
    return { type: permissionType, threshold: raw.threshold };
}
/**
 * @param rawTransaction
 */
function isValidTxJsonString(rawTransaction) {
    var transaction = JSON.parse(rawTransaction);
    return transaction.hasOwnProperty('txID');
}
exports.isValidTxJsonString = isValidTxJsonString;
/**
 * Returns whether the provided raw transaction accommodates to bitgo's preferred format
 *
 * @param {any} rawTransaction - The raw transaction to be checked
 * @returns {boolean} the validation result
 */
function isValidRawTransactionFormat(rawTransaction) {
    if (typeof rawTransaction === 'string' && (isValidHex(rawTransaction) || isValidTxJsonString(rawTransaction))) {
        return true;
    }
    return false;
}
exports.isValidRawTransactionFormat = isValidRawTransactionFormat;
/**
 * Returns an hex string of the given buffer
 *
 * @param {Buffer | Uint8Array} buffer - the buffer to be converted to hex
 * @returns {string} - the hex value
 */
function toHex(buffer) {
    return hex.encode(buffer, true);
}
exports.toHex = toHex;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi90cngvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUE0QjtBQUM1QixrREFBc0M7QUFDdEMsK0NBQW1DO0FBQ25DLDZEQUFnRTtBQUVoRSw2Q0FBZ0Q7QUFTaEQsK0JBQXNEO0FBUXREOztHQUVHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLE9BQWU7SUFDN0MsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUZELDBDQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQiwwQkFBMEIsQ0FBQyxHQUFXO0lBQ3BELE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRkQsZ0VBRUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLDBCQUEwQixDQUFDLEdBQWM7SUFDdkQsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRkQsZ0VBRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGVBQWUsQ0FDN0IsZUFBdUIsRUFDdkIsYUFBcUIsRUFDckIsTUFBYyxFQUNkLGFBQW9CO0lBQXBCLDhCQUFBLEVBQUEsb0JBQW9CO0lBRXBCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdkIsTUFBTSxJQUFJLG1CQUFVLENBQUMsNkRBQTZELENBQUMsQ0FBQztLQUNyRjtJQUVELElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLG1CQUFVLENBQUMsMkRB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c3NlcnQnO1xuaW1wb3J0ICogYXMgaGV4IGZyb20gJ0BzdGFibGVsaWIvaGV4JztcbmltcG9ydCAqIGFzIHRyb253ZWIgZnJvbSAndHJvbndlYic7XG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlcy90cngvcHJvdG9idWYvdHJvbic7XG5cbmltcG9ydCB7IFV0aWxzRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgVHJhbnNmZXJDb250cmFjdCxcbiAgUmF3RGF0YSxcbiAgQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdCxcbiAgVHJhbnNhY3Rpb25SZWNlaXB0LFxuICBQZXJtaXNzaW9uLFxuICBUcmlnZ2VyU21hcnRDb250cmFjdCxcbn0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBDb250cmFjdFR5cGUsIFBlcm1pc3Npb25UeXBlIH0gZnJvbSAnLi9lbnVtJztcblxuLyoqXG4gKiBUcm9uLXNwZWNpZmljIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgVHJvbkJpbmFyeUxpa2UgPSBCeXRlQXJyYXkgfCBCdWZmZXIgfCBVaW50OEFycmF5IHwgc3RyaW5nO1xuZXhwb3J0IHR5cGUgQnl0ZUFycmF5ID0gbnVtYmVyW107XG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLmlzQWRkcmVzc1ZhbGlkKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBzdHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHN0cjogc3RyaW5nKTogQnl0ZUFycmF5IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY29kZS5oZXhTdHIyYnl0ZUFycmF5KHN0ci5yZXBsYWNlKCcweCcsICcnKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIGFyclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGV4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYXJyOiBCeXRlQXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jb2RlLmJ5dGVBcnJheTJoZXhTdHIoYXJyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbWVzc2FnZVRvVmVyaWZ5XG4gKiBAcGFyYW0gYmFzZTU4QWRkcmVzc1xuICogQHBhcmFtIHNpZ0hleFxuICogQHBhcmFtIHVzZVRyb25IZWFkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShcbiAgbWVzc2FnZVRvVmVyaWZ5OiBzdHJpbmcsXG4gIGJhc2U1OEFkZHJlc3M6IHN0cmluZyxcbiAgc2lnSGV4OiBzdHJpbmcsXG4gIHVzZVRyb25IZWFkZXIgPSB0cnVlLFxuKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZEhleChzaWdIZXgpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ3NpZ25hdHVyZSBpcyBub3QgaW4gYSB2YWxpZCBmb3JtYXQsIG5lZWRzIHRvIGJlIGhleGFkZWNpbWFsJyk7XG4gIH1cblxuICBpZiAoIWlzVmFsaWRIZXgobWVzc2FnZVRvVmVyaWZ5KSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdtZXNzYWdlIGlzIG5vdCBpbiBhIHZhbGlkIGZvcm1hdCwgbmVlZHMgdG8gYmUgaGV4YWRlY2ltYWwnKTtcbiAgfVxuXG4gIGlmICghaXNCYXNlNThBZGRyZXNzKGJhc2U1OEFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ2FkZHJlc3MgbmVlZHMgdG8gYmUgYmFzZTU4IGVuY29kZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0cm9ud2ViLlRyeC52ZXJpZnlTaWduYXR1cmUobWVzc2FnZVRvVmVyaWZ5LCBiYXNlNThBZGRyZXNzLCBzaWdIZXgsIHVzZVRyb25IZWFkZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBiYXNlNThcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhleEFkZHJlc3NGcm9tQmFzZTU4QWRkcmVzcyhiYXNlNTg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHB1bGxlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vVFJPTi1VUy90cm9ud2ViL2Jsb2IvZGNiOGVmYTM2YTVlYmI2NWM0ZGFiMzYyNmU5MDI1NmE0NTNmM2IwZC9zcmMvdXRpbHMvaGVscC5qcyNMMTdcbiAgLy8gYnV0IHRoZXkgZG9uJ3Qgc3VyZmFjZSB0aGlzIGNhbGwgaW4gaW5kZXguanNcbiAgY29uc3QgYnl0ZXMgPSB0cm9ud2ViLnV0aWxzLmNyeXB0by5kZWNvZGVCYXNlNThBZGRyZXNzKGJhc2U1OCk7XG4gIHJldHVybiBnZXRIZXhBZGRyZXNzRnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHByaXZhdGVLZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YktleUZyb21QcmlLZXkocHJpdmF0ZUtleTogVHJvbkJpbmFyeUxpa2UpOiBCeXRlQXJyYXkge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uZ2V0UHViS2V5RnJvbVByaUtleShwcml2YXRlS2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0Zyb21QcmlLZXkocHJpdmF0ZUtleTogVHJvbkJpbmFyeUxpa2UpOiBCeXRlQXJyYXkge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uZ2V0QWRkcmVzc0Zyb21QcmlLZXkocHJpdmF0ZUtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KGFkZHJlc3M6IEJ5dGVBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5nZXRCYXNlNThDaGVja0FkZHJlc3MoYWRkcmVzcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIGhleFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZTU4QWRkcmVzc0Zyb21IZXgoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBhcnIgPSBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhoZXgpO1xuICByZXR1cm4gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYXJyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocHJpdmF0ZUtleTogc3RyaW5nIHwgQnl0ZUFycmF5LCB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0KTogVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLnNpZ25UcmFuc2FjdGlvbihwcml2YXRlS2V5LCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEBwYXJhbSBwcml2YXRlS2V5XG4gKiBAcGFyYW0gdXNlVHJvbkhlYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnblN0cmluZyhtZXNzYWdlOiBzdHJpbmcsIHByaXZhdGVLZXk6IHN0cmluZyB8IEJ5dGVBcnJheSwgdXNlVHJvbkhlYWRlciA9IHRydWUpOiBzdHJpbmcge1xuICByZXR1cm4gdHJvbndlYi5Ucnguc2lnblN0cmluZyhtZXNzYWdlLCBwcml2YXRlS2V5LCB1c2VUcm9uSGVhZGVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHViQnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd0FkZHJlc3NGcm9tUHViS2V5KHB1YkJ5dGVzOiBUcm9uQmluYXJ5TGlrZSk6IEJ5dGVBcnJheSB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5jb21wdXRlQWRkcmVzcyhwdWJCeXRlcyk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHRyYW5zYWN0aW9uIGluIGl0cyBwcm90b2J1ZiByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIHJhd19kYXRhX2hleCBmaWVsZCBmcm9tIHRyb24gdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2FjdGlvbihoZXhTdHJpbmc6IHN0cmluZyk6IFJhd0RhdGEge1xuICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IGRlY29kZVJhd1RyYW5zYWN0aW9uKGhleFN0cmluZyk7XG5cbiAgLy8gdGhlcmUgc2hvdWxkIG5vdCBiZSBtdWx0aXBsZSBjb250cmFjdHMgaW4gdGhpcyBkYXRhXG4gIGlmIChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ051bWJlciBvZiBjb250cmFjdHMgaXMgZ3JlYXRlciB0aGFuIDEuJyk7XG4gIH1cblxuICBsZXQgY29udHJhY3Q6IFRyYW5zZmVyQ29udHJhY3RbXSB8IEFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3RbXSB8IFRyaWdnZXJTbWFydENvbnRyYWN0W107XG4gIGxldCBjb250cmFjdFR5cGU6IENvbnRyYWN0VHlwZTtcbiAgLy8gZW5zdXJlIHRoZSBjb250cmFjdCB0eXBlIGlzIHN1cHBvcnRlZFxuICBzd2l0Y2ggKHJhd1RyYW5zYWN0aW9uLmNvbnRyYWN0c1swXS5wYXJhbWV0ZXIudHlwZV91cmwpIHtcbiAgICBjYXNlICd0eXBlLmdvb2dsZWFwaXMuY29tL3Byb3RvY29sLlRyYW5zZmVyQ29udHJhY3QnOlxuICAgICAgY29udHJhY3RUeXBlID0gQ29udHJhY3RUeXBlLlRyYW5zZmVyO1xuICAgICAgY29udHJhY3QgPSBleHBvcnRzLmRlY29kZVRyYW5zZmVyQ29udHJhY3QocmF3VHJhbnNhY3Rpb24uY29udHJhY3RzWzBdLnBhcmFtZXRlci52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0eXBlLmdvb2dsZWFwaXMuY29tL3Byb3RvY29sLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3QnOlxuICAgICAgY29udHJhY3RUeXBlID0gQ29udHJhY3RUeXBlLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlO1xuICAgICAgY29udHJhY3QgPSBleHBvcnRzLmRlY29kZUFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3QocmF3VHJhbnNhY3Rpb24uY29udHJhY3RzWzBdLnBhcmFtZXRlci52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0eXBlLmdvb2dsZWFwaXMuY29tL3Byb3RvY29sLlRyaWdnZXJTbWFydENvbnRyYWN0JzpcbiAgICAgIGNvbnRyYWN0VHlwZSA9IENvbnRyYWN0VHlwZS5UcmlnZ2VyU21hcnRDb250cmFjdDtcbiAgICAgIGNvbnRyYWN0ID0gZXhwb3J0cy5kZWNvZGVUcmlnZ2VyU21hcnRDb250cmFjdChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHNbMF0ucGFyYW1ldGVyLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVW5zdXBwb3J0ZWQgY29udHJhY3QgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250cmFjdFR5cGUsXG4gICAgY29udHJhY3QsXG4gICAgZXhwaXJhdGlvbjogcmF3VHJhbnNhY3Rpb24uZXhwaXJhdGlvbixcbiAgICB0aW1lc3RhbXA6IHJhd1RyYW5zYWN0aW9uLnRpbWVzdGFtcCxcbiAgICByZWZfYmxvY2tfYnl0ZXM6IHJhd1RyYW5zYWN0aW9uLmJsb2NrQnl0ZXMsXG4gICAgcmVmX2Jsb2NrX2hhc2g6IHJhd1RyYW5zYWN0aW9uLmJsb2NrSGFzaCxcbiAgICBmZWVfbGltaXQ6ICtyYXdUcmFuc2FjdGlvbi5mZWVMaW1pdCxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgdHJhbnNhY3Rpb24ncyByYXcgZmllbGQgZnJvbSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhIHByb3RvYnVmIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgdGhpcyBpcyB0aGUgcmF3IGhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nLiBEb2MgZm91bmQgaW4gdGhlIGZvbGxvd2luZyBsaW5rLlxuICogQGV4YW1wbGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9iaXRnby1hY2NvdW50LWxpYi9ibG9iLzVmMjgyNTg4NzAxNzc4YTQ0MjFjNzVmYTYxZjQyNzEzZjU2ZTk1YjkvcmVzb3VyY2VzL3RyeC9wcm90b2J1Zi90cm9uLnByb3RvI0wzMTl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSYXdUcmFuc2FjdGlvbihoZXhTdHJpbmc6IHN0cmluZyk6IHtcbiAgZXhwaXJhdGlvbjogbnVtYmVyO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgY29udHJhY3RzOiBBcnJheTxhbnk+O1xuICBibG9ja0J5dGVzOiBzdHJpbmc7XG4gIGJsb2NrSGFzaDogc3RyaW5nO1xuICBmZWVMaW1pdDogc3RyaW5nO1xufSB7XG4gIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmZyb20oaGV4U3RyaW5nLCAnaGV4Jyk7XG5cbiAgbGV0IHJhdztcbiAgdHJ5IHtcbiAgICAvLyB3ZSBuZWVkIHRvIGRlY29kZSBvdXIgcmF3X2RhdGFfaGV4IGZpZWxkIGZpcnN0XG4gICAgcmF3ID0gcHJvdG9jb2wuVHJhbnNhY3Rpb24ucmF3LmRlY29kZShieXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGRlY29kaW5nIHRoZSBpbml0aWFsIHJhd19kYXRhX2hleCBmcm9tIHRoZSBzZXJpYWxpemVkIHR4LicpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBpcmF0aW9uOiBOdW1iZXIocmF3LmV4cGlyYXRpb24pLFxuICAgIHRpbWVzdGFtcDogTnVtYmVyKHJhdy50aW1lc3RhbXApLFxuICAgIGNvbnRyYWN0czogcmF3LmNvbnRyYWN0LFxuICAgIGJsb2NrQnl0ZXM6IHRvSGV4KHJhdy5yZWZCbG9ja0J5dGVzKSxcbiAgICBmZWVMaW1pdDogcmF3LmZlZUxpbWl0LFxuICAgIGJsb2NrSGFzaDogdG9IZXgocmF3LnJlZkJsb2NrSGFzaCksXG4gIH07XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBhc3NlZCBzdHJpbmcgaXMgYSBzYWZlIGhleCBzdHJpbmcgZm9yIHRyb24ncyBwdXJwb3Nlcy5cbiAqXG4gKiBAcGFyYW0gaGV4IEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0IGJlIGEgc3RyaW5nIG1hZGUgb2YgbnVtYmVycyBhbmQgY2hhcmFjdGVycyBhbmQgaGFzIGFuIGV2ZW4gbGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleChoZXg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL14oMHgpPyhbMC05YS1mXXsyfSkrJC9pLnRlc3QoaGV4KTtcbn1cblxuLyoqIERlc2VyaWFsaXplIHRoZSBzZWdtZW50IG9mIHRoZSB0eEhleCB3aGljaCBjb3JyZXNwb25kcyB3aXRoIHRoZSBkZXRhaWxzIG9mIHRoZSB0cmFuc2ZlclxuICpcbiAqIEBwYXJhbSB0cmFuc2ZlckhleCBpcyB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIFwicGFyYW1ldGVyXCIgZmllbGQgb2YgY29udHJhY3RMaXN0WzBdXG4gKiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zZmVyQ29udHJhY3QodHJhbnNmZXJIZXg6IHN0cmluZyk6IFRyYW5zZmVyQ29udHJhY3RbXSB7XG4gIGNvbnN0IGNvbnRyYWN0Qnl0ZXMgPSBCdWZmZXIuZnJvbSh0cmFuc2ZlckhleCwgJ2Jhc2U2NCcpO1xuICBsZXQgdHJhbnNmZXJDb250cmFjdDtcblxuICB0cnkge1xuICAgIHRyYW5zZmVyQ29udHJhY3QgPSBwcm90b2NvbC5UcmFuc2ZlckNvbnRyYWN0LmRlY29kZShjb250cmFjdEJ5dGVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZGVjb2RpbmcgdGhlIHRyYW5zZmVyIGNvbnRyYWN0IGluIHRoZSB0cmFuc2FjdGlvbi4nKTtcbiAgfVxuXG4gIGlmICghdHJhbnNmZXJDb250cmFjdC5vd25lckFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignT3duZXIgYWRkcmVzcyBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHRyYW5zZmVyIGNvbnRyYWN0LicpO1xuICB9XG5cbiAgaWYgKCF0cmFuc2ZlckNvbnRyYWN0LnRvQWRkcmVzcykge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdEZXN0aW5hdGlvbiBhZGRyZXNzIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJhbnNmZXIgY29udHJhY3QuJyk7XG4gIH1cblxuICBpZiAoIXRyYW5zZmVyQ29udHJhY3QuaGFzT3duUHJvcGVydHkoJ2Ftb3VudCcpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0Ftb3VudCBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHRyYW5zZmVyIGNvbnRyYWN0LicpO1xuICB9XG5cbiAgLy8gZGVzZXJpYWxpemUgYXR0cmlidXRlc1xuICBjb25zdCBvd25lcl9hZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20odHJhbnNmZXJDb250cmFjdC5vd25lckFkZHJlc3MsICdiYXNlNjQnKS50b1N0cmluZygnaGV4JykpLFxuICApO1xuICBjb25zdCB0b19hZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20odHJhbnNmZXJDb250cmFjdC50b0FkZHJlc3MsICdiYXNlNjQnKS50b1N0cmluZygnaGV4JykpLFxuICApO1xuICBjb25zdCBhbW91bnQgPSB0cmFuc2ZlckNvbnRyYWN0LmFtb3VudDtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGFtb3VudDogTnVtYmVyKGFtb3VudCksXG4gICAgICAgICAgb3duZXJfYWRkcmVzcyxcbiAgICAgICAgICB0b19hZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICBdO1xufVxuXG4vKipcbiAqIERlc2VyaWFsaXplIHRoZSBzZWdtZW50IG9mIHRoZSB0eEhleCBjb3JyZXNwb25kaW5nIHdpdGggdHJpZ2dlciBzbWFydCBjb250cmFjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEByZXR1cm5zIHtBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVHJpZ2dlclNtYXJ0Q29udHJhY3QoYmFzZTY0OiBzdHJpbmcpOiBUcmlnZ2VyU21hcnRDb250cmFjdFtdIHtcbiAgbGV0IGNvbnRyYWN0Q2FsbERlY29kZWQ7XG4gIHRyeSB7XG4gICAgY29udHJhY3RDYWxsRGVjb2RlZCA9IHByb3RvY29sLlRyaWdnZXJTbWFydENvbnRyYWN0LmRlY29kZShCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKSkudG9KU09OKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGRlY29kaW5nIHRoZSBjb250cmFjdCBjYWxsIGluIHRoZSB0cmFuc2FjdGlvbi4nKTtcbiAgfVxuXG4gIGlmICghY29udHJhY3RDYWxsRGVjb2RlZC5vd25lckFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignT3duZXIgYWRkcmVzcyBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGNvbnRyYWN0IGNhbGwuJyk7XG4gIH1cblxuICBpZiAoIWNvbnRyYWN0Q2FsbERlY29kZWQuY29udHJhY3RBZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0Rlc3RpbmF0aW9uIGNvbnRyYWN0IGFkZHJlc3MgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBjb250cmFjdCBjYWxsLicpO1xuICB9XG5cbiAgaWYgKCFjb250cmFjdENhbGxEZWNvZGVkLmRhdGEpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignRGF0YSBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGNvbnRyYWN0IGNhbGwuJyk7XG4gIH1cblxuICAvLyBkZXNlcmlhbGl6ZSBhdHRyaWJ1dGVzXG4gIGNvbnN0IG93bmVyX2FkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShcbiAgICBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhCdWZmZXIuZnJvbShjb250cmFjdENhbGxEZWNvZGVkLm93bmVyQWRkcmVzcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdoZXgnKSksXG4gICk7XG4gIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShcbiAgICBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhCdWZmZXIuZnJvbShjb250cmFjdENhbGxEZWNvZGVkLmNvbnRyYWN0QWRkcmVzcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdoZXgnKSksXG4gICk7XG4gIGNvbnN0IGRhdGEgPSBjb250cmFjdENhbGxEZWNvZGVkLmRhdGE7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBvd25lcl9hZGRyZXNzLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIF07XG59XG5cbi8qKlxuICogRGVzZXJpYWxpemUgdGhlIHNlZ21lbnQgb2YgdGhlIHR4SGV4IGNvcnJlc3BvbmRpbmcgd2l0aCB0aGUgZGV0YWlscyBvZiB0aGUgY29udHJhY3Qgd2hpY2ggdXBkYXRlc1xuICogYWNjb3VudCBwZXJtaXNzaW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFxuICogQHJldHVybnMge0FjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0KGJhc2U2NDogc3RyaW5nKTogQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdCB7XG4gIGNvbnN0IGFjY291bnRVcGRhdGVDb250cmFjdCA9IHByb3RvY29sLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3QuZGVjb2RlKEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpKS50b0pTT04oKTtcbiAgYXNzZXJ0KGFjY291bnRVcGRhdGVDb250cmFjdC5vd25lckFkZHJlc3MpO1xuICBhc3NlcnQoYWNjb3VudFVwZGF0ZUNvbnRyYWN0Lm93bmVyKTtcbiAgYXNzZXJ0KGFjY291bnRVcGRhdGVDb250cmFjdC5oYXNPd25Qcm9wZXJ0eSgnYWN0aXZlcycpKTtcblxuICBjb25zdCBvd25lckFkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShcbiAgICBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhCdWZmZXIuZnJvbShhY2NvdW50VXBkYXRlQ29udHJhY3Qub3duZXJBZGRyZXNzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpKSxcbiAgKTtcbiAgY29uc3Qgb3duZXI6IFBlcm1pc3Npb24gPSBjcmVhdGVQZXJtaXNzaW9uKGFjY291bnRVcGRhdGVDb250cmFjdC5vd25lcik7XG4gIGxldCB3aXRuZXNzOiBQZXJtaXNzaW9uIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBpZiAoYWNjb3VudFVwZGF0ZUNvbnRyYWN0LndpdG5lc3MpIHtcbiAgICB3aXRuZXNzID0gY3JlYXRlUGVybWlzc2lvbihhY2NvdW50VXBkYXRlQ29udHJhY3Qud2l0bmVzcyk7XG4gIH1cbiAgY29uc3QgYWN0aXZlTGlzdCA9IGFjY291bnRVcGRhdGVDb250cmFjdC5hY3RpdmVzLm1hcCgoYWN0aXZlKSA9PiBjcmVhdGVQZXJtaXNzaW9uKGFjdGl2ZSkpO1xuXG4gIHJldHVybiB7XG4gICAgb3duZXJBZGRyZXNzLFxuICAgIG93bmVyLFxuICAgIHdpdG5lc3MsXG4gICAgYWN0aXZlczogYWN0aXZlTGlzdCxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcmF3XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBlcm1pc3Npb24ocmF3OiB7IHBlcm1pc3Npb25OYW1lOiBzdHJpbmc7IHRocmVzaG9sZDogbnVtYmVyIH0pOiBQZXJtaXNzaW9uIHtcbiAgbGV0IHBlcm1pc3Npb25UeXBlOiBQZXJtaXNzaW9uVHlwZTtcbiAgY29uc3QgcGVybWlzc2lvbiA9IHJhdy5wZXJtaXNzaW9uTmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgaWYgKHBlcm1pc3Npb24gPT09ICdvd25lcicpIHtcbiAgICBwZXJtaXNzaW9uVHlwZSA9IFBlcm1pc3Npb25UeXBlLk93bmVyO1xuICB9IGVsc2UgaWYgKHBlcm1pc3Npb24gPT09ICd3aXRuZXNzJykge1xuICAgIHBlcm1pc3Npb25UeXBlID0gUGVybWlzc2lvblR5cGUuV2l0bmVzcztcbiAgfSBlbHNlIGlmIChwZXJtaXNzaW9uLnN1YnN0cigwLCA2KSA9PT0gJ2FjdGl2ZScpIHtcbiAgICBwZXJtaXNzaW9uVHlwZSA9IFBlcm1pc3Npb25UeXBlLkFjdGl2ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignUGVybWlzc2lvbiB0eXBlIG5vdCBwYXJzZWFibGUuJyk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGVybWlzc2lvblR5cGUsIHRocmVzaG9sZDogcmF3LnRocmVzaG9sZCB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSByYXdUcmFuc2FjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFR4SnNvblN0cmluZyhyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gSlNPTi5wYXJzZShyYXdUcmFuc2FjdGlvbik7XG4gIHJldHVybiB0cmFuc2FjdGlvbi5oYXNPd25Qcm9wZXJ0eSgndHhJRCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcmF3IHRyYW5zYWN0aW9uIGFjY29tbW9kYXRlcyB0byBiaXRnbydzIHByZWZlcnJlZCBmb3JtYXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VHJhbnNhY3Rpb24gLSBUaGUgcmF3IHRyYW5zYWN0aW9uIHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRSYXdUcmFuc2FjdGlvbkZvcm1hdChyYXdUcmFuc2FjdGlvbjogYW55KTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnICYmIChpc1ZhbGlkSGV4KHJhd1RyYW5zYWN0aW9uKSB8fCBpc1ZhbGlkVHhKc29uU3RyaW5nKHJhd1RyYW5zYWN0aW9uKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBoZXggc3RyaW5nIG9mIHRoZSBnaXZlbiBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXl9IGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmUgY29udmVydGVkIHRvIGhleFxuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChidWZmZXI6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gaGV4LmVuY29kZShidWZmZXIsIHRydWUpO1xufVxuIl19