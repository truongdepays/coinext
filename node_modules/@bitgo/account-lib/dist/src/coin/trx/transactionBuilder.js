"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var crypto_1 = require("crypto");
var _ = __importStar(require("lodash"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var utils_1 = require("./utils");
var transaction_1 = require("./transaction");
var keyPair_1 = require("./keyPair");
/**
 * Tron transaction builder.
 */
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    /**
     * Public constructor.
     *
     * @param {CoinConfig} _coinConfig Configuration object
     */
    function TransactionBuilder(_coinConfig) {
        return _super.call(this, _coinConfig) || this;
    }
    /**
     * Parse transaction takes in raw JSON directly from the node.
     *
     * @param {TransactionReceipt} rawTransaction The Tron transaction in JSON format as returned by the Tron lib or a stringifyed version of such JSON.
     * @returns {Transaction} Tron transaction
     */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        var tx;
        if (typeof rawTransaction === 'string') {
            var transaction = JSON.parse(rawTransaction);
            tx = new transaction_1.Transaction(this._coinConfig, transaction);
        }
        else {
            tx = new transaction_1.Transaction(this._coinConfig, rawTransaction);
        }
        return tx;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        if (!this.transaction.inputs) {
            throw new errors_1.SigningError('Transaction has no sender');
        }
        if (!this.transaction.outputs) {
            throw new errors_1.SigningError('Transaction has no receiver');
        }
        return this.applySignature(key);
    };
    TransactionBuilder.prototype.applySignature = function (key) {
        var oldTransaction = this.transaction.toJson();
        // Store the original signatures to compare them with the new ones in a later step. Signatures
        // can be undefined if this is the first time the transaction is being signed
        var oldSignatureCount = oldTransaction.signature ? oldTransaction.signature.length : 0;
        var signedTransaction;
        try {
            var keyPair = new keyPair_1.KeyPair({ prv: key.key });
            // Since the key pair was generated using a private key, it will always have a prv attribute,
            // hence it is safe to use non-null operator
            signedTransaction = utils_1.signTransaction(keyPair.getKeys().prv, this.transaction.toJson());
        }
        catch (e) {
            throw new errors_1.SigningError('Failed to sign transaction via helper.');
        }
        // Ensure that we have more signatures than what we started with
        if (!signedTransaction.signature || oldSignatureCount >= signedTransaction.signature.length) {
            throw new errors_1.SigningError('Transaction signing did not return an additional signature.');
        }
        return new transaction_1.Transaction(this._coinConfig, signedTransaction);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // This is a no-op since Tron transactions are built from
                if (!this.transaction.id) {
                    throw new errors_1.BuildTransactionError('A valid transaction must have an id');
                }
                return [2 /*return*/, Promise.resolve(this.transaction)];
            });
        });
    };
    TransactionBuilder.prototype.initBuilder = function (tx) {
        this.transaction = this.fromImplementation(tx);
    };
    /**
     * Extend the validity of this transaction by the given amount of time
     *
     * @param {number} extensionMs The number of milliseconds to extend the validTo time
     * @returns {undefined}
     */
    TransactionBuilder.prototype.extendValidTo = function (extensionMs) {
        this.transaction.extendExpiration(extensionMs);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThanOrEqualTo(0)) {
            throw new Error('Value cannot be below zero.');
        }
        // max long in Java - assumed upper limit for a TRX transaction
        if (value.isGreaterThan(new bignumber_js_1.default('9223372036854775807'))) {
            throw new Error('Value cannot be greater than handled by the javatron node.');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address) {
        // assumes a base 58 address for our addresses
        if (!utils_1.isBase58Address(address.address)) {
            throw new Error(address.address + ' is not a valid base58 address.');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch (err) {
            throw new Error('The provided key is not valid');
        }
    };
    /**
     * Validate the contents of a raw transaction. The validation
     * phase is to compare the raw-data-hex to the raw-data of the
     * transaction.
     *
     * The contents to be validated are
     * 1. The transaction id
     * 2. The expiration date
     * 3. The timestamp
     * 4. The contract
     *
     * @param {TransactionReceipt | string} rawTransaction The raw transaction to be validated
     */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        // TODO: Validation of signature
        if (!rawTransaction) {
            throw new errors_1.InvalidTransactionError('Raw transaction is empty');
        }
        var currTransaction;
        // rawTransaction can be either Stringified JSON OR
        // it can be a regular JSON object (not stringified).
        if (typeof rawTransaction === 'string') {
            try {
                currTransaction = JSON.parse(rawTransaction);
            }
            catch (e) {
                throw new errors_1.ParseTransactionError('There was error in parsing the JSON string');
            }
        }
        else if (_.isObject(rawTransaction)) {
            currTransaction = rawTransaction;
        }
        else {
            throw new errors_1.InvalidTransactionError('Transaction is not an object or stringified json');
        }
        var decodedRawDataHex = utils_1.decodeTransaction(currTransaction.raw_data_hex);
        if (!currTransaction.txID) {
            throw new errors_1.InvalidTransactionError('Transaction ID is empty');
        }
        // Validate the transaction ID from the raw data hex
        var hexBuffer = Buffer.from(currTransaction.raw_data_hex, 'hex');
        var currTxID = crypto_1.createHash('sha256').update(hexBuffer).digest('hex');
        if (currTransaction.txID !== currTxID) {
            throw new errors_1.InvalidTransactionError('Transaction has not have a valid id');
        }
        // Validate the expiration time from the raw-data-hex
        if (currTransaction.raw_data.expiration !== decodedRawDataHex.expiration) {
            throw new errors_1.InvalidTransactionError('Transaction has not have a valid expiration');
        }
        // Validate the timestamp from the raw-data-hex
        if (currTransaction.raw_data.timestamp !== decodedRawDataHex.timestamp) {
            throw new errors_1.InvalidTransactionError('Transaction has not have a valid timetamp');
        }
        // Transaction contract must exist
        if (!currTransaction.raw_data.contract) {
            throw new errors_1.InvalidTransactionError('Transaction contracts are empty');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        var hexBuffer = Buffer.from(transaction.toJson().raw_data_hex, 'hex');
        var txId = crypto_1.createHash('sha256').update(hexBuffer).digest('hex');
        if (transaction.id !== txId) {
            throw new errors_1.InvalidTransactionError(transaction.id + ' is not a valid transaction id. Expecting: ' + txId);
        }
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: false,
        configurable: true
    });
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vdHJ4L3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQW9DO0FBQ3BDLHdDQUE0QjtBQUM1Qiw4REFBcUM7QUFFckMsNkNBSzRCO0FBRTVCLHdDQUFxRDtBQUdyRCxpQ0FBOEU7QUFDOUUsNkNBQTRDO0FBQzVDLHFDQUFvQztBQUVwQzs7R0FFRztBQUNIO0lBQXdDLHNDQUFzQjtJQUc1RDs7OztPQUlHO0lBQ0gsNEJBQVksV0FBaUM7ZUFDM0Msa0JBQU0sV0FBVyxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLCtDQUFrQixHQUE1QixVQUE2QixjQUEyQztRQUN0RSxJQUFJLEVBQUUsQ0FBQztRQUNQLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1lBQ3RDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDL0MsRUFBRSxHQUFHLElBQUkseUJBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1NBQ3JEO2FBQU07WUFDTCxFQUFFLEdBQUcsSUFBSSx5QkFBVyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7U0FDeEQ7UUFDRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxrQkFBa0I7SUFDUiwrQ0FBa0IsR0FBNUIsVUFBNkIsR0FBWTtRQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUU7WUFDNUIsTUFBTSxJQUFJLHFCQUFZLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUNyRDtRQUVELElBQUks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LENBQUMsQ0FBQztTQUMxRztJQUNILENBQUM7SUFHRCxzQkFBYywyQ0FBVztRQUR6QixrQkFBa0I7YUFDbEI7WUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQztRQUVELGtCQUFrQjthQUNsQixVQUEwQixXQUF3QjtZQUNoRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNsQyxDQUFDOzs7T0FMQTtJQU1ILHlCQUFDO0FBQUQsQ0FBQyxBQTlMRCxDQUF3QyxpQ0FBc0IsR0E4TDdEO0FBOUxZLGdEQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7XG4gIFNpZ25pbmdFcnJvcixcbiAgQnVpbGRUcmFuc2FjdGlvbkVycm9yLFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxufSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICcuL2FkZHJlc3MnO1xuaW1wb3J0IHsgc2lnblRyYW5zYWN0aW9uLCBpc0Jhc2U1OEFkZHJlc3MsIGRlY29kZVRyYW5zYWN0aW9uIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5cbi8qKlxuICogVHJvbiB0cmFuc2FjdGlvbiBidWlsZGVyLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25CdWlsZGVyIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIC8vIHRyYW5zYWN0aW9uIGJlaW5nIGJ1aWx0XG4gIHByaXZhdGUgX3RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtDb2luQ29uZmlnfSBfY29pbkNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRyYW5zYWN0aW9uIHRha2VzIGluIHJhdyBKU09OIGRpcmVjdGx5IGZyb20gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZWNlaXB0fSByYXdUcmFuc2FjdGlvbiBUaGUgVHJvbiB0cmFuc2FjdGlvbiBpbiBKU09OIGZvcm1hdCBhcyByZXR1cm5lZCBieSB0aGUgVHJvbiBsaWIgb3IgYSBzdHJpbmdpZnllZCB2ZXJzaW9uIG9mIHN1Y2ggSlNPTi5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcm9uIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcm90ZWN0ZWQgZnJvbUltcGxlbWVudGF0aW9uKHJhd1RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmcpOiBUcmFuc2FjdGlvbiB7XG4gICAgbGV0IHR4O1xuICAgIGlmICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IEpTT04ucGFyc2UocmF3VHJhbnNhY3Rpb24pO1xuICAgICAgdHggPSBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZywgdHJhbnNhY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnLCByYXdUcmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2lnbkltcGxlbWVudGF0aW9uKGtleTogQmFzZUtleSk6IFRyYW5zYWN0aW9uIHtcbiAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb24uaW5wdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm8gc2VuZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLm91dHB1dHMpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBubyByZWNlaXZlcicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hcHBseVNpZ25hdHVyZShrZXkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFwcGx5U2lnbmF0dXJlKGtleTogQmFzZUtleSk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCBvbGRUcmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24udG9Kc29uKCk7XG4gICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHNpZ25hdHVyZXMgdG8gY29tcGFyZSB0aGVtIHdpdGggdGhlIG5ldyBvbmVzIGluIGEgbGF0ZXIgc3RlcC4gU2lnbmF0dXJlc1xuICAgIC8vIGNhbiBiZSB1bmRlZmluZWQgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgdHJhbnNhY3Rpb24gaXMgYmVpbmcgc2lnbmVkXG4gICAgY29uc3Qgb2xkU2lnbmF0dXJlQ291bnQgPSBvbGRUcmFuc2FjdGlvbi5zaWduYXR1cmUgPyBvbGRUcmFuc2FjdGlvbi5zaWduYXR1cmUubGVuZ3RoIDogMDtcbiAgICBsZXQgc2lnbmVkVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjZWlwdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5UGFpciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgICAgLy8gU2luY2UgdGhlIGtleSBwYWlyIHdhcyBnZW5lcmF0ZWQgdXNpbmcgYSBwcml2YXRlIGtleSwgaXQgd2lsbCBhbHdheXMgaGF2ZSBhIHBydiBhdHRyaWJ1dGUsXG4gICAgICAvLyBoZW5jZSBpdCBpcyBzYWZlIHRvIHVzZSBub24tbnVsbCBvcGVyYXRvclxuICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSBzaWduVHJhbnNhY3Rpb24oa2V5UGFpci5nZXRLZXlzKCkucHJ2ISwgdGhpcy50cmFuc2FjdGlvbi50b0pzb24oKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb24gdmlhIGhlbHBlci4nKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIG1vcmUgc2lnbmF0dXJlcyB0aGFuIHdoYXQgd2Ugc3RhcnRlZCB3aXRoXG4gICAgaWYgKCFzaWduZWRUcmFuc2FjdGlvbi5zaWduYXR1cmUgfHwgb2xkU2lnbmF0dXJlQ291bnQgPj0gc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignVHJhbnNhY3Rpb24gc2lnbmluZyBkaWQgbm90IHJldHVybiBhbiBhZGRpdGlvbmFsIHNpZ25hdHVyZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcsIHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgLy8gVGhpcyBpcyBhIG5vLW9wIHNpbmNlIFRyb24gdHJhbnNhY3Rpb25zIGFyZSBidWlsdCBmcm9tXG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdBIHZhbGlkIHRyYW5zYWN0aW9uIG11c3QgaGF2ZSBhbiBpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uUmVjZWlwdCB8IHN0cmluZykge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0aGlzLmZyb21JbXBsZW1lbnRhdGlvbih0eCk7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHRoZSB2YWxpZGl0eSBvZiB0aGlzIHRyYW5zYWN0aW9uIGJ5IHRoZSBnaXZlbiBhbW91bnQgb2YgdGltZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZXh0ZW5zaW9uTXMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZXh0ZW5kIHRoZSB2YWxpZFRvIHRpbWVcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGV4dGVuZFZhbGlkVG8oZXh0ZW5zaW9uTXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMudHJhbnNhY3Rpb24uZXh0ZW5kRXhwaXJhdGlvbihleHRlbnNpb25Ncyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVWYWx1ZSh2YWx1ZTogQmlnTnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHZhbHVlLmlzTGVzc1RoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgY2Fubm90IGJlIGJlbG93IHplcm8uJyk7XG4gICAgfVxuXG4gICAgLy8gbWF4IGxvbmcgaW4gSmF2YSAtIGFzc3VtZWQgdXBwZXIgbGltaXQgZm9yIGEgVFJYIHRyYW5zYWN0aW9uXG4gICAgaWYgKHZhbHVlLmlzR3JlYXRlclRoYW4obmV3IEJpZ051bWJlcignOTIyMzM3MjAzNjg1NDc3NTgwNycpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIGhhbmRsZWQgYnkgdGhlIGphdmF0cm9uIG5vZGUuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBBZGRyZXNzKTogdm9pZCB7XG4gICAgLy8gYXNzdW1lcyBhIGJhc2UgNTggYWRkcmVzcyBmb3Igb3VyIGFkZHJlc3Nlc1xuICAgIGlmICghaXNCYXNlNThBZGRyZXNzKGFkZHJlc3MuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhZGRyZXNzLmFkZHJlc3MgKyAnIGlzIG5vdCBhIHZhbGlkIGJhc2U1OCBhZGRyZXNzLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUtleShrZXk6IEJhc2VLZXkpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEtleVBhaXIoeyBwcnY6IGtleS5rZXkgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgbm90IHZhbGlkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBjb250ZW50cyBvZiBhIHJhdyB0cmFuc2FjdGlvbi4gVGhlIHZhbGlkYXRpb25cbiAgICogcGhhc2UgaXMgdG8gY29tcGFyZSB0aGUgcmF3LWRhdGEtaGV4IHRvIHRoZSByYXctZGF0YSBvZiB0aGVcbiAgICogdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFRoZSBjb250ZW50cyB0byBiZSB2YWxpZGF0ZWQgYXJlXG4gICAqIDEuIFRoZSB0cmFuc2FjdGlvbiBpZFxuICAgKiAyLiBUaGUgZXhwaXJhdGlvbiBkYXRlXG4gICAqIDMuIFRoZSB0aW1lc3RhbXBcbiAgICogNC4gVGhlIGNvbnRyYWN0XG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZWNlaXB0IHwgc3RyaW5nfSByYXdUcmFuc2FjdGlvbiBUaGUgcmF3IHRyYW5zYWN0aW9uIHRvIGJlIHZhbGlkYXRlZFxuICAgKi9cbiAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0IHwgc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gVE9ETzogVmFsaWRhdGlvbiBvZiBzaWduYXR1cmVcbiAgICBpZiAoIXJhd1RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1JhdyB0cmFuc2FjdGlvbiBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBsZXQgY3VyclRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQ7XG4gICAgLy8gcmF3VHJhbnNhY3Rpb24gY2FuIGJlIGVpdGhlciBTdHJpbmdpZmllZCBKU09OIE9SXG4gICAgLy8gaXQgY2FuIGJlIGEgcmVndWxhciBKU09OIG9iamVjdCAobm90IHN0cmluZ2lmaWVkKS5cbiAgICBpZiAodHlwZW9mIHJhd1RyYW5zYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY3VyclRyYW5zYWN0aW9uID0gSlNPTi5wYXJzZShyYXdUcmFuc2FjdGlvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1RoZXJlIHdhcyBlcnJvciBpbiBwYXJzaW5nIHRoZSBKU09OIHN0cmluZycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyYXdUcmFuc2FjdGlvbikpIHtcbiAgICAgIGN1cnJUcmFuc2FjdGlvbiA9IHJhd1RyYW5zYWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGlzIG5vdCBhbiBvYmplY3Qgb3Igc3RyaW5naWZpZWQganNvbicpO1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkUmF3RGF0YUhleCA9IGRlY29kZVRyYW5zYWN0aW9uKGN1cnJUcmFuc2FjdGlvbi5yYXdfZGF0YV9oZXgpO1xuICAgIGlmICghY3VyclRyYW5zYWN0aW9uLnR4SUQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gSUQgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhlIHRyYW5zYWN0aW9uIElEIGZyb20gdGhlIHJhdyBkYXRhIGhleFxuICAgIGNvbnN0IGhleEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGN1cnJUcmFuc2FjdGlvbi5yYXdfZGF0YV9oZXgsICdoZXgnKTtcbiAgICBjb25zdCBjdXJyVHhJRCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShoZXhCdWZmZXIpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgaWYgKGN1cnJUcmFuc2FjdGlvbi50eElEICE9PSBjdXJyVHhJRCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGhhdmUgYSB2YWxpZCBpZCcpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgZXhwaXJhdGlvbiB0aW1lIGZyb20gdGhlIHJhdy1kYXRhLWhleFxuICAgIGlmIChjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGEuZXhwaXJhdGlvbiAhPT0gZGVjb2RlZFJhd0RhdGFIZXguZXhwaXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGhhdmUgYSB2YWxpZCBleHBpcmF0aW9uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoZSB0aW1lc3RhbXAgZnJvbSB0aGUgcmF3LWRhdGEtaGV4XG4gICAgaWYgKGN1cnJUcmFuc2FjdGlvbi5yYXdfZGF0YS50aW1lc3RhbXAgIT09IGRlY29kZWRSYXdEYXRhSGV4LnRpbWVzdGFtcCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGhhdmUgYSB2YWxpZCB0aW1ldGFtcCcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBjb250cmFjdCBtdXN0IGV4aXN0XG4gICAgaWYgKCFjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGEuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gY29udHJhY3RzIGFyZSBlbXB0eScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IGhleEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnRvSnNvbigpLnJhd19kYXRhX2hleCwgJ2hleCcpO1xuICAgIGNvbnN0IHR4SWQgPSBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaGV4QnVmZmVyKS5kaWdlc3QoJ2hleCcpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5pZCAhPT0gdHhJZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKHRyYW5zYWN0aW9uLmlkICsgJyBpcyBub3QgYSB2YWxpZCB0cmFuc2FjdGlvbiBpZC4gRXhwZWN0aW5nOiAnICsgdHhJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2V0IHRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cbn1cbiJdfQ==