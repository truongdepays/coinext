"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrappedBuilder = void 0;
var errors_1 = require("../baseCoin/errors");
var transactionBuilder_1 = require("./transactionBuilder");
var keyPair_1 = require("./keyPair");
var utils_1 = require("./utils");
var enum_1 = require("./enum");
var contractCallBuilder_1 = require("./contractCallBuilder");
/**
 * Wrapped Builder class
 * This builder is created to maintain compatibility with the current uses of account-lib
 * It has an instance of Transaction Builder or Contract Call Builder as required.
 */
var WrappedBuilder = /** @class */ (function (_super) {
    __extends(WrappedBuilder, _super);
    function WrappedBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        // defaults to old builder
        _this._builder = new transactionBuilder_1.TransactionBuilder(_coinConfig);
        return _this;
    }
    /**
     * Returns a specific builder to create a contract call transaction
     *
     * @param {Transaction} [tx] The transaction to initialize builder
     * @returns {ContractCallBuilder} The specific contract call builder
     */
    WrappedBuilder.prototype.getContractCallBuilder = function (tx) {
        return this.initializeBuilder(tx, new contractCallBuilder_1.ContractCallBuilder(this._coinConfig));
    };
    WrappedBuilder.prototype.getTransactionBuilder = function (tx) {
        return this.initializeBuilder(tx, new transactionBuilder_1.TransactionBuilder(this._coinConfig));
    };
    WrappedBuilder.prototype.initializeBuilder = function (tx, builder) {
        if (tx) {
            builder.initBuilder(tx);
        }
        return builder;
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.extendValidTo = function (extensionMs) {
        this._builder.extendValidTo(extensionMs);
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.sign = function (key) {
        this._builder.sign(key);
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.build = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._builder.build()];
            });
        });
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.from = function (raw) {
        this.validateRawTransaction(raw);
        var rawDataHex = this.getTxReceipt(raw);
        var decodedTx = utils_1.decodeTransaction(rawDataHex);
        var contractType = decodedTx.contractType;
        switch (contractType) {
            case enum_1.ContractType.Transfer:
            case enum_1.ContractType.AccountPermissionUpdate:
                this._builder = this.getTransactionBuilder(raw);
                return this._builder;
            case enum_1.ContractType.TriggerSmartContract:
                return this.getContractCallBuilder(raw);
            default:
                throw new errors_1.InvalidTransactionError('Invalid transaction type: ' + contractType);
        }
    };
    /**
     * Get the raw data hex from a raw transaction
     *
     * @param {string | { [key: string]: any }} raw the raw transaction as a string or as an object
     * @returns {string} the raw data hex
     */
    WrappedBuilder.prototype.getTxReceipt = function (raw) {
        return raw['raw_data_hex'] || this.getTxReceipt(JSON.parse(raw));
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.validateAddress = function (address) {
        this._builder.validateAddress(address);
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.validateKey = function (key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch (err) {
            throw new Error('The provided key is not valid');
        }
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        this._builder.validateRawTransaction(rawTransaction);
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.validateTransaction = function (transaction) {
        this._builder.validateTransaction(transaction);
    };
    /** @inheritdoc */
    WrappedBuilder.prototype.validateValue = function (value) {
        this._builder.validateValue(value);
    };
    return WrappedBuilder;
}(transactionBuilder_1.TransactionBuilder));
exports.WrappedBuilder = WrappedBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JhcHBlZEJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi90cngvd3JhcHBlZEJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsNkNBQTZEO0FBRzdELDJEQUEwRDtBQUMxRCxxQ0FBb0M7QUFDcEMsaUNBQTRDO0FBQzVDLCtCQUFzQztBQUN0Qyw2REFBNEQ7QUFHNUQ7Ozs7R0FJRztBQUNIO0lBQW9DLGtDQUFrQjtJQUdwRCx3QkFBWSxXQUFpQztRQUE3QyxZQUNFLGtCQUFNLFdBQVcsQ0FBQyxTQUduQjtRQUZDLDBCQUEwQjtRQUMxQixLQUFJLENBQUMsUUFBUSxHQUFHLElBQUksdUNBQWtCLENBQUMsV0FBVyxDQUFDLENBQUM7O0lBQ3RELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILCtDQUFzQixHQUF0QixVQUF1QixFQUFnQztRQUNyRCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSx5Q0FBbUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRUQsOENBQXFCLEdBQXJCLFVBQXNCLEVBQWdDO1FBQ3BELE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLHVDQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFFTywwQ0FBaUIsR0FBekIsVUFBd0QsRUFBMkMsRUFBRSxPQUFVO1FBQzdHLElBQUksRUFBRSxFQUFFO1lBQ04sT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUN6QjtRQUNELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsc0NBQWEsR0FBYixVQUFjLFdBQW1CO1FBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsNkJBQUksR0FBSixVQUFLLEdBQVk7UUFDZixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQsa0JBQWtCO0lBQ1osOEJBQUssR0FBWDs7O2dCQUNFLHNCQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUM7OztLQUM5QjtJQUVELGtCQUFrQjtJQUNsQiw2QkFBSSxHQUFKLFVBQUssR0FBUTtRQUNYLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqQyxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLElBQU0sU0FBUyxHQUFHLHlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2hELElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUM7UUFDNUMsUUFBUSxZQUFZLEVBQUU7WUFDcEIsS0FBSyxtQkFBWSxDQUFDLFFBQVEsQ0FBQztZQUMzQixLQUFLLG1CQUFZLENBQUMsdUJBQXVCO2dCQUN2QyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDaEQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3ZCLEtBQUssbUJBQVksQ0FBQyxvQkFBb0I7Z0JBQ3BDLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFDO2dCQUNFLE1BQU0sSUFBSSxnQ0FBdUIsQ0FBQyw0QkFBNEIsR0FBRyxZQUFZLENBQUMsQ0FBQztTQUNsRjtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLHFDQUFZLEdBQXBCLFVBQXFCLEdBQW9DO1FBQ3ZELE9BQU8sR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFhLENBQUMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsd0NBQWUsR0FBZixVQUFnQixPQUFnQjtRQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLG9DQUFXLEdBQVgsVUFBWSxHQUFZO1FBQ3RCLElBQUk7WUFDRixJQUFJLGlCQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7U0FDL0I7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztTQUNsRDtJQUNILENBQUM7SUFDRCxrQkFBa0I7SUFDbEIsK0NBQXNCLEdBQXRCLFVBQXVCLGNBQW1CO1FBQ3hDLElBQUksQ0FBQyxRQUFRLENBQUMsc0JBQXNCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELGtCQUFrQjtJQUNsQiw0Q0FBbUIsR0FBbkIsVUFBb0IsV0FBd0I7UUFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLHNDQUFhLEdBQWIsVUFBYyxLQUFnQjtRQUM1QixJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQUFDLEFBcEdELENBQW9DLHVDQUFrQixHQW9HckQ7QUFwR1ksd0NBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEludmFsaWRUcmFuc2FjdGlvbkVycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnLi9hZGRyZXNzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHsgZGVjb2RlVHJhbnNhY3Rpb24gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IENvbnRyYWN0VHlwZSB9IGZyb20gJy4vZW51bSc7XG5pbXBvcnQgeyBDb250cmFjdENhbGxCdWlsZGVyIH0gZnJvbSAnLi9jb250cmFjdENhbGxCdWlsZGVyJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uUmVjZWlwdCB9IGZyb20gJy4vaWZhY2UnO1xuXG4vKipcbiAqIFdyYXBwZWQgQnVpbGRlciBjbGFzc1xuICogVGhpcyBidWlsZGVyIGlzIGNyZWF0ZWQgdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBjdXJyZW50IHVzZXMgb2YgYWNjb3VudC1saWJcbiAqIEl0IGhhcyBhbiBpbnN0YW5jZSBvZiBUcmFuc2FjdGlvbiBCdWlsZGVyIG9yIENvbnRyYWN0IENhbGwgQnVpbGRlciBhcyByZXF1aXJlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdyYXBwZWRCdWlsZGVyIGV4dGVuZHMgVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfYnVpbGRlcjogVHJhbnNhY3Rpb25CdWlsZGVyO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICAvLyBkZWZhdWx0cyB0byBvbGQgYnVpbGRlclxuICAgIHRoaXMuX2J1aWxkZXIgPSBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWMgYnVpbGRlciB0byBjcmVhdGUgYSBjb250cmFjdCBjYWxsIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IFt0eF0gVGhlIHRyYW5zYWN0aW9uIHRvIGluaXRpYWxpemUgYnVpbGRlclxuICAgKiBAcmV0dXJucyB7Q29udHJhY3RDYWxsQnVpbGRlcn0gVGhlIHNwZWNpZmljIGNvbnRyYWN0IGNhbGwgYnVpbGRlclxuICAgKi9cbiAgZ2V0Q29udHJhY3RDYWxsQnVpbGRlcih0eD86IFRyYW5zYWN0aW9uUmVjZWlwdCB8IHN0cmluZyk6IENvbnRyYWN0Q2FsbEJ1aWxkZXIge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVCdWlsZGVyKHR4LCBuZXcgQ29udHJhY3RDYWxsQnVpbGRlcih0aGlzLl9jb2luQ29uZmlnKSk7XG4gIH1cblxuICBnZXRUcmFuc2FjdGlvbkJ1aWxkZXIodHg/OiBUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmcpOiBUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVCdWlsZGVyKHR4LCBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyKHRoaXMuX2NvaW5Db25maWcpKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUJ1aWxkZXI8VCBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlcj4odHg6IFRyYW5zYWN0aW9uUmVjZWlwdCB8IHN0cmluZyB8IHVuZGVmaW5lZCwgYnVpbGRlcjogVCk6IFQge1xuICAgIGlmICh0eCkge1xuICAgICAgYnVpbGRlci5pbml0QnVpbGRlcih0eCk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZGVyO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGV4dGVuZFZhbGlkVG8oZXh0ZW5zaW9uTXM6IG51bWJlcikge1xuICAgIHRoaXMuX2J1aWxkZXIuZXh0ZW5kVmFsaWRUbyhleHRlbnNpb25Ncyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc2lnbihrZXk6IEJhc2VLZXkpIHtcbiAgICB0aGlzLl9idWlsZGVyLnNpZ24oa2V5KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBhc3luYyBidWlsZCgpOiBQcm9taXNlPEJhc2VUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLl9idWlsZGVyLmJ1aWxkKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZnJvbShyYXc6IGFueSkge1xuICAgIHRoaXMudmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXcpO1xuICAgIGNvbnN0IHJhd0RhdGFIZXggPSB0aGlzLmdldFR4UmVjZWlwdChyYXcpO1xuICAgIGNvbnN0IGRlY29kZWRUeCA9IGRlY29kZVRyYW5zYWN0aW9uKHJhd0RhdGFIZXgpO1xuICAgIGNvbnN0IGNvbnRyYWN0VHlwZSA9IGRlY29kZWRUeC5jb250cmFjdFR5cGU7XG4gICAgc3dpdGNoIChjb250cmFjdFR5cGUpIHtcbiAgICAgIGNhc2UgQ29udHJhY3RUeXBlLlRyYW5zZmVyOlxuICAgICAgY2FzZSBDb250cmFjdFR5cGUuQWNjb3VudFBlcm1pc3Npb25VcGRhdGU6XG4gICAgICAgIHRoaXMuX2J1aWxkZXIgPSB0aGlzLmdldFRyYW5zYWN0aW9uQnVpbGRlcihyYXcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRlcjtcbiAgICAgIGNhc2UgQ29udHJhY3RUeXBlLlRyaWdnZXJTbWFydENvbnRyYWN0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250cmFjdENhbGxCdWlsZGVyKHJhdyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gdHlwZTogJyArIGNvbnRyYWN0VHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmF3IGRhdGEgaGV4IGZyb20gYSByYXcgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB7IFtrZXk6IHN0cmluZ106IGFueSB9fSByYXcgdGhlIHJhdyB0cmFuc2FjdGlvbiBhcyBhIHN0cmluZyBvciBhcyBhbiBvYmplY3RcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHJhdyBkYXRhIGhleFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRUeFJlY2VpcHQocmF3OiBzdHJpbmcgfCB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmF3WydyYXdfZGF0YV9oZXgnXSB8fCB0aGlzLmdldFR4UmVjZWlwdChKU09OLnBhcnNlKHJhdyBhcyBzdHJpbmcpKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQWRkcmVzcyk6IHZvaWQge1xuICAgIHRoaXMuX2J1aWxkZXIudmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlS2V5KGtleTogQmFzZUtleSk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBuZXcgS2V5UGFpcih7IHBydjoga2V5LmtleSB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBub3QgdmFsaWQnKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX2J1aWxkZXIudmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLl9idWlsZGVyLnZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVmFsdWUodmFsdWU6IEJpZ051bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2J1aWxkZXIudmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cbiJdfQ==