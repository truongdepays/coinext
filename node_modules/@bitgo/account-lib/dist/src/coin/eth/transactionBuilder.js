"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var Crypto = __importStar(require("../../utils/crypto"));
var baseCoin_1 = require("../baseCoin");
var eth_1 = require("../eth");
var errors_1 = require("../baseCoin/errors");
var keyPair_1 = require("./keyPair");
var iface_1 = require("./iface");
var utils_1 = require("./utils");
var walletUtil_1 = require("./walletUtil");
var ethUtil = __importStar(require("ethereumjs-util"));
var tx_1 = require("@ethereumjs/tx");
var transferBuilderERC1155_1 = require("./transferBuilder/transferBuilderERC1155");
var transferBuilderERC721_1 = require("./transferBuilder/transferBuilderERC721");
var DEFAULT_M = 3;
/**
 * Ethereum transaction builder.
 */
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    /**
     * Public constructor.
     *
     * @param _coinConfig
     */
    function TransactionBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._common = utils_1.getCommon(_this._coinConfig.network);
        _this._type = baseCoin_1.TransactionType.Send;
        _this._counter = 0;
        _this._value = '0';
        _this._walletOwnerAddresses = [];
        _this.transaction = new eth_1.Transaction(_this._coinConfig, _this._common);
        return _this;
    }
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            var transactionData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        transactionData = this.getTransactionData();
                        if (this._txSignature) {
                            Object.assign(transactionData, this._txSignature);
                        }
                        this.transaction.setTransactionType(this._type);
                        transactionData.from = this._sourceKeyPair ? this._sourceKeyPair.getAddress() : undefined;
                        this.transaction.setTransactionData(transactionData);
                        if (!(this._sourceKeyPair && this._sourceKeyPair.getKeys().prv)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.transaction.sign(this._sourceKeyPair)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, this.transaction];
                }
            });
        });
    };
    TransactionBuilder.prototype.getTransactionData = function () {
        switch (this._type) {
            case baseCoin_1.TransactionType.WalletInitialization:
                return this.buildWalletInitializationTransaction();
            case baseCoin_1.TransactionType.Send:
            case baseCoin_1.TransactionType.SendERC721:
            case baseCoin_1.TransactionType.SendERC1155:
                return this.buildSendTransaction();
            case baseCoin_1.TransactionType.AddressInitialization:
                return this.buildAddressInitializationTransaction();
            case baseCoin_1.TransactionType.FlushTokens:
                return this.buildFlushTokensTransaction();
            case baseCoin_1.TransactionType.FlushCoins:
                return this.buildFlushCoinsTransaction();
            case baseCoin_1.TransactionType.SingleSigSend:
                return this.buildBase('0x');
            case baseCoin_1.TransactionType.ContractCall:
                return this.buildGenericContractCallTransaction();
            default:
                throw new errors_1.BuildTransactionError('Unsupported transaction type');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        var tx;
        if (/^0x?[0-9a-f]{1,}$/.test(rawTransaction.toLowerCase())) {
            tx = eth_1.Transaction.fromSerialized(this._coinConfig, this._common, rawTransaction);
            this.loadBuilderInput(tx.toJson());
        }
        else {
            var txData = JSON.parse(rawTransaction);
            tx = new eth_1.Transaction(this._coinConfig, txData);
        }
        return tx;
    };
    /**
     * Load the builder data using the deserialized transaction
     *
     * @param {TxData} transactionJson the deserialized transaction json
     */
    TransactionBuilder.prototype.loadBuilderInput = function (transactionJson) {
        var decodedType = eth_1.Utils.classifyTransaction(transactionJson.data);
        this.type(decodedType);
        this.counter(transactionJson.nonce);
        this.value(transactionJson.value);
        if (transactionJson._type === iface_1.ETHTransactionType.LEGACY) {
            this.fee({
                fee: transactionJson.gasPrice,
                gasPrice: transactionJson.gasPrice,
                gasLimit: transactionJson.gasLimit,
            });
        }
        else {
            this.fee({
                gasLimit: transactionJson.gasLimit,
                fee: transactionJson.maxFeePerGas,
                eip1559: {
                    maxFeePerGas: transactionJson.maxFeePerGas,
                    maxPriorityFeePerGas: transactionJson.maxPriorityFeePerGas,
                },
            });
        }
        if (utils_1.hasSignature(transactionJson)) {
            this._txSignature = { v: transactionJson.v, r: transactionJson.r, s: transactionJson.s };
        }
        this.setTransactionTypeFields(decodedType, transactionJson);
    };
    TransactionBuilder.prototype.setTransactionTypeFields = function (decodedType, transactionJson) {
        var _this = this;
        switch (decodedType) {
            case baseCoin_1.TransactionType.WalletInitialization:
                var owners = eth_1.Utils.decodeWalletCreationData(transactionJson.data);
                owners.forEach(function (element) {
                    _this.owner(element);
                });
                break;
            case baseCoin_1.TransactionType.FlushTokens:
                this.setContract(transactionJson.to);
                var _a = eth_1.Utils.decodeFlushTokensData(transactionJson.data), forwarderAddress = _a.forwarderAddress, tokenAddress = _a.tokenAddress;
                this.forwarderAddress(forwarderAddress);
                this.tokenAddress(tokenAddress);
                break;
            case baseCoin_1.TransactionType.FlushCoins:
                this.setContract(transactionJson.to);
                break;
            case baseCoin_1.TransactionType.Send:
            case baseCoin_1.TransactionType.SendERC1155:
            case baseCoin_1.TransactionType.SendERC721:
                this.setContract(transactionJson.to);
                this._transfer = this.transfer(transactionJson.data);
                break;
            case baseCoin_1.TransactionType.AddressInitialization:
                this.setContract(transactionJson.to);
                break;
            case baseCoin_1.TransactionType.SingleSigSend:
                this.setContract(transactionJson.to);
                break;
            case baseCoin_1.TransactionType.ContractCall:
                this.setContract(transactionJson.to);
                this.data(transactionJson.data);
                break;
            default:
                throw new errors_1.BuildTransactionError('Unsupported transaction type');
            // TODO: Add other cases of deserialization
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        var signer = new keyPair_1.KeyPair({ prv: key.key });
        if (this._type === baseCoin_1.TransactionType.WalletInitialization && this._walletOwnerAddresses.length === 0) {
            throw new errors_1.SigningError('Cannot sign an wallet initialization transaction without owners');
        }
        if (this._sourceKeyPair) {
            throw new errors_1.SigningError('Cannot sign multiple times a non send-type transaction');
        }
        // Signing the transaction is an async operation, so save the source and leave the actual
        // signing for the build step
        this._sourceKeyPair = signer;
        return this.transaction;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address) {
        if (!utils_1.isValidEthAddress(address.address)) {
            throw new errors_1.BuildTransactionError('Invalid address ' + address.address);
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        if (!(Crypto.isValidXprv(key.key) || Crypto.isValidPrv(key.key))) {
            throw new errors_1.BuildTransactionError('Invalid key');
        }
    };
    /**
     * Validate the raw transaction is either a JSON or
     * a hex encoded transaction
     *
     * @param {any} rawTransaction The raw transaction to be validated
     */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        if (!rawTransaction) {
            throw new errors_1.InvalidTransactionError('Raw transaction is empty');
        }
        if (typeof rawTransaction === 'string') {
            if (/^0x?[0-9a-f]{1,}$/.test(rawTransaction.toLowerCase())) {
                var txBytes = ethUtil.toBuffer(ethUtil.addHexPrefix(rawTransaction.toLowerCase()));
                if (!this.isEip1559Txn(txBytes) && !this.isRLPDecodable(txBytes)) {
                    throw new errors_1.ParseTransactionError('There was error in decoding the hex string');
                }
            }
            else {
                try {
                    JSON.parse(rawTransaction);
                }
                catch (e) {
                    throw new errors_1.ParseTransactionError('There was error in parsing the JSON string');
                }
            }
        }
        else {
            throw new errors_1.InvalidTransactionError('Transaction is not a hex string or stringified json');
        }
    };
    TransactionBuilder.prototype.isEip1559Txn = function (txn) {
        try {
            tx_1.FeeMarketEIP1559Transaction.fromSerializedTx(txn);
            return true;
        }
        catch (_) {
            return false;
        }
    };
    TransactionBuilder.prototype.isRLPDecodable = function (bytes) {
        try {
            ethUtil.rlp.decode(bytes);
            return true;
        }
        catch (_) {
            return false;
        }
    };
    TransactionBuilder.prototype.validateBaseTransactionFields = function () {
        if (this._fee === undefined || (!this._fee.fee && !this._fee.gasPrice && !this._fee.eip1559)) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing fee');
        }
        if (this._common === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: network common');
        }
        if (this._counter === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing address counter');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        this.validateBaseTransactionFields();
        switch (this._type) {
            case baseCoin_1.TransactionType.WalletInitialization:
                this.validateWalletInitializationFields();
                break;
            case baseCoin_1.TransactionType.Send:
            case baseCoin_1.TransactionType.SendERC721:
            case baseCoin_1.TransactionType.SendERC1155:
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.AddressInitialization:
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.FlushCoins:
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.FlushTokens:
                this.validateContractAddress();
                this.validateForwarderAddress();
                this.validateTokenAddress();
                break;
            case baseCoin_1.TransactionType.SingleSigSend:
                // for single sig sends, the contract address is actually the recipient
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.StakingLock:
            case baseCoin_1.TransactionType.StakingUnlock:
            case baseCoin_1.TransactionType.StakingVote:
            case baseCoin_1.TransactionType.StakingUnvote:
            case baseCoin_1.TransactionType.StakingActivate:
            case baseCoin_1.TransactionType.StakingWithdraw:
                break;
            case baseCoin_1.TransactionType.ContractCall:
                this.validateContractAddress();
                this.validateDataField();
                break;
            default:
                throw new errors_1.BuildTransactionError('Unsupported transaction type');
        }
    };
    /**
     * Check wallet owner addresses for wallet initialization transactions are valid or throw.
     */
    TransactionBuilder.prototype.validateWalletInitializationFields = function () {
        if (this._walletOwnerAddresses === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing wallet owners');
        }
        if (this._walletOwnerAddresses.length !== 3) {
            throw new errors_1.BuildTransactionError("Invalid transaction: wrong number of owners -- required: 3, found: " + this._walletOwnerAddresses.length);
        }
    };
    /**
     * Check if a token address for the tx was defined or throw.
     */
    TransactionBuilder.prototype.validateTokenAddress = function () {
        if (this._tokenAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing token address');
        }
    };
    /**
     * Check if a forwarder address for the tx was defined or throw.
     */
    TransactionBuilder.prototype.validateForwarderAddress = function () {
        if (this._forwarderAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing forwarder address');
        }
    };
    /**
     * Check if a contract address for the wallet was defined or throw.
     */
    TransactionBuilder.prototype.validateContractAddress = function () {
        if (this._contractAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing contract address');
        }
    };
    /**
     * Checks if a contract call data field was defined or throws otherwise
     */
    TransactionBuilder.prototype.validateDataField = function () {
        if (!this._data) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing contract call data field');
        }
    };
    TransactionBuilder.prototype.setContract = function (address) {
        if (address === undefined) {
            throw new errors_1.BuildTransactionError('Undefined recipient address');
        }
        this.contract(address);
    };
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThan(0)) {
            throw new errors_1.BuildTransactionError('Value cannot be below less than zero');
        }
        // TODO: validate the amount is not bigger than the max amount in each Eth family coin
    };
    // region Common builder methods
    /**
     * The type of transaction being built.
     *
     * @param {TransactionType} type
     */
    TransactionBuilder.prototype.type = function (type) {
        this._type = type;
    };
    /**
     * Set the transaction fees. Low fees may get a transaction rejected or never picked up by bakers.
     *
     * @param {Fee} fee Baker fees. May also include the maximum gas to pay
     */
    TransactionBuilder.prototype.fee = function (fee) {
        this.validateValue(new bignumber_js_1.default(fee.fee));
        if (fee.gasLimit) {
            this.validateValue(new bignumber_js_1.default(fee.gasLimit));
        }
        if (fee.eip1559) {
            this.validateValue(new bignumber_js_1.default(fee.eip1559.maxFeePerGas));
            this.validateValue(new bignumber_js_1.default(fee.eip1559.maxPriorityFeePerGas));
        }
        if (fee.gasPrice) {
            this.validateValue(new bignumber_js_1.default(fee.gasPrice));
        }
        this._fee = fee;
    };
    /**
     * Set the transaction counter to prevent submitting repeated transactions.
     *
     * @param {number} counter The counter to use
     */
    TransactionBuilder.prototype.counter = function (counter) {
        if (counter < 0) {
            throw new errors_1.BuildTransactionError("Invalid counter: " + counter);
        }
        this._counter = counter;
    };
    /**
     * The value to send along with this transaction. 0 by default
     *
     * @param {string} value The value to send along with this transaction
     */
    TransactionBuilder.prototype.value = function (value) {
        this._value = value;
    };
    // set args that are required for all types of eth transactions
    TransactionBuilder.prototype.buildBase = function (data) {
        var _a, _b;
        var baseParams = {
            gasLimit: this._fee.gasLimit,
            nonce: this._counter,
            data: data,
            chainId: this._common.chainIdBN().toString(),
            value: this._value,
            to: this._contractAddress,
        };
        if (this._fee.eip1559) {
            return __assign(__assign({}, baseParams), { _type: iface_1.ETHTransactionType.EIP1559, maxFeePerGas: this._fee.eip1559.maxFeePerGas, maxPriorityFeePerGas: this._fee.eip1559.maxPriorityFeePerGas });
        }
        else {
            return __assign(__assign({}, baseParams), { _type: iface_1.ETHTransactionType.LEGACY, gasPrice: (_b = (_a = this._fee) === null || _a === void 0 ? void 0 : _a.gasPrice) !== null && _b !== void 0 ? _b : this._fee.fee, v: this.getFinalV() });
        }
    };
    // endregion
    // region WalletInitialization builder methods
    /**
     * Set one of the owners of the multisig wallet.
     *
     * @param {string} address An Ethereum address
     */
    TransactionBuilder.prototype.owner = function (address) {
        if (this._type !== baseCoin_1.TransactionType.WalletInitialization) {
            throw new errors_1.BuildTransactionError('Multisig wallet owner can only be set for initialization transactions');
        }
        if (this._walletOwnerAddresses.length >= DEFAULT_M) {
            throw new errors_1.BuildTransactionError('A maximum of ' + DEFAULT_M + ' owners can be set for a multisig wallet');
        }
        if (!utils_1.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        if (this._walletOwnerAddresses.includes(address)) {
            throw new errors_1.BuildTransactionError('Repeated owner address: ' + address);
        }
        this._walletOwnerAddresses.push(address);
    };
    /**
     * Build a transaction for a generic multisig contract.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildWalletInitializationTransaction = function () {
        return this.buildBase(this.getContractData(this._walletOwnerAddresses));
    };
    /**
     * Returns the smart contract encoded data
     *
     * @param {string[]} addresses - the contract signers
     * @returns {string} - the smart contract encoded data
     */
    TransactionBuilder.prototype.getContractData = function (addresses) {
        var params = [addresses];
        var resultEncodedParameters = ethereumjs_abi_1.default.rawEncode(walletUtil_1.walletSimpleConstructor, params)
            .toString('hex')
            .replace('0x', '');
        return walletUtil_1.walletSimpleByteCode + resultEncodedParameters;
    };
    // endregion
    // region Send builder methods
    TransactionBuilder.prototype.contract = function (address) {
        if (!utils_1.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        this._contractAddress = address;
    };
    /**
     * Gets the transfer funds builder if exist, or creates a new one for this transaction and returns it
     *
     * @param [data] transfer data to initialize the transfer builder with, empty if none given
     * @returns {TransferBuilder} the transfer builder
     */
    TransactionBuilder.prototype.transfer = function (data) {
        if (!(this._type === baseCoin_1.TransactionType.Send ||
            this._type === baseCoin_1.TransactionType.SendERC721 ||
            this._type === baseCoin_1.TransactionType.SendERC1155)) {
            throw new errors_1.BuildTransactionError('Transfers can only be set for send transactions');
        }
        else if (!this._transfer) {
            if (this._type === baseCoin_1.TransactionType.Send) {
                this._transfer = new eth_1.TransferBuilder(data);
            }
            else if (this._type === baseCoin_1.TransactionType.SendERC721) {
                this._transfer = new transferBuilderERC721_1.ERC721TransferBuilder(data);
            }
            else if (this._type === baseCoin_1.TransactionType.SendERC1155) {
                this._transfer = new transferBuilderERC1155_1.ERC1155TransferBuilder(data);
            }
        }
        return this._transfer;
    };
    /**
     * Returns the serialized sendMultiSig contract method data
     *
     * @returns {string} serialized sendMultiSig data
     */
    TransactionBuilder.prototype.getSendData = function () {
        if (!this._transfer) {
            throw new errors_1.BuildTransactionError('Missing transfer information');
        }
        return this._transfer.signAndBuild();
    };
    TransactionBuilder.prototype.buildSendTransaction = function () {
        var sendData = this.getSendData();
        var tx = this.buildBase(sendData);
        tx.to = this._contractAddress;
        return tx;
    };
    // endregion
    // region AddressInitialization builder methods
    /**
     * Set the contract transaction nonce to calculate the forwarder address.
     *
     * @param {number} contractCounter The counter to use
     */
    TransactionBuilder.prototype.contractCounter = function (contractCounter) {
        if (contractCounter < 0) {
            throw new errors_1.BuildTransactionError("Invalid contract counter: " + contractCounter);
        }
        this._contractCounter = contractCounter;
    };
    /**
     * Build a transaction to create a forwarder.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildAddressInitializationTransaction = function () {
        var addressInitData = utils_1.getAddressInitializationData();
        var tx = this.buildBase(addressInitData);
        tx.to = this._contractAddress;
        if (this._contractCounter) {
            tx.deployedAddress = utils_1.calculateForwarderAddress(this._contractAddress, this._contractCounter);
        }
        return tx;
    };
    // endregion
    // region flush methods
    /**
     * Set the forwarder address to flush
     *
     * @param {string} address The address to flush
     */
    TransactionBuilder.prototype.forwarderAddress = function (address) {
        if (!utils_1.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        this._forwarderAddress = address;
    };
    /**
     * Set the address of the ERC20 token contract that we are flushing tokens for
     *
     * @param {string} address the contract address of the token to flush
     */
    TransactionBuilder.prototype.tokenAddress = function (address) {
        if (!utils_1.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        this._tokenAddress = address;
    };
    /**
     * Build a transaction to flush tokens from a forwarder.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildFlushTokensTransaction = function () {
        return this.buildBase(utils_1.flushTokensData(this._forwarderAddress, this._tokenAddress));
    };
    /**
     * Build a transaction to flush tokens from a forwarder.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildFlushCoinsTransaction = function () {
        return this.buildBase(utils_1.flushCoinsData());
    };
    // endregion
    // region generic contract call
    TransactionBuilder.prototype.data = function (encodedCall) {
        if (this._type !== baseCoin_1.TransactionType.ContractCall) {
            throw new errors_1.BuildTransactionError('data can only be set for contract call transaction types');
        }
        this._data = encodedCall;
    };
    TransactionBuilder.prototype.buildGenericContractCallTransaction = function () {
        return this.buildBase(this._data);
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        // endregion
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get the final v value. Final v is described in EIP-155.
     *
     * @protected for internal use when the enableFinalVField flag is true.
     */
    TransactionBuilder.prototype.getFinalV = function () {
        return ethUtil.addHexPrefix(this._common.chainIdBN().muln(2).addn(35).toString(16));
    };
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vZXRoL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxrRUFBeUM7QUFDekMsOERBQXFDO0FBRXJDLHlEQUE2QztBQUM3Qyx3Q0FBdUY7QUFFdkYsOEJBQTZEO0FBQzdELDZDQUs0QjtBQUM1QixxQ0FBb0M7QUFDcEMsaUNBQTBFO0FBQzFFLGlDQVFpQjtBQUNqQiwyQ0FBNkU7QUFDN0UsdURBQTJDO0FBQzNDLHFDQUE2RDtBQUM3RCxtRkFBa0Y7QUFDbEYsaUZBQWdGO0FBRWhGLElBQU0sU0FBUyxHQUFHLENBQUMsQ0FBQztBQUVwQjs7R0FFRztBQUNIO0lBQXdDLHNDQUFzQjtJQTZCNUQ7Ozs7T0FJRztJQUNILDRCQUFZLFdBQWlDO1FBQTdDLFlBQ0Usa0JBQU0sV0FBVyxDQUFDLFNBT25CO1FBTkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxpQkFBUyxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsT0FBMEIsQ0FBQyxDQUFDO1FBQ3RFLEtBQUksQ0FBQyxLQUFLLEdBQUcsMEJBQWUsQ0FBQyxJQUFJLENBQUM7UUFDbEMsS0FBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDbEIsS0FBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFDbEIsS0FBSSxDQUFDLHFCQUFxQixHQUFHLEVBQUUsQ0FBQztRQUNoQyxLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksaUJBQVcsQ0FBQyxLQUFJLENBQUMsV0FBVyxFQUFFLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7SUFDckUsQ0FBQztJQUVELGtCQUFrQjtJQUNGLGdEQUFtQixHQUFuQzs7Ozs7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QUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBSUQsc0JBQWMsMkNBQVc7UUFIekIsWUFBWTtRQUVaLGtCQUFrQjthQUNsQjtZQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzQixDQUFDO1FBRUQsa0JBQWtCO2FBQ2xCLFVBQTBCLFdBQXdCO1lBQ2hELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2xDLENBQUM7OztPQUxBO0lBT0Q7Ozs7T0FJRztJQUNPLHNDQUFTLEdBQW5CO1FBQ0UsT0FBTyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN0RixDQUFDO0lBQ0gseUJBQUM7QUFBRCxDQUFDLEFBbnBCRCxDQUF3QyxpQ0FBc0IsR0FtcEI3RDtBQW5wQlksZ0RBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZywgRXRoZXJldW1OZXR3b3JrIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IEV0aGVyZXVtQ29tbW9uIGZyb20gJ0BldGhlcmV1bWpzL2NvbW1vbic7XG5pbXBvcnQgRXRoZXJldW1BYmkgZnJvbSAnZXRoZXJldW1qcy1hYmknO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5pbXBvcnQgKiBhcyBDcnlwdG8gZnJvbSAnLi4vLi4vdXRpbHMvY3J5cHRvJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbiwgQmFzZVRyYW5zYWN0aW9uQnVpbGRlciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQmFzZUFkZHJlc3MsIEJhc2VLZXkgfSBmcm9tICcuLi9iYXNlQ29pbi9pZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgVHJhbnNmZXJCdWlsZGVyLCBVdGlscyB9IGZyb20gJy4uL2V0aCc7XG5pbXBvcnQge1xuICBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFNpZ25pbmdFcnJvcixcbn0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHsgRVRIVHJhbnNhY3Rpb25UeXBlLCBGZWUsIFNpZ25hdHVyZVBhcnRzLCBUeERhdGEgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7XG4gIGNhbGN1bGF0ZUZvcndhcmRlckFkZHJlc3MsXG4gIGZsdXNoQ29pbnNEYXRhLFxuICBmbHVzaFRva2Vuc0RhdGEsXG4gIGdldEFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEsXG4gIGdldENvbW1vbixcbiAgaGFzU2lnbmF0dXJlLFxuICBpc1ZhbGlkRXRoQWRkcmVzcyxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB3YWxsZXRTaW1wbGVCeXRlQ29kZSwgd2FsbGV0U2ltcGxlQ29uc3RydWN0b3IgfSBmcm9tICcuL3dhbGxldFV0aWwnO1xuaW1wb3J0ICogYXMgZXRoVXRpbCBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uIH0gZnJvbSAnQGV0aGVyZXVtanMvdHgnO1xuaW1wb3J0IHsgRVJDMTE1NVRyYW5zZmVyQnVpbGRlciB9IGZyb20gJy4vdHJhbnNmZXJCdWlsZGVyL3RyYW5zZmVyQnVpbGRlckVSQzExNTUnO1xuaW1wb3J0IHsgRVJDNzIxVHJhbnNmZXJCdWlsZGVyIH0gZnJvbSAnLi90cmFuc2ZlckJ1aWxkZXIvdHJhbnNmZXJCdWlsZGVyRVJDNzIxJztcblxuY29uc3QgREVGQVVMVF9NID0gMztcblxuLyoqXG4gKiBFdGhlcmV1bSB0cmFuc2FjdGlvbiBidWlsZGVyLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25CdWlsZGVyIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByb3RlY3RlZCBfdHlwZTogVHJhbnNhY3Rpb25UeXBlO1xuICAvLyBTcGVjaWZpZXMgY29tbW9uIGNoYWluIGFuZCBoYXJkZm9yayBwYXJhbWV0ZXJzLlxuICBwcm90ZWN0ZWQgX2NvbW1vbjogRXRoZXJldW1Db21tb247XG4gIHByaXZhdGUgX3RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjtcbiAgcHJpdmF0ZSBfc291cmNlS2V5UGFpcjogS2V5UGFpcjtcbiAgcHJpdmF0ZSBfY291bnRlcjogbnVtYmVyO1xuICBwcml2YXRlIF9mZWU6IEZlZTtcbiAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZztcblxuICAvLyB0aGUgc2lnbmF0dXJlIG9uIHRoZSBleHRlcm5hbCBFVEggdHJhbnNhY3Rpb25cbiAgcHJpdmF0ZSBfdHhTaWduYXR1cmU6IFNpZ25hdHVyZVBhcnRzO1xuXG4gIC8vIFdhbGxldCBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgX3dhbGxldE93bmVyQWRkcmVzc2VzOiBzdHJpbmdbXTtcblxuICAvLyBmbHVzaCB0b2tlbnMgcGFyYW1ldGVyc1xuICBwcml2YXRlIF9mb3J3YXJkZXJBZGRyZXNzOiBzdHJpbmc7XG4gIHByaXZhdGUgX3Rva2VuQWRkcmVzczogc3RyaW5nO1xuXG4gIC8vIFNlbmQgYW5kIEFkZHJlc3NJbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbiBzcGVjaWZpYyBwYXJhbWV0ZXJzXG4gIHByb3RlY3RlZCBfdHJhbnNmZXI6IFRyYW5zZmVyQnVpbGRlciB8IEVSQzcyMVRyYW5zZmVyQnVpbGRlciB8IEVSQzExNTVUcmFuc2ZlckJ1aWxkZXI7XG4gIHByaXZhdGUgX2NvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICBwcml2YXRlIF9jb250cmFjdENvdW50ZXI6IG51bWJlcjtcblxuICAvLyBnZW5lcmljIGNvbnRyYWN0IGNhbGwgYnVpbGRlclxuICAvLyBlbmNvZGVkIGNvbnRyYWN0IGNhbGwgaGV4XG4gIHByaXZhdGUgX2RhdGE6IHN0cmluZztcblxuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gX2NvaW5Db25maWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl9jb21tb24gPSBnZXRDb21tb24odGhpcy5fY29pbkNvbmZpZy5uZXR3b3JrIGFzIEV0aGVyZXVtTmV0d29yayk7XG4gICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xuICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgIHRoaXMuX3ZhbHVlID0gJzAnO1xuICAgIHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzID0gW107XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnLCB0aGlzLl9jb21tb24pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBhc3luYyBidWlsZEltcGxlbWVudGF0aW9uKCk6IFByb21pc2U8QmFzZVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbkRhdGEoKTtcblxuICAgIGlmICh0aGlzLl90eFNpZ25hdHVyZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0cmFuc2FjdGlvbkRhdGEsIHRoaXMuX3R4U2lnbmF0dXJlKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uVHlwZSh0aGlzLl90eXBlKTtcbiAgICB0cmFuc2FjdGlvbkRhdGEuZnJvbSA9IHRoaXMuX3NvdXJjZUtleVBhaXIgPyB0aGlzLl9zb3VyY2VLZXlQYWlyLmdldEFkZHJlc3MoKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uRGF0YSh0cmFuc2FjdGlvbkRhdGEpO1xuXG4gICAgLy8gQnVpbGQgYW5kIHNpZ24gYSBuZXcgdHJhbnNhY3Rpb24gYmFzZWQgb24gdGhlIGxhdGVzdCBjaGFuZ2VzXG4gICAgaWYgKHRoaXMuX3NvdXJjZUtleVBhaXIgJiYgdGhpcy5fc291cmNlS2V5UGFpci5nZXRLZXlzKCkucHJ2KSB7XG4gICAgICBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uLnNpZ24odGhpcy5fc291cmNlS2V5UGFpcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFRyYW5zYWN0aW9uRGF0YSgpOiBUeERhdGEge1xuICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb246XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkV2FsbGV0SW5pdGlhbGl6YXRpb25UcmFuc2FjdGlvbigpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmRFUkM3MjE6XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TZW5kRVJDMTE1NTpcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTZW5kVHJhbnNhY3Rpb24oKTtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbjpcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBZGRyZXNzSW5pdGlhbGl6YXRpb25UcmFuc2FjdGlvbigpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRmx1c2hUb2tlbnM6XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRmx1c2hUb2tlbnNUcmFuc2FjdGlvbigpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRmx1c2hDb2luczpcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGbHVzaENvaW5zVHJhbnNhY3Rpb24oKTtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQ6XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQmFzZSgnMHgnKTtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkNvbnRyYWN0Q2FsbDpcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRHZW5lcmljQ29udHJhY3RDYWxsVHJhbnNhY3Rpb24oKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogVHJhbnNhY3Rpb24ge1xuICAgIGxldCB0eDogVHJhbnNhY3Rpb247XG4gICAgaWYgKC9eMHg/WzAtOWEtZl17MSx9JC8udGVzdChyYXdUcmFuc2FjdGlvbi50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgdHggPSBUcmFuc2FjdGlvbi5mcm9tU2VyaWFsaXplZCh0aGlzLl9jb2luQ29uZmlnLCB0aGlzLl9jb21tb24sIHJhd1RyYW5zYWN0aW9uKTtcbiAgICAgIHRoaXMubG9hZEJ1aWxkZXJJbnB1dCh0eC50b0pzb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR4RGF0YSA9IEpTT04ucGFyc2UocmF3VHJhbnNhY3Rpb24pO1xuICAgICAgdHggPSBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZywgdHhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4O1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGJ1aWxkZXIgZGF0YSB1c2luZyB0aGUgZGVzZXJpYWxpemVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7VHhEYXRhfSB0cmFuc2FjdGlvbkpzb24gdGhlIGRlc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBqc29uXG4gICAqL1xuICBwcm90ZWN0ZWQgbG9hZEJ1aWxkZXJJbnB1dCh0cmFuc2FjdGlvbkpzb246IFR4RGF0YSk6IHZvaWQge1xuICAgIGNvbnN0IGRlY29kZWRUeXBlID0gVXRpbHMuY2xhc3NpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkpzb24uZGF0YSk7XG4gICAgdGhpcy50eXBlKGRlY29kZWRUeXBlKTtcbiAgICB0aGlzLmNvdW50ZXIodHJhbnNhY3Rpb25Kc29uLm5vbmNlKTtcbiAgICB0aGlzLnZhbHVlKHRyYW5zYWN0aW9uSnNvbi52YWx1ZSk7XG5cbiAgICBpZiAodHJhbnNhY3Rpb25Kc29uLl90eXBlID09PSBFVEhUcmFuc2FjdGlvblR5cGUuTEVHQUNZKSB7XG4gICAgICB0aGlzLmZlZSh7XG4gICAgICAgIGZlZTogdHJhbnNhY3Rpb25Kc29uLmdhc1ByaWNlLFxuICAgICAgICBnYXNQcmljZTogdHJhbnNhY3Rpb25Kc29uLmdhc1ByaWNlLFxuICAgICAgICBnYXNMaW1pdDogdHJhbnNhY3Rpb25Kc29uLmdhc0xpbWl0LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmVlKHtcbiAgICAgICAgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uSnNvbi5nYXNMaW1pdCxcbiAgICAgICAgZmVlOiB0cmFuc2FjdGlvbkpzb24ubWF4RmVlUGVyR2FzLFxuICAgICAgICBlaXAxNTU5OiB7XG4gICAgICAgICAgbWF4RmVlUGVyR2FzOiB0cmFuc2FjdGlvbkpzb24ubWF4RmVlUGVyR2FzLFxuICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cmFuc2FjdGlvbkpzb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU2lnbmF0dXJlKHRyYW5zYWN0aW9uSnNvbikpIHtcbiAgICAgIHRoaXMuX3R4U2lnbmF0dXJlID0geyB2OiB0cmFuc2FjdGlvbkpzb24udiEsIHI6IHRyYW5zYWN0aW9uSnNvbi5yISwgczogdHJhbnNhY3Rpb25Kc29uLnMhIH07XG4gICAgfVxuICAgIHRoaXMuc2V0VHJhbnNhY3Rpb25UeXBlRmllbGRzKGRlY29kZWRUeXBlLCB0cmFuc2FjdGlvbkpzb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFRyYW5zYWN0aW9uVHlwZUZpZWxkcyhkZWNvZGVkVHlwZTogVHJhbnNhY3Rpb25UeXBlLCB0cmFuc2FjdGlvbkpzb246IFR4RGF0YSk6IHZvaWQge1xuICAgIHN3aXRjaCAoZGVjb2RlZFR5cGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uOlxuICAgICAgICBjb25zdCBvd25lcnMgPSBVdGlscy5kZWNvZGVXYWxsZXRDcmVhdGlvbkRhdGEodHJhbnNhY3Rpb25Kc29uLmRhdGEpO1xuICAgICAgICBvd25lcnMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHRoaXMub3duZXIoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkZsdXNoVG9rZW5zOlxuICAgICAgICB0aGlzLnNldENvbnRyYWN0KHRyYW5zYWN0aW9uSnNvbi50byk7XG4gICAgICAgIGNvbnN0IHsgZm9yd2FyZGVyQWRkcmVzcywgdG9rZW5BZGRyZXNzIH0gPSBVdGlscy5kZWNvZGVGbHVzaFRva2Vuc0RhdGEodHJhbnNhY3Rpb25Kc29uLmRhdGEpO1xuICAgICAgICB0aGlzLmZvcndhcmRlckFkZHJlc3MoZm9yd2FyZGVyQWRkcmVzcyk7XG4gICAgICAgIHRoaXMudG9rZW5BZGRyZXNzKHRva2VuQWRkcmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRmx1c2hDb2luczpcbiAgICAgICAgdGhpcy5zZXRDb250cmFjdCh0cmFuc2FjdGlvbkpzb24udG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmQ6XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TZW5kRVJDMTE1NTpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmRFUkM3MjE6XG4gICAgICAgIHRoaXMuc2V0Q29udHJhY3QodHJhbnNhY3Rpb25Kc29uLnRvKTtcbiAgICAgICAgdGhpcy5fdHJhbnNmZXIgPSB0aGlzLnRyYW5zZmVyKHRyYW5zYWN0aW9uSnNvbi5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb246XG4gICAgICAgIHRoaXMuc2V0Q29udHJhY3QodHJhbnNhY3Rpb25Kc29uLnRvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TaW5nbGVTaWdTZW5kOlxuICAgICAgICB0aGlzLnNldENvbnRyYWN0KHRyYW5zYWN0aW9uSnNvbi50byk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsOlxuICAgICAgICB0aGlzLnNldENvbnRyYWN0KHRyYW5zYWN0aW9uSnNvbi50byk7XG4gICAgICAgIHRoaXMuZGF0YSh0cmFuc2FjdGlvbkpzb24uZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZScpO1xuICAgICAgLy8gVE9ETzogQWRkIG90aGVyIGNhc2VzIG9mIGRlc2VyaWFsaXphdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2lnbkltcGxlbWVudGF0aW9uKGtleTogQmFzZUtleSk6IEJhc2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3Qgc2lnbmVyID0gbmV3IEtleVBhaXIoeyBwcnY6IGtleS5rZXkgfSk7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbiAmJiB0aGlzLl93YWxsZXRPd25lckFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0Nhbm5vdCBzaWduIGFuIHdhbGxldCBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbiB3aXRob3V0IG93bmVycycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlS2V5UGFpcikge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignQ2Fubm90IHNpZ24gbXVsdGlwbGUgdGltZXMgYSBub24gc2VuZC10eXBlIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIC8vIFNpZ25pbmcgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGFzeW5jIG9wZXJhdGlvbiwgc28gc2F2ZSB0aGUgc291cmNlIGFuZCBsZWF2ZSB0aGUgYWN0dWFsXG4gICAgLy8gc2lnbmluZyBmb3IgdGhlIGJ1aWxkIHN0ZXBcbiAgICB0aGlzLl9zb3VyY2VLZXlQYWlyID0gc2lnbmVyO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBCYXNlQWRkcmVzcyk6IHZvaWQge1xuICAgIGlmICghaXNWYWxpZEV0aEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBhZGRyZXNzICcgKyBhZGRyZXNzLmFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUtleShrZXk6IEJhc2VLZXkpOiB2b2lkIHtcbiAgICBpZiAoIShDcnlwdG8uaXNWYWxpZFhwcnYoa2V5LmtleSkgfHwgQ3J5cHRvLmlzVmFsaWRQcnYoa2V5LmtleSkpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgcmF3IHRyYW5zYWN0aW9uIGlzIGVpdGhlciBhIEpTT04gb3JcbiAgICogYSBoZXggZW5jb2RlZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gcmF3VHJhbnNhY3Rpb24gVGhlIHJhdyB0cmFuc2FjdGlvbiB0byBiZSB2YWxpZGF0ZWRcbiAgICovXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IGFueSk6IHZvaWQge1xuICAgIGlmICghcmF3VHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignUmF3IHRyYW5zYWN0aW9uIGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoL14weD9bMC05YS1mXXsxLH0kLy50ZXN0KHJhd1RyYW5zYWN0aW9uLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGNvbnN0IHR4Qnl0ZXMgPSBldGhVdGlsLnRvQnVmZmVyKGV0aFV0aWwuYWRkSGV4UHJlZml4KHJhd1RyYW5zYWN0aW9uLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRWlwMTU1OVR4bih0eEJ5dGVzKSAmJiAhdGhpcy5pc1JMUERlY29kYWJsZSh0eEJ5dGVzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1RoZXJlIHdhcyBlcnJvciBpbiBkZWNvZGluZyB0aGUgaGV4IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEpTT04ucGFyc2UocmF3VHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignVGhlcmUgd2FzIGVycm9yIGluIHBhcnNpbmcgdGhlIEpTT04gc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBpcyBub3QgYSBoZXggc3RyaW5nIG9yIHN0cmluZ2lmaWVkIGpzb24nKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzRWlwMTU1OVR4bih0eG46IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24uZnJvbVNlcmlhbGl6ZWRUeCh0eG4pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNSTFBEZWNvZGFibGUoYnl0ZXM6IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBldGhVdGlsLnJscC5kZWNvZGUoYnl0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCB2YWxpZGF0ZUJhc2VUcmFuc2FjdGlvbkZpZWxkcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZmVlID09PSB1bmRlZmluZWQgfHwgKCF0aGlzLl9mZWUuZmVlICYmICF0aGlzLl9mZWUuZ2FzUHJpY2UgJiYgIXRoaXMuX2ZlZS5laXAxNTU5KSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbWlzc2luZyBmZWUnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbW1vbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBuZXR3b3JrIGNvbW1vbicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY291bnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGFkZHJlc3MgY291bnRlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLnZhbGlkYXRlQmFzZVRyYW5zYWN0aW9uRmllbGRzKCk7XG4gICAgc3dpdGNoICh0aGlzLl90eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjpcbiAgICAgICAgdGhpcy52YWxpZGF0ZVdhbGxldEluaXRpYWxpemF0aW9uRmllbGRzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmRFUkM3MjE6XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TZW5kRVJDMTE1NTpcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbjpcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkZsdXNoQ29pbnM6XG4gICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdEFkZHJlc3MoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5GbHVzaFRva2VuczpcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcygpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlRm9yd2FyZGVyQWRkcmVzcygpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlVG9rZW5BZGRyZXNzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2luZ2xlU2lnU2VuZDpcbiAgICAgICAgLy8gZm9yIHNpbmdsZSBzaWcgc2VuZHMsIHRoZSBjb250cmFjdCBhZGRyZXNzIGlzIGFjdHVhbGx5IHRoZSByZWNpcGllbnRcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdMb2NrOlxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9jazpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdWb3RlOlxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1Vudm90ZTpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZTpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGw6XG4gICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdEFkZHJlc3MoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZURhdGFGaWVsZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2FsbGV0IG93bmVyIGFkZHJlc3NlcyBmb3Igd2FsbGV0IGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9ucyBhcmUgdmFsaWQgb3IgdGhyb3cuXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlV2FsbGV0SW5pdGlhbGl6YXRpb25GaWVsZHMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3Npbmcgd2FsbGV0IG93bmVycycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl93YWxsZXRPd25lckFkZHJlc3Nlcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHRyYW5zYWN0aW9uOiB3cm9uZyBudW1iZXIgb2Ygb3duZXJzIC0tIHJlcXVpcmVkOiAzLCBmb3VuZDogJHt0aGlzLl93YWxsZXRPd25lckFkZHJlc3Nlcy5sZW5ndGh9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdG9rZW4gYWRkcmVzcyBmb3IgdGhlIHR4IHdhcyBkZWZpbmVkIG9yIHRocm93LlxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVRva2VuQWRkcmVzcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fdG9rZW5BZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3NpbmcgdG9rZW4gYWRkcmVzcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGZvcndhcmRlciBhZGRyZXNzIGZvciB0aGUgdHggd2FzIGRlZmluZWQgb3IgdGhyb3cuXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlRm9yd2FyZGVyQWRkcmVzcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZm9yd2FyZGVyQWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGZvcndhcmRlciBhZGRyZXNzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhlIHdhbGxldCB3YXMgZGVmaW5lZCBvciB0aHJvdy5cbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVDb250cmFjdEFkZHJlc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2NvbnRyYWN0QWRkcmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGNvbnRyYWN0IGFkZHJlc3MnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgY29udHJhY3QgY2FsbCBkYXRhIGZpZWxkIHdhcyBkZWZpbmVkIG9yIHRocm93cyBvdGhlcndpc2VcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVEYXRhRmllbGQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGNvbnRyYWN0IGNhbGwgZGF0YSBmaWVsZCcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0Q29udHJhY3QoYWRkcmVzczogc3RyaW5nIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKGFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVW5kZWZpbmVkIHJlY2lwaWVudCBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHRoaXMuY29udHJhY3QoYWRkcmVzcyk7XG4gIH1cblxuICB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUuaXNMZXNzVGhhbigwKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVmFsdWUgY2Fubm90IGJlIGJlbG93IGxlc3MgdGhhbiB6ZXJvJyk7XG4gICAgfVxuICAgIC8vIFRPRE86IHZhbGlkYXRlIHRoZSBhbW91bnQgaXMgbm90IGJpZ2dlciB0aGFuIHRoZSBtYXggYW1vdW50IGluIGVhY2ggRXRoIGZhbWlseSBjb2luXG4gIH1cblxuICAvLyByZWdpb24gQ29tbW9uIGJ1aWxkZXIgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvbiBiZWluZyBidWlsdC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblR5cGV9IHR5cGVcbiAgICovXG4gIHR5cGUodHlwZTogVHJhbnNhY3Rpb25UeXBlKTogdm9pZCB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiBmZWVzLiBMb3cgZmVlcyBtYXkgZ2V0IGEgdHJhbnNhY3Rpb24gcmVqZWN0ZWQgb3IgbmV2ZXIgcGlja2VkIHVwIGJ5IGJha2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHtGZWV9IGZlZSBCYWtlciBmZWVzLiBNYXkgYWxzbyBpbmNsdWRlIHRoZSBtYXhpbXVtIGdhcyB0byBwYXlcbiAgICovXG4gIGZlZShmZWU6IEZlZSk6IHZvaWQge1xuICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGZlZS5mZWUpKTtcbiAgICBpZiAoZmVlLmdhc0xpbWl0KSB7XG4gICAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcihmZWUuZ2FzTGltaXQpKTtcbiAgICB9XG4gICAgaWYgKGZlZS5laXAxNTU5KSB7XG4gICAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcihmZWUuZWlwMTU1OS5tYXhGZWVQZXJHYXMpKTtcbiAgICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGZlZS5laXAxNTU5Lm1heFByaW9yaXR5RmVlUGVyR2FzKSk7XG4gICAgfVxuICAgIGlmIChmZWUuZ2FzUHJpY2UpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGZlZS5nYXNQcmljZSkpO1xuICAgIH1cbiAgICB0aGlzLl9mZWUgPSBmZWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiBjb3VudGVyIHRvIHByZXZlbnQgc3VibWl0dGluZyByZXBlYXRlZCB0cmFuc2FjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudGVyIFRoZSBjb3VudGVyIHRvIHVzZVxuICAgKi9cbiAgY291bnRlcihjb3VudGVyOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoY291bnRlciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgY291bnRlcjogJHtjb3VudGVyfWApO1xuICAgIH1cblxuICAgIHRoaXMuX2NvdW50ZXIgPSBjb3VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSB0byBzZW5kIGFsb25nIHdpdGggdGhpcyB0cmFuc2FjdGlvbi4gMCBieSBkZWZhdWx0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VuZCBhbG9uZyB3aXRoIHRoaXMgdHJhbnNhY3Rpb25cbiAgICovXG4gIHZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLy8gc2V0IGFyZ3MgdGhhdCBhcmUgcmVxdWlyZWQgZm9yIGFsbCB0eXBlcyBvZiBldGggdHJhbnNhY3Rpb25zXG4gIHByb3RlY3RlZCBidWlsZEJhc2UoZGF0YTogc3RyaW5nKTogVHhEYXRhIHtcbiAgICBjb25zdCBiYXNlUGFyYW1zID0ge1xuICAgICAgZ2FzTGltaXQ6IHRoaXMuX2ZlZS5nYXNMaW1pdCxcbiAgICAgIG5vbmNlOiB0aGlzLl9jb3VudGVyLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGNoYWluSWQ6IHRoaXMuX2NvbW1vbi5jaGFpbklkQk4oKS50b1N0cmluZygpLFxuICAgICAgdmFsdWU6IHRoaXMuX3ZhbHVlLFxuICAgICAgdG86IHRoaXMuX2NvbnRyYWN0QWRkcmVzcyxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2ZlZS5laXAxNTU5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5iYXNlUGFyYW1zLFxuICAgICAgICBfdHlwZTogRVRIVHJhbnNhY3Rpb25UeXBlLkVJUDE1NTksXG4gICAgICAgIG1heEZlZVBlckdhczogdGhpcy5fZmVlLmVpcDE1NTkubWF4RmVlUGVyR2FzLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdGhpcy5fZmVlLmVpcDE1NTkubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5iYXNlUGFyYW1zLFxuICAgICAgICBfdHlwZTogRVRIVHJhbnNhY3Rpb25UeXBlLkxFR0FDWSxcbiAgICAgICAgZ2FzUHJpY2U6IHRoaXMuX2ZlZT8uZ2FzUHJpY2UgPz8gdGhpcy5fZmVlLmZlZSxcbiAgICAgICAgdjogdGhpcy5nZXRGaW5hbFYoKSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFdhbGxldEluaXRpYWxpemF0aW9uIGJ1aWxkZXIgbWV0aG9kc1xuICAvKipcbiAgICogU2V0IG9uZSBvZiB0aGUgb3duZXJzIG9mIHRoZSBtdWx0aXNpZyB3YWxsZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIEFuIEV0aGVyZXVtIGFkZHJlc3NcbiAgICovXG4gIG93bmVyKGFkZHJlc3M6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl90eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ011bHRpc2lnIHdhbGxldCBvd25lciBjYW4gb25seSBiZSBzZXQgZm9yIGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9ucycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2FsbGV0T3duZXJBZGRyZXNzZXMubGVuZ3RoID49IERFRkFVTFRfTSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQSBtYXhpbXVtIG9mICcgKyBERUZBVUxUX00gKyAnIG93bmVycyBjYW4gYmUgc2V0IGZvciBhIG11bHRpc2lnIHdhbGxldCcpO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGFkZHJlc3M6ICcgKyBhZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzLmluY2x1ZGVzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdSZXBlYXRlZCBvd25lciBhZGRyZXNzOiAnICsgYWRkcmVzcyk7XG4gICAgfVxuICAgIHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSB0cmFuc2FjdGlvbiBmb3IgYSBnZW5lcmljIG11bHRpc2lnIGNvbnRyYWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7VHhEYXRhfSBUaGUgRXRoZXJldW0gdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkV2FsbGV0SW5pdGlhbGl6YXRpb25UcmFuc2FjdGlvbigpOiBUeERhdGEge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkQmFzZSh0aGlzLmdldENvbnRyYWN0RGF0YSh0aGlzLl93YWxsZXRPd25lckFkZHJlc3NlcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNtYXJ0IGNvbnRyYWN0IGVuY29kZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzZXMgLSB0aGUgY29udHJhY3Qgc2lnbmVyc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBzbWFydCBjb250cmFjdCBlbmNvZGVkIGRhdGFcbiAgICovXG4gIHByb3RlY3RlZCBnZXRDb250cmFjdERhdGEoYWRkcmVzc2VzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFyYW1zID0gW2FkZHJlc3Nlc107XG4gICAgY29uc3QgcmVzdWx0RW5jb2RlZFBhcmFtZXRlcnMgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUod2FsbGV0U2ltcGxlQ29uc3RydWN0b3IsIHBhcmFtcylcbiAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICAgIC5yZXBsYWNlKCcweCcsICcnKTtcbiAgICByZXR1cm4gd2FsbGV0U2ltcGxlQnl0ZUNvZGUgKyByZXN1bHRFbmNvZGVkUGFyYW1ldGVycztcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gU2VuZCBidWlsZGVyIG1ldGhvZHNcblxuICBjb250cmFjdChhZGRyZXNzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGFkZHJlc3M6ICcgKyBhZGRyZXNzKTtcbiAgICB9XG4gICAgdGhpcy5fY29udHJhY3RBZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0cmFuc2ZlciBmdW5kcyBidWlsZGVyIGlmIGV4aXN0LCBvciBjcmVhdGVzIGEgbmV3IG9uZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiBhbmQgcmV0dXJucyBpdFxuICAgKlxuICAgKiBAcGFyYW0gW2RhdGFdIHRyYW5zZmVyIGRhdGEgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNmZXIgYnVpbGRlciB3aXRoLCBlbXB0eSBpZiBub25lIGdpdmVuXG4gICAqIEByZXR1cm5zIHtUcmFuc2ZlckJ1aWxkZXJ9IHRoZSB0cmFuc2ZlciBidWlsZGVyXG4gICAqL1xuICB0cmFuc2ZlcihkYXRhPzogc3RyaW5nKTogVHJhbnNmZXJCdWlsZGVyIHwgRVJDNzIxVHJhbnNmZXJCdWlsZGVyIHwgRVJDMTE1NVRyYW5zZmVyQnVpbGRlciB7XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgdGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmQgfHxcbiAgICAgICAgdGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmRFUkM3MjEgfHxcbiAgICAgICAgdGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmRFUkMxMTU1XG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2ZlcnMgY2FuIG9ubHkgYmUgc2V0IGZvciBzZW5kIHRyYW5zYWN0aW9ucycpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX3RyYW5zZmVyKSB7XG4gICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmZXIgPSBuZXcgVHJhbnNmZXJCdWlsZGVyKGRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZEVSQzcyMSkge1xuICAgICAgICB0aGlzLl90cmFuc2ZlciA9IG5ldyBFUkM3MjFUcmFuc2ZlckJ1aWxkZXIoZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kRVJDMTE1NSkge1xuICAgICAgICB0aGlzLl90cmFuc2ZlciA9IG5ldyBFUkMxMTU1VHJhbnNmZXJCdWlsZGVyKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2VyaWFsaXplZCBzZW5kTXVsdGlTaWcgY29udHJhY3QgbWV0aG9kIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2VyaWFsaXplZCBzZW5kTXVsdGlTaWcgZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTZW5kRGF0YSgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fdHJhbnNmZXIpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ01pc3NpbmcgdHJhbnNmZXIgaW5mb3JtYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZmVyLnNpZ25BbmRCdWlsZCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZFNlbmRUcmFuc2FjdGlvbigpOiBUeERhdGEge1xuICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5nZXRTZW5kRGF0YSgpO1xuICAgIGNvbnN0IHR4OiBUeERhdGEgPSB0aGlzLmJ1aWxkQmFzZShzZW5kRGF0YSk7XG4gICAgdHgudG8gPSB0aGlzLl9jb250cmFjdEFkZHJlc3M7XG4gICAgcmV0dXJuIHR4O1xuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIEFkZHJlc3NJbml0aWFsaXphdGlvbiBidWlsZGVyIG1ldGhvZHNcblxuICAvKipcbiAgICogU2V0IHRoZSBjb250cmFjdCB0cmFuc2FjdGlvbiBub25jZSB0byBjYWxjdWxhdGUgdGhlIGZvcndhcmRlciBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29udHJhY3RDb3VudGVyIFRoZSBjb3VudGVyIHRvIHVzZVxuICAgKi9cbiAgY29udHJhY3RDb3VudGVyKGNvbnRyYWN0Q291bnRlcjogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKGNvbnRyYWN0Q291bnRlciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgY29udHJhY3QgY291bnRlcjogJHtjb250cmFjdENvdW50ZXJ9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29udHJhY3RDb3VudGVyID0gY29udHJhY3RDb3VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgdHJhbnNhY3Rpb24gdG8gY3JlYXRlIGEgZm9yd2FyZGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VHhEYXRhfSBUaGUgRXRoZXJldW0gdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZEFkZHJlc3NJbml0aWFsaXphdGlvblRyYW5zYWN0aW9uKCk6IFR4RGF0YSB7XG4gICAgY29uc3QgYWRkcmVzc0luaXREYXRhID0gZ2V0QWRkcmVzc0luaXRpYWxpemF0aW9uRGF0YSgpO1xuICAgIGNvbnN0IHR4OiBUeERhdGEgPSB0aGlzLmJ1aWxkQmFzZShhZGRyZXNzSW5pdERhdGEpO1xuICAgIHR4LnRvID0gdGhpcy5fY29udHJhY3RBZGRyZXNzO1xuICAgIGlmICh0aGlzLl9jb250cmFjdENvdW50ZXIpIHtcbiAgICAgIHR4LmRlcGxveWVkQWRkcmVzcyA9IGNhbGN1bGF0ZUZvcndhcmRlckFkZHJlc3ModGhpcy5fY29udHJhY3RBZGRyZXNzLCB0aGlzLl9jb250cmFjdENvdW50ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIGZsdXNoIG1ldGhvZHNcbiAgLyoqXG4gICAqIFNldCB0aGUgZm9yd2FyZGVyIGFkZHJlc3MgdG8gZmx1c2hcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gZmx1c2hcbiAgICovXG4gIGZvcndhcmRlckFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFpc1ZhbGlkRXRoQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBhZGRyZXNzOiAnICsgYWRkcmVzcyk7XG4gICAgfVxuICAgIHRoaXMuX2ZvcndhcmRlckFkZHJlc3MgPSBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYWRkcmVzcyBvZiB0aGUgRVJDMjAgdG9rZW4gY29udHJhY3QgdGhhdCB3ZSBhcmUgZmx1c2hpbmcgdG9rZW5zIGZvclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gZmx1c2hcbiAgICovXG4gIHRva2VuQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGFkZHJlc3M6ICcgKyBhZGRyZXNzKTtcbiAgICB9XG4gICAgdGhpcy5fdG9rZW5BZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIHRyYW5zYWN0aW9uIHRvIGZsdXNoIHRva2VucyBmcm9tIGEgZm9yd2FyZGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VHhEYXRhfSBUaGUgRXRoZXJldW0gdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZEZsdXNoVG9rZW5zVHJhbnNhY3Rpb24oKTogVHhEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZEJhc2UoZmx1c2hUb2tlbnNEYXRhKHRoaXMuX2ZvcndhcmRlckFkZHJlc3MsIHRoaXMuX3Rva2VuQWRkcmVzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgdHJhbnNhY3Rpb24gdG8gZmx1c2ggdG9rZW5zIGZyb20gYSBmb3J3YXJkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtUeERhdGF9IFRoZSBFdGhlcmV1bSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkRmx1c2hDb2luc1RyYW5zYWN0aW9uKCk6IFR4RGF0YSB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRCYXNlKGZsdXNoQ29pbnNEYXRhKCkpO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBnZW5lcmljIGNvbnRyYWN0IGNhbGxcbiAgZGF0YShlbmNvZGVkQ2FsbDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3R5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGwpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ2RhdGEgY2FuIG9ubHkgYmUgc2V0IGZvciBjb250cmFjdCBjYWxsIHRyYW5zYWN0aW9uIHR5cGVzJyk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGEgPSBlbmNvZGVkQ2FsbDtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHZW5lcmljQ29udHJhY3RDYWxsVHJhbnNhY3Rpb24oKTogVHhEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZEJhc2UodGhpcy5fZGF0YSk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2V0IHRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaW5hbCB2IHZhbHVlLiBGaW5hbCB2IGlzIGRlc2NyaWJlZCBpbiBFSVAtMTU1LlxuICAgKlxuICAgKiBAcHJvdGVjdGVkIGZvciBpbnRlcm5hbCB1c2Ugd2hlbiB0aGUgZW5hYmxlRmluYWxWRmllbGQgZmxhZyBpcyB0cnVlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEZpbmFsVigpOiBzdHJpbmcge1xuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeCh0aGlzLl9jb21tb24uY2hhaW5JZEJOKCkubXVsbigyKS5hZGRuKDM1KS50b1N0cmluZygxNikpO1xuICB9XG59XG4iXX0=