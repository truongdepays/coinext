"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getToken = exports.getBufferedByteCode = exports.getRawDecoded = exports.hasSignature = exports.toStringSig = exports.getProxyInitcode = exports.calculateForwarderV1Address = exports.calculateForwarderAddress = exports.hexStringToNumber = exports.numberToHexString = exports.classifyTransaction = exports.decodeFlushTokensData = exports.decodeNativeTransferData = exports.decodeERC1155TransferData = exports.decodeERC721TransferData = exports.decodeTokenTransferData = exports.decodeTransferData = exports.decodeWalletCreationData = exports.isValidAmount = exports.isValidEthAddress = exports.getAddressInitializationData = exports.flushCoinsData = exports.flushTokensData = exports.sendMultiSigTokenData = exports.sendMultiSigData = exports.sign = exports.signInternal = exports.getCommon = void 0;
var buffer_1 = require("buffer");
var assert_1 = __importDefault(require("assert"));
var ethereumjs_utils_old_1 = require("ethereumjs-utils-old");
var ethereumjs_util_1 = require("ethereumjs-util");
var statics_1 = require("@bitgo/statics");
var ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
var common_1 = __importDefault(require("@ethereumjs/common"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var stakingUtils_1 = require("../celo/stakingUtils");
var walletUtil_1 = require("./walletUtil");
var types_1 = require("./types");
/**
 * @param network
 */
function getCommon(network) {
    return common_1.default.forCustomChain(
    // use the mainnet config as a base, override chain ids and network name
    'mainnet', {
        name: network.type,
        networkId: network.chainId,
        chainId: network.chainId,
    }, 'london');
}
exports.getCommon = getCommon;
/**
 * Signs the transaction using the appropriate algorithm
 * and the provided common for the blockchain
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @param {EthereumCommon} customCommon the network's custom common
 * @returns {string} the transaction signed and encoded
 */
function signInternal(transactionData, keyPair, customCommon) {
    return __awaiter(this, void 0, void 0, function () {
        var ethTx;
        return __generator(this, function (_a) {
            if (!keyPair.getKeys().prv) {
                throw new errors_1.SigningError('Missing private key');
            }
            ethTx = types_1.EthTransactionData.fromJson(transactionData, customCommon);
            ethTx.sign(keyPair);
            return [2 /*return*/, ethTx.toSerialized()];
        });
    });
}
exports.signInternal = signInternal;
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
function sign(transactionData, keyPair) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, signInternal(transactionData, keyPair, getCommon(statics_1.coins.get('teth').network))];
        });
    });
}
exports.sign = sign;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} data aditional method call data
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigData(to, value, data, expireTime, sequenceId, signature) {
    var params = [to, value, ethereumjs_utils_old_1.toBuffer(data), expireTime, sequenceId, ethereumjs_utils_old_1.toBuffer(signature)];
    var method = ethereumjs_abi_1.default.methodID('sendMultiSig', walletUtil_1.sendMultiSigTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTypes, params);
    return ethereumjs_utils_old_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigData = sendMultiSigData;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} tokenContractAddress the address of the erc20 token contract
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigTokenData(to, value, tokenContractAddress, expireTime, sequenceId, signature) {
    var params = [to, value, tokenContractAddress, expireTime, sequenceId, ethereumjs_utils_old_1.toBuffer(signature)];
    var method = ethereumjs_abi_1.default.methodID('sendMultiSigToken', walletUtil_1.sendMultiSigTokenTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTokenTypes, params);
    return ethereumjs_utils_old_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigTokenData = sendMultiSigTokenData;
/**
 * Get the data required to make a flush tokens contract call
 *
 * @param forwarderAddress The forwarder address to flush
 * @param tokenAddress The token address to flush from
 */
function flushTokensData(forwarderAddress, tokenAddress) {
    var params = [forwarderAddress, tokenAddress];
    var method = ethereumjs_abi_1.default.methodID('flushForwarderTokens', walletUtil_1.flushTokensTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypes, params);
    return ethereumjs_utils_old_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushTokensData = flushTokensData;
/**
 * Get the data required to make a flush native coins contract call
 */
function flushCoinsData() {
    var params = [];
    var method = ethereumjs_abi_1.default.methodID('flush', walletUtil_1.flushCoinsTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushCoinsTypes, params);
    return ethereumjs_utils_old_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushCoinsData = flushCoinsData;
/**
 * Returns the create forwarder method calling data
 *
 * @returns {string} - the createForwarder method encoded
 */
function getAddressInitializationData() {
    return walletUtil_1.createForwarderMethodId;
}
exports.getAddressInitializationData = getAddressInitializationData;
/**
 * Returns whether or not the string is a valid Eth address
 *
 * @param {string} address - the tx hash to validate
 * @returns {boolean} - the validation result
 */
function isValidEthAddress(address) {
    return ethereumjs_utils_old_1.isValidAddress(address);
}
exports.isValidEthAddress = isValidEthAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    var bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns the smart contract encoded data
 *
 * @param {string} data The wallet creation data to decode
 * @returns {string[]} - The list of signer addresses
 */
function decodeWalletCreationData(data) {
    if (!data.startsWith(walletUtil_1.walletInitializationFirstBytes)) {
        throw new errors_1.BuildTransactionError("Invalid wallet bytecode: " + data);
    }
    var dataBuffer = buffer_1.Buffer.from(data.slice(2), 'hex');
    // the last 160 bytes contain the serialized address array
    var serializedSigners = dataBuffer.slice(-160);
    var resultEncodedParameters = ethereumjs_abi_1.default.rawDecode(walletUtil_1.walletSimpleConstructor, serializedSigners);
    if (resultEncodedParameters.length !== 1) {
        throw new errors_1.BuildTransactionError("Could not decode wallet constructor bytecode: " + resultEncodedParameters);
    }
    var addresses = resultEncodedParameters[0];
    if (addresses.length !== 3) {
        throw new errors_1.BuildTransactionError("invalid number of addresses in parsed constructor: " + addresses);
    }
    // sometimes ethereumjs-abi removes 0 padding at the start of addresses,
    // so we should pad until they are the standard 20 bytes
    var paddedAddresses = addresses.map(function (address) { return ethereumjs_utils_old_1.stripHexPrefix(address.toString('hex')).padStart(40, '0'); });
    return paddedAddresses.map(function (address) { return ethereumjs_utils_old_1.addHexPrefix(address); });
}
exports.decodeWalletCreationData = decodeWalletCreationData;
/**
 * Decode the given ABI-encoded transfer data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeTransferData(data) {
    if (data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        return decodeNativeTransferData(data);
    }
    else if (data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        return decodeTokenTransferData(data);
    }
    else {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
}
exports.decodeTransferData = decodeTransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisigToken function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed token transfer data
 */
function decodeTokenTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.sendMultiSigTokenTypes, getBufferedByteCode(walletUtil_1.sendMultisigTokenMethodId, data)), to = _a[0], amount = _a[1], tokenContractAddress = _a[2], expireTime = _a[3], sequenceId = _a[4], signature = _a[5];
    return {
        to: ethereumjs_utils_old_1.addHexPrefix(to),
        amount: new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(amount)).toFixed(),
        expireTime: ethereumjs_utils_old_1.bufferToInt(expireTime),
        sequenceId: ethereumjs_utils_old_1.bufferToInt(sequenceId),
        signature: ethereumjs_utils_old_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_utils_old_1.addHexPrefix(tokenContractAddress),
    };
}
exports.decodeTokenTransferData = decodeTokenTransferData;
function decodeERC721TransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data)), to = _a[0], amount = _a[1], internalData = _a[2], expireTime = _a[3], sequenceId = _a[4], signature = _a[5];
    var internalDataHex = ethereumjs_utils_old_1.bufferToHex(internalData);
    if (!internalDataHex.startsWith(walletUtil_1.ERC721SafeTransferTypeMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _b = getRawDecoded(walletUtil_1.ERC721SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC721SafeTransferTypeMethodId, internalDataHex)), from = _b[0], receiver = _b[1], tokenId = _b[2], userSentData = _b[3];
    return {
        to: ethereumjs_utils_old_1.addHexPrefix(receiver),
        from: ethereumjs_utils_old_1.addHexPrefix(from),
        expireTime: ethereumjs_utils_old_1.bufferToInt(expireTime),
        amount: new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(amount)).toFixed(),
        tokenId: new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(tokenId)).toFixed(),
        sequenceId: ethereumjs_utils_old_1.bufferToInt(sequenceId),
        signature: ethereumjs_utils_old_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_utils_old_1.addHexPrefix(to),
        userData: ethereumjs_utils_old_1.bufferToHex(userSentData),
    };
}
exports.decodeERC721TransferData = decodeERC721TransferData;
function decodeERC1155TransferData(data) {
    var _a, _b;
    var from, receiver, userSentData;
    var tokenIds;
    var values;
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _c = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data)), to = _c[0], amount = _c[1], internalData = _c[2], expireTime = _c[3], sequenceId = _c[4], signature = _c[5];
    var internalDataHex = ethereumjs_utils_old_1.bufferToHex(internalData);
    if (internalDataHex.startsWith(walletUtil_1.ERC1155SafeTransferTypeMethodId)) {
        var tokenId = void 0;
        var value = void 0;
        _a = getRawDecoded(walletUtil_1.ERC1155SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155SafeTransferTypeMethodId, internalDataHex)), from = _a[0], receiver = _a[1], tokenId = _a[2], value = _a[3], userSentData = _a[4];
        tokenIds = [new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(tokenId)).toFixed()];
        values = [new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(value)).toFixed()];
    }
    else if (ethereumjs_utils_old_1.bufferToHex(internalData).startsWith(walletUtil_1.ERC1155BatchTransferTypeMethodId)) {
        var tempTokenIds = void 0, tempValues = void 0;
        _b = getRawDecoded(walletUtil_1.ERC1155BatchTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155BatchTransferTypeMethodId, internalDataHex)), from = _b[0], receiver = _b[1], tempTokenIds = _b[2], tempValues = _b[3], userSentData = _b[4];
        tokenIds = tempTokenIds.map(function (x) { return new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(x)).toFixed(); });
        values = tempValues.map(function (x) { return new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(x)).toFixed(); });
    }
    else {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    return {
        to: ethereumjs_utils_old_1.addHexPrefix(receiver),
        from: ethereumjs_utils_old_1.addHexPrefix(from),
        expireTime: ethereumjs_utils_old_1.bufferToInt(expireTime),
        amount: new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(amount)).toFixed(),
        tokenIds: tokenIds,
        values: values,
        sequenceId: ethereumjs_utils_old_1.bufferToInt(sequenceId),
        signature: ethereumjs_utils_old_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_utils_old_1.addHexPrefix(to),
        userData: userSentData,
    };
}
exports.decodeERC1155TransferData = decodeERC1155TransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisig function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeNativeTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data)), to = _a[0], amount = _a[1], internalData = _a[2], expireTime = _a[3], sequenceId = _a[4], signature = _a[5];
    return {
        to: ethereumjs_utils_old_1.addHexPrefix(to),
        amount: new bignumber_js_1.default(ethereumjs_utils_old_1.bufferToHex(amount)).toFixed(),
        expireTime: ethereumjs_utils_old_1.bufferToInt(expireTime),
        sequenceId: ethereumjs_utils_old_1.bufferToInt(sequenceId),
        signature: ethereumjs_utils_old_1.bufferToHex(signature),
        data: ethereumjs_utils_old_1.bufferToHex(internalData),
    };
}
exports.decodeNativeTransferData = decodeNativeTransferData;
/**
 * Decode the given ABI-encoded flush tokens data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeFlushTokensData(data) {
    if (!data.startsWith(walletUtil_1.flushForwarderTokensMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.flushTokensTypes, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodId, data)), forwarderAddress = _a[0], tokenAddress = _a[1];
    return {
        forwarderAddress: ethereumjs_utils_old_1.addHexPrefix(forwarderAddress),
        tokenAddress: ethereumjs_utils_old_1.addHexPrefix(tokenAddress),
    };
}
exports.decodeFlushTokensData = decodeFlushTokensData;
/**
 * Classify the given transaction data based as a transaction type.
 * ETH transactions are defined by the first 8 bytes of the transaction data, also known as the method id
 *
 * @param {string} data The data to classify the transaction with
 * @returns {TransactionType} The classified transaction type
 */
function classifyTransaction(data) {
    if (data.length < 10) {
        // contract calls must have at least 4 bytes (method id) and '0x'
        // if it doesn't have enough data to be a contract call it must be a single sig send
        return baseCoin_1.TransactionType.SingleSigSend;
    }
    // TODO(STLX-1970): validate if we are going to constraint to some methods allowed
    var transactionType = transactionTypesMap[data.slice(0, 10).toLowerCase()];
    if (transactionType === undefined) {
        transactionType = baseCoin_1.TransactionType.ContractCall;
    }
    return transactionType;
}
exports.classifyTransaction = classifyTransaction;
/**
 * A transaction types map according to the starting part of the encoded data
 */
var transactionTypesMap = (_a = {},
    _a[walletUtil_1.walletInitializationFirstBytes] = baseCoin_1.TransactionType.WalletInitialization,
    _a[walletUtil_1.createForwarderMethodId] = baseCoin_1.TransactionType.AddressInitialization,
    _a[walletUtil_1.sendMultisigMethodId] = baseCoin_1.TransactionType.Send,
    _a[walletUtil_1.flushForwarderTokensMethodId] = baseCoin_1.TransactionType.FlushTokens,
    _a[walletUtil_1.flushCoinsMethodId] = baseCoin_1.TransactionType.FlushCoins,
    _a[walletUtil_1.sendMultisigTokenMethodId] = baseCoin_1.TransactionType.Send,
    _a[stakingUtils_1.LockMethodId] = baseCoin_1.TransactionType.StakingLock,
    _a[stakingUtils_1.VoteMethodId] = baseCoin_1.TransactionType.StakingVote,
    _a[stakingUtils_1.ActivateMethodId] = baseCoin_1.TransactionType.StakingActivate,
    _a[stakingUtils_1.UnvoteMethodId] = baseCoin_1.TransactionType.StakingUnvote,
    _a[stakingUtils_1.UnlockMethodId] = baseCoin_1.TransactionType.StakingUnlock,
    _a[stakingUtils_1.WithdrawMethodId] = baseCoin_1.TransactionType.StakingWithdraw,
    _a);
/**
 *
 * @param {number} num number to be converted to hex
 * @returns {string} the hex number
 */
function numberToHexString(num) {
    var hex = num.toString(16);
    return hex.length % 2 === 0 ? '0x' + hex : '0x0' + hex;
}
exports.numberToHexString = numberToHexString;
/**
 *
 * @param {string} hex The hex string to be converted
 * @returns {number} the resulting number
 */
function hexStringToNumber(hex) {
    return parseInt(hex.slice(2), 16);
}
exports.hexStringToNumber = hexStringToNumber;
/**
 * Generates an address of the forwarder address to be deployed
 *
 * @param {string} contractAddress the address which is creating this new address
 * @param {number} contractCounter the nonce of the contract address
 * @returns {string} the calculated forwarder contract address
 */
function calculateForwarderAddress(contractAddress, contractCounter) {
    var forwarderAddress = ethereumjs_utils_old_1.generateAddress(contractAddress, contractCounter);
    return ethereumjs_utils_old_1.addHexPrefix(forwarderAddress.toString('hex'));
}
exports.calculateForwarderAddress = calculateForwarderAddress;
/**
 * Calculate the forwarder v1 address that will be generated if `creatorAddress` creates it with salt `salt`
 * and initcode `inicode using the create2 opcode
 * @param {string} creatorAddress The address that is sending the tx to create a new address, hex string
 * @param {string} salt The salt to create the address with using create2, hex string
 * @param {string} initcode The initcode that will be deployed to the address, hex string
 * @return {string} The calculated address
 */
function calculateForwarderV1Address(creatorAddress, salt, initcode) {
    var forwarderV1Address = ethereumjs_util_1.generateAddress2(buffer_1.Buffer.from(ethereumjs_utils_old_1.stripHexPrefix(creatorAddress), 'hex'), buffer_1.Buffer.from(ethereumjs_utils_old_1.stripHexPrefix(salt), 'hex'), buffer_1.Buffer.from(ethereumjs_utils_old_1.stripHexPrefix(initcode), 'hex'));
    return ethereumjs_utils_old_1.addHexPrefix(forwarderV1Address.toString('hex'));
}
exports.calculateForwarderV1Address = calculateForwarderV1Address;
/**
 * Take the implementation address for the proxy contract, and get the binary initcode for the associated proxy
 * @param {string} implementationAddress The address of the implementation contract for the proxy
 * @return {string} Binary hex string of the proxy
 */
function getProxyInitcode(implementationAddress) {
    var target = ethereumjs_utils_old_1.stripHexPrefix(implementationAddress.toLowerCase()).padStart(40, '0');
    // bytecode of the proxy, from:
    // https://github.com/BitGo/eth-multisig-v4/blob/d546a937f90f93e83b3423a5bf933d1d77c677c3/contracts/CloneFactory.sol#L42-L56
    return "0x3d602d80600a3d3981f3363d3d373d3d3d363d73" + target + "5af43d82803e903d91602b57fd5bf3";
}
exports.getProxyInitcode = getProxyInitcode;
/**
 * Convert the given signature parts to a string representation
 *
 * @param {SignatureParts} sig The signature to convert to string
 * @returns {string} String representation of the signature
 */
function toStringSig(sig) {
    return ethereumjs_utils_old_1.bufferToHex(buffer_1.Buffer.concat([ethereumjs_utils_old_1.setLengthLeft(sig.r, 32), ethereumjs_utils_old_1.setLengthLeft(sig.s, 32), ethereumjs_utils_old_1.toBuffer(sig.v)]));
}
exports.toStringSig = toStringSig;
/**
 * Return whether or not the given tx data has a signature
 *
 * @param {TxData} txData The transaction data to check for signature
 * @returns {boolean} true if the tx has a signature, else false
 */
function hasSignature(txData) {
    return (txData.v !== undefined &&
        txData.r !== undefined &&
        txData.s !== undefined &&
        txData.v.length > 0 &&
        txData.r.length > 0 &&
        txData.s.length > 0);
}
exports.hasSignature = hasSignature;
/**
 * Get the raw data decoded for some types
 *
 * @param {string[]} types ABI types definition
 * @param {Buffer} serializedArgs encoded args
 * @returns {Buffer[]} the decoded raw
 */
function getRawDecoded(types, serializedArgs) {
    return ethereumjs_abi_1.default.rawDecode(types, serializedArgs);
}
exports.getRawDecoded = getRawDecoded;
/**
 * Get the buffered bytecode from rawData using a methodId as delimiter
 *
 * @param {string} methodId the hex encoded method Id
 * @param {string} rawData the hex encoded raw data
 * @returns {Buffer} data buffered bytecode
 */
function getBufferedByteCode(methodId, rawData) {
    var splitBytecode = rawData.split(methodId);
    if (splitBytecode.length !== 2) {
        throw new errors_1.BuildTransactionError("Invalid send bytecode: " + rawData);
    }
    return buffer_1.Buffer.from(splitBytecode[1], 'hex');
}
exports.getBufferedByteCode = getBufferedByteCode;
/**
 * Get the statics coin object matching a given contract address if it exists
 *
 * @param tokenContractAddress The contract address to match against
 * @returns statics BaseCoin object for the matching token
 */
function getToken(tokenContractAddress, network) {
    var tokens = statics_1.coins.filter(function (coin) {
        if (coin instanceof statics_1.ContractAddressDefinedToken) {
            return (coin.network.type === network.type && coin.contractAddress.toLowerCase() === tokenContractAddress.toLowerCase());
        }
        return false;
    });
    // if length of tokens is 1, return the first, else return undefined
    // Can't directly index into tokens, or call `length`, so we use map to get an array
    var tokensArray = tokens.map(function (token) { return token; });
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        assert_1.default(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getToken = getToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9ldGgvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlDQUFnQztBQUNoQyxrREFBNEI7QUFDNUIsNkRBUzhCO0FBQzlCLG1EQUFtRDtBQUNuRCwwQ0FBNEc7QUFDNUcsa0VBQXlDO0FBQ3pDLDhEQUFnRDtBQUVoRCw4REFBcUM7QUFDckMsNkNBQXlFO0FBQ3pFLHdDQUE4QztBQUM5QyxxREFPOEI7QUFZOUIsMkNBa0JzQjtBQUN0QixpQ0FBNkM7QUFFN0M7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsT0FBd0I7SUFDaEQsT0FBTyxnQkFBYyxDQUFDLGNBQWM7SUFDbEMsd0VBQXdFO0lBQ3hFLFNBQVMsRUFDVDtRQUNFLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSTtRQUNsQixTQUFTLEVBQUUsT0FBTyxDQUFDLE9BQU87UUFDMUIsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPO0tBQ3pCLEVBQ0QsUUFBUSxDQUNULENBQUM7QUFDSixDQUFDO0FBWEQsOEJBV0M7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILFNBQXNCLFlBQVksQ0FDaEMsZUFBdUIsRUFDdkIsT0FBZ0IsRUFDaEIsWUFBNEI7Ozs7WUFFNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQzFCLE1BQU0sSUFBSSxxQkFBWSxDQUFDLHFCQUFxQixDQUFDLENBQUM7YUFDL0M7WUFDSyxLQUFLLEdBQUcsMEJBQWtCLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUN6RSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3BCLHNCQUFPLEtBQUssQ0FBQyxZQUFZLEVBQUUsRUFBQzs7O0NBQzdCO0FBWEQsb0NBV0M7QUFF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cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7XG4gIGFkZEhleFByZWZpeCxcbiAgYnVmZmVyVG9IZXgsXG4gIGJ1ZmZlclRvSW50LFxuICBnZW5lcmF0ZUFkZHJlc3MsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBzZXRMZW5ndGhMZWZ0LFxuICBzdHJpcEhleFByZWZpeCxcbiAgdG9CdWZmZXIsXG59IGZyb20gJ2V0aGVyZXVtanMtdXRpbHMtb2xkJztcbmltcG9ydCB7IGdlbmVyYXRlQWRkcmVzczIgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgQmFzZUNvaW4sIEJhc2VOZXR3b3JrLCBjb2lucywgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuLCBFdGhlcmV1bU5ldHdvcmsgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgRXRoZXJldW1BYmkgZnJvbSAnZXRoZXJldW1qcy1hYmknO1xuaW1wb3J0IEV0aGVyZXVtQ29tbW9uIGZyb20gJ0BldGhlcmV1bWpzL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIFNpZ25pbmdFcnJvciB9IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQge1xuICBBY3RpdmF0ZU1ldGhvZElkLFxuICBMb2NrTWV0aG9kSWQsXG4gIFVubG9ja01ldGhvZElkLFxuICBVbnZvdGVNZXRob2RJZCxcbiAgVm90ZU1ldGhvZElkLFxuICBXaXRoZHJhd01ldGhvZElkLFxufSBmcm9tICcuLi9jZWxvL3N0YWtpbmdVdGlscyc7XG5pbXBvcnQge1xuICBFUkMxMTU1VHJhbnNmZXJEYXRhLFxuICBFUkM3MjFUcmFuc2ZlckRhdGEsXG4gIEZsdXNoVG9rZW5zRGF0YSxcbiAgTmF0aXZlVHJhbnNmZXJEYXRhLFxuICBTaWduYXR1cmVQYXJ0cyxcbiAgVG9rZW5UcmFuc2ZlckRhdGEsXG4gIFRyYW5zZmVyRGF0YSxcbiAgVHhEYXRhLFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQsXG4gIEVSQzExNTVCYXRjaFRyYW5zZmVyVHlwZU1ldGhvZElkLFxuICBFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVzLFxuICBFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkLFxuICBFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZXMsXG4gIEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCxcbiAgRVJDNzIxU2FmZVRyYW5zZmVyVHlwZXMsXG4gIGZsdXNoQ29pbnNNZXRob2RJZCxcbiAgZmx1c2hDb2luc1R5cGVzLFxuICBmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkLFxuICBmbHVzaFRva2Vuc1R5cGVzLFxuICBzZW5kTXVsdGlzaWdNZXRob2RJZCxcbiAgc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCxcbiAgc2VuZE11bHRpU2lnVG9rZW5UeXBlcyxcbiAgc2VuZE11bHRpU2lnVHlwZXMsXG4gIHdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcyxcbiAgd2FsbGV0U2ltcGxlQ29uc3RydWN0b3IsXG59IGZyb20gJy4vd2FsbGV0VXRpbCc7XG5pbXBvcnQgeyBFdGhUcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBAcGFyYW0gbmV0d29ya1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbW9uKG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayk6IEV0aGVyZXVtQ29tbW9uIHtcbiAgcmV0dXJuIEV0aGVyZXVtQ29tbW9uLmZvckN1c3RvbUNoYWluKFxuICAgIC8vIHVzZSB0aGUgbWFpbm5ldCBjb25maWcgYXMgYSBiYXNlLCBvdmVycmlkZSBjaGFpbiBpZHMgYW5kIG5ldHdvcmsgbmFtZVxuICAgICdtYWlubmV0JyxcbiAgICB7XG4gICAgICBuYW1lOiBuZXR3b3JrLnR5cGUsXG4gICAgICBuZXR3b3JrSWQ6IG5ldHdvcmsuY2hhaW5JZCxcbiAgICAgIGNoYWluSWQ6IG5ldHdvcmsuY2hhaW5JZCxcbiAgICB9LFxuICAgICdsb25kb24nLFxuICApO1xufVxuXG4vKipcbiAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtXG4gKiBhbmQgdGhlIHByb3ZpZGVkIGNvbW1vbiBmb3IgdGhlIGJsb2NrY2hhaW5cbiAqXG4gKiBAcGFyYW0ge1R4RGF0YX0gdHJhbnNhY3Rpb25EYXRhIHRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIHNpZ25cbiAqIEBwYXJhbSB7S2V5UGFpcn0ga2V5UGFpciB0aGUgc2lnbmVyJ3Mga2V5cGFpclxuICogQHBhcmFtIHtFdGhlcmV1bUNvbW1vbn0gY3VzdG9tQ29tbW9uIHRoZSBuZXR3b3JrJ3MgY3VzdG9tIGNvbW1vblxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHRyYW5zYWN0aW9uIHNpZ25lZCBhbmQgZW5jb2RlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkludGVybmFsKFxuICB0cmFuc2FjdGlvbkRhdGE6IFR4RGF0YSxcbiAga2V5UGFpcjogS2V5UGFpcixcbiAgY3VzdG9tQ29tbW9uOiBFdGhlcmV1bUNvbW1vbixcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmICgha2V5UGFpci5nZXRLZXlzKCkucHJ2KSB7XG4gICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICB9XG4gIGNvbnN0IGV0aFR4ID0gRXRoVHJhbnNhY3Rpb25EYXRhLmZyb21Kc29uKHRyYW5zYWN0aW9uRGF0YSwgY3VzdG9tQ29tbW9uKTtcbiAgZXRoVHguc2lnbihrZXlQYWlyKTtcbiAgcmV0dXJuIGV0aFR4LnRvU2VyaWFsaXplZCgpO1xufVxuXG4vKipcbiAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtUeERhdGF9IHRyYW5zYWN0aW9uRGF0YSB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduXG4gKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXIgdGhlIHNpZ25lcidzIGtleXBhaXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2FjdGlvbiBzaWduZWQgYW5kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ24odHJhbnNhY3Rpb25EYXRhOiBUeERhdGEsIGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gc2lnbkludGVybmFsKHRyYW5zYWN0aW9uRGF0YSwga2V5UGFpciwgZ2V0Q29tbW9uKGNvaW5zLmdldCgndGV0aCcpLm5ldHdvcmsgYXMgRXRoZXJldW1OZXR3b3JrKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0byBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQW1vdW50IHRvIHRyYW5mZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIGFkaXRpb25hbCBtZXRob2QgY2FsbCBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwaXJlVGltZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2VJZCBzZXF1ZW5jZSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBzaWduYXR1cmUgb2YgdGhlIGNhbGxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0tIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kTXVsdGlTaWdEYXRhKFxuICB0bzogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxuICBkYXRhOiBzdHJpbmcsXG4gIGV4cGlyZVRpbWU6IG51bWJlcixcbiAgc2VxdWVuY2VJZDogbnVtYmVyLFxuICBzaWduYXR1cmU6IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IFt0bywgdmFsdWUsIHRvQnVmZmVyKGRhdGEpLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCB0b0J1ZmZlcihzaWduYXR1cmUpXTtcbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ3NlbmRNdWx0aVNpZycsIHNlbmRNdWx0aVNpZ1R5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShzZW5kTXVsdGlTaWdUeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRyYWN0IG1ldGhvZCBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG8gZGVzdGluYXRpb24gYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEFtb3VudCB0byB0cmFuZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5Db250cmFjdEFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIGVyYzIwIHRva2VuIGNvbnRyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gZXhwaXJlVGltZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2VJZCBzZXF1ZW5jZSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBzaWduYXR1cmUgb2YgdGhlIGNhbGxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0tIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kTXVsdGlTaWdUb2tlbkRhdGEoXG4gIHRvOiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcsXG4gIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGV4cGlyZVRpbWU6IG51bWJlcixcbiAgc2VxdWVuY2VJZDogbnVtYmVyLFxuICBzaWduYXR1cmU6IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IFt0bywgdmFsdWUsIHRva2VuQ29udHJhY3RBZGRyZXNzLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCB0b0J1ZmZlcihzaWduYXR1cmUpXTtcblxuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnVG9rZW4nLCBzZW5kTXVsdGlTaWdUb2tlblR5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShzZW5kTXVsdGlTaWdUb2tlblR5cGVzLCBwYXJhbXMpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIHJlcXVpcmVkIHRvIG1ha2UgYSBmbHVzaCB0b2tlbnMgY29udHJhY3QgY2FsbFxuICpcbiAqIEBwYXJhbSBmb3J3YXJkZXJBZGRyZXNzIFRoZSBmb3J3YXJkZXIgYWRkcmVzcyB0byBmbHVzaFxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUaGUgdG9rZW4gYWRkcmVzcyB0byBmbHVzaCBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFRva2Vuc0RhdGEoZm9yd2FyZGVyQWRkcmVzcywgdG9rZW5BZGRyZXNzKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyYW1zID0gW2ZvcndhcmRlckFkZHJlc3MsIHRva2VuQWRkcmVzc107XG4gIGNvbnN0IG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdmbHVzaEZvcndhcmRlclRva2VucycsIGZsdXNoVG9rZW5zVHlwZXMpO1xuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKGZsdXNoVG9rZW5zVHlwZXMsIHBhcmFtcyk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgcmVxdWlyZWQgdG8gbWFrZSBhIGZsdXNoIG5hdGl2ZSBjb2lucyBjb250cmFjdCBjYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaENvaW5zRGF0YSgpOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ2ZsdXNoJywgZmx1c2hDb2luc1R5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShmbHVzaENvaW5zVHlwZXMsIHBhcmFtcyk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcmVhdGUgZm9yd2FyZGVyIG1ldGhvZCBjYWxsaW5nIGRhdGFcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjcmVhdGVGb3J3YXJkZXIgbWV0aG9kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNyZWF0ZUZvcndhcmRlck1ldGhvZElkO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEV0aCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSB0aGUgdHggaGFzaCB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRXRoQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudCBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IC0gdGhlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQW1vdW50KGFtb3VudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYW1vdW50KTtcbiAgcmV0dXJuIGJpZ051bWJlckFtb3VudC5pc0ludGVnZXIoKSAmJiBiaWdOdW1iZXJBbW91bnQuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbygwKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzbWFydCBjb250cmFjdCBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgd2FsbGV0IGNyZWF0aW9uIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gVGhlIGxpc3Qgb2Ygc2lnbmVyIGFkZHJlc3Nlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlV2FsbGV0Q3JlYXRpb25EYXRhKGRhdGE6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgod2FsbGV0SW5pdGlhbGl6YXRpb25GaXJzdEJ5dGVzKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgd2FsbGV0IGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBkYXRhQnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YS5zbGljZSgyKSwgJ2hleCcpO1xuXG4gIC8vIHRoZSBsYXN0IDE2MCBieXRlcyBjb250YWluIHRoZSBzZXJpYWxpemVkIGFkZHJlc3MgYXJyYXlcbiAgY29uc3Qgc2VyaWFsaXplZFNpZ25lcnMgPSBkYXRhQnVmZmVyLnNsaWNlKC0xNjApO1xuXG4gIGNvbnN0IHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzID0gRXRoZXJldW1BYmkucmF3RGVjb2RlKHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yLCBzZXJpYWxpemVkU2lnbmVycyk7XG4gIGlmIChyZXN1bHRFbmNvZGVkUGFyYW1ldGVycy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBDb3VsZCBub3QgZGVjb2RlIHdhbGxldCBjb25zdHJ1Y3RvciBieXRlY29kZTogJHtyZXN1bHRFbmNvZGVkUGFyYW1ldGVyc31gKTtcbiAgfVxuXG4gIGNvbnN0IGFkZHJlc3NlczogQk5bXSA9IHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzWzBdO1xuICBpZiAoYWRkcmVzc2VzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYGludmFsaWQgbnVtYmVyIG9mIGFkZHJlc3NlcyBpbiBwYXJzZWQgY29uc3RydWN0b3I6ICR7YWRkcmVzc2VzfWApO1xuICB9XG5cbiAgLy8gc29tZXRpbWVzIGV0aGVyZXVtanMtYWJpIHJlbW92ZXMgMCBwYWRkaW5nIGF0IHRoZSBzdGFydCBvZiBhZGRyZXNzZXMsXG4gIC8vIHNvIHdlIHNob3VsZCBwYWQgdW50aWwgdGhleSBhcmUgdGhlIHN0YW5kYXJkIDIwIGJ5dGVzXG4gIGNvbnN0IHBhZGRlZEFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHN0cmlwSGV4UHJlZml4KGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKS5wYWRTdGFydCg0MCwgJzAnKSk7XG5cbiAgcmV0dXJuIHBhZGRlZEFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IGFkZEhleFByZWZpeChhZGRyZXNzKSk7XG59XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCB0cmFuc2ZlciBkYXRhIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBUcmFuc2ZlckRhdGEge1xuICBpZiAoZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHJldHVybiBkZWNvZGVOYXRpdmVUcmFuc2ZlckRhdGEoZGF0YSk7XG4gIH0gZWxzZSBpZiAoZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQpKSB7XG4gICAgcmV0dXJuIGRlY29kZVRva2VuVHJhbnNmZXJEYXRhKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIERlY29kZSB0aGUgZ2l2ZW4gQUJJLWVuY29kZWQgdHJhbnNmZXIgZGF0YSBmb3IgdGhlIHNlbmRNdWx0aXNpZ1Rva2VuIGZ1bmN0aW9uIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRva2VuIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRva2VuVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IFRva2VuVHJhbnNmZXJEYXRhIHtcbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBbdG8sIGFtb3VudCwgdG9rZW5Db250cmFjdEFkZHJlc3MsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkLCBkYXRhKSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHRvOiBhZGRIZXhQcmVmaXgodG8pLFxuICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleChhbW91bnQpKS50b0ZpeGVkKCksXG4gICAgZXhwaXJlVGltZTogYnVmZmVyVG9JbnQoZXhwaXJlVGltZSksXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCksXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUpLFxuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBhZGRIZXhQcmVmaXgodG9rZW5Db250cmFjdEFkZHJlc3MpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRVJDNzIxVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IEVSQzcyMVRyYW5zZmVyRGF0YSB7XG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCBpbnRlcm5hbERhdGEsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnTWV0aG9kSWQsIGRhdGEpLFxuICApO1xuXG4gIGNvbnN0IGludGVybmFsRGF0YUhleCA9IGJ1ZmZlclRvSGV4KGludGVybmFsRGF0YSk7XG4gIGlmICghaW50ZXJuYWxEYXRhSGV4LnN0YXJ0c1dpdGgoRVJDNzIxU2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFtmcm9tLCByZWNlaXZlciwgdG9rZW5JZCwgdXNlclNlbnREYXRhXSA9IGdldFJhd0RlY29kZWQoXG4gICAgRVJDNzIxU2FmZVRyYW5zZmVyVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShFUkM3MjFTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQsIGludGVybmFsRGF0YUhleCksXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB0bzogYWRkSGV4UHJlZml4KHJlY2VpdmVyKSxcbiAgICBmcm9tOiBhZGRIZXhQcmVmaXgoZnJvbSksXG4gICAgZXhwaXJlVGltZTogYnVmZmVyVG9JbnQoZXhwaXJlVGltZSksXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCkpLnRvRml4ZWQoKSxcbiAgICB0b2tlbklkOiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHRva2VuSWQpKS50b0ZpeGVkKCksXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCksXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUpLFxuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBhZGRIZXhQcmVmaXgodG8pLFxuICAgIHVzZXJEYXRhOiBidWZmZXJUb0hleCh1c2VyU2VudERhdGEpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRVJDMTE1NVRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBFUkMxMTU1VHJhbnNmZXJEYXRhIHtcbiAgbGV0IGZyb20sIHJlY2VpdmVyLCB1c2VyU2VudERhdGE7XG4gIGxldCB0b2tlbklkczogc3RyaW5nW107XG4gIGxldCB2YWx1ZXM6IHN0cmluZ1tdO1xuXG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCBpbnRlcm5hbERhdGEsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnTWV0aG9kSWQsIGRhdGEpLFxuICApO1xuXG4gIGNvbnN0IGludGVybmFsRGF0YUhleCA9IGJ1ZmZlclRvSGV4KGludGVybmFsRGF0YSk7XG4gIGlmIChpbnRlcm5hbERhdGFIZXguc3RhcnRzV2l0aChFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkKSkge1xuICAgIGxldCB0b2tlbklkO1xuICAgIGxldCB2YWx1ZTtcblxuICAgIFtmcm9tLCByZWNlaXZlciwgdG9rZW5JZCwgdmFsdWUsIHVzZXJTZW50RGF0YV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkLCBpbnRlcm5hbERhdGFIZXgpLFxuICAgICk7XG5cbiAgICB0b2tlbklkcyA9IFtuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHRva2VuSWQpKS50b0ZpeGVkKCldO1xuICAgIHZhbHVlcyA9IFtuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHZhbHVlKSkudG9GaXhlZCgpXTtcbiAgfSBlbHNlIGlmIChidWZmZXJUb0hleChpbnRlcm5hbERhdGEpLnN0YXJ0c1dpdGgoRVJDMTE1NUJhdGNoVHJhbnNmZXJUeXBlTWV0aG9kSWQpKSB7XG4gICAgbGV0IHRlbXBUb2tlbklkcywgdGVtcFZhbHVlcztcbiAgICBbZnJvbSwgcmVjZWl2ZXIsIHRlbXBUb2tlbklkcywgdGVtcFZhbHVlcywgdXNlclNlbnREYXRhXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVNZXRob2RJZCwgaW50ZXJuYWxEYXRhSGV4KSxcbiAgICApO1xuICAgIHRva2VuSWRzID0gdGVtcFRva2VuSWRzLm1hcCgoeCkgPT4gbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh4KSkudG9GaXhlZCgpKTtcbiAgICB2YWx1ZXMgPSB0ZW1wVmFsdWVzLm1hcCgoeCkgPT4gbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh4KSkudG9GaXhlZCgpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvOiBhZGRIZXhQcmVmaXgocmVjZWl2ZXIpLFxuICAgIGZyb206IGFkZEhleFByZWZpeChmcm9tKSxcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lKSxcbiAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoYW1vdW50KSkudG9GaXhlZCgpLFxuICAgIHRva2VuSWRzLFxuICAgIHZhbHVlcyxcbiAgICBzZXF1ZW5jZUlkOiBidWZmZXJUb0ludChzZXF1ZW5jZUlkKSxcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSksXG4gICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IGFkZEhleFByZWZpeCh0byksXG4gICAgdXNlckRhdGE6IHVzZXJTZW50RGF0YSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIHRyYW5zZmVyIGRhdGEgZm9yIHRoZSBzZW5kTXVsdGlzaWcgZnVuY3Rpb24gYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyBwYXJzZWQgdHJhbnNmZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmF0aXZlVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IE5hdGl2ZVRyYW5zZmVyRGF0YSB7XG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCBpbnRlcm5hbERhdGEsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnTWV0aG9kSWQsIGRhdGEpLFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgdG86IGFkZEhleFByZWZpeCh0byksXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCkpLnRvRml4ZWQoKSxcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lKSxcbiAgICBzZXF1ZW5jZUlkOiBidWZmZXJUb0ludChzZXF1ZW5jZUlkKSxcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSksXG4gICAgZGF0YTogYnVmZmVyVG9IZXgoaW50ZXJuYWxEYXRhKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIGZsdXNoIHRva2VucyBkYXRhIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUZsdXNoVG9rZW5zRGF0YShkYXRhOiBzdHJpbmcpOiBGbHVzaFRva2Vuc0RhdGEge1xuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFtmb3J3YXJkZXJBZGRyZXNzLCB0b2tlbkFkZHJlc3NdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBmbHVzaFRva2Vuc1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCwgZGF0YSksXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBmb3J3YXJkZXJBZGRyZXNzOiBhZGRIZXhQcmVmaXgoZm9yd2FyZGVyQWRkcmVzcyksXG4gICAgdG9rZW5BZGRyZXNzOiBhZGRIZXhQcmVmaXgodG9rZW5BZGRyZXNzKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDbGFzc2lmeSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gZGF0YSBiYXNlZCBhcyBhIHRyYW5zYWN0aW9uIHR5cGUuXG4gKiBFVEggdHJhbnNhY3Rpb25zIGFyZSBkZWZpbmVkIGJ5IHRoZSBmaXJzdCA4IGJ5dGVzIG9mIHRoZSB0cmFuc2FjdGlvbiBkYXRhLCBhbHNvIGtub3duIGFzIHRoZSBtZXRob2QgaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBjbGFzc2lmeSB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICogQHJldHVybnMge1RyYW5zYWN0aW9uVHlwZX0gVGhlIGNsYXNzaWZpZWQgdHJhbnNhY3Rpb24gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NpZnlUcmFuc2FjdGlvbihkYXRhOiBzdHJpbmcpOiBUcmFuc2FjdGlvblR5cGUge1xuICBpZiAoZGF0YS5sZW5ndGggPCAxMCkge1xuICAgIC8vIGNvbnRyYWN0IGNhbGxzIG11c3QgaGF2ZSBhdCBsZWFzdCA0IGJ5dGVzIChtZXRob2QgaWQpIGFuZCAnMHgnXG4gICAgLy8gaWYgaXQgZG9lc24ndCBoYXZlIGVub3VnaCBkYXRhIHRvIGJlIGEgY29udHJhY3QgY2FsbCBpdCBtdXN0IGJlIGEgc2luZ2xlIHNpZyBzZW5kXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TaW5nbGVTaWdTZW5kO1xuICB9XG5cbiAgLy8gVE9ETyhTVExYLTE5NzApOiB2YWxpZGF0ZSBpZiB3ZSBhcmUgZ29pbmcgdG8gY29uc3RyYWludCB0byBzb21lIG1ldGhvZHMgYWxsb3dlZFxuICBsZXQgdHJhbnNhY3Rpb25UeXBlID0gdHJhbnNhY3Rpb25UeXBlc01hcFtkYXRhLnNsaWNlKDAsIDEwKS50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKHRyYW5zYWN0aW9uVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNhY3Rpb25UeXBlID0gVHJhbnNhY3Rpb25UeXBlLkNvbnRyYWN0Q2FsbDtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvblR5cGU7XG59XG5cbi8qKlxuICogQSB0cmFuc2FjdGlvbiB0eXBlcyBtYXAgYWNjb3JkaW5nIHRvIHRoZSBzdGFydGluZyBwYXJ0IG9mIHRoZSBlbmNvZGVkIGRhdGFcbiAqL1xuY29uc3QgdHJhbnNhY3Rpb25UeXBlc01hcCA9IHtcbiAgW3dhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlc106IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbixcbiAgW2NyZWF0ZUZvcndhcmRlck1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbixcbiAgW3NlbmRNdWx0aXNpZ01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlNlbmQsXG4gIFtmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLkZsdXNoVG9rZW5zLFxuICBbZmx1c2hDb2luc01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLkZsdXNoQ29pbnMsXG4gIFtzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlNlbmQsXG4gIFtMb2NrTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0xvY2ssXG4gIFtWb3RlTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1ZvdGUsXG4gIFtBY3RpdmF0ZU1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZSxcbiAgW1Vudm90ZU1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbnZvdGUsXG4gIFtVbmxvY2tNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVW5sb2NrLFxuICBbV2l0aGRyYXdNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXcsXG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIG51bWJlciB0byBiZSBjb252ZXJ0ZWQgdG8gaGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgaGV4IG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhTdHJpbmcobnVtOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPT09IDAgPyAnMHgnICsgaGV4IDogJzB4MCcgKyBoZXg7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXggVGhlIGhleCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcmVzdWx0aW5nIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4U3RyaW5nVG9OdW1iZXIoaGV4OiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gcGFyc2VJbnQoaGV4LnNsaWNlKDIpLCAxNik7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgdGhlIGZvcndhcmRlciBhZGRyZXNzIHRvIGJlIGRlcGxveWVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gY29udHJhY3RDb3VudGVyIHRoZSBub25jZSBvZiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGNhbGN1bGF0ZWQgZm9yd2FyZGVyIGNvbnRyYWN0IGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZvcndhcmRlckFkZHJlc3MoY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIGNvbnRyYWN0Q291bnRlcjogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgZm9yd2FyZGVyQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0Q291bnRlcik7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoZm9yd2FyZGVyQWRkcmVzcy50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZm9yd2FyZGVyIHYxIGFkZHJlc3MgdGhhdCB3aWxsIGJlIGdlbmVyYXRlZCBpZiBgY3JlYXRvckFkZHJlc3NgIGNyZWF0ZXMgaXQgd2l0aCBzYWx0IGBzYWx0YFxuICogYW5kIGluaXRjb2RlIGBpbmljb2RlIHVzaW5nIHRoZSBjcmVhdGUyIG9wY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGNyZWF0b3JBZGRyZXNzIFRoZSBhZGRyZXNzIHRoYXQgaXMgc2VuZGluZyB0aGUgdHggdG8gY3JlYXRlIGEgbmV3IGFkZHJlc3MsIGhleCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzYWx0IFRoZSBzYWx0IHRvIGNyZWF0ZSB0aGUgYWRkcmVzcyB3aXRoIHVzaW5nIGNyZWF0ZTIsIGhleCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0Y29kZSBUaGUgaW5pdGNvZGUgdGhhdCB3aWxsIGJlIGRlcGxveWVkIHRvIHRoZSBhZGRyZXNzLCBoZXggc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjYWxjdWxhdGVkIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZvcndhcmRlclYxQWRkcmVzcyhjcmVhdG9yQWRkcmVzczogc3RyaW5nLCBzYWx0OiBzdHJpbmcsIGluaXRjb2RlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBmb3J3YXJkZXJWMUFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3MyKFxuICAgIEJ1ZmZlci5mcm9tKHN0cmlwSGV4UHJlZml4KGNyZWF0b3JBZGRyZXNzKSwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKHN0cmlwSGV4UHJlZml4KHNhbHQpLCAnaGV4JyksXG4gICAgQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoaW5pdGNvZGUpLCAnaGV4JyksXG4gICk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoZm9yd2FyZGVyVjFBZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogVGFrZSB0aGUgaW1wbGVtZW50YXRpb24gYWRkcmVzcyBmb3IgdGhlIHByb3h5IGNvbnRyYWN0LCBhbmQgZ2V0IHRoZSBiaW5hcnkgaW5pdGNvZGUgZm9yIHRoZSBhc3NvY2lhdGVkIHByb3h5XG4gKiBAcGFyYW0ge3N0cmluZ30gaW1wbGVtZW50YXRpb25BZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBjb250cmFjdCBmb3IgdGhlIHByb3h5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJpbmFyeSBoZXggc3RyaW5nIG9mIHRoZSBwcm94eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJveHlJbml0Y29kZShpbXBsZW1lbnRhdGlvbkFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHRhcmdldCA9IHN0cmlwSGV4UHJlZml4KGltcGxlbWVudGF0aW9uQWRkcmVzcy50b0xvd2VyQ2FzZSgpKS5wYWRTdGFydCg0MCwgJzAnKTtcblxuICAvLyBieXRlY29kZSBvZiB0aGUgcHJveHksIGZyb206XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9ldGgtbXVsdGlzaWctdjQvYmxvYi9kNTQ2YTkzN2Y5MGY5M2U4M2IzNDIzYTViZjkzM2QxZDc3YzY3N2MzL2NvbnRyYWN0cy9DbG9uZUZhY3Rvcnkuc29sI0w0Mi1MNTZcbiAgcmV0dXJuIGAweDNkNjAyZDgwNjAwYTNkMzk4MWYzMzYzZDNkMzczZDNkM2QzNjNkNzMke3RhcmdldH01YWY0M2Q4MjgwM2U5MDNkOTE2MDJiNTdmZDViZjNgO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHNpZ25hdHVyZSBwYXJ0cyB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U2lnbmF0dXJlUGFydHN9IHNpZyBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQgdG8gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNpZ25hdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdTaWcoc2lnOiBTaWduYXR1cmVQYXJ0cyk6IHN0cmluZyB7XG4gIHJldHVybiBidWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtzZXRMZW5ndGhMZWZ0KHNpZy5yLCAzMiksIHNldExlbmd0aExlZnQoc2lnLnMsIDMyKSwgdG9CdWZmZXIoc2lnLnYpXSkpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdHggZGF0YSBoYXMgYSBzaWduYXR1cmVcbiAqXG4gKiBAcGFyYW0ge1R4RGF0YX0gdHhEYXRhIFRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIGNoZWNrIGZvciBzaWduYXR1cmVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0eCBoYXMgYSBzaWduYXR1cmUsIGVsc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1NpZ25hdHVyZSh0eERhdGE6IFR4RGF0YSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHR4RGF0YS52ICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eERhdGEuciAhPT0gdW5kZWZpbmVkICYmXG4gICAgdHhEYXRhLnMgIT09IHVuZGVmaW5lZCAmJlxuICAgIHR4RGF0YS52Lmxlbmd0aCA+IDAgJiZcbiAgICB0eERhdGEuci5sZW5ndGggPiAwICYmXG4gICAgdHhEYXRhLnMubGVuZ3RoID4gMFxuICApO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IGRhdGEgZGVjb2RlZCBmb3Igc29tZSB0eXBlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHR5cGVzIEFCSSB0eXBlcyBkZWZpbml0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2VyaWFsaXplZEFyZ3MgZW5jb2RlZCBhcmdzXG4gKiBAcmV0dXJucyB7QnVmZmVyW119IHRoZSBkZWNvZGVkIHJhd1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3RGVjb2RlZCh0eXBlczogc3RyaW5nW10sIHNlcmlhbGl6ZWRBcmdzOiBCdWZmZXIpOiBCdWZmZXJbXSB7XG4gIHJldHVybiBFdGhlcmV1bUFiaS5yYXdEZWNvZGUodHlwZXMsIHNlcmlhbGl6ZWRBcmdzKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJ1ZmZlcmVkIGJ5dGVjb2RlIGZyb20gcmF3RGF0YSB1c2luZyBhIG1ldGhvZElkIGFzIGRlbGltaXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RJZCB0aGUgaGV4IGVuY29kZWQgbWV0aG9kIElkXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3RGF0YSB0aGUgaGV4IGVuY29kZWQgcmF3IGRhdGFcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGRhdGEgYnVmZmVyZWQgYnl0ZWNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkQnl0ZUNvZGUobWV0aG9kSWQ6IHN0cmluZywgcmF3RGF0YTogc3RyaW5nKTogQnVmZmVyIHtcbiAgY29uc3Qgc3BsaXRCeXRlY29kZSA9IHJhd0RhdGEuc3BsaXQobWV0aG9kSWQpO1xuICBpZiAoc3BsaXRCeXRlY29kZS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHNlbmQgYnl0ZWNvZGU6ICR7cmF3RGF0YX1gKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oc3BsaXRCeXRlY29kZVsxXSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3RhdGljcyBjb2luIG9iamVjdCBtYXRjaGluZyBhIGdpdmVuIGNvbnRyYWN0IGFkZHJlc3MgaWYgaXQgZXhpc3RzXG4gKlxuICogQHBhcmFtIHRva2VuQ29udHJhY3RBZGRyZXNzIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHN0YXRpY3MgQmFzZUNvaW4gb2JqZWN0IGZvciB0aGUgbWF0Y2hpbmcgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuKHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIG5ldHdvcms6IEJhc2VOZXR3b3JrKTogUmVhZG9ubHk8QmFzZUNvaW4+IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdG9rZW5zID0gY29pbnMuZmlsdGVyKChjb2luKSA9PiB7XG4gICAgaWYgKGNvaW4gaW5zdGFuY2VvZiBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNvaW4ubmV0d29yay50eXBlID09PSBuZXR3b3JrLnR5cGUgJiYgY29pbi5jb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5Db250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICAvLyBpZiBsZW5ndGggb2YgdG9rZW5zIGlzIDEsIHJldHVybiB0aGUgZmlyc3QsIGVsc2UgcmV0dXJuIHVuZGVmaW5lZFxuICAvLyBDYW4ndCBkaXJlY3RseSBpbmRleCBpbnRvIHRva2Vucywgb3IgY2FsbCBgbGVuZ3RoYCwgc28gd2UgdXNlIG1hcCB0byBnZXQgYW4gYXJyYXlcbiAgY29uc3QgdG9rZW5zQXJyYXkgPSB0b2tlbnMubWFwKCh0b2tlbikgPT4gdG9rZW4pO1xuICBpZiAodG9rZW5zQXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgbmV2ZXIgYmUgdHdvIHRva2VucyB3aXRoIHRoZSBzYW1lIGNvbnRyYWN0IGFkZHJlc3MsIHNvIHdlIGFzc2VydCB0aGF0IGhlcmVcbiAgICBhc3NlcnQodG9rZW5zQXJyYXkubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdG9rZW5zQXJyYXlbMF07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiJdfQ==