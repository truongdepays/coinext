"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var types_1 = require("./types");
var utils_1 = require("./utils");
var UNSUPPORTED_COIN_NAME = 'unsupported';
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     * @param common the network commons
     * @param {TxData} txData The object transaction data or encoded transaction data
     */
    function Transaction(coinConfig, common, txData) {
        var _this = _super.call(this, coinConfig) || this;
        _this._common = common;
        if (txData) {
            _this.setTransactionData(txData);
        }
        return _this;
    }
    /**
     * return a new Transaction initialized with the serialized tx string
     *
     * @param coinConfig The coin configuration object
     * @param common network commons
     * @param serializedTx The serialized tx string with which to initialize the transaction
     * @returns a new transaction object
     */
    Transaction.fromSerialized = function (coinConfig, common, serializedTx) {
        return new Transaction(coinConfig, common, types_1.EthTransactionData.fromSerialized(serializedTx, common).toJson());
    };
    /**
     * Set the transaction data
     *
     * @param {TxData} txData The transaction data to set
     */
    Transaction.prototype.setTransactionData = function (txData) {
        this._transactionData = types_1.EthTransactionData.fromJson(txData, this._common);
        this.updateFields();
    };
    /**
     * Update the internal fields based on the currently set transaction data, if there is any
     */
    Transaction.prototype.updateFields = function () {
        if (!this._transactionData) {
            return;
        }
        var txData = this._transactionData.toJson();
        if (txData.id) {
            this._id = txData.id;
        }
        this._type = utils_1.classifyTransaction(txData.data);
        // reset arrays to empty to ensure that they are only set with one set of fresh values
        this._inputs = [];
        this._outputs = [];
        this._signatures = [];
        if (utils_1.hasSignature(txData)) {
            this._signatures.push(utils_1.toStringSig({ v: txData.v, r: txData.r, s: txData.s }));
        }
        // only send transactions have inputs / outputs / signatures to parse
        if (this._type === baseCoin_1.TransactionType.Send ||
            this._type === baseCoin_1.TransactionType.SendERC721 ||
            this._type === baseCoin_1.TransactionType.SendERC1155) {
            var _a = utils_1.decodeTransferData(txData.data), to = _a.to, amount = _a.amount, tokenContractAddress = _a.tokenContractAddress, signature = _a.signature;
            var coinName = void 0;
            if (tokenContractAddress) {
                var token = utils_1.getToken(tokenContractAddress, this._coinConfig.network);
                coinName = token ? token.name : UNSUPPORTED_COIN_NAME;
            }
            else {
                coinName = this._coinConfig.name;
            }
            this.outputs.push({
                address: to,
                value: amount,
                coin: coinName,
            });
            this.inputs.push({
                address: txData.to,
                value: amount,
                coin: coinName,
            });
            this._signatures.push(signature);
        }
    };
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    Transaction.prototype.setTransactionType = function (transactionType) {
        this._type = transactionType;
    };
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        // TODO: implement this validation for the ethereum network
        return true;
    };
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    Transaction.prototype.sign = function (keyPair) {
        return __awaiter(this, void 0, void 0, function () {
            var txData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._transactionData) {
                            throw new errors_1.InvalidTransactionError('No transaction data to sign');
                        }
                        if (!keyPair.getKeys().prv) {
                            throw new errors_1.SigningError('Missing private key');
                        }
                        return [4 /*yield*/, this._transactionData.sign(keyPair)];
                    case 1:
                        _a.sent();
                        txData = this._transactionData.toJson();
                        if (txData.id) {
                            this._id = txData.id;
                        }
                        this._signatures.push(utils_1.toStringSig({ v: txData.v, r: txData.r, s: txData.s }));
                        return [2 /*return*/];
                }
            });
        });
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        if (this._transactionData) {
            return this._transactionData.toSerialized();
        }
        throw new errors_1.InvalidTransactionError('No transaction data to format');
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        if (this._transactionData) {
            return this._transactionData.toJson();
        }
        throw new errors_1.InvalidTransactionError('Empty transaction');
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9ldGgvdHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0Esd0NBQStEO0FBRS9ELDZDQUEyRTtBQUczRSxpQ0FBNkM7QUFDN0MsaUNBQXVHO0FBRXZHLElBQU0scUJBQXFCLEdBQUcsYUFBYSxDQUFDO0FBRTVDO0lBQWlDLCtCQUFlO0lBMEI5Qzs7Ozs7O09BTUc7SUFDSCxxQkFBWSxVQUFnQyxFQUFFLE1BQXNCLEVBQUUsTUFBZTtRQUFyRixZQUNFLGtCQUFNLFVBQVUsQ0FBQyxTQUtsQjtRQUpDLEtBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksTUFBTSxFQUFFO1lBQ1YsS0FBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2pDOztJQUNILENBQUM7SUE3QkQ7Ozs7Ozs7T0FPRztJQUNXLDBCQUFjLEdBQTVCLFVBQ0UsVUFBZ0MsRUFDaEMsTUFBc0IsRUFDdEIsWUFBb0I7UUFFcEIsT0FBTyxJQUFJLFdBQVcsQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLDBCQUFrQixDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUMvRyxDQUFDO0lBaUJEOzs7O09BSUc7SUFDSCx3Q0FBa0IsR0FBbEIsVUFBbUIsTUFBYztRQUMvQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsMEJBQWtCLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7T0FFRztJQUNPLGtDQUFZLEdBQXRCO1FBQ0UsSUFBSSxDQUFDLElBQUks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Q0FBQzt5QkFDL0M7d0JBQ0QscUJBQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBQTs7d0JBQXpDLFNBQXlDLENBQUM7d0JBQ3BDLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUM7d0JBQzlDLElBQUksTUFBTSxDQUFDLEVBQUUsRUFBRTs0QkFDYixJQUFJLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUM7eUJBQ3RCO3dCQUNELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLG1CQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs7Ozs7S0FDbEY7SUFFRCxrQkFBa0I7SUFDbEIsdUNBQWlCLEdBQWpCO1FBQ0UsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDekIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDN0M7UUFDRCxNQUFNLElBQUksZ0NBQXVCLENBQUMsK0JBQStCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLDRCQUFNLEdBQU47UUFDRSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN6QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUN2QztRQUNELE1BQU0sSUFBSSxnQ0FBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFDSCxrQkFBQztBQUFELENBQUMsQUE1SkQsQ0FBaUMsMEJBQWUsR0E0Si9DO0FBNUpZLGtDQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFdGhlcmV1bSB0cmFuc2FjdGlvbiBtb2RlbC4gVGhpcyBpcyB0aGUgYmFzZSBtb2RlbCBmb3IgYWxsIGV0aGVyZXVtIGJhc2VkIGNvaW5zIChDZWxvLCBFVEMsIFJTSywgRVRIKVxuICovXG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IEV0aGVyZXVtQ29tbW9uIGZyb20gJ0BldGhlcmV1bWpzL2NvbW1vbic7XG5pbXBvcnQgeyBCYXNlVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJhc2VLZXksIEVudHJ5IH0gZnJvbSAnLi4vYmFzZUNvaW4vaWZhY2UnO1xuaW1wb3J0IHsgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsIFNpZ25pbmdFcnJvciB9IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7IEV0aExpa2VUcmFuc2FjdGlvbkRhdGEsIFR4RGF0YSB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgRXRoVHJhbnNhY3Rpb25EYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjbGFzc2lmeVRyYW5zYWN0aW9uLCBkZWNvZGVUcmFuc2ZlckRhdGEsIGdldFRva2VuLCBoYXNTaWduYXR1cmUsIHRvU3RyaW5nU2lnIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IFVOU1VQUE9SVEVEX0NPSU5fTkFNRSA9ICd1bnN1cHBvcnRlZCc7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIHByb3RlY3RlZCBfaWQ6IHN0cmluZzsgLy8gVGhlIHRyYW5zYWN0aW9uIGlkIGFzIHNlZW4gaW4gdGhlIGJsb2NrY2hhaW5cbiAgcHJvdGVjdGVkIF9pbnB1dHM6IEVudHJ5W107XG4gIHByb3RlY3RlZCBfb3V0cHV0czogRW50cnlbXTtcbiAgcHJvdGVjdGVkIF9zaWduYXR1cmVzOiBzdHJpbmdbXTtcbiAgcHJvdGVjdGVkIF90eXBlOiBUcmFuc2FjdGlvblR5cGU7XG4gIHByb3RlY3RlZCBfY29tbW9uOiBFdGhlcmV1bUNvbW1vbjtcblxuICBwcm90ZWN0ZWQgX3RyYW5zYWN0aW9uRGF0YT86IEV0aExpa2VUcmFuc2FjdGlvbkRhdGE7XG5cbiAgLyoqXG4gICAqIHJldHVybiBhIG5ldyBUcmFuc2FjdGlvbiBpbml0aWFsaXplZCB3aXRoIHRoZSBzZXJpYWxpemVkIHR4IHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0gY29pbkNvbmZpZyBUaGUgY29pbiBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gY29tbW9uIG5ldHdvcmsgY29tbW9uc1xuICAgKiBAcGFyYW0gc2VyaWFsaXplZFR4IFRoZSBzZXJpYWxpemVkIHR4IHN0cmluZyB3aXRoIHdoaWNoIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIGEgbmV3IHRyYW5zYWN0aW9uIG9iamVjdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tU2VyaWFsaXplZChcbiAgICBjb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPixcbiAgICBjb21tb246IEV0aGVyZXVtQ29tbW9uLFxuICAgIHNlcmlhbGl6ZWRUeDogc3RyaW5nLFxuICApOiBUcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihjb2luQ29uZmlnLCBjb21tb24sIEV0aFRyYW5zYWN0aW9uRGF0YS5mcm9tU2VyaWFsaXplZChzZXJpYWxpemVkVHgsIGNvbW1vbikudG9Kc29uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkb25seTxDb2luQ29uZmlnPn0gY29pbkNvbmZpZ1xuICAgKiBAcGFyYW0gY29tbW9uIHRoZSBuZXR3b3JrIGNvbW1vbnNcbiAgICogQHBhcmFtIHtUeERhdGF9IHR4RGF0YSBUaGUgb2JqZWN0IHRyYW5zYWN0aW9uIGRhdGEgb3IgZW5jb2RlZCB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPiwgY29tbW9uOiBFdGhlcmV1bUNvbW1vbiwgdHhEYXRhPzogVHhEYXRhKSB7XG4gICAgc3VwZXIoY29pbkNvbmZpZyk7XG4gICAgdGhpcy5fY29tbW9uID0gY29tbW9uO1xuICAgIGlmICh0eERhdGEpIHtcbiAgICAgIHRoaXMuc2V0VHJhbnNhY3Rpb25EYXRhKHR4RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1R4RGF0YX0gdHhEYXRhIFRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIHNldFxuICAgKi9cbiAgc2V0VHJhbnNhY3Rpb25EYXRhKHR4RGF0YTogVHhEYXRhKTogdm9pZCB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25EYXRhID0gRXRoVHJhbnNhY3Rpb25EYXRhLmZyb21Kc29uKHR4RGF0YSwgdGhpcy5fY29tbW9uKTtcbiAgICB0aGlzLnVwZGF0ZUZpZWxkcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgaW50ZXJuYWwgZmllbGRzIGJhc2VkIG9uIHRoZSBjdXJyZW50bHkgc2V0IHRyYW5zYWN0aW9uIGRhdGEsIGlmIHRoZXJlIGlzIGFueVxuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZUZpZWxkcygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHR4RGF0YSA9IHRoaXMuX3RyYW5zYWN0aW9uRGF0YS50b0pzb24oKTtcbiAgICBpZiAodHhEYXRhLmlkKSB7XG4gICAgICB0aGlzLl9pZCA9IHR4RGF0YS5pZDtcbiAgICB9XG4gICAgdGhpcy5fdHlwZSA9IGNsYXNzaWZ5VHJhbnNhY3Rpb24odHhEYXRhLmRhdGEpO1xuXG4gICAgLy8gcmVzZXQgYXJyYXlzIHRvIGVtcHR5IHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlIG9ubHkgc2V0IHdpdGggb25lIHNldCBvZiBmcmVzaCB2YWx1ZXNcbiAgICB0aGlzLl9pbnB1dHMgPSBbXTtcbiAgICB0aGlzLl9vdXRwdXRzID0gW107XG4gICAgdGhpcy5fc2lnbmF0dXJlcyA9IFtdO1xuXG4gICAgaWYgKGhhc1NpZ25hdHVyZSh0eERhdGEpKSB7XG4gICAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2godG9TdHJpbmdTaWcoeyB2OiB0eERhdGEudiEsIHI6IHR4RGF0YS5yISwgczogdHhEYXRhLnMhIH0pKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHNlbmQgdHJhbnNhY3Rpb25zIGhhdmUgaW5wdXRzIC8gb3V0cHV0cyAvIHNpZ25hdHVyZXMgdG8gcGFyc2VcbiAgICBpZiAoXG4gICAgICB0aGlzLl90eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZCB8fFxuICAgICAgdGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmRFUkM3MjEgfHxcbiAgICAgIHRoaXMuX3R5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kRVJDMTE1NVxuICAgICkge1xuICAgICAgY29uc3QgeyB0bywgYW1vdW50LCB0b2tlbkNvbnRyYWN0QWRkcmVzcywgc2lnbmF0dXJlIH0gPSBkZWNvZGVUcmFuc2ZlckRhdGEodHhEYXRhLmRhdGEpO1xuICAgICAgbGV0IGNvaW5OYW1lOiBzdHJpbmc7XG4gICAgICBpZiAodG9rZW5Db250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbih0b2tlbkNvbnRyYWN0QWRkcmVzcywgdGhpcy5fY29pbkNvbmZpZy5uZXR3b3JrKTtcbiAgICAgICAgY29pbk5hbWUgPSB0b2tlbiA/IHRva2VuLm5hbWUgOiBVTlNVUFBPUlRFRF9DT0lOX05BTUU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2luTmFtZSA9IHRoaXMuX2NvaW5Db25maWcubmFtZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRwdXRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiB0byxcbiAgICAgICAgdmFsdWU6IGFtb3VudCxcbiAgICAgICAgY29pbjogY29pbk5hbWUsXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5pbnB1dHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IHR4RGF0YS50byEsIC8vIHRoZSBzZW5kaW5nIHdhbGxldCBjb250cmFjdCBpcyB0aGUgcmVjaXBpZW50IG9mIHRoZSBvdXRlciB0cmFuc2FjdGlvblxuICAgICAgICB2YWx1ZTogYW1vdW50LFxuICAgICAgICBjb2luOiBjb2luTmFtZSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0cmFuc2FjdGlvblR5cGUgVGhlIHRyYW5zYWN0aW9uIHR5cGUgdG8gYmUgc2V0XG4gICAqL1xuICBzZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb25UeXBlOiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICB0aGlzLl90eXBlID0gdHJhbnNhY3Rpb25UeXBlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGNhblNpZ24oa2V5OiBCYXNlS2V5KTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgdmFsaWRhdGlvbiBmb3IgdGhlIGV0aGVyZXVtIG5ldHdvcmtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBrZXkuIEl0IGRvZXMgbm90IGNoZWNrIGlmIHRoZSBzaWduZXIgaXMgYWxsb3dlZCB0byBzaWduXG4gICAqIGl0IG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIFRoZSBrZXkgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICAgKi9cbiAgYXN5bmMgc2lnbihrZXlQYWlyOiBLZXlQYWlyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbkRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignTm8gdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduJyk7XG4gICAgfVxuICAgIGlmICgha2V5UGFpci5nZXRLZXlzKCkucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX3RyYW5zYWN0aW9uRGF0YS5zaWduKGtleVBhaXIpO1xuICAgIGNvbnN0IHR4RGF0YSA9IHRoaXMuX3RyYW5zYWN0aW9uRGF0YS50b0pzb24oKTtcbiAgICBpZiAodHhEYXRhLmlkKSB7XG4gICAgICB0aGlzLl9pZCA9IHR4RGF0YS5pZDtcbiAgICB9XG4gICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHRvU3RyaW5nU2lnKHsgdjogdHhEYXRhLnYhLCByOiB0eERhdGEuciEsIHM6IHR4RGF0YS5zISB9KSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Ccm9hZGNhc3RGb3JtYXQoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25EYXRhLnRvU2VyaWFsaXplZCgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ05vIHRyYW5zYWN0aW9uIGRhdGEgdG8gZm9ybWF0Jyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Kc29uKCk6IFR4RGF0YSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uRGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uRGF0YS50b0pzb24oKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICB9XG59XG4iXX0=