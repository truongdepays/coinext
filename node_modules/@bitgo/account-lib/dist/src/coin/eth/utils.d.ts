/// <reference types="node" />
import { BaseCoin, BaseNetwork, EthereumNetwork } from '@bitgo/statics';
import EthereumCommon from '@ethereumjs/common';
import { TransactionType } from '../baseCoin';
import { ERC1155TransferData, ERC721TransferData, FlushTokensData, NativeTransferData, SignatureParts, TokenTransferData, TransferData, TxData } from './iface';
import { KeyPair } from './keyPair';
/**
 * @param network
 */
export declare function getCommon(network: EthereumNetwork): EthereumCommon;
/**
 * Signs the transaction using the appropriate algorithm
 * and the provided common for the blockchain
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @param {EthereumCommon} customCommon the network's custom common
 * @returns {string} the transaction signed and encoded
 */
export declare function signInternal(transactionData: TxData, keyPair: KeyPair, customCommon: EthereumCommon): Promise<string>;
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
export declare function sign(transactionData: TxData, keyPair: KeyPair): Promise<string>;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} data aditional method call data
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
export declare function sendMultiSigData(to: string, value: string, data: string, expireTime: number, sequenceId: number, signature: string): string;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} tokenContractAddress the address of the erc20 token contract
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
export declare function sendMultiSigTokenData(to: string, value: string, tokenContractAddress: string, expireTime: number, sequenceId: number, signature: string): string;
/**
 * Get the data required to make a flush tokens contract call
 *
 * @param forwarderAddress The forwarder address to flush
 * @param tokenAddress The token address to flush from
 */
export declare function flushTokensData(forwarderAddress: any, tokenAddress: any): string;
/**
 * Get the data required to make a flush native coins contract call
 */
export declare function flushCoinsData(): string;
/**
 * Returns the create forwarder method calling data
 *
 * @returns {string} - the createForwarder method encoded
 */
export declare function getAddressInitializationData(): string;
/**
 * Returns whether or not the string is a valid Eth address
 *
 * @param {string} address - the tx hash to validate
 * @returns {boolean} - the validation result
 */
export declare function isValidEthAddress(address: string): boolean;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
export declare function isValidAmount(amount: string): boolean;
/**
 * Returns the smart contract encoded data
 *
 * @param {string} data The wallet creation data to decode
 * @returns {string[]} - The list of signer addresses
 */
export declare function decodeWalletCreationData(data: string): string[];
/**
 * Decode the given ABI-encoded transfer data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
export declare function decodeTransferData(data: string): TransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisigToken function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed token transfer data
 */
export declare function decodeTokenTransferData(data: string): TokenTransferData;
export declare function decodeERC721TransferData(data: string): ERC721TransferData;
export declare function decodeERC1155TransferData(data: string): ERC1155TransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisig function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
export declare function decodeNativeTransferData(data: string): NativeTransferData;
/**
 * Decode the given ABI-encoded flush tokens data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
export declare function decodeFlushTokensData(data: string): FlushTokensData;
/**
 * Classify the given transaction data based as a transaction type.
 * ETH transactions are defined by the first 8 bytes of the transaction data, also known as the method id
 *
 * @param {string} data The data to classify the transaction with
 * @returns {TransactionType} The classified transaction type
 */
export declare function classifyTransaction(data: string): TransactionType;
/**
 *
 * @param {number} num number to be converted to hex
 * @returns {string} the hex number
 */
export declare function numberToHexString(num: number): string;
/**
 *
 * @param {string} hex The hex string to be converted
 * @returns {number} the resulting number
 */
export declare function hexStringToNumber(hex: string): number;
/**
 * Generates an address of the forwarder address to be deployed
 *
 * @param {string} contractAddress the address which is creating this new address
 * @param {number} contractCounter the nonce of the contract address
 * @returns {string} the calculated forwarder contract address
 */
export declare function calculateForwarderAddress(contractAddress: string, contractCounter: number): string;
/**
 * Calculate the forwarder v1 address that will be generated if `creatorAddress` creates it with salt `salt`
 * and initcode `inicode using the create2 opcode
 * @param {string} creatorAddress The address that is sending the tx to create a new address, hex string
 * @param {string} salt The salt to create the address with using create2, hex string
 * @param {string} initcode The initcode that will be deployed to the address, hex string
 * @return {string} The calculated address
 */
export declare function calculateForwarderV1Address(creatorAddress: string, salt: string, initcode: string): string;
/**
 * Take the implementation address for the proxy contract, and get the binary initcode for the associated proxy
 * @param {string} implementationAddress The address of the implementation contract for the proxy
 * @return {string} Binary hex string of the proxy
 */
export declare function getProxyInitcode(implementationAddress: string): string;
/**
 * Convert the given signature parts to a string representation
 *
 * @param {SignatureParts} sig The signature to convert to string
 * @returns {string} String representation of the signature
 */
export declare function toStringSig(sig: SignatureParts): string;
/**
 * Return whether or not the given tx data has a signature
 *
 * @param {TxData} txData The transaction data to check for signature
 * @returns {boolean} true if the tx has a signature, else false
 */
export declare function hasSignature(txData: TxData): boolean;
/**
 * Get the raw data decoded for some types
 *
 * @param {string[]} types ABI types definition
 * @param {Buffer} serializedArgs encoded args
 * @returns {Buffer[]} the decoded raw
 */
export declare function getRawDecoded(types: string[], serializedArgs: Buffer): Buffer[];
/**
 * Get the buffered bytecode from rawData using a methodId as delimiter
 *
 * @param {string} methodId the hex encoded method Id
 * @param {string} rawData the hex encoded raw data
 * @returns {Buffer} data buffered bytecode
 */
export declare function getBufferedByteCode(methodId: string, rawData: string): Buffer;
/**
 * Get the statics coin object matching a given contract address if it exists
 *
 * @param tokenContractAddress The contract address to match against
 * @returns statics BaseCoin object for the matching token
 */
export declare function getToken(tokenContractAddress: string, network: BaseNetwork): Readonly<BaseCoin> | undefined;
//# sourceMappingURL=utils.d.ts.map