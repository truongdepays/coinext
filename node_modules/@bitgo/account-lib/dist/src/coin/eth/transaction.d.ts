/**
 * Ethereum transaction model. This is the base model for all ethereum based coins (Celo, ETC, RSK, ETH)
 */
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import EthereumCommon from '@ethereumjs/common';
import { BaseTransaction, TransactionType } from '../baseCoin';
import { BaseKey, Entry } from '../baseCoin/iface';
import { KeyPair } from './keyPair';
import { EthLikeTransactionData, TxData } from './iface';
export declare class Transaction extends BaseTransaction {
    protected _id: string;
    protected _inputs: Entry[];
    protected _outputs: Entry[];
    protected _signatures: string[];
    protected _type: TransactionType;
    protected _common: EthereumCommon;
    protected _transactionData?: EthLikeTransactionData;
    /**
     * return a new Transaction initialized with the serialized tx string
     *
     * @param coinConfig The coin configuration object
     * @param common network commons
     * @param serializedTx The serialized tx string with which to initialize the transaction
     * @returns a new transaction object
     */
    static fromSerialized(coinConfig: Readonly<CoinConfig>, common: EthereumCommon, serializedTx: string): Transaction;
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     * @param common the network commons
     * @param {TxData} txData The object transaction data or encoded transaction data
     */
    constructor(coinConfig: Readonly<CoinConfig>, common: EthereumCommon, txData?: TxData);
    /**
     * Set the transaction data
     *
     * @param {TxData} txData The transaction data to set
     */
    setTransactionData(txData: TxData): void;
    /**
     * Update the internal fields based on the currently set transaction data, if there is any
     */
    protected updateFields(): void;
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType: TransactionType): void;
    /** @inheritdoc */
    canSign(key: BaseKey): boolean;
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    sign(keyPair: KeyPair): Promise<void>;
    /** @inheritdoc */
    toBroadcastFormat(): string;
    /** @inheritdoc */
    toJson(): TxData;
}
//# sourceMappingURL=transaction.d.ts.map