"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
var algosdk_1 = __importStar(require("algosdk"));
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var utils_1 = __importDefault(require("./utils"));
var KeyPair = /** @class */ (function (_super) {
    __extends(KeyPair, _super);
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    function KeyPair(source) {
        return _super.call(this, source) || this;
    }
    /** @inheritdoc */
    KeyPair.prototype.recordKeysFromPrivateKeyInProtocolFormat = function (prv) {
        var decodedSeed = utils_1.default.decodeSeed(prv);
        var bufferFromSeed = Buffer.from(decodedSeed.seed);
        return utils_1.default.keyPairFromSeed(bufferFromSeed).keyPair;
    };
    /** @inheritdoc */
    KeyPair.prototype.recordKeysFromPublicKeyInProtocolFormat = function (pub) {
        var publicKey = algosdk_1.default.decodeAddress(pub).publicKey;
        return { pub: utils_1.default.toHex(publicKey) };
    };
    /** @inheritdoc */
    KeyPair.prototype.getAddress = function () {
        return algosdk_1.encodeAddress(utils_1.default.toUint8Array(this.keyPair.pub));
    };
    /** @inheritdoc */
    KeyPair.prototype.getKeys = function () {
        // TODO(https://bitgoinc.atlassian.net/browse/STLX-6062): refactor this method
        // should return the pub and prv in the Algorand encoded format
        var result = { pub: this.keyPair.pub };
        if (this.keyPair.prv) {
            result.prv = this.keyPair.prv;
        }
        return result;
    };
    /**
     * Getting the base64 private key for signing an algo transaction.
     *
     * @returns {Uint8Array} base64 private key
     * @see https://developer.algorand.org/docs/features/accounts/#transformation-private-key-to-base64-private-key
     */
    KeyPair.prototype.getSigningKey = function () {
        if (!this.keyPair.prv) {
            throw new errors_1.InvalidKey('Private key undefined');
        }
        return utils_1.default.toUint8Array(this.keyPair.prv + this.keyPair.pub);
    };
    return KeyPair;
}(baseCoin_1.Ed25519KeyPair));
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2luL2FsZ28va2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaURBQWlEO0FBQ2pELHdDQUE2QztBQUU3Qyw2Q0FBZ0Q7QUFDaEQsa0RBQTRCO0FBRTVCO0lBQTZCLDJCQUFjO0lBQ3pDOzs7O09BSUc7SUFDSCxpQkFBWSxNQUF1QjtlQUNqQyxrQkFBTSxNQUFNLENBQUM7SUFDZixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLDBEQUF3QyxHQUF4QyxVQUF5QyxHQUFXO1FBQ2xELElBQU0sV0FBVyxHQUFHLGVBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDMUMsSUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckQsT0FBTyxlQUFLLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUN2RCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLHlEQUF1QyxHQUF2QyxVQUF3QyxHQUFXO1FBQ2pELElBQU0sU0FBUyxHQUFHLGlCQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUN2RCxPQUFPLEVBQUUsR0FBRyxFQUFFLGVBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLDRCQUFVLEdBQVY7UUFDRSxPQUFPLHVCQUFhLENBQUMsZUFBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVELGtCQUFrQjtJQUNsQix5QkFBTyxHQUFQO1FBQ0UsOEVBQThFO1FBQzlFLCtEQUErRDtRQUMvRCxJQUFNLE1BQU0sR0FBZ0IsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUV0RCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFO1lBQ3BCLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7U0FDL0I7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwrQkFBYSxHQUFiO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxtQkFBVSxDQUFDLHVCQUF1QixDQUFDLENBQUM7U0FDL0M7UUFDRCxPQUFPLGVBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBQ0gsY0FBQztBQUFELENBQUMsQUF0REQsQ0FBNkIseUJBQWMsR0FzRDFDO0FBdERZLDBCQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFsZ29zZGssIHsgZW5jb2RlQWRkcmVzcyB9IGZyb20gJ2FsZ29zZGsnO1xuaW1wb3J0IHsgRWQyNTUxOUtleVBhaXIgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBEZWZhdWx0S2V5cywgS2V5UGFpck9wdGlvbnMgfSBmcm9tICcuLi9iYXNlQ29pbi9pZmFjZSc7XG5pbXBvcnQgeyBJbnZhbGlkS2V5IH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIEtleVBhaXIgZXh0ZW5kcyBFZDI1NTE5S2V5UGFpciB7XG4gIC8qKlxuICAgKiBQdWJsaWMgY29uc3RydWN0b3IuIEJ5IGRlZmF1bHQsIGNyZWF0ZXMgYSBrZXkgcGFpciB3aXRoIGEgcmFuZG9tIG1hc3RlciBzZWVkLlxuICAgKlxuICAgKiBAcGFyYW0geyBLZXlQYWlyT3B0aW9ucyB9IHNvdXJjZSBFaXRoZXIgYSBtYXN0ZXIgc2VlZCwgYSBwcml2YXRlIGtleSwgb3IgYSBwdWJsaWMga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5SW5Qcm90b2NvbEZvcm1hdChwcnY6IHN0cmluZyk6IERlZmF1bHRLZXlzIHtcbiAgICBjb25zdCBkZWNvZGVkU2VlZCA9IHV0aWxzLmRlY29kZVNlZWQocHJ2KTtcbiAgICBjb25zdCBidWZmZXJGcm9tU2VlZCA9IEJ1ZmZlci5mcm9tKGRlY29kZWRTZWVkLnNlZWQpO1xuXG4gICAgcmV0dXJuIHV0aWxzLmtleVBhaXJGcm9tU2VlZChidWZmZXJGcm9tU2VlZCkua2V5UGFpcjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZWNvcmRLZXlzRnJvbVB1YmxpY0tleUluUHJvdG9jb2xGb3JtYXQocHViOiBzdHJpbmcpOiBEZWZhdWx0S2V5cyB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gYWxnb3Nkay5kZWNvZGVBZGRyZXNzKHB1YikucHVibGljS2V5O1xuICAgIHJldHVybiB7IHB1YjogdXRpbHMudG9IZXgocHVibGljS2V5KSB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldEFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyh1dGlscy50b1VpbnQ4QXJyYXkodGhpcy5rZXlQYWlyLnB1YikpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldEtleXMoKTogRGVmYXVsdEtleXMge1xuICAgIC8vIFRPRE8oaHR0cHM6Ly9iaXRnb2luYy5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9TVExYLTYwNjIpOiByZWZhY3RvciB0aGlzIG1ldGhvZFxuICAgIC8vIHNob3VsZCByZXR1cm4gdGhlIHB1YiBhbmQgcHJ2IGluIHRoZSBBbGdvcmFuZCBlbmNvZGVkIGZvcm1hdFxuICAgIGNvbnN0IHJlc3VsdDogRGVmYXVsdEtleXMgPSB7IHB1YjogdGhpcy5rZXlQYWlyLnB1YiB9O1xuXG4gICAgaWYgKHRoaXMua2V5UGFpci5wcnYpIHtcbiAgICAgIHJlc3VsdC5wcnYgPSB0aGlzLmtleVBhaXIucHJ2O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0dGluZyB0aGUgYmFzZTY0IHByaXZhdGUga2V5IGZvciBzaWduaW5nIGFuIGFsZ28gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBiYXNlNjQgcHJpdmF0ZSBrZXlcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5hbGdvcmFuZC5vcmcvZG9jcy9mZWF0dXJlcy9hY2NvdW50cy8jdHJhbnNmb3JtYXRpb24tcHJpdmF0ZS1rZXktdG8tYmFzZTY0LXByaXZhdGUta2V5XG4gICAqL1xuICBnZXRTaWduaW5nS2V5KCk6IFVpbnQ4QXJyYXkge1xuICAgIGlmICghdGhpcy5rZXlQYWlyLnBydikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRLZXkoJ1ByaXZhdGUga2V5IHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMudG9VaW50OEFycmF5KHRoaXMua2V5UGFpci5wcnYgKyB0aGlzLmtleVBhaXIucHViKTtcbiAgfVxufVxuIl19