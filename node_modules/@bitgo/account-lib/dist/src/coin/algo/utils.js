"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
var algosdk_1 = __importDefault(require("algosdk"));
var stellar_sdk_1 = __importDefault(require("stellar-sdk"));
var hex = __importStar(require("@stablelib/hex"));
var nacl = __importStar(require("tweetnacl"));
var hi_base32_1 = __importDefault(require("hi-base32"));
var js_sha512_1 = __importDefault(require("js-sha512"));
var lodash_1 = __importDefault(require("lodash"));
var crypto_1 = require("../../utils/crypto");
var errors_1 = require("../baseCoin/errors");
var keyPair_1 = require("./keyPair");
var seedEncoding_1 = require("./seedEncoding");
var algoNacl = __importStar(require("algosdk/dist/cjs/src/nacl/naclWrappers"));
var encoding = __importStar(require("algosdk/dist/cjs/src/encoding/encoding"));
var ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
var ALGORAND_SEED_LENGTH = 58;
var ALGORAND_SEED_BYTE_LENGTH = 36;
var ALGORAND_TRANSACTION_LENGTH = 52;
var SEED_BYTES_LENGTH = 32;
/**
 * Determines whether the string is only composed of hex chars.
 *
 * @param {string} maybe The string to be validated.
 * @returns {boolean} true if the string consists of only hex characters, otherwise false.
 */
function allHexChars(maybe) {
    return /^([0-9a-f]{2})+$/i.test(maybe);
}
/**
 * ConcatArrays takes two array and returns a joint array of both
 *
 * @param a {Uint8Array} first array to concat
 * @param b {Uint8Array} second array
 * @returns {Uint8Array} a new array containing all elements of 'a' followed by all elements of 'b'
 */
function concatArrays(a, b) {
    var c = new Uint8Array(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
}
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /** @inheritdoc */
    Utils.prototype.isValidAddress = function (address) {
        return algosdk_1.default.isValidAddress(address);
    };
    /** @inheritdoc */
    Utils.prototype.isValidTransactionId = function (txId) {
        if (txId.length !== 104) {
            return false;
        }
        return allHexChars(txId);
    };
    /** @inheritdoc */
    Utils.prototype.isValidPublicKey = function (key) {
        return crypto_1.isValidEd25519PublicKey(key);
    };
    /** @inheritdoc */
    Utils.prototype.isValidPrivateKey = function (key) {
        return crypto_1.isValidEd25519SecretKey(key);
    };
    /**
     * Returns an hex string of the given buffer
     *
     * @param {Uint8Array} buffer - the buffer to be converted to hex
     * @returns {string} - the hex value
     */
    Utils.prototype.toHex = function (buffer) {
        return hex.encode(buffer, true);
    };
    /** @inheritdoc */
    Utils.prototype.isValidSignature = function (signature) {
        throw new errors_1.NotImplementedError('isValidSignature not implemented.');
    };
    /** @inheritdoc */
    Utils.prototype.isValidBlockId = function (hash) {
        throw new errors_1.NotImplementedError('hash not implemented.');
    };
    /**
     * Compare two Keys
     *
     * @param {Uint8Array} key1 - key to be compare
     * @param {Uint8Array} key2 - key to be compare
     * @returns {boolean} - returns true if both keys are equal
     */
    Utils.prototype.areKeysEqual = function (key1, key2) {
        return nacl.verify(key1, key2);
    };
    /**
     * Returns a Uint8Array of the given hex string
     *
     * @param {string} str - the hex string to be converted
     * @returns {string} - the Uint8Array value
     */
    Utils.prototype.toUint8Array = function (str) {
        return Buffer.from(str, 'hex');
    };
    /**
     * Determines whether a seed is valid.
     *
     * @param {string} seed - the seed to be validated
     * @returns {boolean} - true if the seed is valid
     */
    Utils.prototype.isValidSeed = function (seed) {
        if (typeof seed !== 'string')
            return false;
        if (seed.length !== ALGORAND_SEED_LENGTH)
            return false;
        // Try to decode
        var decoded;
        try {
            decoded = this.decodeSeed(seed);
        }
        catch (e) {
            return false;
        }
        // Compute checksum
        var checksum = new Uint8Array(js_sha512_1.default.sha512_256.array(decoded.seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH));
        // Check if the checksum matches the one from the decoded seed
        return lodash_1.default.isEqual(checksum, decoded.checksum);
    };
    /**
     * Encode an algo seed
     *
     * @param  {Buffer} secretKey - the valid secretKey .
     * @returns {string} - the seed to be validated.
     */
    Utils.prototype.encodeSeed = function (secretKey) {
        // get seed
        var seed = secretKey.slice(0, SEED_BYTES_LENGTH);
        // compute checksum
        var checksum = Buffer.from(js_sha512_1.default.sha512_256.array(seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH));
        var encodedSeed = hi_base32_1.default.encode(concatArrays(seed, checksum));
        return encodedSeed.toString().slice(0, ALGORAND_SEED_LENGTH); // removing the extra '===='
    };
    /**
     * decodeSeed decodes an algo seed
     *
     * Decoding algo seed is same as decoding address.
     * Latest version of algo sdk (1.9, at this writing) does not expose explicit method for decoding seed.
     * Parameter is decoded and split into seed and checksum.
     *
     * @param {string} seed - hex or base64 encoded seed to be validated
     * @returns {Seed} - validated object Seed
     */
    Utils.prototype.decodeSeed = function (seed) {
        // try to decode
        var decoded = hi_base32_1.default.decode.asBytes(seed);
        // Sanity check
        if (decoded.length !== ALGORAND_SEED_BYTE_LENGTH)
            throw new Error('seed seems to be malformed');
        return {
            seed: new Uint8Array(decoded.slice(0, ALGORAND_SEED_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)),
            checksum: new Uint8Array(decoded.slice(SEED_BYTES_LENGTH, ALGORAND_SEED_BYTE_LENGTH)),
        };
    };
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub {Uint8Array} public key
     * @param message {Uint8Array} signed message
     * @param signature {Buffer} signature to verify
     * @returns {Boolean} true if signature is valid.
     */
    Utils.prototype.verifySignature = function (message, signature, pub) {
        return nacl.sign.detached.verify(message, signature, pub);
    };
    /**
     * Transforms an Ed25519 public key into an algorand address.
     *
     * @param {Uint8Array} pk The Ed25519 public key.
     * @see https://developer.algorand.org/docs/features/accounts/#transformation-public-key-to-algorand-address
     *
     * @returns {string} The algorand address.
     */
    Utils.prototype.publicKeyToAlgoAddress = function (pk) {
        return new keyPair_1.KeyPair({ pub: Buffer.from(pk).toString('hex') }).getAddress();
    };
    /**
     * Checks if a unsigned algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded unsigned transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    Utils.prototype.isDecodableUnsignedAlgoTxn = function (txn) {
        try {
            algosdk_1.default.decodeUnsignedTransaction(txn);
            return true;
        }
        catch (_a) {
            return false;
        }
    };
    /**
     * Checks if a signed algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded signed transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    Utils.prototype.isDecodableSignedTransaction = function (txn) {
        try {
            algosdk_1.default.decodeSignedTransaction(txn);
            return true;
        }
        catch (_a) {
            return false;
        }
    };
    /**
     * Decodes a signed or unsigned algo transaction.
     *
     * @param {Uint8Array | string} txnBytes The encoded unsigned or signed txn.
     * @returns {EncodedTx} The decoded transaction.
     */
    Utils.prototype.decodeAlgoTxn = function (txnBytes) {
        var buffer = typeof txnBytes === 'string'
            ? Buffer.from(txnBytes, allHexChars(txnBytes) ? 'hex' : 'base64')
            : Buffer.from(txnBytes);
        // In order to maintain backward compatibility with old keyreg transactions encoded with
        // forked algosdk 1.2.0 (https://github.com/BitGo/algosdk-bitgo),
        // the relevant information is extracted and parsed following the latest algosdk
        // release standard.
        // This way we can decode transactions successfully by still maintaining backward compatibility.
        var decodedTx = encoding.decode(buffer);
        if (decodedTx.txn &&
            decodedTx.txn.type === 'keyreg' &&
            decodedTx.txn.votefst &&
            decodedTx.txn.votelst &&
            decodedTx.txn.votekd) {
            decodedTx.txn.votekey = decodedTx.txn.votekey || decodedTx.msig.subsig[0].pk;
            decodedTx.txn.selkey = decodedTx.txn.selkey || decodedTx.msig.subsig[0].pk;
            buffer = decodedTx.msig || decodedTx.sig ? encoding.encode(decodedTx) : encoding.encode(decodedTx.txn);
        }
        try {
            return this.tryToDecodeUnsignedTransaction(buffer);
        }
        catch (_a) {
            // Ignore error to try different format
        }
        try {
            return this.tryToDecodeSignedTransaction(buffer);
        }
        catch (_b) {
            throw new errors_1.InvalidTransactionError('Transaction cannot be decoded');
        }
    };
    /**
     * Try to decode a signed Algo transaction
     * @param buffer the encoded transaction
     * @returns { EncodedTx } the decoded signed transaction
     * @throws error if it is not a valid encoded signed transaction
     */
    Utils.prototype.tryToDecodeSignedTransaction = function (buffer) {
        // TODO: Replace with
        // return algosdk.Transaction.from_obj_for_encoding(algosdk.decodeSignedTransaction(buffer).txn);
        // see: https://github.com/algorand/js-algorand-sdk/issues/364
        // "...some parts of the codebase treat the output of Transaction.from_obj_for_encoding as EncodedTransaction.
        // They need to be fixed(or we at least need to make it so Transaction conforms to EncodedTransaction)."
        var tx = algosdk_1.default.decodeSignedTransaction(buffer);
        var signers = [];
        var signedBy = [];
        if (tx.msig && tx.msig.subsig) {
            for (var _i = 0, _a = tx.msig.subsig; _i < _a.length; _i++) {
                var sig = _a[_i];
                var addr = algosdk_1.default.encodeAddress(sig.pk);
                signers.push(addr);
                if (sig.s) {
                    signedBy.push(addr);
                }
            }
        }
        return {
            rawTransaction: new Uint8Array(buffer),
            txn: tx.txn,
            signed: true,
            signers: signers,
            signedBy: signedBy,
        };
    };
    /**
     * Try to decode an unsigned Algo transaction
     * @param buffer the encoded transaction
     * @returns {EncodedTx} the decoded unsigned transaction
     * @throws error if it is not a valid encoded unsigned transaction
     */
    Utils.prototype.tryToDecodeUnsignedTransaction = function (buffer) {
        var txn = algosdk_1.default.decodeUnsignedTransaction(buffer);
        return {
            rawTransaction: new Uint8Array(buffer),
            txn: txn,
            signed: false,
        };
    };
    /*
     * encodeObj takes a javascript object and returns its msgpack encoding
     * Note that the encoding sorts the fields alphabetically
     *
     * @param {Record<string | number | symbol, any>} obj js obj
     * @returns {Uint8Array} Uint8Array binary representation
     */
    Utils.prototype.encodeObj = function (obj) {
        return algosdk_1.default.encodeObj(obj);
    };
    /**
     * decodeObj takes a Uint8Array and returns its javascript obj
     * @param o - Uint8Array to decode
     * @returns object
     */
    Utils.prototype.decodeObj = function (o) {
        return algosdk_1.default.decodeObj(o);
    };
    /**
     * secretKeyToMnemonic takes an Algorant secret key and returns the corresponding mnemonic
     *
     * @param sk - Algorant secret key
     * @return Secret key is associated mnemonic
     */
    Utils.prototype.secretKeyToMnemonic = function (sk) {
        var skValid = Buffer.from(sk.toString('hex'));
        if (!this.isValidPrivateKey(skValid.toString('hex'))) {
            throw new errors_1.InvalidKey("The secret key: " + sk.toString('hex') + " is invalid");
        }
        var skUnit8Array = Buffer.from(sk);
        return algosdk_1.default.secretKeyToMnemonic(skUnit8Array);
    };
    /**
     * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it
     * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one
     * of the passed words is not found in the words list
     *
     * @param mnemonic - 25 words mnemonic
     * @returns 32 bytes long seed
     */
    Utils.prototype.seedFromMnemonic = function (mnemonic) {
        return algosdk_1.default.mnemonicToMasterDerivationKey(mnemonic);
    };
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the algosdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    Utils.prototype.keyPairFromSeed = function (seed) {
        var mn = this.mnemonicFromSeed(seed);
        var base64PrivateKey = algosdk_1.default.mnemonicToSecretKey(mn).sk;
        return this.createKeyPair(base64PrivateKey);
    };
    /**
     * Generate a new `KeyPair` object from the given private key.
     *
     * @param base64PrivateKey 64 bytes long privateKey
     * @returns KeyPair
     */
    Utils.prototype.createKeyPair = function (base64PrivateKey) {
        var sk = base64PrivateKey.slice(0, 32);
        return new keyPair_1.KeyPair({ prv: Buffer.from(sk).toString('hex') });
    };
    /**
     * decodePrivateKey generates a seed with a mnemonic and using algosdk.
     *
     * @param seed 32 bytes long seed
     * @returns mnemonic - 25 words mnemonic - 25 words mnemonic
     */
    Utils.prototype.mnemonicFromSeed = function (seed) {
        return algosdk_1.default.masterDerivationKeyToMnemonic(seed);
    };
    /**
     * Validates the key with the stellar-sdk
     *
     * @param publicKey
     * @returns boolean
     */
    Utils.prototype.isValidEd25519PublicKeyStellar = function (publicKey) {
        return stellar_sdk_1.default.StrKey.isValidEd25519PublicKey(publicKey);
    };
    /**
     * Decodes the key with the stellar-sdk
     *
     * @param publicKey
     * @returns Buffer
     */
    Utils.prototype.decodeEd25519PublicKeyStellar = function (publicKey) {
        return stellar_sdk_1.default.StrKey.decodeEd25519PublicKey(publicKey);
    };
    /**
     * Convert a stellar seed to algorand encoding
     *
     * @param seed
     * @returns string the encoded seed
     */
    Utils.prototype.convertFromStellarSeed = function (seed) {
        return seedEncoding_1.SeedEncoding.encode(stellar_sdk_1.default.StrKey.decodeEd25519SecretSeed(seed));
    };
    /**
     * Returns an address encoded with algosdk
     *
     * @param addr
     * @returns string
     */
    Utils.prototype.encodeAddress = function (addr) {
        return algosdk_1.default.encodeAddress(addr);
    };
    /**
     * Return an address decoded with algosdk
     *
     * @param addr
     * @returns Address
     */
    Utils.prototype.decodeAddress = function (addr) {
        return algosdk_1.default.decodeAddress(addr);
    };
    /**
     * Converts an address into an ALGO one
     * If the given data is a Stellar address or public key, it is converted to ALGO address.
     *
     * @param addressOrPubKey an ALGO address, or an Stellar address or public key
     * @returns address algo address string
     */
    Utils.prototype.stellarAddressToAlgoAddress = function (addressOrPubKey) {
        // we have an Algorand address
        if (this.isValidAddress(addressOrPubKey)) {
            return addressOrPubKey;
        }
        // we have a stellar key
        if (this.isValidEd25519PublicKeyStellar(addressOrPubKey)) {
            var stellarPub = this.decodeEd25519PublicKeyStellar(addressOrPubKey);
            var algoAddress = this.encodeAddress(stellarPub);
            if (this.isValidAddress(algoAddress)) {
                return algoAddress;
            }
            throw new Error('Cannot convert Stellar address to an Algorand address via pubkey.');
        }
        throw new Error('Neither an Algorand address nor a stellar pubkey.');
    };
    /**
     * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
     *
     * @param {number} version mutlisig version
     * @param {number} threshold multisig threshold
     * @param {string[]} addrs list of Algorand addresses
     * @returns {string} human readable Algorand address.
     */
    Utils.prototype.multisigAddress = function (version, threshold, addrs) {
        return algosdk_1.default.multisigAddress({
            version: version,
            threshold: threshold,
            addrs: addrs,
        });
    };
    /**
     * generateAccount generates un account with a secretKey and an address
     *
     * Function has not params
     * @returns Account
     */
    Utils.prototype.generateAccount = function () {
        return algosdk_1.default.generateAccount();
    };
    Utils.prototype.generateAccountFromSeed = function (seed) {
        var keys = nacl.sign.keyPair.fromSeed(seed);
        return {
            addr: algosdk_1.default.encodeAddress(keys.publicKey),
            sk: keys.secretKey,
        };
    };
    /**
     * Generates Tx ID from an encoded multisig transaction
     *
     * This is done because of a change made on version 1.10.1 on algosdk so method txID() only supports SignedTransaction type.
     * (https://github.com/algorand/js-algorand-sdk/blob/develop/CHANGELOG.md#1101)
     *
     * @param {string} txBase64 - encoded base64 multisig transaction
     * @returns {string} - transaction ID
     */
    Utils.prototype.getMultisigTxID = function (txBase64) {
        var txBytes = Buffer.from(txBase64, 'base64');
        var decodeSignTx = algosdk_1.default.decodeSignedTransaction(txBytes);
        var wellFormedDecodedSignTx = decodeSignTx.txn.get_obj_for_encoding();
        var txForEncoding = { msig: decodeSignTx.msig, txn: wellFormedDecodedSignTx };
        var en_msg = encoding.encode(txForEncoding);
        var tag = Buffer.from([84, 88]);
        var gh = Buffer.from(concatArrays(tag, en_msg));
        var hash = Buffer.from(algoNacl.genericHash(gh));
        return hi_base32_1.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
    };
    /**
     * Determines if a given transaction data is to enable or disable a token
     * @param amount the amount in transaction
     * @param from the originated address
     * @param to the target address
     * @param closeRemainderTo (optional) address to send remaining units in originated address
     * @returns 'enableToken' or 'disableToken'
     */
    Utils.prototype.getTokenTxType = function (amount, from, to, closeRemainderTo) {
        var type = 'transferToken';
        if (amount === '0' && from === to) {
            type = !closeRemainderTo ? 'enableToken' : 'disableToken';
        }
        return type;
    };
    /**
     * Validate if the key is a valid base64 string
     * @param key the key to validate
     */
    Utils.prototype.validateBase64 = function (key) {
        if (!key || typeof key !== 'string') {
            throw new Error('Invalid base64 string');
        }
        var base64RegExp = /^(?:[a-zA-Z0-9+\/]{4})*(?:|(?:[a-zA-Z0-9+\/]{3}=)|(?:[a-zA-Z0-9+\/]{2}==)|(?:[a-zA-Z0-9+\/]{1}===))$/;
        if (!base64RegExp.test(key)) {
            throw new Error('Invalid base64 string');
        }
    };
    return Utils;
}());
exports.Utils = Utils;
var utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9hbGdvL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBOEI7QUFDOUIsNERBQWtDO0FBQ2xDLGtEQUFzQztBQUN0Qyw4Q0FBa0M7QUFDbEMsd0RBQStCO0FBQy9CLHdEQUErQjtBQUMvQixrREFBdUI7QUFDdkIsNkNBQXNGO0FBRXRGLDZDQUE4RjtBQUU5RixxQ0FBb0M7QUFDcEMsK0NBQThDO0FBQzlDLCtFQUFtRTtBQUNuRSwrRUFBbUU7QUFFbkUsSUFBTSw2QkFBNkIsR0FBRyxDQUFDLENBQUM7QUFDeEMsSUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUM7QUFDaEMsSUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUM7QUFDckMsSUFBTSwyQkFBMkIsR0FBRyxFQUFFLENBQUM7QUFDdkMsSUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFFN0I7Ozs7O0dBS0c7QUFDSCxTQUFTLFdBQVcsQ0FBQyxLQUFhO0lBQ2hDLE9BQU8sbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFTLFlBQVksQ0FBQyxDQUFhLEVBQUUsQ0FBYTtJQUNoRCxJQUFNLENBQUMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25CLE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQUVEO0lBQUE7SUFzZ0JBLENBQUM7SUFyZ0JDLGtCQUFrQjtJQUNsQiw4QkFBYyxHQUFkLFVBQWUsT0FB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QUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztTQUMxQztRQUNELElBQU0sWUFBWSxHQUNoQixzR0FBc0csQ0FBQztRQUN6RyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7U0FDMUM7SUFDSCxDQUFDO0lBQ0gsWUFBQztBQUFELENBQUMsQUF0Z0JELElBc2dCQztBQXRnQlksc0JBQUs7QUF3Z0JsQixJQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0FBRTFCLGtCQUFlLEtBQUssQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhbGdvc2RrIGZyb20gJ2FsZ29zZGsnO1xuaW1wb3J0IHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0ICogYXMgaGV4IGZyb20gJ0BzdGFibGVsaWIvaGV4JztcbmltcG9ydCAqIGFzIG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCBiYXNlMzIgZnJvbSAnaGktYmFzZTMyJztcbmltcG9ydCBzaGE1MTIgZnJvbSAnanMtc2hhNTEyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleSwgaXNWYWxpZEVkMjU1MTlTZWNyZXRLZXkgfSBmcm9tICcuLi8uLi91dGlscy9jcnlwdG8nO1xuaW1wb3J0IHsgQmFzZVV0aWxzIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgSW52YWxpZEtleSwgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsIE5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgQWRkcmVzcywgRW5jb2RlZFR4LCBTZWVkIH0gZnJvbSAnLi9pZmFjZXMnO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgeyBTZWVkRW5jb2RpbmcgfSBmcm9tICcuL3NlZWRFbmNvZGluZyc7XG5pbXBvcnQgKiBhcyBhbGdvTmFjbCBmcm9tICdhbGdvc2RrL2Rpc3QvY2pzL3NyYy9uYWNsL25hY2xXcmFwcGVycyc7XG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdhbGdvc2RrL2Rpc3QvY2pzL3NyYy9lbmNvZGluZy9lbmNvZGluZyc7XG5cbmNvbnN0IEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RIID0gNDtcbmNvbnN0IEFMR09SQU5EX1NFRURfTEVOR1RIID0gNTg7XG5jb25zdCBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIID0gMzY7XG5jb25zdCBBTEdPUkFORF9UUkFOU0FDVElPTl9MRU5HVEggPSA1MjtcbmNvbnN0IFNFRURfQllURVNfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdHJpbmcgaXMgb25seSBjb21wb3NlZCBvZiBoZXggY2hhcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1heWJlIFRoZSBzdHJpbmcgdG8gYmUgdmFsaWRhdGVkLlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0cmluZyBjb25zaXN0cyBvZiBvbmx5IGhleCBjaGFyYWN0ZXJzLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGFsbEhleENoYXJzKG1heWJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eKFswLTlhLWZdezJ9KSskL2kudGVzdChtYXliZSk7XG59XG5cbi8qKlxuICogQ29uY2F0QXJyYXlzIHRha2VzIHR3byBhcnJheSBhbmQgcmV0dXJucyBhIGpvaW50IGFycmF5IG9mIGJvdGhcbiAqXG4gKiBAcGFyYW0gYSB7VWludDhBcnJheX0gZmlyc3QgYXJyYXkgdG8gY29uY2F0XG4gKiBAcGFyYW0gYiB7VWludDhBcnJheX0gc2Vjb25kIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gYSBuZXcgYXJyYXkgY29udGFpbmluZyBhbGwgZWxlbWVudHMgb2YgJ2EnIGZvbGxvd2VkIGJ5IGFsbCBlbGVtZW50cyBvZiAnYidcbiAqL1xuZnVuY3Rpb24gY29uY2F0QXJyYXlzKGE6IFVpbnQ4QXJyYXksIGI6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICBjLnNldChhKTtcbiAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICByZXR1cm4gYztcbn1cblxuZXhwb3J0IGNsYXNzIFV0aWxzIGltcGxlbWVudHMgQmFzZVV0aWxzIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhbGdvc2RrLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRUcmFuc2FjdGlvbklkKHR4SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0eElkLmxlbmd0aCAhPT0gMTA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbEhleENoYXJzKHR4SWQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQdWJsaWNLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoa2V5KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHJpdmF0ZUtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkRWQyNTUxOVNlY3JldEtleShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaGV4IHN0cmluZyBvZiB0aGUgZ2l2ZW4gYnVmZmVyXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0byBiZSBjb252ZXJ0ZWQgdG8gaGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleCB2YWx1ZVxuICAgKi9cbiAgdG9IZXgoYnVmZmVyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gaGV4LmVuY29kZShidWZmZXIsIHRydWUpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaXNWYWxpZFNpZ25hdHVyZSBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEJsb2NrSWQoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2hhc2ggbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIEtleXNcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXkxIC0ga2V5IHRvIGJlIGNvbXBhcmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXkyIC0ga2V5IHRvIGJlIGNvbXBhcmVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gcmV0dXJucyB0cnVlIGlmIGJvdGgga2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGFyZUtleXNFcXVhbChrZXkxOiBVaW50OEFycmF5LCBrZXkyOiBVaW50OEFycmF5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hY2wudmVyaWZ5KGtleTEsIGtleTIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBVaW50OEFycmF5IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSB0aGUgaGV4IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgVWludDhBcnJheSB2YWx1ZVxuICAgKi9cbiAgdG9VaW50OEFycmF5KHN0cjogc3RyaW5nKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHNlZWQgaXMgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkIC0gdGhlIHNlZWQgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHNlZWQgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRTZWVkKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0eXBlb2Ygc2VlZCAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChzZWVkLmxlbmd0aCAhPT0gQUxHT1JBTkRfU0VFRF9MRU5HVEgpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFRyeSB0byBkZWNvZGVcbiAgICBsZXQgZGVjb2RlZDtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IHRoaXMuZGVjb2RlU2VlZChzZWVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBjaGVja3N1bVxuICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBzaGE1MTIuc2hhNTEyXzI1Ni5hcnJheShkZWNvZGVkLnNlZWQpLnNsaWNlKFNFRURfQllURVNfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEgsIFNFRURfQllURVNfTEVOR1RIKSxcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoZWNrc3VtIG1hdGNoZXMgdGhlIG9uZSBmcm9tIHRoZSBkZWNvZGVkIHNlZWRcbiAgICByZXR1cm4gXy5pc0VxdWFsKGNoZWNrc3VtLCBkZWNvZGVkLmNoZWNrc3VtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gYWxnbyBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSAge0J1ZmZlcn0gc2VjcmV0S2V5IC0gdGhlIHZhbGlkIHNlY3JldEtleSAuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHNlZWQgdG8gYmUgdmFsaWRhdGVkLlxuICAgKi9cbiAgZW5jb2RlU2VlZChzZWNyZXRLZXk6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgLy8gZ2V0IHNlZWRcbiAgICBjb25zdCBzZWVkID0gc2VjcmV0S2V5LnNsaWNlKDAsIFNFRURfQllURVNfTEVOR1RIKTtcbiAgICAvLyBjb21wdXRlIGNoZWNrc3VtXG4gICAgY29uc3QgY2hlY2tzdW0gPSBCdWZmZXIuZnJvbShcbiAgICAgIHNoYTUxMi5zaGE1MTJfMjU2LmFycmF5KHNlZWQpLnNsaWNlKFNFRURfQllURVNfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEgsIFNFRURfQllURVNfTEVOR1RIKSxcbiAgICApO1xuICAgIGNvbnN0IGVuY29kZWRTZWVkID0gYmFzZTMyLmVuY29kZShjb25jYXRBcnJheXMoc2VlZCwgY2hlY2tzdW0pKTtcblxuICAgIHJldHVybiBlbmNvZGVkU2VlZC50b1N0cmluZygpLnNsaWNlKDAsIEFMR09SQU5EX1NFRURfTEVOR1RIKTsgLy8gcmVtb3ZpbmcgdGhlIGV4dHJhICc9PT09J1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZVNlZWQgZGVjb2RlcyBhbiBhbGdvIHNlZWRcbiAgICpcbiAgICogRGVjb2RpbmcgYWxnbyBzZWVkIGlzIHNhbWUgYXMgZGVjb2RpbmcgYWRkcmVzcy5cbiAgICogTGF0ZXN0IHZlcnNpb24gb2YgYWxnbyBzZGsgKDEuOSwgYXQgdGhpcyB3cml0aW5nKSBkb2VzIG5vdCBleHBvc2UgZXhwbGljaXQgbWV0aG9kIGZvciBkZWNvZGluZyBzZWVkLlxuICAgKiBQYXJhbWV0ZXIgaXMgZGVjb2RlZCBhbmQgc3BsaXQgaW50byBzZWVkIGFuZCBjaGVja3N1bS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlZWQgLSBoZXggb3IgYmFzZTY0IGVuY29kZWQgc2VlZCB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHJldHVybnMge1NlZWR9IC0gdmFsaWRhdGVkIG9iamVjdCBTZWVkXG4gICAqL1xuICBkZWNvZGVTZWVkKHNlZWQ6IHN0cmluZyk6IFNlZWQge1xuICAgIC8vIHRyeSB0byBkZWNvZGVcbiAgICBjb25zdCBkZWNvZGVkID0gYmFzZTMyLmRlY29kZS5hc0J5dGVzKHNlZWQpO1xuXG4gICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgaWYgKGRlY29kZWQubGVuZ3RoICE9PSBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIKSB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgc2VlbXMgdG8gYmUgbWFsZm9ybWVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlZWQ6IG5ldyBVaW50OEFycmF5KGRlY29kZWQuc2xpY2UoMCwgQUxHT1JBTkRfU0VFRF9CWVRFX0xFTkdUSCAtIEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RIKSksXG4gICAgICBjaGVja3N1bTogbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5zbGljZShTRUVEX0JZVEVTX0xFTkdUSCwgQUxHT1JBTkRfU0VFRF9CWVRFX0xFTkdUSCkpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgaWYgc2lnbmF0dXJlIGZvciBtZXNzYWdlIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHtVaW50OEFycmF5fSBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlIHtVaW50OEFycmF5fSBzaWduZWQgbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHtCdWZmZXJ9IHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2U6IFVpbnQ4QXJyYXksIHNpZ25hdHVyZTogQnVmZmVyLCBwdWI6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhbiBFZDI1NTE5IHB1YmxpYyBrZXkgaW50byBhbiBhbGdvcmFuZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBrIFRoZSBFZDI1NTE5IHB1YmxpYyBrZXkuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYWxnb3JhbmQub3JnL2RvY3MvZmVhdHVyZXMvYWNjb3VudHMvI3RyYW5zZm9ybWF0aW9uLXB1YmxpYy1rZXktdG8tYWxnb3JhbmQtYWRkcmVzc1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWxnb3JhbmQgYWRkcmVzcy5cbiAgICovXG4gIHB1YmxpY0tleVRvQWxnb0FkZHJlc3MocGs6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHB1YjogQnVmZmVyLmZyb20ocGspLnRvU3RyaW5nKCdoZXgnKSB9KS5nZXRBZGRyZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHVuc2lnbmVkIGFsZ28gdHJhbnNhY3Rpb24gY2FuIGJlIGRlY29kZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdHhuIFRoZSBlbmNvZGVkIHVuc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gY2FuIGJlIGRlY29kZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgKi9cbiAgcHJvdGVjdGVkIGlzRGVjb2RhYmxlVW5zaWduZWRBbGdvVHhuKHR4bjogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBhbGdvc2RrLmRlY29kZVVuc2lnbmVkVHJhbnNhY3Rpb24odHhuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzaWduZWQgYWxnbyB0cmFuc2FjdGlvbiBjYW4gYmUgZGVjb2RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB0eG4gVGhlIGVuY29kZWQgc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gY2FuIGJlIGRlY29kZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgKi9cbiAgcHJvdGVjdGVkIGlzRGVjb2RhYmxlU2lnbmVkVHJhbnNhY3Rpb24odHhuOiBVaW50OEFycmF5KTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGFsZ29zZGsuZGVjb2RlU2lnbmVkVHJhbnNhY3Rpb24odHhuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIGEgc2lnbmVkIG9yIHVuc2lnbmVkIGFsZ28gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheSB8IHN0cmluZ30gdHhuQnl0ZXMgVGhlIGVuY29kZWQgdW5zaWduZWQgb3Igc2lnbmVkIHR4bi5cbiAgICogQHJldHVybnMge0VuY29kZWRUeH0gVGhlIGRlY29kZWQgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBkZWNvZGVBbGdvVHhuKHR4bkJ5dGVzOiBVaW50OEFycmF5IHwgc3RyaW5nKTogRW5jb2RlZFR4IHtcbiAgICBsZXQgYnVmZmVyID1cbiAgICAgIHR5cGVvZiB0eG5CeXRlcyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh0eG5CeXRlcywgYWxsSGV4Q2hhcnModHhuQnl0ZXMpID8gJ2hleCcgOiAnYmFzZTY0JylcbiAgICAgICAgOiBCdWZmZXIuZnJvbSh0eG5CeXRlcyk7XG5cbiAgICAvLyBJbiBvcmRlciB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGtleXJlZyB0cmFuc2FjdGlvbnMgZW5jb2RlZCB3aXRoXG4gICAgLy8gZm9ya2VkIGFsZ29zZGsgMS4yLjAgKGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9hbGdvc2RrLWJpdGdvKSxcbiAgICAvLyB0aGUgcmVsZXZhbnQgaW5mb3JtYXRpb24gaXMgZXh0cmFjdGVkIGFuZCBwYXJzZWQgZm9sbG93aW5nIHRoZSBsYXRlc3QgYWxnb3Nka1xuICAgIC8vIHJlbGVhc2Ugc3RhbmRhcmQuXG4gICAgLy8gVGhpcyB3YXkgd2UgY2FuIGRlY29kZSB0cmFuc2FjdGlvbnMgc3VjY2Vzc2Z1bGx5IGJ5IHN0aWxsIG1haW50YWluaW5nIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgY29uc3QgZGVjb2RlZFR4ID0gZW5jb2RpbmcuZGVjb2RlKGJ1ZmZlcik7XG4gICAgaWYgKFxuICAgICAgZGVjb2RlZFR4LnR4biAmJlxuICAgICAgZGVjb2RlZFR4LnR4bi50eXBlID09PSAna2V5cmVnJyAmJlxuICAgICAgZGVjb2RlZFR4LnR4bi52b3RlZnN0ICYmXG4gICAgICBkZWNvZGVkVHgudHhuLnZvdGVsc3QgJiZcbiAgICAgIGRlY29kZWRUeC50eG4udm90ZWtkXG4gICAgKSB7XG4gICAgICBkZWNvZGVkVHgudHhuLnZvdGVrZXkgPSBkZWNvZGVkVHgudHhuLnZvdGVrZXkgfHwgZGVjb2RlZFR4Lm1zaWcuc3Vic2lnWzBdLnBrO1xuICAgICAgZGVjb2RlZFR4LnR4bi5zZWxrZXkgPSBkZWNvZGVkVHgudHhuLnNlbGtleSB8fCBkZWNvZGVkVHgubXNpZy5zdWJzaWdbMF0ucGs7XG4gICAgICBidWZmZXIgPSBkZWNvZGVkVHgubXNpZyB8fCBkZWNvZGVkVHguc2lnID8gZW5jb2RpbmcuZW5jb2RlKGRlY29kZWRUeCkgOiBlbmNvZGluZy5lbmNvZGUoZGVjb2RlZFR4LnR4bik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnRyeVRvRGVjb2RlVW5zaWduZWRUcmFuc2FjdGlvbihidWZmZXIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlIGVycm9yIHRvIHRyeSBkaWZmZXJlbnQgZm9ybWF0XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnRyeVRvRGVjb2RlU2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gY2Fubm90IGJlIGRlY29kZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIGRlY29kZSBhIHNpZ25lZCBBbGdvIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBidWZmZXIgdGhlIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMgeyBFbmNvZGVkVHggfSB0aGUgZGVjb2RlZCBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHRocm93cyBlcnJvciBpZiBpdCBpcyBub3QgYSB2YWxpZCBlbmNvZGVkIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgdHJ5VG9EZWNvZGVTaWduZWRUcmFuc2FjdGlvbihidWZmZXI6IEJ1ZmZlcik6IEVuY29kZWRUeCB7XG4gICAgLy8gVE9ETzogUmVwbGFjZSB3aXRoXG4gICAgLy8gcmV0dXJuIGFsZ29zZGsuVHJhbnNhY3Rpb24uZnJvbV9vYmpfZm9yX2VuY29kaW5nKGFsZ29zZGsuZGVjb2RlU2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyKS50eG4pO1xuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kL2pzLWFsZ29yYW5kLXNkay9pc3N1ZXMvMzY0XG4gICAgLy8gXCIuLi5zb21lIHBhcnRzIG9mIHRoZSBjb2RlYmFzZSB0cmVhdCB0aGUgb3V0cHV0IG9mIFRyYW5zYWN0aW9uLmZyb21fb2JqX2Zvcl9lbmNvZGluZyBhcyBFbmNvZGVkVHJhbnNhY3Rpb24uXG4gICAgLy8gVGhleSBuZWVkIHRvIGJlIGZpeGVkKG9yIHdlIGF0IGxlYXN0IG5lZWQgdG8gbWFrZSBpdCBzbyBUcmFuc2FjdGlvbiBjb25mb3JtcyB0byBFbmNvZGVkVHJhbnNhY3Rpb24pLlwiXG4gICAgY29uc3QgdHggPSBhbGdvc2RrLmRlY29kZVNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG5cbiAgICBjb25zdCBzaWduZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHNpZ25lZEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmICh0eC5tc2lnICYmIHR4Lm1zaWcuc3Vic2lnKSB7XG4gICAgICBmb3IgKGNvbnN0IHNpZyBvZiB0eC5tc2lnLnN1YnNpZykge1xuICAgICAgICBjb25zdCBhZGRyID0gYWxnb3Nkay5lbmNvZGVBZGRyZXNzKHNpZy5wayk7XG4gICAgICAgIHNpZ25lcnMucHVzaChhZGRyKTtcbiAgICAgICAgaWYgKHNpZy5zKSB7XG4gICAgICAgICAgc2lnbmVkQnkucHVzaChhZGRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByYXdUcmFuc2FjdGlvbjogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSxcbiAgICAgIHR4bjogdHgudHhuLFxuICAgICAgc2lnbmVkOiB0cnVlLFxuICAgICAgc2lnbmVyczogc2lnbmVycyxcbiAgICAgIHNpZ25lZEJ5OiBzaWduZWRCeSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBkZWNvZGUgYW4gdW5zaWduZWQgQWxnbyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVmZmVyIHRoZSBlbmNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtFbmNvZGVkVHh9IHRoZSBkZWNvZGVkIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgaXQgaXMgbm90IGEgdmFsaWQgZW5jb2RlZCB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgdHJ5VG9EZWNvZGVVbnNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcjogQnVmZmVyKTogRW5jb2RlZFR4IHtcbiAgICBjb25zdCB0eG4gPSBhbGdvc2RrLmRlY29kZVVuc2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3VHJhbnNhY3Rpb246IG5ldyBVaW50OEFycmF5KGJ1ZmZlciksXG4gICAgICB0eG4sXG4gICAgICBzaWduZWQ6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvKlxuICAgKiBlbmNvZGVPYmogdGFrZXMgYSBqYXZhc2NyaXB0IG9iamVjdCBhbmQgcmV0dXJucyBpdHMgbXNncGFjayBlbmNvZGluZ1xuICAgKiBOb3RlIHRoYXQgdGhlIGVuY29kaW5nIHNvcnRzIHRoZSBmaWVsZHMgYWxwaGFiZXRpY2FsbHlcbiAgICpcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBhbnk+fSBvYmoganMgb2JqXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBVaW50OEFycmF5IGJpbmFyeSByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgZW5jb2RlT2JqKG9iajogUmVjb3JkPHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgYW55Pik6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBhbGdvc2RrLmVuY29kZU9iaihvYmopO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZU9iaiB0YWtlcyBhIFVpbnQ4QXJyYXkgYW5kIHJldHVybnMgaXRzIGphdmFzY3JpcHQgb2JqXG4gICAqIEBwYXJhbSBvIC0gVWludDhBcnJheSB0byBkZWNvZGVcbiAgICogQHJldHVybnMgb2JqZWN0XG4gICAqL1xuICBkZWNvZGVPYmoobzogQXJyYXlMaWtlPG51bWJlcj4pOiB1bmtub3duIHtcbiAgICByZXR1cm4gYWxnb3Nkay5kZWNvZGVPYmoobyk7XG4gIH1cblxuICAvKipcbiAgICogc2VjcmV0S2V5VG9NbmVtb25pYyB0YWtlcyBhbiBBbGdvcmFudCBzZWNyZXQga2V5IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIG1uZW1vbmljXG4gICAqXG4gICAqIEBwYXJhbSBzayAtIEFsZ29yYW50IHNlY3JldCBrZXlcbiAgICogQHJldHVybiBTZWNyZXQga2V5IGlzIGFzc29jaWF0ZWQgbW5lbW9uaWNcbiAgICovXG4gIHNlY3JldEtleVRvTW5lbW9uaWMoc2s6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgY29uc3Qgc2tWYWxpZCA9IEJ1ZmZlci5mcm9tKHNrLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRQcml2YXRlS2V5KHNrVmFsaWQudG9TdHJpbmcoJ2hleCcpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRLZXkoYFRoZSBzZWNyZXQga2V5OiAke3NrLnRvU3RyaW5nKCdoZXgnKX0gaXMgaW52YWxpZGApO1xuICAgIH1cbiAgICBjb25zdCBza1VuaXQ4QXJyYXkgPSBCdWZmZXIuZnJvbShzayk7XG4gICAgcmV0dXJuIGFsZ29zZGsuc2VjcmV0S2V5VG9NbmVtb25pYyhza1VuaXQ4QXJyYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlZWRGcm9tTW5lbW9uaWMgY29udmVydHMgYSBtbmVtb25pYyBnZW5lcmF0ZWQgdXNpbmcgdGhpcyBsaWJyYXJ5IGludG8gdGhlIHNvdXJjZSBrZXkgdXNlZCB0byBjcmVhdGUgaXRcbiAgICogSXQgcmV0dXJucyBhbiBlcnJvciBpZiB0aGUgcGFzc2VkIG1uZW1vbmljIGhhcyBhbiBpbmNvcnJlY3QgY2hlY2tzdW0sIGlmIHRoZSBudW1iZXIgb2Ygd29yZHMgaXMgdW5leHBlY3RlZCwgb3IgaWYgb25lXG4gICAqIG9mIHRoZSBwYXNzZWQgd29yZHMgaXMgbm90IGZvdW5kIGluIHRoZSB3b3JkcyBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSBtbmVtb25pYyAtIDI1IHdvcmRzIG1uZW1vbmljXG4gICAqIEByZXR1cm5zIDMyIGJ5dGVzIGxvbmcgc2VlZFxuICAgKi9cbiAgc2VlZEZyb21NbmVtb25pYyhtbmVtb25pYzogc3RyaW5nKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIGFsZ29zZGsubW5lbW9uaWNUb01hc3RlckRlcml2YXRpb25LZXkobW5lbW9uaWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGtleVBhaXJGcm9tU2VlZCBnZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggc2VjcmV0S2V5IGFuZCBwdWJsaWNLZXkgdXNpbmcgdGhlIGFsZ29zZGtcbiAgICogQHBhcmFtIHNlZWQgMzIgYnl0ZXMgbG9uZyBzZWVkXG4gICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICovXG4gIGtleVBhaXJGcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogS2V5UGFpciB7XG4gICAgY29uc3QgbW4gPSB0aGlzLm1uZW1vbmljRnJvbVNlZWQoc2VlZCk7XG4gICAgY29uc3QgYmFzZTY0UHJpdmF0ZUtleSA9IGFsZ29zZGsubW5lbW9uaWNUb1NlY3JldEtleShtbikuc2s7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlS2V5UGFpcihiYXNlNjRQcml2YXRlS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBgS2V5UGFpcmAgb2JqZWN0IGZyb20gdGhlIGdpdmVuIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZTY0UHJpdmF0ZUtleSA2NCBieXRlcyBsb25nIHByaXZhdGVLZXlcbiAgICogQHJldHVybnMgS2V5UGFpclxuICAgKi9cbiAgcHJvdGVjdGVkIGNyZWF0ZUtleVBhaXIoYmFzZTY0UHJpdmF0ZUtleTogVWludDhBcnJheSk6IEtleVBhaXIge1xuICAgIGNvbnN0IHNrID0gYmFzZTY0UHJpdmF0ZUtleS5zbGljZSgwLCAzMik7XG4gICAgcmV0dXJuIG5ldyBLZXlQYWlyKHsgcHJ2OiBCdWZmZXIuZnJvbShzaykudG9TdHJpbmcoJ2hleCcpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZVByaXZhdGVLZXkgZ2VuZXJhdGVzIGEgc2VlZCB3aXRoIGEgbW5lbW9uaWMgYW5kIHVzaW5nIGFsZ29zZGsuXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIDMyIGJ5dGVzIGxvbmcgc2VlZFxuICAgKiBAcmV0dXJucyBtbmVtb25pYyAtIDI1IHdvcmRzIG1uZW1vbmljIC0gMjUgd29yZHMgbW5lbW9uaWNcbiAgICovXG4gIHByb3RlY3RlZCBtbmVtb25pY0Zyb21TZWVkKHNlZWQ6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIHJldHVybiBhbGdvc2RrLm1hc3RlckRlcml2YXRpb25LZXlUb01uZW1vbmljKHNlZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUga2V5IHdpdGggdGhlIHN0ZWxsYXItc2RrXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXlcbiAgICogQHJldHVybnMgYm9vbGVhblxuICAgKi9cbiAgcHJvdGVjdGVkIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5U3RlbGxhcihwdWJsaWNLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIGtleSB3aXRoIHRoZSBzdGVsbGFyLXNka1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5XG4gICAqIEByZXR1cm5zIEJ1ZmZlclxuICAgKi9cbiAgcHJvdGVjdGVkIGRlY29kZUVkMjU1MTlQdWJsaWNLZXlTdGVsbGFyKHB1YmxpY0tleTogc3RyaW5nKTogQnVmZmVyIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzdGVsbGFyIHNlZWQgdG8gYWxnb3JhbmQgZW5jb2RpbmdcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMgc3RyaW5nIHRoZSBlbmNvZGVkIHNlZWRcbiAgICovXG4gIGNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gU2VlZEVuY29kaW5nLmVuY29kZShzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5U2VjcmV0U2VlZChzZWVkKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhZGRyZXNzIGVuY29kZWQgd2l0aCBhbGdvc2RrXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyXG4gICAqIEByZXR1cm5zIHN0cmluZ1xuICAgKi9cbiAgZW5jb2RlQWRkcmVzcyhhZGRyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWxnb3Nkay5lbmNvZGVBZGRyZXNzKGFkZHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhZGRyZXNzIGRlY29kZWQgd2l0aCBhbGdvc2RrXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyXG4gICAqIEByZXR1cm5zIEFkZHJlc3NcbiAgICovXG4gIGRlY29kZUFkZHJlc3MoYWRkcjogc3RyaW5nKTogQWRkcmVzcyB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZGVjb2RlQWRkcmVzcyhhZGRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBhZGRyZXNzIGludG8gYW4gQUxHTyBvbmVcbiAgICogSWYgdGhlIGdpdmVuIGRhdGEgaXMgYSBTdGVsbGFyIGFkZHJlc3Mgb3IgcHVibGljIGtleSwgaXQgaXMgY29udmVydGVkIHRvIEFMR08gYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3NPclB1YktleSBhbiBBTEdPIGFkZHJlc3MsIG9yIGFuIFN0ZWxsYXIgYWRkcmVzcyBvciBwdWJsaWMga2V5XG4gICAqIEByZXR1cm5zIGFkZHJlc3MgYWxnbyBhZGRyZXNzIHN0cmluZ1xuICAgKi9cbiAgc3RlbGxhckFkZHJlc3NUb0FsZ29BZGRyZXNzKGFkZHJlc3NPclB1YktleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyB3ZSBoYXZlIGFuIEFsZ29yYW5kIGFkZHJlc3NcbiAgICBpZiAodGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzT3JQdWJLZXkpKSB7XG4gICAgICByZXR1cm4gYWRkcmVzc09yUHViS2V5O1xuICAgIH1cbiAgICAvLyB3ZSBoYXZlIGEgc3RlbGxhciBrZXlcbiAgICBpZiAodGhpcy5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleVN0ZWxsYXIoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgY29uc3Qgc3RlbGxhclB1YiA9IHRoaXMuZGVjb2RlRWQyNTUxOVB1YmxpY0tleVN0ZWxsYXIoYWRkcmVzc09yUHViS2V5KTtcbiAgICAgIGNvbnN0IGFsZ29BZGRyZXNzID0gdGhpcy5lbmNvZGVBZGRyZXNzKHN0ZWxsYXJQdWIpO1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZEFkZHJlc3MoYWxnb0FkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhbGdvQWRkcmVzcztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgU3RlbGxhciBhZGRyZXNzIHRvIGFuIEFsZ29yYW5kIGFkZHJlc3MgdmlhIHB1YmtleS4nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIGFuIEFsZ29yYW5kIGFkZHJlc3Mgbm9yIGEgc3RlbGxhciBwdWJrZXkuJyk7XG4gIH1cblxuICAvKipcbiAgICogbXVsdGlzaWdBZGRyZXNzIHRha2VzIG11bHRpc2lnIG1ldGFkYXRhIChwcmVpbWFnZSkgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgaHVtYW4gcmVhZGFibGUgQWxnb3JhbmQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gbXV0bGlzaWcgdmVyc2lvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIG11bHRpc2lnIHRocmVzaG9sZFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRycyBsaXN0IG9mIEFsZ29yYW5kIGFkZHJlc3Nlc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBodW1hbiByZWFkYWJsZSBBbGdvcmFuZCBhZGRyZXNzLlxuICAgKi9cbiAgbXVsdGlzaWdBZGRyZXNzKHZlcnNpb246IG51bWJlciwgdGhyZXNob2xkOiBudW1iZXIsIGFkZHJzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFsZ29zZGsubXVsdGlzaWdBZGRyZXNzKHtcbiAgICAgIHZlcnNpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBhZGRycyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZW5lcmF0ZUFjY291bnQgZ2VuZXJhdGVzIHVuIGFjY291bnQgd2l0aCBhIHNlY3JldEtleSBhbmQgYW4gYWRkcmVzc1xuICAgKlxuICAgKiBGdW5jdGlvbiBoYXMgbm90IHBhcmFtc1xuICAgKiBAcmV0dXJucyBBY2NvdW50XG4gICAqL1xuICBnZW5lcmF0ZUFjY291bnQoKTogYWxnb3Nkay5BY2NvdW50IHtcbiAgICByZXR1cm4gYWxnb3Nkay5nZW5lcmF0ZUFjY291bnQoKTtcbiAgfVxuXG4gIGdlbmVyYXRlQWNjb3VudEZyb21TZWVkKHNlZWQ6IFVpbnQ4QXJyYXkpOiBhbGdvc2RrLkFjY291bnQge1xuICAgIGNvbnN0IGtleXMgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZChzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcjogYWxnb3Nkay5lbmNvZGVBZGRyZXNzKGtleXMucHVibGljS2V5KSxcbiAgICAgIHNrOiBrZXlzLnNlY3JldEtleSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBUeCBJRCBmcm9tIGFuIGVuY29kZWQgbXVsdGlzaWcgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogVGhpcyBpcyBkb25lIGJlY2F1c2Ugb2YgYSBjaGFuZ2UgbWFkZSBvbiB2ZXJzaW9uIDEuMTAuMSBvbiBhbGdvc2RrIHNvIG1ldGhvZCB0eElEKCkgb25seSBzdXBwb3J0cyBTaWduZWRUcmFuc2FjdGlvbiB0eXBlLlxuICAgKiAoaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kL2pzLWFsZ29yYW5kLXNkay9ibG9iL2RldmVsb3AvQ0hBTkdFTE9HLm1kIzExMDEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEJhc2U2NCAtIGVuY29kZWQgYmFzZTY0IG11bHRpc2lnIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdHJhbnNhY3Rpb24gSURcbiAgICovXG4gIGdldE11bHRpc2lnVHhJRCh0eEJhc2U2NDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB0eEJ5dGVzID0gQnVmZmVyLmZyb20odHhCYXNlNjQsICdiYXNlNjQnKTtcbiAgICBjb25zdCBkZWNvZGVTaWduVHggPSBhbGdvc2RrLmRlY29kZVNpZ25lZFRyYW5zYWN0aW9uKHR4Qnl0ZXMpO1xuICAgIGNvbnN0IHdlbGxGb3JtZWREZWNvZGVkU2lnblR4ID0gZGVjb2RlU2lnblR4LnR4bi5nZXRfb2JqX2Zvcl9lbmNvZGluZygpO1xuICAgIGNvbnN0IHR4Rm9yRW5jb2RpbmcgPSB7IG1zaWc6IGRlY29kZVNpZ25UeC5tc2lnLCB0eG46IHdlbGxGb3JtZWREZWNvZGVkU2lnblR4IH07XG4gICAgY29uc3QgZW5fbXNnID0gZW5jb2RpbmcuZW5jb2RlKHR4Rm9yRW5jb2RpbmcpO1xuICAgIGNvbnN0IHRhZyA9IEJ1ZmZlci5mcm9tKFs4NCwgODhdKTtcbiAgICBjb25zdCBnaCA9IEJ1ZmZlci5mcm9tKGNvbmNhdEFycmF5cyh0YWcsIGVuX21zZykpO1xuICAgIGNvbnN0IGhhc2ggPSBCdWZmZXIuZnJvbShhbGdvTmFjbC5nZW5lcmljSGFzaChnaCkpO1xuICAgIHJldHVybiBiYXNlMzIuZW5jb2RlKGhhc2gpLnNsaWNlKDAsIEFMR09SQU5EX1RSQU5TQUNUSU9OX0xFTkdUSCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHRyYW5zYWN0aW9uIGRhdGEgaXMgdG8gZW5hYmxlIG9yIGRpc2FibGUgYSB0b2tlblxuICAgKiBAcGFyYW0gYW1vdW50IHRoZSBhbW91bnQgaW4gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGZyb20gdGhlIG9yaWdpbmF0ZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gdG8gdGhlIHRhcmdldCBhZGRyZXNzXG4gICAqIEBwYXJhbSBjbG9zZVJlbWFpbmRlclRvIChvcHRpb25hbCkgYWRkcmVzcyB0byBzZW5kIHJlbWFpbmluZyB1bml0cyBpbiBvcmlnaW5hdGVkIGFkZHJlc3NcbiAgICogQHJldHVybnMgJ2VuYWJsZVRva2VuJyBvciAnZGlzYWJsZVRva2VuJ1xuICAgKi9cbiAgZ2V0VG9rZW5UeFR5cGUoYW1vdW50OiBzdHJpbmcsIGZyb206IHN0cmluZywgdG86IHN0cmluZywgY2xvc2VSZW1haW5kZXJUbz86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHR5cGUgPSAndHJhbnNmZXJUb2tlbic7XG4gICAgaWYgKGFtb3VudCA9PT0gJzAnICYmIGZyb20gPT09IHRvKSB7XG4gICAgICB0eXBlID0gIWNsb3NlUmVtYWluZGVyVG8gPyAnZW5hYmxlVG9rZW4nIDogJ2Rpc2FibGVUb2tlbic7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIHRoZSBrZXkgaXMgYSB2YWxpZCBiYXNlNjQgc3RyaW5nXG4gICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB2YWxpZGF0ZVxuICAgKi9cbiAgdmFsaWRhdGVCYXNlNjQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWtleSB8fCB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U2NCBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZTY0UmVnRXhwID1cbiAgICAgIC9eKD86W2EtekEtWjAtOStcXC9dezR9KSooPzp8KD86W2EtekEtWjAtOStcXC9dezN9PSl8KD86W2EtekEtWjAtOStcXC9dezJ9PT0pfCg/OlthLXpBLVowLTkrXFwvXXsxfT09PSkpJC87XG4gICAgaWYgKCFiYXNlNjRSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFzZTY0IHN0cmluZycpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCB1dGlscyA9IG5ldyBVdGlscygpO1xuXG5leHBvcnQgZGVmYXVsdCB1dGlscztcbiJdfQ==