/// <reference types="node" />
import algosdk from 'algosdk';
import { BaseUtils } from '../baseCoin';
import { Address, EncodedTx, Seed } from './ifaces';
import { KeyPair } from './keyPair';
export declare class Utils implements BaseUtils {
    /** @inheritdoc */
    isValidAddress(address: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    /** @inheritdoc */
    isValidPublicKey(key: string): boolean;
    /** @inheritdoc */
    isValidPrivateKey(key: string): boolean;
    /**
     * Returns an hex string of the given buffer
     *
     * @param {Uint8Array} buffer - the buffer to be converted to hex
     * @returns {string} - the hex value
     */
    toHex(buffer: Uint8Array): string;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /**
     * Compare two Keys
     *
     * @param {Uint8Array} key1 - key to be compare
     * @param {Uint8Array} key2 - key to be compare
     * @returns {boolean} - returns true if both keys are equal
     */
    areKeysEqual(key1: Uint8Array, key2: Uint8Array): boolean;
    /**
     * Returns a Uint8Array of the given hex string
     *
     * @param {string} str - the hex string to be converted
     * @returns {string} - the Uint8Array value
     */
    toUint8Array(str: string): Uint8Array;
    /**
     * Determines whether a seed is valid.
     *
     * @param {string} seed - the seed to be validated
     * @returns {boolean} - true if the seed is valid
     */
    isValidSeed(seed: string): boolean;
    /**
     * Encode an algo seed
     *
     * @param  {Buffer} secretKey - the valid secretKey .
     * @returns {string} - the seed to be validated.
     */
    encodeSeed(secretKey: Buffer): string;
    /**
     * decodeSeed decodes an algo seed
     *
     * Decoding algo seed is same as decoding address.
     * Latest version of algo sdk (1.9, at this writing) does not expose explicit method for decoding seed.
     * Parameter is decoded and split into seed and checksum.
     *
     * @param {string} seed - hex or base64 encoded seed to be validated
     * @returns {Seed} - validated object Seed
     */
    decodeSeed(seed: string): Seed;
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub {Uint8Array} public key
     * @param message {Uint8Array} signed message
     * @param signature {Buffer} signature to verify
     * @returns {Boolean} true if signature is valid.
     */
    verifySignature(message: Uint8Array, signature: Buffer, pub: Uint8Array): boolean;
    /**
     * Transforms an Ed25519 public key into an algorand address.
     *
     * @param {Uint8Array} pk The Ed25519 public key.
     * @see https://developer.algorand.org/docs/features/accounts/#transformation-public-key-to-algorand-address
     *
     * @returns {string} The algorand address.
     */
    publicKeyToAlgoAddress(pk: Uint8Array): string;
    /**
     * Checks if a unsigned algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded unsigned transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    protected isDecodableUnsignedAlgoTxn(txn: Uint8Array): boolean;
    /**
     * Checks if a signed algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded signed transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    protected isDecodableSignedTransaction(txn: Uint8Array): boolean;
    /**
     * Decodes a signed or unsigned algo transaction.
     *
     * @param {Uint8Array | string} txnBytes The encoded unsigned or signed txn.
     * @returns {EncodedTx} The decoded transaction.
     */
    decodeAlgoTxn(txnBytes: Uint8Array | string): EncodedTx;
    /**
     * Try to decode a signed Algo transaction
     * @param buffer the encoded transaction
     * @returns { EncodedTx } the decoded signed transaction
     * @throws error if it is not a valid encoded signed transaction
     */
    tryToDecodeSignedTransaction(buffer: Buffer): EncodedTx;
    /**
     * Try to decode an unsigned Algo transaction
     * @param buffer the encoded transaction
     * @returns {EncodedTx} the decoded unsigned transaction
     * @throws error if it is not a valid encoded unsigned transaction
     */
    tryToDecodeUnsignedTransaction(buffer: Buffer): EncodedTx;
    encodeObj(obj: Record<string | number | symbol, any>): Uint8Array;
    /**
     * decodeObj takes a Uint8Array and returns its javascript obj
     * @param o - Uint8Array to decode
     * @returns object
     */
    decodeObj(o: ArrayLike<number>): unknown;
    /**
     * secretKeyToMnemonic takes an Algorant secret key and returns the corresponding mnemonic
     *
     * @param sk - Algorant secret key
     * @return Secret key is associated mnemonic
     */
    secretKeyToMnemonic(sk: Buffer): string;
    /**
     * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it
     * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one
     * of the passed words is not found in the words list
     *
     * @param mnemonic - 25 words mnemonic
     * @returns 32 bytes long seed
     */
    seedFromMnemonic(mnemonic: string): Uint8Array;
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the algosdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    keyPairFromSeed(seed: Uint8Array): KeyPair;
    /**
     * Generate a new `KeyPair` object from the given private key.
     *
     * @param base64PrivateKey 64 bytes long privateKey
     * @returns KeyPair
     */
    protected createKeyPair(base64PrivateKey: Uint8Array): KeyPair;
    /**
     * decodePrivateKey generates a seed with a mnemonic and using algosdk.
     *
     * @param seed 32 bytes long seed
     * @returns mnemonic - 25 words mnemonic - 25 words mnemonic
     */
    protected mnemonicFromSeed(seed: Uint8Array): string;
    /**
     * Validates the key with the stellar-sdk
     *
     * @param publicKey
     * @returns boolean
     */
    protected isValidEd25519PublicKeyStellar(publicKey: string): boolean;
    /**
     * Decodes the key with the stellar-sdk
     *
     * @param publicKey
     * @returns Buffer
     */
    protected decodeEd25519PublicKeyStellar(publicKey: string): Buffer;
    /**
     * Convert a stellar seed to algorand encoding
     *
     * @param seed
     * @returns string the encoded seed
     */
    convertFromStellarSeed(seed: string): string;
    /**
     * Returns an address encoded with algosdk
     *
     * @param addr
     * @returns string
     */
    encodeAddress(addr: Uint8Array): string;
    /**
     * Return an address decoded with algosdk
     *
     * @param addr
     * @returns Address
     */
    decodeAddress(addr: string): Address;
    /**
     * Converts an address into an ALGO one
     * If the given data is a Stellar address or public key, it is converted to ALGO address.
     *
     * @param addressOrPubKey an ALGO address, or an Stellar address or public key
     * @returns address algo address string
     */
    stellarAddressToAlgoAddress(addressOrPubKey: string): string;
    /**
     * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
     *
     * @param {number} version mutlisig version
     * @param {number} threshold multisig threshold
     * @param {string[]} addrs list of Algorand addresses
     * @returns {string} human readable Algorand address.
     */
    multisigAddress(version: number, threshold: number, addrs: string[]): string;
    /**
     * generateAccount generates un account with a secretKey and an address
     *
     * Function has not params
     * @returns Account
     */
    generateAccount(): algosdk.Account;
    generateAccountFromSeed(seed: Uint8Array): algosdk.Account;
    /**
     * Generates Tx ID from an encoded multisig transaction
     *
     * This is done because of a change made on version 1.10.1 on algosdk so method txID() only supports SignedTransaction type.
     * (https://github.com/algorand/js-algorand-sdk/blob/develop/CHANGELOG.md#1101)
     *
     * @param {string} txBase64 - encoded base64 multisig transaction
     * @returns {string} - transaction ID
     */
    getMultisigTxID(txBase64: string): string;
    /**
     * Determines if a given transaction data is to enable or disable a token
     * @param amount the amount in transaction
     * @param from the originated address
     * @param to the target address
     * @param closeRemainderTo (optional) address to send remaining units in originated address
     * @returns 'enableToken' or 'disableToken'
     */
    getTokenTxType(amount: string, from: string, to: string, closeRemainderTo?: string): string;
    /**
     * Validate if the key is a valid base64 string
     * @param key the key to validate
     */
    validateBase64(key: string): void;
}
declare const utils: Utils;
export default utils;
//# sourceMappingURL=utils.d.ts.map