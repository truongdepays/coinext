"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var multisigUtils_1 = require("./multisigUtils");
var transaction_1 = require("./transaction");
var keyPair_1 = require("./keyPair");
var utils_1 = require("./utils");
var transferBuilder_1 = require("./transferBuilder");
var DEFAULT_M = 3;
/**
 * Tezos transaction builder.
 */
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    /**
     * Public constructor.
     *
     * @param {CoinConfig} _coinConfig - coin configuration
     */
    function TransactionBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._type = baseCoin_1.TransactionType.Send;
        _this._counter = new bignumber_js_1.default(0);
        _this._transfers = [];
        _this._walletOwnerPublicKeys = [];
        _this._multisigSignerKeyPairs = [];
        _this._dataToSignOverride = [];
        _this.transaction = new transaction_1.Transaction(_coinConfig);
        return _this;
    }
    // region Base Builder
    /** @inheritdoc */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        // Decoding the transaction is an async operation, so save it and leave the decoding for the
        // build step
        this._serializedTransaction = rawTransaction;
        return new transaction_1.Transaction(this._coinConfig);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        var signer = new keyPair_1.KeyPair({ prv: key.key });
        // Currently public key revelation is the only type of account update tx supported in Tezos
        if (this._type === baseCoin_1.TransactionType.AccountUpdate && !this._publicKeyToReveal) {
            throw new errors_1.SigningError('Cannot sign a public key revelation transaction without public key');
        }
        if (this._type === baseCoin_1.TransactionType.WalletInitialization && this._walletOwnerPublicKeys.length === 0) {
            throw new errors_1.SigningError('Cannot sign an wallet initialization transaction without owners');
        }
        if (this._type === baseCoin_1.TransactionType.Send &&
            this._transfers.length === 0 &&
            this._serializedTransaction === undefined) {
            throw new errors_1.SigningError('Cannot sign an empty send transaction');
        }
        if (this._type === baseCoin_1.TransactionType.Send && (!this._sourceAddress || this._sourceAddress !== signer.getAddress())) {
            // If the signer is not the source and it is a send transaction, add it to the list of
            // multisig wallet signers
            // TODO: support a combination of keys with and without custom index
            if (key.index && key.index >= DEFAULT_M) {
                throw new errors_1.BuildTransactionError('Custom index cannot be greater than the wallet total number of signers (owners)');
            }
            // Make sure either all keys passed have a custom index or none of them have
            var shouldHaveCustomIndex = key.hasOwnProperty('index');
            for (var i = 0; i < this._multisigSignerKeyPairs.length; i++) {
                if (shouldHaveCustomIndex !== (this._multisigSignerKeyPairs[i].index !== undefined)) {
                    throw new errors_1.BuildTransactionError('Custom index has to be set for all multisig contract signing keys or none');
                }
            }
            var multisigSignerKey = shouldHaveCustomIndex ? { key: signer, index: key.index } : { key: signer };
            this._multisigSignerKeyPairs.push(multisigSignerKey);
        }
        else {
            if (this._sourceKeyPair) {
                throw new errors_1.SigningError('Cannot sign multiple times a non send-type transaction');
            }
            this._sourceKeyPair = signer;
        }
        // Signing the transaction is an async operation, so save the source and leave the actual
        // signing for the build step
        return this.transaction;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            var i, signatures, contents, _a, _b, _c, _d, _e, parsedTransaction;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!this._serializedTransaction) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.transaction.initFromSerializedTransaction(this._serializedTransaction)];
                    case 1:
                        _f.sent();
                        i = 0;
                        _f.label = 2;
                    case 2:
                        if (!(i < this._dataToSignOverride.length)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.getSignatures(this._dataToSignOverride[i].dataToSign)];
                    case 3:
                        signatures = _f.sent();
                        return [4 /*yield*/, this.transaction.addTransferSignature(signatures, this._dataToSignOverride[i].index || i)];
                    case 4:
                        _f.sent();
                        _f.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 2];
                    case 6: return [3 /*break*/, 18];
                    case 7:
                        contents = [];
                        _a = this._type;
                        switch (_a) {
                            case baseCoin_1.TransactionType.AccountUpdate: return [3 /*break*/, 8];
                            case baseCoin_1.TransactionType.WalletInitialization: return [3 /*break*/, 9];
                            case baseCoin_1.TransactionType.Send: return [3 /*break*/, 10];
                            case baseCoin_1.TransactionType.AddressInitialization: return [3 /*break*/, 12];
                            case baseCoin_1.TransactionType.SingleSigSend: return [3 /*break*/, 13];
                        }
                        return [3 /*break*/, 15];
                    case 8:
                        if (this._publicKeyToReveal) {
                            contents.push(this.buildPublicKeyRevelationOperation());
                        }
                        return [3 /*break*/, 16];
                    case 9:
                        if (this._publicKeyToReveal) {
                            contents.push(this.buildPublicKeyRevelationOperation());
                        }
                        contents.push(this.buildWalletInitializationOperations());
                        return [3 /*break*/, 16];
                    case 10:
                        if (this._publicKeyToReveal) {
                            contents.push(this.buildPublicKeyRevelationOperation());
                        }
                        _c = (_b = contents).concat;
                        return [4 /*yield*/, this.buildSendTransactionContent()];
                    case 11:
                        contents = _c.apply(_b, [_f.sent()]);
                        return [3 /*break*/, 16];
                    case 12:
                        if (this._publicKeyToReveal) {
                            contents.push(this.buildPublicKeyRevelationOperation());
                        }
                        contents = contents.concat(this.buildForwarderDeploymentContent());
                        return [3 /*break*/, 16];
                    case 13:
                        _e = (_d = contents).concat;
                        return [4 /*yield*/, this.buildSendTransactionContent()];
                    case 14:
                        // No support for revelation txns as primary use case is to send from fee address
                        contents = _e.apply(_d, [_f.sent()]);
                        return [3 /*break*/, 16];
                    case 15: throw new errors_1.BuildTransactionError('Unsupported transaction type');
                    case 16:
                        if (contents.length === 0) {
                            throw new errors_1.BuildTransactionError('Empty transaction');
                        }
                        parsedTransaction = {
                            branch: this._blockHeader,
                            contents: contents,
                        };
                        this.transaction = new transaction_1.Transaction(this._coinConfig);
                        // Build and sign a new transaction based on the latest changes
                        return [4 /*yield*/, this.transaction.initFromParsedTransaction(parsedTransaction)];
                    case 17:
                        // Build and sign a new transaction based on the latest changes
                        _f.sent();
                        _f.label = 18;
                    case 18:
                        if (!(this._sourceKeyPair && this._sourceKeyPair.getKeys().prv)) return [3 /*break*/, 20];
                        // TODO: check if there are more signers than needed for a singlesig or multisig transaction
                        return [4 /*yield*/, this.transaction.sign(this._sourceKeyPair)];
                    case 19:
                        // TODO: check if there are more signers than needed for a singlesig or multisig transaction
                        _f.sent();
                        _f.label = 20;
                    case 20: return [2 /*return*/, this.transaction];
                }
            });
        });
    };
    // endregion
    // region Common builder methods
    /**
     * Set the transaction branch id.
     *
     * @param {string} blockId A block hash to use as branch reference
     */
    TransactionBuilder.prototype.branch = function (blockId) {
        if (!utils_1.isValidBlockHash(blockId)) {
            throw new errors_1.BuildTransactionError('Invalid block hash ' + blockId);
        }
        this._blockHeader = blockId;
    };
    /**
     * The type of transaction being built.
     *
     * @param {TransactionType} type - type of the transaction
     */
    TransactionBuilder.prototype.type = function (type) {
        if (type === baseCoin_1.TransactionType.Send && this._walletOwnerPublicKeys.length > 0) {
            throw new errors_1.BuildTransactionError('Transaction cannot be labeled as Send when owners have already been set');
        }
        if (type !== baseCoin_1.TransactionType.Send && this._transfers.length > 0) {
            throw new errors_1.BuildTransactionError('Transaction contains transfers and can only be labeled as Send');
        }
        this._type = type;
    };
    /**
     * Set the transaction fees. Low fees may get a transaction rejected or never picked up by bakers.
     *
     * @param {Fee} fee Baker fees. May also include the maximum gas and storage fees to pay
     */
    TransactionBuilder.prototype.fee = function (fee) {
        this.validateValue(new bignumber_js_1.default(fee.fee));
        if (fee.gasLimit) {
            this.validateValue(new bignumber_js_1.default(fee.gasLimit));
        }
        if (fee.storageLimit) {
            this.validateValue(new bignumber_js_1.default(fee.storageLimit));
        }
        this._fee = fee;
    };
    /**
     * Set the transaction initiator. This account will pay for the transaction fees, but it will not
     * be added as an owner of a wallet in a init transaction, unless manually set as one of the
     * owners.
     *
     * @param {string} source A Tezos address
     */
    TransactionBuilder.prototype.source = function (source) {
        this.validateAddress({ address: source });
        this._sourceAddress = source;
    };
    /**
     * Set an amount of mutez to transfer in this transaction this transaction. This is different than
     * the amount to transfer from a multisig wallet.
     *
     * @param {string} amount Amount in mutez (1/1000000 Tezies)
     */
    TransactionBuilder.prototype.initialBalance = function (amount) {
        if (this._type !== baseCoin_1.TransactionType.WalletInitialization) {
            throw new errors_1.BuildTransactionError('Initial balance can only be set for wallet initialization transactions');
        }
        this.validateValue(new bignumber_js_1.default(amount));
        this._initialBalance = amount;
    };
    /**
     * Set the transaction counter to prevent submitting repeated transactions.
     *
     * @param {string} counter The counter to use
     */
    TransactionBuilder.prototype.counter = function (counter) {
        this._counter = new bignumber_js_1.default(counter);
    };
    /**
     * Set the destination address of a forwarder contract
     * Used in forwarder contract deployment as destination address
     *
     * @param {string} contractAddress - contract address to use
     */
    TransactionBuilder.prototype.forwarderDestination = function (contractAddress) {
        if (this._type !== baseCoin_1.TransactionType.AddressInitialization) {
            throw new errors_1.BuildTransactionError('Forwarder destination can only be set for address initialization transactions');
        }
        if (!utils_1.isValidOriginatedAddress(contractAddress)) {
            throw new errors_1.BuildTransactionError('Forwarder destination can only be an originated address');
        }
        this._forwarderDestination = contractAddress;
    };
    // endregion
    // region PublicKeyRevelation builder methods
    /**
     * The public key to reveal.
     *
     * @param {string} publicKey A Tezos public key
     */
    TransactionBuilder.prototype.publicKeyToReveal = function (publicKey) {
        if (this._publicKeyToReveal) {
            throw new errors_1.BuildTransactionError('Public key to reveal already set: ' + this._publicKeyToReveal);
        }
        var keyPair = new keyPair_1.KeyPair({ pub: publicKey });
        if (keyPair.getAddress() !== this._sourceAddress) {
            throw new errors_1.BuildTransactionError('Public key does not match the source address: ' + this._sourceAddress);
        }
        this._publicKeyToReveal = keyPair.getKeys().pub;
    };
    /**
     * Build a reveal operation for the source account with default fees.
     *
     * @returns {RevealOp} A Tezos reveal operation
     */
    TransactionBuilder.prototype.buildPublicKeyRevelationOperation = function () {
        var operation = multisigUtils_1.revealOperation(this._counter.toString(), this._sourceAddress, this._publicKeyToReveal);
        this._counter = this._counter.plus(1);
        return operation;
    };
    // endregion
    // region WalletInitialization builder methods
    /**
     * Set one of the owners of the multisig wallet.
     *
     * @param {string} publicKey A Tezos public key
     */
    TransactionBuilder.prototype.owner = function (publicKey) {
        if (this._type !== baseCoin_1.TransactionType.WalletInitialization) {
            throw new errors_1.BuildTransactionError('Multisig wallet owner can only be set for initialization transactions');
        }
        if (this._walletOwnerPublicKeys.length >= DEFAULT_M) {
            throw new errors_1.BuildTransactionError('A maximum of ' + DEFAULT_M + ' owners can be set for a multisig wallet');
        }
        if (!utils_1.isValidPublicKey(publicKey)) {
            throw new errors_1.BuildTransactionError('Invalid public key: ' + publicKey);
        }
        if (this._walletOwnerPublicKeys.includes(publicKey)) {
            throw new errors_1.BuildTransactionError('Repeated owner public key: ' + publicKey);
        }
        this._walletOwnerPublicKeys.push(publicKey);
    };
    /**
     * Set an initial delegate to initialize this wallet to. This is different than the delegation to
     * set while doing a separate delegation transaction.
     *
     * @param {string} delegate The address to delegate the funds to
     */
    TransactionBuilder.prototype.initialDelegate = function (delegate) {
        if (this._type !== baseCoin_1.TransactionType.WalletInitialization) {
            throw new errors_1.BuildTransactionError('Initial delegation can only be set for wallet initialization transactions');
        }
        this.validateAddress({ address: delegate });
        this._initialDelegate = delegate;
    };
    /**
     * Build an origination operation for a generic multisig contract.
     *
     * @returns {Operation} A Tezos origination operation
     */
    TransactionBuilder.prototype.buildWalletInitializationOperations = function () {
        var originationOp = multisigUtils_1.genericMultisigOriginationOperation(this._counter.toString(), this._sourceAddress, this._fee.fee, this._fee.gasLimit || utils_1.DEFAULT_GAS_LIMIT.ORIGINATION.toString(), this._fee.storageLimit || utils_1.DEFAULT_STORAGE_LIMIT.ORIGINATION.toString(), this._initialBalance || '0', this._walletOwnerPublicKeys, this._initialDelegate);
        this._counter = this._counter.plus(1);
        return originationOp;
    };
    // endregion
    // region Send builder methods
    /**
     * Initialize a new TransferBuilder to for a singlesig or multisig transaction.
     *
     * @param {string} amount Amount in mutez to be transferred
     * @returns {TransferBuilder} A transfer builder
     */
    TransactionBuilder.prototype.transfer = function (amount) {
        if (this._type !== baseCoin_1.TransactionType.Send && this._type !== baseCoin_1.TransactionType.SingleSigSend) {
            throw new errors_1.BuildTransactionError('Transfers can only be set for send transactions');
        }
        var transferBuilder = new transferBuilder_1.TransferBuilder();
        // If source was set, use it as default for
        if (this._sourceAddress) {
            transferBuilder = transferBuilder.from(this._sourceAddress);
        }
        if (this._fee) {
            transferBuilder = transferBuilder.fee(this._fee.fee);
            transferBuilder = this._fee.gasLimit ? transferBuilder.gasLimit(this._fee.gasLimit) : transferBuilder;
            transferBuilder = this._fee.storageLimit ? transferBuilder.storageLimit(this._fee.storageLimit) : transferBuilder;
        }
        this._transfers.push(transferBuilder);
        return transferBuilder.amount(amount);
    };
    /**
     * Calculate the signatures for the multisig transaction.
     *
     * @param {string} packedData The string in hexadecimal to sign
     * @returns {Promise<string[]>} List of signatures for packedData
     */
    TransactionBuilder.prototype.getSignatures = function (packedData) {
        return __awaiter(this, void 0, void 0, function () {
            var signatures, i, signature, index;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        signatures = [];
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < this._multisigSignerKeyPairs.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, utils_1.sign(this._multisigSignerKeyPairs[i].key, packedData, new Uint8Array(0))];
                    case 2:
                        signature = _a.sent();
                        index = this._multisigSignerKeyPairs[i].index;
                        signatures.push(index ? { signature: signature.sig, index: index } : { signature: signature.sig });
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, signatures];
                }
            });
        });
    };
    /**
     * Override the data to sign for a specific transfer. Used for offline signing to pass the
     * respective dataToSign for transfer at a particular index.
     *
     * @param {DataToSignOverride} data - data to override
     */
    TransactionBuilder.prototype.overrideDataToSign = function (data) {
        if (!data.index) {
            data.index = this._dataToSignOverride.length;
        }
        this._dataToSignOverride.push(data);
    };
    /**
     * Build a transaction operation for a generic multisig contract.
     *
     * @returns {Promise<TransactionOp[]>} A Tezos transaction operation
     */
    TransactionBuilder.prototype.buildSendTransactionContent = function () {
        return __awaiter(this, void 0, void 0, function () {
            var contents, i, transfer, transactionOp, signatures, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        contents = [];
                        i = 0;
                        _b.label = 1;
                    case 1:
                        if (!(i < this._transfers.length)) return [3 /*break*/, 8];
                        transfer = this._transfers[i].build();
                        transactionOp = void 0;
                        if (!utils_1.isValidOriginatedAddress(transfer.from)) return [3 /*break*/, 5];
                        if (!transfer.dataToSign) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getSignatures(transfer.dataToSign)];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = [];
                        _b.label = 4;
                    case 4:
                        signatures = _a;
                        transactionOp = multisigUtils_1.multisigTransactionOperation(this._counter.toString(), this._sourceAddress, transfer.amount, transfer.from, transfer.counter || '0', transfer.to, signatures, transfer.fee.fee, transfer.fee.gasLimit, transfer.fee.storageLimit);
                        return [3 /*break*/, 6];
                    case 5:
                        transactionOp = multisigUtils_1.singlesigTransactionOperation(this._counter.toString(), this._sourceAddress, transfer.amount, transfer.to, transfer.fee.fee, transfer.fee.gasLimit, transfer.fee.storageLimit);
                        _b.label = 6;
                    case 6:
                        contents.push(transactionOp);
                        this._counter = this._counter.plus(1);
                        _b.label = 7;
                    case 7:
                        i++;
                        return [3 /*break*/, 1];
                    case 8: return [2 /*return*/, contents];
                }
            });
        });
    };
    // endregion
    // region ForwarderAddressDeployment
    /**
     * Build a transaction operation for a forwarder contract
     *
     * @returns {OriginationOp} a Tezos transaction operation
     */
    TransactionBuilder.prototype.buildForwarderDeploymentContent = function () {
        var operation = multisigUtils_1.forwarderOriginationOperation(this._forwarderDestination, this._counter.toString(), this._sourceAddress, this._fee.fee, this._fee.gasLimit || utils_1.DEFAULT_GAS_LIMIT.ORIGINATION.toString(), this._fee.storageLimit || utils_1.DEFAULT_STORAGE_LIMIT.ORIGINATION.toString(), this._initialBalance || '0');
        this._counter = this._counter.plus(1);
        return operation;
    };
    // endregion
    // region Validators
    /** @inheritdoc */
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThan(0)) {
            throw new errors_1.BuildTransactionError('Value cannot be below less than zero');
        }
        // TODO: validate the amount is not bigger than the max amount in Tezos
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address) {
        if (!utils_1.isValidAddress(address.address)) {
            throw new errors_1.BuildTransactionError('Invalid address ' + address.address);
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        var keyPair = new keyPair_1.KeyPair({ prv: key.key });
        if (!keyPair.getKeys().prv) {
            throw new errors_1.BuildTransactionError('Invalid key');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        // TODO: validate the transaction is either a JSON or a hex
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        // TODO: validate all required fields are present in the builder before buildImplementation
        switch (this._type) {
            case baseCoin_1.TransactionType.AccountUpdate:
                break;
            case baseCoin_1.TransactionType.WalletInitialization:
                break;
            case baseCoin_1.TransactionType.Send:
                break;
            case baseCoin_1.TransactionType.AddressInitialization:
                break;
            case baseCoin_1.TransactionType.SingleSigSend:
                break;
            default:
                throw new errors_1.BuildTransactionError('Transaction type not supported');
        }
    };
    // endregion
    /** @inheritdoc */
    TransactionBuilder.prototype.displayName = function () {
        return this._coinConfig.fullName;
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: false,
        configurable: true
    });
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4veHR6L3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4REFBcUM7QUFHckMsNkNBQXlFO0FBRXpFLHdDQUFzRTtBQUN0RSxpREFNeUI7QUFFekIsNkNBQTRDO0FBQzVDLHFDQUFvQztBQUVwQyxpQ0FRaUI7QUFDakIscURBQW9EO0FBRXBELElBQU0sU0FBUyxHQUFHLENBQUMsQ0FBQztBQVVwQjs7R0FFRztBQUNIO0lBQXdDLHNDQUFzQjtJQTBCNUQ7Ozs7T0FJRztJQUNILDRCQUFZLFdBQWlDO1FBQTdDLFlBQ0Usa0JBQU0sV0FBVyxDQUFDLFNBUW5CO1FBUEMsS0FBSSxDQUFDLEtBQUssR0FBRywwQkFBZSxDQUFDLElBQUksQ0FBQztRQUNsQyxLQUFJLENBQUMsUUFBUSxHQUFHLElBQUksc0JBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxLQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUNyQixLQUFJLENBQUMsc0JBQXNCLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLEtBQUksQ0FBQyx1QkFBdUIsR0FBRyxFQUFFLENBQUM7UUFDbEMsS0FBSSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztRQUM5QixLQUFJLENBQUMsV0FBVyxHQUFHLElBQUkseUJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7SUFDbEQsQ0FBQztJQUVELHNCQUFzQjtJQUN0QixrQkFBa0I7SUFDUiwrQ0FBa0IsR0FBNUIsVUFBNkIsY0FBc0I7UUFDakQsNEZBQTRGO1FBQzVGLGFBQWE7UUFDYixJQUFJLENBQUMsc0JBQXNCLEdBQUcsY0FBYyxDQUFDO1FBQzdDLE9BQU8sSUFBSSx5QkFBVyxDQUFDLElBQUks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ZSxDQUFDLHFCQUFxQjtnQkFDeEMsTUFBTTtZQUNSLEtBQUssMEJBQWUsQ0FBQyxhQUFhO2dCQUNoQyxNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLDhCQUFxQixDQUFDLGdDQUFnQyxDQUFDLENBQUM7U0FDckU7SUFDSCxDQUFDO0lBQ0QsWUFBWTtJQUVaLGtCQUFrQjtJQUNsQix3Q0FBVyxHQUFYO1FBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQztJQUNuQyxDQUFDO0lBR0Qsc0JBQWMsMkNBQVc7UUFEekIsa0JBQWtCO2FBQ2xCO1lBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQzNCLENBQUM7UUFFRCxrQkFBa0I7YUFDbEIsVUFBMEIsV0FBd0I7WUFDaEQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7UUFDbEMsQ0FBQzs7O09BTEE7SUFNSCx5QkFBQztBQUFELENBQUMsQUFwaEJELENBQXdDLGlDQUFzQixHQW9oQjdEO0FBcGhCWSxnREFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIFNpZ25pbmdFcnJvciB9IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBCYXNlS2V5IH0gZnJvbSAnLi4vYmFzZUNvaW4vaWZhY2UnO1xuaW1wb3J0IHsgQmFzZVRyYW5zYWN0aW9uQnVpbGRlciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHtcbiAgZm9yd2FyZGVyT3JpZ2luYXRpb25PcGVyYXRpb24sXG4gIGdlbmVyaWNNdWx0aXNpZ09yaWdpbmF0aW9uT3BlcmF0aW9uLFxuICBtdWx0aXNpZ1RyYW5zYWN0aW9uT3BlcmF0aW9uLFxuICByZXZlYWxPcGVyYXRpb24sXG4gIHNpbmdsZXNpZ1RyYW5zYWN0aW9uT3BlcmF0aW9uLFxufSBmcm9tICcuL211bHRpc2lnVXRpbHMnO1xuaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJy4vYWRkcmVzcyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgeyBGZWUsIEluZGV4ZWREYXRhLCBJbmRleGVkU2lnbmF0dXJlLCBLZXksIE9wZXJhdGlvbiwgT3JpZ2luYXRpb25PcCwgUmV2ZWFsT3AsIFRyYW5zYWN0aW9uT3AgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7XG4gIERFRkFVTFRfR0FTX0xJTUlULFxuICBERUZBVUxUX1NUT1JBR0VfTElNSVQsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBpc1ZhbGlkQmxvY2tIYXNoLFxuICBpc1ZhbGlkT3JpZ2luYXRlZEFkZHJlc3MsXG4gIGlzVmFsaWRQdWJsaWNLZXksXG4gIHNpZ24sXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNmZXJCdWlsZGVyIH0gZnJvbSAnLi90cmFuc2ZlckJ1aWxkZXInO1xuXG5jb25zdCBERUZBVUxUX00gPSAzO1xuXG5pbnRlcmZhY2UgRGF0YVRvU2lnbk92ZXJyaWRlIGV4dGVuZHMgSW5kZXhlZERhdGEge1xuICBkYXRhVG9TaWduOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJbmRleGVkS2V5UGFpciBleHRlbmRzIEluZGV4ZWREYXRhIHtcbiAga2V5OiBLZXlQYWlyO1xufVxuXG4vKipcbiAqIFRlem9zIHRyYW5zYWN0aW9uIGJ1aWxkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfc2VyaWFsaXplZFRyYW5zYWN0aW9uOiBzdHJpbmc7XG4gIHByaXZhdGUgX3RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjtcbiAgcHJpdmF0ZSBfdHlwZTogVHJhbnNhY3Rpb25UeXBlO1xuICBwcml2YXRlIF9ibG9ja0hlYWRlcjogc3RyaW5nO1xuICBwcml2YXRlIF9jb3VudGVyOiBCaWdOdW1iZXI7XG4gIHByaXZhdGUgX2ZlZTogRmVlO1xuICBwcml2YXRlIF9zb3VyY2VBZGRyZXNzOiBzdHJpbmc7XG4gIHByaXZhdGUgX3NvdXJjZUtleVBhaXI/OiBLZXlQYWlyO1xuXG4gIC8vIFB1YmxpYyBrZXkgcmV2ZWxhdGlvbiB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgX3B1YmxpY0tleVRvUmV2ZWFsOiBzdHJpbmc7XG5cbiAgLy8gV2FsbGV0IGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnNcbiAgcHJpdmF0ZSBfaW5pdGlhbEJhbGFuY2U6IHN0cmluZztcbiAgcHJpdmF0ZSBfaW5pdGlhbERlbGVnYXRlOiBzdHJpbmc7XG4gIHByaXZhdGUgX3dhbGxldE93bmVyUHVibGljS2V5czogc3RyaW5nW107XG5cbiAgLy8gU2VuZCB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgX211bHRpc2lnU2lnbmVyS2V5UGFpcnM6IEluZGV4ZWRLZXlQYWlyW107XG4gIHByaXZhdGUgX2RhdGFUb1NpZ25PdmVycmlkZTogRGF0YVRvU2lnbk92ZXJyaWRlW107XG4gIHByaXZhdGUgX3RyYW5zZmVyczogVHJhbnNmZXJCdWlsZGVyW107XG5cbiAgLy8gQWRkcmVzcyBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgX2ZvcndhcmRlckRlc3RpbmF0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtDb2luQ29uZmlnfSBfY29pbkNvbmZpZyAtIGNvaW4gY29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICB0aGlzLl9jb3VudGVyID0gbmV3IEJpZ051bWJlcigwKTtcbiAgICB0aGlzLl90cmFuc2ZlcnMgPSBbXTtcbiAgICB0aGlzLl93YWxsZXRPd25lclB1YmxpY0tleXMgPSBbXTtcbiAgICB0aGlzLl9tdWx0aXNpZ1NpZ25lcktleVBhaXJzID0gW107XG4gICAgdGhpcy5fZGF0YVRvU2lnbk92ZXJyaWRlID0gW107XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvLyByZWdpb24gQmFzZSBCdWlsZGVyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgZnJvbUltcGxlbWVudGF0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBUcmFuc2FjdGlvbiB7XG4gICAgLy8gRGVjb2RpbmcgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGFzeW5jIG9wZXJhdGlvbiwgc28gc2F2ZSBpdCBhbmQgbGVhdmUgdGhlIGRlY29kaW5nIGZvciB0aGVcbiAgICAvLyBidWlsZCBzdGVwXG4gICAgdGhpcy5fc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gcmF3VHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2lnbkltcGxlbWVudGF0aW9uKGtleTogS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHNpZ25lciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIC8vIEN1cnJlbnRseSBwdWJsaWMga2V5IHJldmVsYXRpb24gaXMgdGhlIG9ubHkgdHlwZSBvZiBhY2NvdW50IHVwZGF0ZSB0eCBzdXBwb3J0ZWQgaW4gVGV6b3NcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFjY291bnRVcGRhdGUgJiYgIXRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdDYW5ub3Qgc2lnbiBhIHB1YmxpYyBrZXkgcmV2ZWxhdGlvbiB0cmFuc2FjdGlvbiB3aXRob3V0IHB1YmxpYyBrZXknKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uICYmIHRoaXMuX3dhbGxldE93bmVyUHVibGljS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0Nhbm5vdCBzaWduIGFuIHdhbGxldCBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbiB3aXRob3V0IG93bmVycycpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMuX3R5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kICYmXG4gICAgICB0aGlzLl90cmFuc2ZlcnMubGVuZ3RoID09PSAwICYmXG4gICAgICB0aGlzLl9zZXJpYWxpemVkVHJhbnNhY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignQ2Fubm90IHNpZ24gYW4gZW1wdHkgc2VuZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZCAmJiAoIXRoaXMuX3NvdXJjZUFkZHJlc3MgfHwgdGhpcy5fc291cmNlQWRkcmVzcyAhPT0gc2lnbmVyLmdldEFkZHJlc3MoKSkpIHtcbiAgICAgIC8vIElmIHRoZSBzaWduZXIgaXMgbm90IHRoZSBzb3VyY2UgYW5kIGl0IGlzIGEgc2VuZCB0cmFuc2FjdGlvbiwgYWRkIGl0IHRvIHRoZSBsaXN0IG9mXG4gICAgICAvLyBtdWx0aXNpZyB3YWxsZXQgc2lnbmVyc1xuXG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGEgY29tYmluYXRpb24gb2Yga2V5cyB3aXRoIGFuZCB3aXRob3V0IGN1c3RvbSBpbmRleFxuICAgICAgaWYgKGtleS5pbmRleCAmJiBrZXkuaW5kZXggPj0gREVGQVVMVF9NKSB7XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgICAgJ0N1c3RvbSBpbmRleCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSB3YWxsZXQgdG90YWwgbnVtYmVyIG9mIHNpZ25lcnMgKG93bmVycyknLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIGVpdGhlciBhbGwga2V5cyBwYXNzZWQgaGF2ZSBhIGN1c3RvbSBpbmRleCBvciBub25lIG9mIHRoZW0gaGF2ZVxuICAgICAgY29uc3Qgc2hvdWxkSGF2ZUN1c3RvbUluZGV4ID0ga2V5Lmhhc093blByb3BlcnR5KCdpbmRleCcpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tdWx0aXNpZ1NpZ25lcktleVBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzaG91bGRIYXZlQ3VzdG9tSW5kZXggIT09ICh0aGlzLl9tdWx0aXNpZ1NpZ25lcktleVBhaXJzW2ldLmluZGV4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQ3VzdG9tIGluZGV4IGhhcyB0byBiZSBzZXQgZm9yIGFsbCBtdWx0aXNpZyBjb250cmFjdCBzaWduaW5nIGtleXMgb3Igbm9uZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtdWx0aXNpZ1NpZ25lcktleSA9IHNob3VsZEhhdmVDdXN0b21JbmRleCA/IHsga2V5OiBzaWduZXIsIGluZGV4OiBrZXkuaW5kZXggfSA6IHsga2V5OiBzaWduZXIgfTtcbiAgICAgIHRoaXMuX211bHRpc2lnU2lnbmVyS2V5UGFpcnMucHVzaChtdWx0aXNpZ1NpZ25lcktleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VLZXlQYWlyKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0Nhbm5vdCBzaWduIG11bHRpcGxlIHRpbWVzIGEgbm9uIHNlbmQtdHlwZSB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlS2V5UGFpciA9IHNpZ25lcjtcbiAgICB9XG5cbiAgICAvLyBTaWduaW5nIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBhc3luYyBvcGVyYXRpb24sIHNvIHNhdmUgdGhlIHNvdXJjZSBhbmQgbGVhdmUgdGhlIGFjdHVhbFxuICAgIC8vIHNpZ25pbmcgZm9yIHRoZSBidWlsZCBzdGVwXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIC8vIElmIHRoZSBmcm9tKCkgbWV0aG9kIHdhcyBjYWxsZWQsIHVzZSB0aGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBhcyBhIGJhc2VcbiAgICBpZiAodGhpcy5fc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgICBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uLmluaXRGcm9tU2VyaWFsaXplZFRyYW5zYWN0aW9uKHRoaXMuX3NlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGFUb1NpZ25PdmVycmlkZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVzKHRoaXMuX2RhdGFUb1NpZ25PdmVycmlkZVtpXS5kYXRhVG9TaWduKTtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc2FjdGlvbi5hZGRUcmFuc2ZlclNpZ25hdHVyZShzaWduYXR1cmVzLCB0aGlzLl9kYXRhVG9TaWduT3ZlcnJpZGVbaV0uaW5kZXggfHwgaSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBtYWtlIGNoYW5nZXMgdG8gdGhlIHRyYW5zYWN0aW9uIGlmIGFueSBleHRyYSBwYXJhbWV0ZXIgaGFzIGJlZW4gc2V0IHRoZW4gc2lnbiBpdFxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29udGVudHM6IE9wZXJhdGlvbltdID0gW107XG4gICAgICBzd2l0Y2ggKHRoaXMuX3R5cGUpIHtcbiAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQWNjb3VudFVwZGF0ZTpcbiAgICAgICAgICBpZiAodGhpcy5fcHVibGljS2V5VG9SZXZlYWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzLnB1c2godGhpcy5idWlsZFB1YmxpY0tleVJldmVsYXRpb25PcGVyYXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjpcbiAgICAgICAgICBpZiAodGhpcy5fcHVibGljS2V5VG9SZXZlYWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzLnB1c2godGhpcy5idWlsZFB1YmxpY0tleVJldmVsYXRpb25PcGVyYXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRlbnRzLnB1c2godGhpcy5idWlsZFdhbGxldEluaXRpYWxpemF0aW9uT3BlcmF0aW9ucygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDpcbiAgICAgICAgICBpZiAodGhpcy5fcHVibGljS2V5VG9SZXZlYWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzLnB1c2godGhpcy5idWlsZFB1YmxpY0tleVJldmVsYXRpb25PcGVyYXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuY29uY2F0KGF3YWl0IHRoaXMuYnVpbGRTZW5kVHJhbnNhY3Rpb25Db250ZW50KCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb246XG4gICAgICAgICAgaWYgKHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsKSB7XG4gICAgICAgICAgICBjb250ZW50cy5wdXNoKHRoaXMuYnVpbGRQdWJsaWNLZXlSZXZlbGF0aW9uT3BlcmF0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLmNvbmNhdCh0aGlzLmJ1aWxkRm9yd2FyZGVyRGVwbG95bWVudENvbnRlbnQoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQ6XG4gICAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgcmV2ZWxhdGlvbiB0eG5zIGFzIHByaW1hcnkgdXNlIGNhc2UgaXMgdG8gc2VuZCBmcm9tIGZlZSBhZGRyZXNzXG4gICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5jb25jYXQoYXdhaXQgdGhpcy5idWlsZFNlbmRUcmFuc2FjdGlvbkNvbnRlbnQoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGJyYW5jaDogdGhpcy5fYmxvY2tIZWFkZXIsXG4gICAgICAgIGNvbnRlbnRzLFxuICAgICAgfTtcblxuICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnKTtcbiAgICAgIC8vIEJ1aWxkIGFuZCBzaWduIGEgbmV3IHRyYW5zYWN0aW9uIGJhc2VkIG9uIHRoZSBsYXRlc3QgY2hhbmdlc1xuICAgICAgYXdhaXQgdGhpcy50cmFuc2FjdGlvbi5pbml0RnJvbVBhcnNlZFRyYW5zYWN0aW9uKHBhcnNlZFRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc291cmNlS2V5UGFpciAmJiB0aGlzLl9zb3VyY2VLZXlQYWlyLmdldEtleXMoKS5wcnYpIHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoZXJlIGFyZSBtb3JlIHNpZ25lcnMgdGhhbiBuZWVkZWQgZm9yIGEgc2luZ2xlc2lnIG9yIG11bHRpc2lnIHRyYW5zYWN0aW9uXG4gICAgICBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uLnNpZ24odGhpcy5fc291cmNlS2V5UGFpcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBDb21tb24gYnVpbGRlciBtZXRob2RzXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zYWN0aW9uIGJyYW5jaCBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrSWQgQSBibG9jayBoYXNoIHRvIHVzZSBhcyBicmFuY2ggcmVmZXJlbmNlXG4gICAqL1xuICBicmFuY2goYmxvY2tJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFpc1ZhbGlkQmxvY2tIYXNoKGJsb2NrSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGJsb2NrIGhhc2ggJyArIGJsb2NrSWQpO1xuICAgIH1cbiAgICB0aGlzLl9ibG9ja0hlYWRlciA9IGJsb2NrSWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdHJhbnNhY3Rpb24gYmVpbmcgYnVpbHQuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0eXBlIC0gdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHR5cGUodHlwZTogVHJhbnNhY3Rpb25UeXBlKTogdm9pZCB7XG4gICAgaWYgKHR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kICYmIHRoaXMuX3dhbGxldE93bmVyUHVibGljS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBjYW5ub3QgYmUgbGFiZWxlZCBhcyBTZW5kIHdoZW4gb3duZXJzIGhhdmUgYWxyZWFkeSBiZWVuIHNldCcpO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLlNlbmQgJiYgdGhpcy5fdHJhbnNmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGNvbnRhaW5zIHRyYW5zZmVycyBhbmQgY2FuIG9ubHkgYmUgbGFiZWxlZCBhcyBTZW5kJyk7XG4gICAgfVxuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gZmVlcy4gTG93IGZlZXMgbWF5IGdldCBhIHRyYW5zYWN0aW9uIHJlamVjdGVkIG9yIG5ldmVyIHBpY2tlZCB1cCBieSBiYWtlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RmVlfSBmZWUgQmFrZXIgZmVlcy4gTWF5IGFsc28gaW5jbHVkZSB0aGUgbWF4aW11bSBnYXMgYW5kIHN0b3JhZ2UgZmVlcyB0byBwYXlcbiAgICovXG4gIGZlZShmZWU6IEZlZSk6IHZvaWQge1xuICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGZlZS5mZWUpKTtcbiAgICBpZiAoZmVlLmdhc0xpbWl0KSB7XG4gICAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcihmZWUuZ2FzTGltaXQpKTtcbiAgICB9XG4gICAgaWYgKGZlZS5zdG9yYWdlTGltaXQpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGZlZS5zdG9yYWdlTGltaXQpKTtcbiAgICB9XG4gICAgdGhpcy5fZmVlID0gZmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gaW5pdGlhdG9yLiBUaGlzIGFjY291bnQgd2lsbCBwYXkgZm9yIHRoZSB0cmFuc2FjdGlvbiBmZWVzLCBidXQgaXQgd2lsbCBub3RcbiAgICogYmUgYWRkZWQgYXMgYW4gb3duZXIgb2YgYSB3YWxsZXQgaW4gYSBpbml0IHRyYW5zYWN0aW9uLCB1bmxlc3MgbWFudWFsbHkgc2V0IGFzIG9uZSBvZiB0aGVcbiAgICogb3duZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIEEgVGV6b3MgYWRkcmVzc1xuICAgKi9cbiAgc291cmNlKHNvdXJjZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoeyBhZGRyZXNzOiBzb3VyY2UgfSk7XG4gICAgdGhpcy5fc291cmNlQWRkcmVzcyA9IHNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gYW1vdW50IG9mIG11dGV6IHRvIHRyYW5zZmVyIGluIHRoaXMgdHJhbnNhY3Rpb24gdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBkaWZmZXJlbnQgdGhhblxuICAgKiB0aGUgYW1vdW50IHRvIHRyYW5zZmVyIGZyb20gYSBtdWx0aXNpZyB3YWxsZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgQW1vdW50IGluIG11dGV6ICgxLzEwMDAwMDAgVGV6aWVzKVxuICAgKi9cbiAgaW5pdGlhbEJhbGFuY2UoYW1vdW50OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fdHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbml0aWFsIGJhbGFuY2UgY2FuIG9ubHkgYmUgc2V0IGZvciB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zJyk7XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGFtb3VudCkpO1xuICAgIHRoaXMuX2luaXRpYWxCYWxhbmNlID0gYW1vdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gY291bnRlciB0byBwcmV2ZW50IHN1Ym1pdHRpbmcgcmVwZWF0ZWQgdHJhbnNhY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY291bnRlciBUaGUgY291bnRlciB0byB1c2VcbiAgICovXG4gIGNvdW50ZXIoY291bnRlcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fY291bnRlciA9IG5ldyBCaWdOdW1iZXIoY291bnRlcik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIG9mIGEgZm9yd2FyZGVyIGNvbnRyYWN0XG4gICAqIFVzZWQgaW4gZm9yd2FyZGVyIGNvbnRyYWN0IGRlcGxveW1lbnQgYXMgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIC0gY29udHJhY3QgYWRkcmVzcyB0byB1c2VcbiAgICovXG4gIGZvcndhcmRlckRlc3RpbmF0aW9uKGNvbnRyYWN0QWRkcmVzczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3R5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ZvcndhcmRlciBkZXN0aW5hdGlvbiBjYW4gb25seSBiZSBzZXQgZm9yIGFkZHJlc3MgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zJyk7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZE9yaWdpbmF0ZWRBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ZvcndhcmRlciBkZXN0aW5hdGlvbiBjYW4gb25seSBiZSBhbiBvcmlnaW5hdGVkIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgdGhpcy5fZm9yd2FyZGVyRGVzdGluYXRpb24gPSBjb250cmFjdEFkZHJlc3M7XG4gIH1cblxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gUHVibGljS2V5UmV2ZWxhdGlvbiBidWlsZGVyIG1ldGhvZHNcbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IHRvIHJldmVhbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleSBBIFRlem9zIHB1YmxpYyBrZXlcbiAgICovXG4gIHB1YmxpY0tleVRvUmV2ZWFsKHB1YmxpY0tleTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdQdWJsaWMga2V5IHRvIHJldmVhbCBhbHJlYWR5IHNldDogJyArIHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlQYWlyID0gbmV3IEtleVBhaXIoeyBwdWI6IHB1YmxpY0tleSB9KTtcbiAgICBpZiAoa2V5UGFpci5nZXRBZGRyZXNzKCkgIT09IHRoaXMuX3NvdXJjZUFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1B1YmxpYyBrZXkgZG9lcyBub3QgbWF0Y2ggdGhlIHNvdXJjZSBhZGRyZXNzOiAnICsgdGhpcy5fc291cmNlQWRkcmVzcyk7XG4gICAgfVxuICAgIHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsID0ga2V5UGFpci5nZXRLZXlzKCkucHViO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgcmV2ZWFsIG9wZXJhdGlvbiBmb3IgdGhlIHNvdXJjZSBhY2NvdW50IHdpdGggZGVmYXVsdCBmZWVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UmV2ZWFsT3B9IEEgVGV6b3MgcmV2ZWFsIG9wZXJhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBidWlsZFB1YmxpY0tleVJldmVsYXRpb25PcGVyYXRpb24oKTogUmV2ZWFsT3Age1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHJldmVhbE9wZXJhdGlvbih0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCksIHRoaXMuX3NvdXJjZUFkZHJlc3MsIHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsKTtcbiAgICB0aGlzLl9jb3VudGVyID0gdGhpcy5fY291bnRlci5wbHVzKDEpO1xuICAgIHJldHVybiBvcGVyYXRpb247XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFdhbGxldEluaXRpYWxpemF0aW9uIGJ1aWxkZXIgbWV0aG9kc1xuICAvKipcbiAgICogU2V0IG9uZSBvZiB0aGUgb3duZXJzIG9mIHRoZSBtdWx0aXNpZyB3YWxsZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNLZXkgQSBUZXpvcyBwdWJsaWMga2V5XG4gICAqL1xuICBvd25lcihwdWJsaWNLZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl90eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ011bHRpc2lnIHdhbGxldCBvd25lciBjYW4gb25seSBiZSBzZXQgZm9yIGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9ucycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2FsbGV0T3duZXJQdWJsaWNLZXlzLmxlbmd0aCA+PSBERUZBVUxUX00pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0EgbWF4aW11bSBvZiAnICsgREVGQVVMVF9NICsgJyBvd25lcnMgY2FuIGJlIHNldCBmb3IgYSBtdWx0aXNpZyB3YWxsZXQnKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkUHVibGljS2V5KHB1YmxpY0tleSkpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleTogJyArIHB1YmxpY0tleSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl93YWxsZXRPd25lclB1YmxpY0tleXMuaW5jbHVkZXMocHVibGljS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignUmVwZWF0ZWQgb3duZXIgcHVibGljIGtleTogJyArIHB1YmxpY0tleSk7XG4gICAgfVxuICAgIHRoaXMuX3dhbGxldE93bmVyUHVibGljS2V5cy5wdXNoKHB1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFuIGluaXRpYWwgZGVsZWdhdGUgdG8gaW5pdGlhbGl6ZSB0aGlzIHdhbGxldCB0by4gVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgZGVsZWdhdGlvbiB0b1xuICAgKiBzZXQgd2hpbGUgZG9pbmcgYSBzZXBhcmF0ZSBkZWxlZ2F0aW9uIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsZWdhdGUgVGhlIGFkZHJlc3MgdG8gZGVsZWdhdGUgdGhlIGZ1bmRzIHRvXG4gICAqL1xuICBpbml0aWFsRGVsZWdhdGUoZGVsZWdhdGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl90eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0luaXRpYWwgZGVsZWdhdGlvbiBjYW4gb25seSBiZSBzZXQgZm9yIHdhbGxldCBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbnMnKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoeyBhZGRyZXNzOiBkZWxlZ2F0ZSB9KTtcbiAgICB0aGlzLl9pbml0aWFsRGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiBvcmlnaW5hdGlvbiBvcGVyYXRpb24gZm9yIGEgZ2VuZXJpYyBtdWx0aXNpZyBjb250cmFjdC5cbiAgICpcbiAgICogQHJldHVybnMge09wZXJhdGlvbn0gQSBUZXpvcyBvcmlnaW5hdGlvbiBvcGVyYXRpb25cbiAgICovXG4gIHByaXZhdGUgYnVpbGRXYWxsZXRJbml0aWFsaXphdGlvbk9wZXJhdGlvbnMoKTogT3JpZ2luYXRpb25PcCB7XG4gICAgY29uc3Qgb3JpZ2luYXRpb25PcCA9IGdlbmVyaWNNdWx0aXNpZ09yaWdpbmF0aW9uT3BlcmF0aW9uKFxuICAgICAgdGhpcy5fY291bnRlci50b1N0cmluZygpLFxuICAgICAgdGhpcy5fc291cmNlQWRkcmVzcyxcbiAgICAgIHRoaXMuX2ZlZS5mZWUsXG4gICAgICB0aGlzLl9mZWUuZ2FzTGltaXQgfHwgREVGQVVMVF9HQVNfTElNSVQuT1JJR0lOQVRJT04udG9TdHJpbmcoKSxcbiAgICAgIHRoaXMuX2ZlZS5zdG9yYWdlTGltaXQgfHwgREVGQVVMVF9TVE9SQUdFX0xJTUlULk9SSUdJTkFUSU9OLnRvU3RyaW5nKCksXG4gICAgICB0aGlzLl9pbml0aWFsQmFsYW5jZSB8fCAnMCcsXG4gICAgICB0aGlzLl93YWxsZXRPd25lclB1YmxpY0tleXMsXG4gICAgICB0aGlzLl9pbml0aWFsRGVsZWdhdGUsXG4gICAgKTtcbiAgICB0aGlzLl9jb3VudGVyID0gdGhpcy5fY291bnRlci5wbHVzKDEpO1xuICAgIHJldHVybiBvcmlnaW5hdGlvbk9wO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8vIHJlZ2lvbiBTZW5kIGJ1aWxkZXIgbWV0aG9kc1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBUcmFuc2ZlckJ1aWxkZXIgdG8gZm9yIGEgc2luZ2xlc2lnIG9yIG11bHRpc2lnIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IEFtb3VudCBpbiBtdXRleiB0byBiZSB0cmFuc2ZlcnJlZFxuICAgKiBAcmV0dXJucyB7VHJhbnNmZXJCdWlsZGVyfSBBIHRyYW5zZmVyIGJ1aWxkZXJcbiAgICovXG4gIHRyYW5zZmVyKGFtb3VudDogc3RyaW5nKTogVHJhbnNmZXJCdWlsZGVyIHtcbiAgICBpZiAodGhpcy5fdHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLlNlbmQgJiYgdGhpcy5fdHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zZmVycyBjYW4gb25seSBiZSBzZXQgZm9yIHNlbmQgdHJhbnNhY3Rpb25zJyk7XG4gICAgfVxuICAgIGxldCB0cmFuc2ZlckJ1aWxkZXIgPSBuZXcgVHJhbnNmZXJCdWlsZGVyKCk7XG4gICAgLy8gSWYgc291cmNlIHdhcyBzZXQsIHVzZSBpdCBhcyBkZWZhdWx0IGZvclxuICAgIGlmICh0aGlzLl9zb3VyY2VBZGRyZXNzKSB7XG4gICAgICB0cmFuc2ZlckJ1aWxkZXIgPSB0cmFuc2ZlckJ1aWxkZXIuZnJvbSh0aGlzLl9zb3VyY2VBZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZlZSkge1xuICAgICAgdHJhbnNmZXJCdWlsZGVyID0gdHJhbnNmZXJCdWlsZGVyLmZlZSh0aGlzLl9mZWUuZmVlKTtcbiAgICAgIHRyYW5zZmVyQnVpbGRlciA9IHRoaXMuX2ZlZS5nYXNMaW1pdCA/IHRyYW5zZmVyQnVpbGRlci5nYXNMaW1pdCh0aGlzLl9mZWUuZ2FzTGltaXQpIDogdHJhbnNmZXJCdWlsZGVyO1xuICAgICAgdHJhbnNmZXJCdWlsZGVyID0gdGhpcy5fZmVlLnN0b3JhZ2VMaW1pdCA/IHRyYW5zZmVyQnVpbGRlci5zdG9yYWdlTGltaXQodGhpcy5fZmVlLnN0b3JhZ2VMaW1pdCkgOiB0cmFuc2ZlckJ1aWxkZXI7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZmVycy5wdXNoKHRyYW5zZmVyQnVpbGRlcik7XG4gICAgcmV0dXJuIHRyYW5zZmVyQnVpbGRlci5hbW91bnQoYW1vdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNpZ25hdHVyZXMgZm9yIHRoZSBtdWx0aXNpZyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhY2tlZERhdGEgVGhlIHN0cmluZyBpbiBoZXhhZGVjaW1hbCB0byBzaWduXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gTGlzdCBvZiBzaWduYXR1cmVzIGZvciBwYWNrZWREYXRhXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldFNpZ25hdHVyZXMocGFja2VkRGF0YTogc3RyaW5nKTogUHJvbWlzZTxJbmRleGVkU2lnbmF0dXJlW10+IHtcbiAgICBjb25zdCBzaWduYXR1cmVzOiBJbmRleGVkU2lnbmF0dXJlW10gPSBbXTtcbiAgICAvLyBHZW5lcmF0ZSB0aGUgbXVsdGlzaWcgY29udHJhY3Qgc2lnbmF0dXJlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbXVsdGlzaWdTaWduZXJLZXlQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbih0aGlzLl9tdWx0aXNpZ1NpZ25lcktleVBhaXJzW2ldLmtleSwgcGFja2VkRGF0YSwgbmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9tdWx0aXNpZ1NpZ25lcktleVBhaXJzW2ldLmluZGV4O1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKGluZGV4ID8geyBzaWduYXR1cmU6IHNpZ25hdHVyZS5zaWcsIGluZGV4IH0gOiB7IHNpZ25hdHVyZTogc2lnbmF0dXJlLnNpZyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRhdGEgdG8gc2lnbiBmb3IgYSBzcGVjaWZpYyB0cmFuc2Zlci4gVXNlZCBmb3Igb2ZmbGluZSBzaWduaW5nIHRvIHBhc3MgdGhlXG4gICAqIHJlc3BlY3RpdmUgZGF0YVRvU2lnbiBmb3IgdHJhbnNmZXIgYXQgYSBwYXJ0aWN1bGFyIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGFUb1NpZ25PdmVycmlkZX0gZGF0YSAtIGRhdGEgdG8gb3ZlcnJpZGVcbiAgICovXG4gIG92ZXJyaWRlRGF0YVRvU2lnbihkYXRhOiBEYXRhVG9TaWduT3ZlcnJpZGUpOiB2b2lkIHtcbiAgICBpZiAoIWRhdGEuaW5kZXgpIHtcbiAgICAgIGRhdGEuaW5kZXggPSB0aGlzLl9kYXRhVG9TaWduT3ZlcnJpZGUubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhVG9TaWduT3ZlcnJpZGUucHVzaChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIHRyYW5zYWN0aW9uIG9wZXJhdGlvbiBmb3IgYSBnZW5lcmljIG11bHRpc2lnIGNvbnRyYWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbk9wW10+fSBBIFRlem9zIHRyYW5zYWN0aW9uIG9wZXJhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBidWlsZFNlbmRUcmFuc2FjdGlvbkNvbnRlbnQoKTogUHJvbWlzZTxUcmFuc2FjdGlvbk9wW10+IHtcbiAgICBjb25zdCBjb250ZW50czogVHJhbnNhY3Rpb25PcFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90cmFuc2ZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYW5zZmVyID0gdGhpcy5fdHJhbnNmZXJzW2ldLmJ1aWxkKCk7XG4gICAgICBsZXQgdHJhbnNhY3Rpb25PcDtcbiAgICAgIGlmIChpc1ZhbGlkT3JpZ2luYXRlZEFkZHJlc3ModHJhbnNmZXIuZnJvbSkpIHtcbiAgICAgICAgLy8gT2ZmbGluZSB0cmFuc2FjdGlvbnMgbWF5IG5vdCBoYXZlIHRoZSBkYXRhIHRvIHNpZ25cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHRyYW5zZmVyLmRhdGFUb1NpZ24gPyBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZXModHJhbnNmZXIuZGF0YVRvU2lnbikgOiBbXTtcbiAgICAgICAgdHJhbnNhY3Rpb25PcCA9IG11bHRpc2lnVHJhbnNhY3Rpb25PcGVyYXRpb24oXG4gICAgICAgICAgdGhpcy5fY291bnRlci50b1N0cmluZygpLFxuICAgICAgICAgIHRoaXMuX3NvdXJjZUFkZHJlc3MsXG4gICAgICAgICAgdHJhbnNmZXIuYW1vdW50LFxuICAgICAgICAgIHRyYW5zZmVyLmZyb20sXG4gICAgICAgICAgdHJhbnNmZXIuY291bnRlciB8fCAnMCcsXG4gICAgICAgICAgdHJhbnNmZXIudG8sXG4gICAgICAgICAgc2lnbmF0dXJlcyxcbiAgICAgICAgICB0cmFuc2Zlci5mZWUuZmVlLFxuICAgICAgICAgIHRyYW5zZmVyLmZlZS5nYXNMaW1pdCxcbiAgICAgICAgICB0cmFuc2Zlci5mZWUuc3RvcmFnZUxpbWl0LFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb25PcCA9IHNpbmdsZXNpZ1RyYW5zYWN0aW9uT3BlcmF0aW9uKFxuICAgICAgICAgIHRoaXMuX2NvdW50ZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICB0aGlzLl9zb3VyY2VBZGRyZXNzLFxuICAgICAgICAgIHRyYW5zZmVyLmFtb3VudCxcbiAgICAgICAgICB0cmFuc2Zlci50byxcbiAgICAgICAgICB0cmFuc2Zlci5mZWUuZmVlLFxuICAgICAgICAgIHRyYW5zZmVyLmZlZS5nYXNMaW1pdCxcbiAgICAgICAgICB0cmFuc2Zlci5mZWUuc3RvcmFnZUxpbWl0LFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGVudHMucHVzaCh0cmFuc2FjdGlvbk9wKTtcbiAgICAgIHRoaXMuX2NvdW50ZXIgPSB0aGlzLl9jb3VudGVyLnBsdXMoMSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50cztcbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gRm9yd2FyZGVyQWRkcmVzc0RlcGxveW1lbnRcbiAgLyoqXG4gICAqIEJ1aWxkIGEgdHJhbnNhY3Rpb24gb3BlcmF0aW9uIGZvciBhIGZvcndhcmRlciBjb250cmFjdFxuICAgKlxuICAgKiBAcmV0dXJucyB7T3JpZ2luYXRpb25PcH0gYSBUZXpvcyB0cmFuc2FjdGlvbiBvcGVyYXRpb25cbiAgICovXG4gIHByaXZhdGUgYnVpbGRGb3J3YXJkZXJEZXBsb3ltZW50Q29udGVudCgpOiBPcmlnaW5hdGlvbk9wIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSBmb3J3YXJkZXJPcmlnaW5hdGlvbk9wZXJhdGlvbihcbiAgICAgIHRoaXMuX2ZvcndhcmRlckRlc3RpbmF0aW9uLFxuICAgICAgdGhpcy5fY291bnRlci50b1N0cmluZygpLFxuICAgICAgdGhpcy5fc291cmNlQWRkcmVzcyxcbiAgICAgIHRoaXMuX2ZlZS5mZWUsXG4gICAgICB0aGlzLl9mZWUuZ2FzTGltaXQgfHwgREVGQVVMVF9HQVNfTElNSVQuT1JJR0lOQVRJT04udG9TdHJpbmcoKSxcbiAgICAgIHRoaXMuX2ZlZS5zdG9yYWdlTGltaXQgfHwgREVGQVVMVF9TVE9SQUdFX0xJTUlULk9SSUdJTkFUSU9OLnRvU3RyaW5nKCksXG4gICAgICB0aGlzLl9pbml0aWFsQmFsYW5jZSB8fCAnMCcsXG4gICAgKTtcbiAgICB0aGlzLl9jb3VudGVyID0gdGhpcy5fY291bnRlci5wbHVzKDEpO1xuICAgIHJldHVybiBvcGVyYXRpb247XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFZhbGlkYXRvcnNcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVmFsdWUodmFsdWU6IEJpZ051bWJlcik6IHZvaWQge1xuICAgIGlmICh2YWx1ZS5pc0xlc3NUaGFuKDApKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdWYWx1ZSBjYW5ub3QgYmUgYmVsb3cgbGVzcyB0aGFuIHplcm8nKTtcbiAgICB9XG4gICAgLy8gVE9ETzogdmFsaWRhdGUgdGhlIGFtb3VudCBpcyBub3QgYmlnZ2VyIHRoYW4gdGhlIG1heCBhbW91bnQgaW4gVGV6b3NcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQWRkcmVzcyk6IHZvaWQge1xuICAgIGlmICghaXNWYWxpZEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBhZGRyZXNzICcgKyBhZGRyZXNzLmFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUtleShrZXk6IEJhc2VLZXkpOiB2b2lkIHtcbiAgICBjb25zdCBrZXlQYWlyID0gbmV3IEtleVBhaXIoeyBwcnY6IGtleS5rZXkgfSk7XG4gICAgaWYgKCFrZXlQYWlyLmdldEtleXMoKS5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IGFueSk6IHZvaWQge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIHRoZSB0cmFuc2FjdGlvbiBpcyBlaXRoZXIgYSBKU09OIG9yIGEgaGV4XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50IGluIHRoZSBidWlsZGVyIGJlZm9yZSBidWlsZEltcGxlbWVudGF0aW9uXG4gICAgc3dpdGNoICh0aGlzLl90eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5BY2NvdW50VXBkYXRlOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQWRkcmVzc0luaXRpYWxpemF0aW9uOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gdHlwZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBkaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb2luQ29uZmlnLmZ1bGxOYW1lO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2V0IHRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cbn1cbiJdfQ==