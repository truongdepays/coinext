"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_STORAGE_LIMIT = exports.DEFAULT_FEE = exports.DEFAULT_GAS_LIMIT = exports.hashTypes = exports.decodeSignature = exports.decodeKey = exports.isValidKey = exports.isValidTransactionHash = exports.isValidBlockHash = exports.isValidPrivateKey = exports.isValidPublicKey = exports.isValidSignature = exports.isValidOriginatedAddress = exports.isValidImplicitAddress = exports.isValidAddress = exports.isValidHash = exports.generateDataToSign = exports.verifySignature = exports.sign = exports.calculateOriginatedAddress = exports.calculateTransactionId = exports.base58encode = exports.DEFAULT_WATERMARK = void 0;
var base58check = __importStar(require("bs58check"));
var libsodium_wrappers_1 = __importDefault(require("libsodium-wrappers"));
var signer_1 = require("@taquito/signer");
var elliptic_1 = require("elliptic");
var errors_1 = require("../baseCoin/errors");
var multisigUtils_1 = require("./multisigUtils");
var Crypto = __importStar(require("./../../utils/crypto"));
// By default, use the transactions prefix
exports.DEFAULT_WATERMARK = new Uint8Array([3]);
/**
 * Encode the payload to base58 with a specific Tezos prefix.
 *
 * @param {Buffer} prefix to add to the encoded payload
 * @param {Buffer} payload to encode
 * @returns {any} base58 payload with a Tezos prefix
 */
function base58encode(prefix, payload) {
    var n = Buffer.alloc(prefix.length + payload.length);
    n.set(prefix);
    n.set(payload, prefix.length);
    return base58check.encode(n);
}
exports.base58encode = base58encode;
/**
 * Calculate the transaction id for a for a signed transaction.
 *
 * @param {string} encodedTransaction Signed transaction in hexadecimal
 * @returns {Promise<string>} The transaction id
 */
function calculateTransactionId(encodedTransaction) {
    return __awaiter(this, void 0, void 0, function () {
        var encodedTransactionBuffer, operationHashPayload;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, libsodium_wrappers_1.default.ready];
                case 1:
                    _a.sent();
                    encodedTransactionBuffer = Uint8Array.from(Buffer.from(encodedTransaction, 'hex'));
                    operationHashPayload = libsodium_wrappers_1.default.crypto_generichash(32, encodedTransactionBuffer);
                    return [2 /*return*/, base58encode(exports.hashTypes.o.prefix, Buffer.from(operationHashPayload))];
            }
        });
    });
}
exports.calculateTransactionId = calculateTransactionId;
/**
 * Calculate the address of a new originated account.
 *
 * @param {string} transactionId The transaction id
 * @param {number} index The index of the origination operation inside the transaction (starts at 0)
 * @returns {Promise<string>} An originated address with the KT prefix
 */
function calculateOriginatedAddress(transactionId, index) {
    return __awaiter(this, void 0, void 0, function () {
        var ob, tt, i, payload;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ob = base58check.decode(transactionId).slice(exports.hashTypes.o.prefix.length);
                    tt = [];
                    for (i = 0; i < ob.length; i++) {
                        tt.push(ob[i]);
                    }
                    tt = tt.concat([
                        (index & 0xff000000) >> 24,
                        (index & 0x00ff0000) >> 16,
                        (index & 0x0000ff00) >> 8,
                        index & 0x000000ff,
                    ]);
                    return [4 /*yield*/, libsodium_wrappers_1.default.ready];
                case 1:
                    _a.sent();
                    payload = libsodium_wrappers_1.default.crypto_generichash(20, new Uint8Array(tt));
                    return [2 /*return*/, base58encode(exports.hashTypes.KT.prefix, Buffer.from(payload))];
            }
        });
    });
}
exports.calculateOriginatedAddress = calculateOriginatedAddress;
/**
 * Generic data signing using Tezos library.
 *
 * @param {KeyPair} keyPair A Key Pair with a private key set
 * @param {string} data The data in hexadecimal to sign
 * @param {Uint8Array} watermark Magic byte: 1 for block, 2 for endorsement, 3 for generic
 * @returns {Promise<SignResponse>}
 */
function sign(keyPair, data, watermark) {
    if (watermark === void 0) { watermark = exports.DEFAULT_WATERMARK; }
    return __awaiter(this, void 0, void 0, function () {
        var signer;
        return __generator(this, function (_a) {
            if (!keyPair.getKeys().prv) {
                throw new errors_1.SigningError('Missing private key');
            }
            signer = new signer_1.InMemorySigner(keyPair.getKeys().prv);
            return [2 /*return*/, signer.sign(data, watermark)];
        });
    });
}
exports.sign = sign;
/**
 * Verifies the signature produced for a given message belongs to a secp256k1 public key.
 *
 * @param {string} message Message in hex format to verify
 * @param {string} publicKey secp256k1 public key with "sppk" prefix to verify the signature with
 * @param {string} signature Tezos signature with "sig" prefix
 * @param {Uint8Array} watermark Optional watermark used to generate the signature
 * @returns {Promise<boolean>}
 */
function verifySignature(message, publicKey, signature, watermark) {
    if (watermark === void 0) { watermark = exports.DEFAULT_WATERMARK; }
    return __awaiter(this, void 0, void 0, function () {
        var rawPublicKey, ec, key, messageBuffer, messageWithWatermark, bytesHash, rawSignature;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    rawPublicKey = decodeKey(publicKey, exports.hashTypes.sppk);
                    ec = new elliptic_1.ec('secp256k1');
                    key = ec.keyFromPublic(rawPublicKey);
                    messageBuffer = Uint8Array.from(Buffer.from(message, 'hex'));
                    messageWithWatermark = new Uint8Array(watermark.length + messageBuffer.length);
                    messageWithWatermark.set(watermark);
                    messageWithWatermark.set(messageBuffer, watermark.length);
                    return [4 /*yield*/, libsodium_wrappers_1.default.ready];
                case 1:
                    _a.sent();
                    bytesHash = Buffer.from(libsodium_wrappers_1.default.crypto_generichash(32, messageWithWatermark));
                    rawSignature = decodeSignature(signature, exports.hashTypes.sig);
                    return [2 /*return*/, key.verify(bytesHash, { r: rawSignature.slice(0, 32), s: rawSignature.slice(32, 64) })];
            }
        });
    });
}
exports.verifySignature = verifySignature;
/**
 * Useful wrapper to create the generic multisig contract data to sign when moving funds.
 *
 * @param {string} contractAddress The wallet contract address with the funds to withdraw
 * @param {string} destinationAddress The address to transfer the funds to
 * @param {number} amount Number mutez to transfer
 * @param {string} contractCounter Wallet counter to use in the transaction
 * @returns {any} A JSON representation of the Michelson script to sign and approve a transfer
 */
function generateDataToSign(contractAddress, destinationAddress, amount, contractCounter) {
    if (!isValidOriginatedAddress(contractAddress)) {
        throw new Error('Invalid contract address ' + contractAddress + '. An originated account address was expected');
    }
    if (!isValidAddress(destinationAddress)) {
        throw new Error('Invalid destination address ' + destinationAddress);
    }
    return multisigUtils_1.genericMultisigDataToSign(contractAddress, destinationAddress, amount, contractCounter);
}
exports.generateDataToSign = generateDataToSign;
/**
 * Returns whether or not the string is a valid Tezos hash of the given type
 *
 * @param {string} hash - the string to validate
 * @param {HashType} hashType - the type of the provided hash
 * @returns {boolean}
 */
function isValidHash(hash, hashType) {
    // Validate encoding
    var decodedHash;
    try {
        decodedHash = base58check.decode(hash);
    }
    catch (e) {
        return false;
    }
    var hashPrefix = decodedHash.slice(0, hashType.prefix.length);
    // Check prefix
    if (!hashPrefix.equals(Buffer.from(hashType.prefix))) {
        return false;
    }
    // Check length
    var hashLength = decodedHash.length - hashPrefix.length;
    return hashLength === hashType.byteLength;
}
exports.isValidHash = isValidHash;
/**
 * Returns whether or not the string is a valid Tezos address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidAddress(hash) {
    return isValidImplicitAddress(hash) || isValidHash(hash, exports.hashTypes.KT);
}
exports.isValidAddress = isValidAddress;
/**
 * Returns whether or not the string is a valid Tezos implicit account address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidImplicitAddress(hash) {
    return isValidHash(hash, exports.hashTypes.tz1) || isValidHash(hash, exports.hashTypes.tz2) || isValidHash(hash, exports.hashTypes.tz3);
}
exports.isValidImplicitAddress = isValidImplicitAddress;
/**
 * Returns whether or not the string is a valid Tezos originated account address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidOriginatedAddress(hash) {
    return isValidHash(hash, exports.hashTypes.KT);
}
exports.isValidOriginatedAddress = isValidOriginatedAddress;
/**
 * Returns whether or not the string is a valid Tezos signature
 *
 * @param {string} hash - the signature to validate
 * @returns {boolean}
 */
function isValidSignature(hash) {
    return (isValidHash(hash, exports.hashTypes.edsig) ||
        isValidHash(hash, exports.hashTypes.spsig1) ||
        isValidHash(hash, exports.hashTypes.p2sig) ||
        isValidHash(hash, exports.hashTypes.sig));
}
exports.isValidSignature = isValidSignature;
/**
 * Returns whether or not the string is a valid Tezos public key
 *
 * @param {string} publicKey The public key to validate
 * @returns {boolean}
 */
function isValidPublicKey(publicKey) {
    return (isValidHash(publicKey, exports.hashTypes.sppk) ||
        isValidHash(publicKey, exports.hashTypes.p2pk) ||
        isValidHash(publicKey, exports.hashTypes.edpk) ||
        Crypto.isValidXpub(publicKey) // xpubs are valid too.
    );
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Returns whether or not the string is a valid Tezos private key
 *
 * @param {string} privateKey The private key to validate
 * @returns {boolean}
 */
function isValidPrivateKey(privateKey) {
    return (isValidHash(privateKey, exports.hashTypes.edesk) ||
        isValidHash(privateKey, exports.hashTypes.edsk) ||
        isValidHash(privateKey, exports.hashTypes.spsk) ||
        isValidHash(privateKey, exports.hashTypes.p2sk));
}
exports.isValidPrivateKey = isValidPrivateKey;
/**
 * Returns whether or not the string is a valid Tezos block hash
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidBlockHash(hash) {
    return isValidHash(hash, exports.hashTypes.b);
}
exports.isValidBlockHash = isValidBlockHash;
/**
 * Returns whether or not the string is a valid Tezos transaction hash
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidTransactionHash(hash) {
    return isValidHash(hash, exports.hashTypes.o);
}
exports.isValidTransactionHash = isValidTransactionHash;
/**
 * Returns whether or not the string is a valid Tezos key given a prefix
 *
 * @param {string} hash - the key to validate
 * @param {HashType} hashType - the type of the provided hash
 * @returns {boolean}
 */
function isValidKey(hash, hashType) {
    return isValidHash(hash, hashType);
}
exports.isValidKey = isValidKey;
/**
 * Get the original key form the text without the given prefix.
 *
 * @param {string} hash - base58 encoded key with a Tezos prefix
 * @param {HashType} hashType - the type of the provided hash
 * @returns {Buffer} the original decoded key
 */
function decodeKey(hash, hashType) {
    if (!isValidKey(hash, hashType)) {
        throw new Error('Unsupported private key');
    }
    var decodedPrv = base58check.decode(hash);
    return Buffer.from(decodedPrv.slice(hashType.prefix.length, decodedPrv.length));
}
exports.decodeKey = decodeKey;
/**
 * Get the raw signature from a Tezos encoded one.
 *
 * @param {string} signature Tezos signatures prefixed with sig, edsig, p2sig or spsig
 * @param {HashType} hashType The prefix of remove
 * @returns {Buffer} The decoded signature without prefix
 */
function decodeSignature(signature, hashType) {
    if (!isValidSignature(signature)) {
        throw new Error('Unsupported signature');
    }
    var decodedPrv = base58check.decode(signature);
    return Buffer.from(decodedPrv.slice(hashType.prefix.length, decodedPrv.length));
}
exports.decodeSignature = decodeSignature;
// Base58Check is used for encoding
// hashedTypes is used to validate hashes by type, by checking their prefix and
// the length of the Buffer obtained by decoding the hash (excluding the prefix)
exports.hashTypes = {
    /* 20 bytes long */
    // ed25519 public key hash
    tz1: {
        prefix: Buffer.from([6, 161, 159]),
        byteLength: 20,
    },
    // secp256k1 public key hash
    tz2: {
        prefix: Buffer.from([6, 161, 161]),
        byteLength: 20,
    },
    // p256 public key hash
    tz3: {
        prefix: Buffer.from([6, 161, 164]),
        byteLength: 20,
    },
    KT: {
        prefix: Buffer.from([2, 90, 121]),
        byteLength: 20,
    },
    /* 32 bytes long */
    // ed25519 public key
    edpk: {
        prefix: Buffer.from([13, 15, 37, 217]),
        byteLength: 32,
    },
    // ed25519 secret key
    edsk2: {
        prefix: Buffer.from([13, 15, 58, 7]),
        byteLength: 32,
    },
    // secp256k1 secret key
    spsk: {
        prefix: Buffer.from([17, 162, 224, 201]),
        byteLength: 32,
    },
    // p256 secret key
    p2sk: {
        prefix: Buffer.from([16, 81, 238, 189]),
        byteLength: 32,
    },
    // block hash
    b: {
        prefix: Buffer.from([1, 52]),
        byteLength: 32,
    },
    // operation hash
    o: {
        prefix: Buffer.from([5, 116]),
        byteLength: 32,
    },
    // operation list hash
    Lo: {
        prefix: Buffer.from([133, 233]),
        byteLength: 32,
    },
    // operation list list hash
    LLo: {
        prefix: Buffer.from([29, 159, 109]),
        byteLength: 32,
    },
    // protocol hash
    P: {
        prefix: Buffer.from([2, 170]),
        byteLength: 32,
    },
    // context hash
    Co: {
        prefix: Buffer.from([79, 179]),
        byteLength: 32,
    },
    /* 33 bytes long */
    // secp256k1 public key
    sppk: {
        prefix: Buffer.from([3, 254, 226, 86]),
        byteLength: 33,
    },
    // p256 public key
    p2pk: {
        prefix: Buffer.from([3, 178, 139, 127]),
        byteLength: 33,
    },
    /* 56 bytes long */
    // ed25519 encrypted seed
    edesk: {
        prefix: Buffer.from([7, 90, 60, 179, 41]),
        byteLength: 56,
    },
    /* 63 bytes long */
    // ed25519 secret key
    edsk: {
        prefix: Buffer.from([43, 246, 78, 7]),
        byteLength: 64,
    },
    // ed25519 signature
    edsig: {
        prefix: Buffer.from([9, 245, 205, 134, 18]),
        byteLength: 64,
    },
    // secp256k1 signature
    spsig1: {
        prefix: Buffer.from([13, 115, 101, 19, 63]),
        byteLength: 64,
    },
    // p256_signature
    p2sig: {
        prefix: Buffer.from([54, 240, 44, 52]),
        byteLength: 64,
    },
    // generic signature
    sig: {
        prefix: Buffer.from([4, 130, 43]),
        byteLength: 64,
    },
    /* 15 bytes long */
    // network hash
    Net: {
        prefix: Buffer.from([87, 82, 0]),
        byteLength: 15,
    },
    // nonce hash
    nce: {
        prefix: Buffer.from([69, 220, 169]),
        byteLength: 15,
    },
    /* 4 bytes long */
    // chain id
    id: {
        prefix: Buffer.from([153, 103]),
        byteLength: 4,
    },
};
// From https://github.com/ecadlabs/taquito/blob/master/packages/taquito/src/constants.ts
var DEFAULT_GAS_LIMIT;
(function (DEFAULT_GAS_LIMIT) {
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["DELEGATION"] = 10600] = "DELEGATION";
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["ORIGINATION"] = 10600] = "ORIGINATION";
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["TRANSFER"] = 10600] = "TRANSFER";
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["REVEAL"] = 10600] = "REVEAL";
})(DEFAULT_GAS_LIMIT = exports.DEFAULT_GAS_LIMIT || (exports.DEFAULT_GAS_LIMIT = {}));
var DEFAULT_FEE;
(function (DEFAULT_FEE) {
    DEFAULT_FEE[DEFAULT_FEE["DELEGATION"] = 1257] = "DELEGATION";
    DEFAULT_FEE[DEFAULT_FEE["ORIGINATION"] = 10000] = "ORIGINATION";
    DEFAULT_FEE[DEFAULT_FEE["TRANSFER"] = 10000] = "TRANSFER";
    DEFAULT_FEE[DEFAULT_FEE["REVEAL"] = 1420] = "REVEAL";
})(DEFAULT_FEE = exports.DEFAULT_FEE || (exports.DEFAULT_FEE = {}));
var DEFAULT_STORAGE_LIMIT;
(function (DEFAULT_STORAGE_LIMIT) {
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["DELEGATION"] = 0] = "DELEGATION";
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["ORIGINATION"] = 257] = "ORIGINATION";
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["TRANSFER"] = 257] = "TRANSFER";
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["REVEAL"] = 0] = "REVEAL";
})(DEFAULT_STORAGE_LIMIT = exports.DEFAULT_STORAGE_LIMIT || (exports.DEFAULT_STORAGE_LIMIT = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi94dHovdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFEQUF5QztBQUN6QywwRUFBd0M7QUFDeEMsMENBQWlEO0FBQ2pELHFDQUFvQztBQUNwQyw2Q0FBa0Q7QUFDbEQsaURBQTREO0FBRzVELDJEQUErQztBQUUvQywwQ0FBMEM7QUFDN0IsUUFBQSxpQkFBaUIsR0FBRyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFckQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLE1BQWMsRUFBRSxPQUFlO0lBQzFELElBQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkQsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNkLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUU5QixPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQztBQU5ELG9DQU1DO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFzQixzQkFBc0IsQ0FBQyxrQkFBMEI7Ozs7O3dCQUNyRSxxQkFBTSw0QkFBTSxDQUFDLEtBQUssRUFBQTs7b0JBQWxCLFNBQWtCLENBQUM7b0JBQ2Isd0JBQXdCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQ25GLG9CQUFvQixHQUFHLDRCQUFNLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLHdCQUF3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cUVBQWdCLENBQUE7SUFDaEIsaUVBQWMsQ0FBQTtBQUNoQixDQUFDLEVBTFcsaUJBQWlCLEdBQWpCLHlCQUFpQixLQUFqQix5QkFBaUIsUUFLNUI7QUFFRCxJQUFZLFdBS1g7QUFMRCxXQUFZLFdBQVc7SUFDckIsNERBQWlCLENBQUE7SUFDakIsK0RBQW1CLENBQUE7SUFDbkIseURBQWdCLENBQUE7SUFDaEIsb0RBQWEsQ0FBQTtBQUNmLENBQUMsRUFMVyxXQUFXLEdBQVgsbUJBQVcsS0FBWCxtQkFBVyxRQUt0QjtBQUVELElBQVkscUJBS1g7QUFMRCxXQUFZLHFCQUFxQjtJQUMvQiw2RUFBYyxDQUFBO0lBQ2QsaUZBQWlCLENBQUE7SUFDakIsMkVBQWMsQ0FBQTtJQUNkLHFFQUFVLENBQUE7QUFDWixDQUFDLEVBTFcscUJBQXFCLEdBQXJCLDZCQUFxQixLQUFyQiw2QkFBcUIsUUFLaEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiYXNlNThjaGVjayBmcm9tICdiczU4Y2hlY2snO1xuaW1wb3J0IHNvZGl1bSBmcm9tICdsaWJzb2RpdW0td3JhcHBlcnMnO1xuaW1wb3J0IHsgSW5NZW1vcnlTaWduZXIgfSBmcm9tICdAdGFxdWl0by9zaWduZXInO1xuaW1wb3J0IHsgZWMgYXMgRUMgfSBmcm9tICdlbGxpcHRpYyc7XG5pbXBvcnQgeyBTaWduaW5nRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2VuZXJpY011bHRpc2lnRGF0YVRvU2lnbiB9IGZyb20gJy4vbXVsdGlzaWdVdGlscyc7XG5pbXBvcnQgeyBIYXNoVHlwZSwgU2lnblJlc3BvbnNlIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCAqIGFzIENyeXB0byBmcm9tICcuLy4uLy4uL3V0aWxzL2NyeXB0byc7XG5cbi8vIEJ5IGRlZmF1bHQsIHVzZSB0aGUgdHJhbnNhY3Rpb25zIHByZWZpeFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfV0FURVJNQVJLID0gbmV3IFVpbnQ4QXJyYXkoWzNdKTtcblxuLyoqXG4gKiBFbmNvZGUgdGhlIHBheWxvYWQgdG8gYmFzZTU4IHdpdGggYSBzcGVjaWZpYyBUZXpvcyBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHByZWZpeCB0byBhZGQgdG8gdGhlIGVuY29kZWQgcGF5bG9hZFxuICogQHBhcmFtIHtCdWZmZXJ9IHBheWxvYWQgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyB7YW55fSBiYXNlNTggcGF5bG9hZCB3aXRoIGEgVGV6b3MgcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNThlbmNvZGUocHJlZml4OiBCdWZmZXIsIHBheWxvYWQ6IEJ1ZmZlcik6IHN0cmluZyB7XG4gIGNvbnN0IG4gPSBCdWZmZXIuYWxsb2MocHJlZml4Lmxlbmd0aCArIHBheWxvYWQubGVuZ3RoKTtcbiAgbi5zZXQocHJlZml4KTtcbiAgbi5zZXQocGF5bG9hZCwgcHJlZml4Lmxlbmd0aCk7XG5cbiAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZShuKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHRyYW5zYWN0aW9uIGlkIGZvciBhIGZvciBhIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZFRyYW5zYWN0aW9uIFNpZ25lZCB0cmFuc2FjdGlvbiBpbiBoZXhhZGVjaW1hbFxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIHRyYW5zYWN0aW9uIGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbklkKGVuY29kZWRUcmFuc2FjdGlvbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgYXdhaXQgc29kaXVtLnJlYWR5O1xuICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb25CdWZmZXIgPSBVaW50OEFycmF5LmZyb20oQnVmZmVyLmZyb20oZW5jb2RlZFRyYW5zYWN0aW9uLCAnaGV4JykpO1xuICBjb25zdCBvcGVyYXRpb25IYXNoUGF5bG9hZCA9IHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goMzIsIGVuY29kZWRUcmFuc2FjdGlvbkJ1ZmZlcik7XG4gIHJldHVybiBiYXNlNThlbmNvZGUoaGFzaFR5cGVzLm8ucHJlZml4LCBCdWZmZXIuZnJvbShvcGVyYXRpb25IYXNoUGF5bG9hZCkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYWRkcmVzcyBvZiBhIG5ldyBvcmlnaW5hdGVkIGFjY291bnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgVGhlIHRyYW5zYWN0aW9uIGlkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hdGlvbiBvcGVyYXRpb24gaW5zaWRlIHRoZSB0cmFuc2FjdGlvbiAoc3RhcnRzIGF0IDApXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBbiBvcmlnaW5hdGVkIGFkZHJlc3Mgd2l0aCB0aGUgS1QgcHJlZml4XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVPcmlnaW5hdGVkQWRkcmVzcyh0cmFuc2FjdGlvbklkOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9UZXpUZWNoL2V6dHovYmxvYi9jZmRjNGZjZmM4OTFmNGY0ZjA3N2MzMDU2ZjQxNDQ3NmRkZTM2MTBiL3NyYy9tYWluLmpzI0w3NjhcbiAgY29uc3Qgb2IgPSBiYXNlNThjaGVjay5kZWNvZGUodHJhbnNhY3Rpb25JZCkuc2xpY2UoaGFzaFR5cGVzLm8ucHJlZml4Lmxlbmd0aCk7XG5cbiAgbGV0IHR0OiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9iLmxlbmd0aDsgaSsrKSB7XG4gICAgdHQucHVzaChvYltpXSk7XG4gIH1cblxuICB0dCA9IHR0LmNvbmNhdChbXG4gICAgKGluZGV4ICYgMHhmZjAwMDAwMCkgPj4gMjQsXG4gICAgKGluZGV4ICYgMHgwMGZmMDAwMCkgPj4gMTYsXG4gICAgKGluZGV4ICYgMHgwMDAwZmYwMCkgPj4gOCxcbiAgICBpbmRleCAmIDB4MDAwMDAwZmYsXG4gIF0pO1xuXG4gIGF3YWl0IHNvZGl1bS5yZWFkeTtcbiAgY29uc3QgcGF5bG9hZCA9IHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goMjAsIG5ldyBVaW50OEFycmF5KHR0KSk7XG4gIHJldHVybiBiYXNlNThlbmNvZGUoaGFzaFR5cGVzLktULnByZWZpeCwgQnVmZmVyLmZyb20ocGF5bG9hZCkpO1xufVxuXG4vKipcbiAqIEdlbmVyaWMgZGF0YSBzaWduaW5nIHVzaW5nIFRlem9zIGxpYnJhcnkuXG4gKlxuICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIEEgS2V5IFBhaXIgd2l0aCBhIHByaXZhdGUga2V5IHNldFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIGRhdGEgaW4gaGV4YWRlY2ltYWwgdG8gc2lnblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB3YXRlcm1hcmsgTWFnaWMgYnl0ZTogMSBmb3IgYmxvY2ssIDIgZm9yIGVuZG9yc2VtZW50LCAzIGZvciBnZW5lcmljXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduUmVzcG9uc2U+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbihcbiAga2V5UGFpcjogS2V5UGFpcixcbiAgZGF0YTogc3RyaW5nLFxuICB3YXRlcm1hcms6IFVpbnQ4QXJyYXkgPSBERUZBVUxUX1dBVEVSTUFSSyxcbik6IFByb21pc2U8U2lnblJlc3BvbnNlPiB7XG4gIGlmICgha2V5UGFpci5nZXRLZXlzKCkucHJ2KSB7XG4gICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICB9XG4gIGNvbnN0IHNpZ25lciA9IG5ldyBJbk1lbW9yeVNpZ25lcihrZXlQYWlyLmdldEtleXMoKS5wcnYhKTtcbiAgcmV0dXJuIHNpZ25lci5zaWduKGRhdGEsIHdhdGVybWFyayk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIHNpZ25hdHVyZSBwcm9kdWNlZCBmb3IgYSBnaXZlbiBtZXNzYWdlIGJlbG9uZ3MgdG8gYSBzZWNwMjU2azEgcHVibGljIGtleS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBNZXNzYWdlIGluIGhleCBmb3JtYXQgdG8gdmVyaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IHNlY3AyNTZrMSBwdWJsaWMga2V5IHdpdGggXCJzcHBrXCIgcHJlZml4IHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgVGV6b3Mgc2lnbmF0dXJlIHdpdGggXCJzaWdcIiBwcmVmaXhcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gd2F0ZXJtYXJrIE9wdGlvbmFsIHdhdGVybWFyayB1c2VkIHRvIGdlbmVyYXRlIHRoZSBzaWduYXR1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIHB1YmxpY0tleTogc3RyaW5nLFxuICBzaWduYXR1cmU6IHN0cmluZyxcbiAgd2F0ZXJtYXJrOiBVaW50OEFycmF5ID0gREVGQVVMVF9XQVRFUk1BUkssXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgcmF3UHVibGljS2V5ID0gZGVjb2RlS2V5KHB1YmxpY0tleSwgaGFzaFR5cGVzLnNwcGspO1xuICBjb25zdCBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG4gIGNvbnN0IGtleSA9IGVjLmtleUZyb21QdWJsaWMocmF3UHVibGljS2V5KTtcblxuICBjb25zdCBtZXNzYWdlQnVmZmVyID0gVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKG1lc3NhZ2UsICdoZXgnKSk7XG4gIC8vIFRlem9zIHNpZ25hdHVyZXMgYWx3YXlzIGhhdmUgYSB3YXRlcm1hcmtcbiAgY29uc3QgbWVzc2FnZVdpdGhXYXRlcm1hcmsgPSBuZXcgVWludDhBcnJheSh3YXRlcm1hcmsubGVuZ3RoICsgbWVzc2FnZUJ1ZmZlci5sZW5ndGgpO1xuICBtZXNzYWdlV2l0aFdhdGVybWFyay5zZXQod2F0ZXJtYXJrKTtcbiAgbWVzc2FnZVdpdGhXYXRlcm1hcmsuc2V0KG1lc3NhZ2VCdWZmZXIsIHdhdGVybWFyay5sZW5ndGgpO1xuXG4gIGF3YWl0IHNvZGl1bS5yZWFkeTtcbiAgY29uc3QgYnl0ZXNIYXNoID0gQnVmZmVyLmZyb20oc29kaXVtLmNyeXB0b19nZW5lcmljaGFzaCgzMiwgbWVzc2FnZVdpdGhXYXRlcm1hcmspKTtcblxuICBjb25zdCByYXdTaWduYXR1cmUgPSBkZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlLCBoYXNoVHlwZXMuc2lnKTtcbiAgcmV0dXJuIGtleS52ZXJpZnkoYnl0ZXNIYXNoLCB7IHI6IHJhd1NpZ25hdHVyZS5zbGljZSgwLCAzMiksIHM6IHJhd1NpZ25hdHVyZS5zbGljZSgzMiwgNjQpIH0pO1xufVxuXG4vKipcbiAqIFVzZWZ1bCB3cmFwcGVyIHRvIGNyZWF0ZSB0aGUgZ2VuZXJpYyBtdWx0aXNpZyBjb250cmFjdCBkYXRhIHRvIHNpZ24gd2hlbiBtb3ZpbmcgZnVuZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBUaGUgd2FsbGV0IGNvbnRyYWN0IGFkZHJlc3Mgd2l0aCB0aGUgZnVuZHMgdG8gd2l0aGRyYXdcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbkFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgdGhlIGZ1bmRzIHRvXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IE51bWJlciBtdXRleiB0byB0cmFuc2ZlclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0Q291bnRlciBXYWxsZXQgY291bnRlciB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJucyB7YW55fSBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIE1pY2hlbHNvbiBzY3JpcHQgdG8gc2lnbiBhbmQgYXBwcm92ZSBhIHRyYW5zZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURhdGFUb1NpZ24oXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBkZXN0aW5hdGlvbkFkZHJlc3M6IHN0cmluZyxcbiAgYW1vdW50OiBzdHJpbmcsXG4gIGNvbnRyYWN0Q291bnRlcjogc3RyaW5nLFxuKTogYW55IHtcbiAgaWYgKCFpc1ZhbGlkT3JpZ2luYXRlZEFkZHJlc3MoY29udHJhY3RBZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb250cmFjdCBhZGRyZXNzICcgKyBjb250cmFjdEFkZHJlc3MgKyAnLiBBbiBvcmlnaW5hdGVkIGFjY291bnQgYWRkcmVzcyB3YXMgZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVzdGluYXRpb24gYWRkcmVzcyAnICsgZGVzdGluYXRpb25BZGRyZXNzKTtcbiAgfVxuICByZXR1cm4gZ2VuZXJpY011bHRpc2lnRGF0YVRvU2lnbihjb250cmFjdEFkZHJlc3MsIGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50LCBjb250cmFjdENvdW50ZXIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGhhc2ggb2YgdGhlIGdpdmVuIHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7SGFzaFR5cGV9IGhhc2hUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIGhhc2hcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhhc2goaGFzaDogc3RyaW5nLCBoYXNoVHlwZTogSGFzaFR5cGUpOiBib29sZWFuIHtcbiAgLy8gVmFsaWRhdGUgZW5jb2RpbmdcbiAgbGV0IGRlY29kZWRIYXNoO1xuICB0cnkge1xuICAgIGRlY29kZWRIYXNoID0gYmFzZTU4Y2hlY2suZGVjb2RlKGhhc2gpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc2hQcmVmaXggPSBkZWNvZGVkSGFzaC5zbGljZSgwLCBoYXNoVHlwZS5wcmVmaXgubGVuZ3RoKTtcblxuICAvLyBDaGVjayBwcmVmaXhcbiAgaWYgKCFoYXNoUHJlZml4LmVxdWFscyhCdWZmZXIuZnJvbShoYXNoVHlwZS5wcmVmaXgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGxlbmd0aFxuICBjb25zdCBoYXNoTGVuZ3RoID0gZGVjb2RlZEhhc2gubGVuZ3RoIC0gaGFzaFByZWZpeC5sZW5ndGg7XG4gIHJldHVybiBoYXNoTGVuZ3RoID09PSBoYXNoVHlwZS5ieXRlTGVuZ3RoO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZEltcGxpY2l0QWRkcmVzcyhoYXNoKSB8fCBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuS1QpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGltcGxpY2l0IGFjY291bnQgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gdGhlIGFkZHJlc3MgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEltcGxpY2l0QWRkcmVzcyhoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy50ejEpIHx8IGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy50ejIpIHx8IGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy50ejMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIG9yaWdpbmF0ZWQgYWNjb3VudCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggLSB0aGUgYWRkcmVzcyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkT3JpZ2luYXRlZEFkZHJlc3MoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuS1QpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gdGhlIHNpZ25hdHVyZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy5lZHNpZykgfHxcbiAgICBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuc3BzaWcxKSB8fFxuICAgIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy5wMnNpZykgfHxcbiAgICBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuc2lnKVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIHB1YmxpYyBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBpc1ZhbGlkSGFzaChwdWJsaWNLZXksIGhhc2hUeXBlcy5zcHBrKSB8fFxuICAgIGlzVmFsaWRIYXNoKHB1YmxpY0tleSwgaGFzaFR5cGVzLnAycGspIHx8XG4gICAgaXNWYWxpZEhhc2gocHVibGljS2V5LCBoYXNoVHlwZXMuZWRwaykgfHxcbiAgICBDcnlwdG8uaXNWYWxpZFhwdWIocHVibGljS2V5KSAvLyB4cHVicyBhcmUgdmFsaWQgdG9vLlxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIHByaXZhdGUga2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgVGhlIHByaXZhdGUga2V5IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGlzVmFsaWRIYXNoKHByaXZhdGVLZXksIGhhc2hUeXBlcy5lZGVzaykgfHxcbiAgICBpc1ZhbGlkSGFzaChwcml2YXRlS2V5LCBoYXNoVHlwZXMuZWRzaykgfHxcbiAgICBpc1ZhbGlkSGFzaChwcml2YXRlS2V5LCBoYXNoVHlwZXMuc3BzaykgfHxcbiAgICBpc1ZhbGlkSGFzaChwcml2YXRlS2V5LCBoYXNoVHlwZXMucDJzaylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBUZXpvcyBibG9jayBoYXNoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggLSB0aGUgYWRkcmVzcyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQmxvY2tIYXNoKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZEhhc2goaGFzaCwgaGFzaFR5cGVzLmIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIHRyYW5zYWN0aW9uIGhhc2hcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUcmFuc2FjdGlvbkhhc2goaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMubyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgVGV6b3Mga2V5IGdpdmVuIGEgcHJlZml4XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggLSB0aGUga2V5IHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge0hhc2hUeXBlfSBoYXNoVHlwZSAtIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBoYXNoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRLZXkoaGFzaDogc3RyaW5nLCBoYXNoVHlwZTogSGFzaFR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9yaWdpbmFsIGtleSBmb3JtIHRoZSB0ZXh0IHdpdGhvdXQgdGhlIGdpdmVuIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIGJhc2U1OCBlbmNvZGVkIGtleSB3aXRoIGEgVGV6b3MgcHJlZml4XG4gKiBAcGFyYW0ge0hhc2hUeXBlfSBoYXNoVHlwZSAtIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBoYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfSB0aGUgb3JpZ2luYWwgZGVjb2RlZCBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUtleShoYXNoOiBzdHJpbmcsIGhhc2hUeXBlOiBIYXNoVHlwZSk6IEJ1ZmZlciB7XG4gIGlmICghaXNWYWxpZEtleShoYXNoLCBoYXNoVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByaXZhdGUga2V5Jyk7XG4gIH1cbiAgY29uc3QgZGVjb2RlZFBydiA9IGJhc2U1OGNoZWNrLmRlY29kZShoYXNoKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlY29kZWRQcnYuc2xpY2UoaGFzaFR5cGUucHJlZml4Lmxlbmd0aCwgZGVjb2RlZFBydi5sZW5ndGgpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyBzaWduYXR1cmUgZnJvbSBhIFRlem9zIGVuY29kZWQgb25lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgVGV6b3Mgc2lnbmF0dXJlcyBwcmVmaXhlZCB3aXRoIHNpZywgZWRzaWcsIHAyc2lnIG9yIHNwc2lnXG4gKiBAcGFyYW0ge0hhc2hUeXBlfSBoYXNoVHlwZSBUaGUgcHJlZml4IG9mIHJlbW92ZVxuICogQHJldHVybnMge0J1ZmZlcn0gVGhlIGRlY29kZWQgc2lnbmF0dXJlIHdpdGhvdXQgcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcsIGhhc2hUeXBlOiBIYXNoVHlwZSk6IEJ1ZmZlciB7XG4gIGlmICghaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzaWduYXR1cmUnKTtcbiAgfVxuICBjb25zdCBkZWNvZGVkUHJ2ID0gYmFzZTU4Y2hlY2suZGVjb2RlKHNpZ25hdHVyZSk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShkZWNvZGVkUHJ2LnNsaWNlKGhhc2hUeXBlLnByZWZpeC5sZW5ndGgsIGRlY29kZWRQcnYubGVuZ3RoKSk7XG59XG5cbi8vIEJhc2U1OENoZWNrIGlzIHVzZWQgZm9yIGVuY29kaW5nXG4vLyBoYXNoZWRUeXBlcyBpcyB1c2VkIHRvIHZhbGlkYXRlIGhhc2hlcyBieSB0eXBlLCBieSBjaGVja2luZyB0aGVpciBwcmVmaXggYW5kXG4vLyB0aGUgbGVuZ3RoIG9mIHRoZSBCdWZmZXIgb2J0YWluZWQgYnkgZGVjb2RpbmcgdGhlIGhhc2ggKGV4Y2x1ZGluZyB0aGUgcHJlZml4KVxuZXhwb3J0IGNvbnN0IGhhc2hUeXBlcyA9IHtcbiAgLyogMjAgYnl0ZXMgbG9uZyAqL1xuICAvLyBlZDI1NTE5IHB1YmxpYyBrZXkgaGFzaFxuICB0ejE6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs2LCAxNjEsIDE1OV0pLFxuICAgIGJ5dGVMZW5ndGg6IDIwLFxuICB9LFxuICAvLyBzZWNwMjU2azEgcHVibGljIGtleSBoYXNoXG4gIHR6Mjoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzYsIDE2MSwgMTYxXSksXG4gICAgYnl0ZUxlbmd0aDogMjAsXG4gIH0sXG4gIC8vIHAyNTYgcHVibGljIGtleSBoYXNoXG4gIHR6Mzoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzYsIDE2MSwgMTY0XSksXG4gICAgYnl0ZUxlbmd0aDogMjAsXG4gIH0sXG4gIEtUOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMiwgOTAsIDEyMV0pLFxuICAgIGJ5dGVMZW5ndGg6IDIwLFxuICB9LFxuICAvKiAzMiBieXRlcyBsb25nICovXG4gIC8vIGVkMjU1MTkgcHVibGljIGtleVxuICBlZHBrOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMTMsIDE1LCAzNywgMjE3XSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIGVkMjU1MTkgc2VjcmV0IGtleVxuICBlZHNrMjoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzEzLCAxNSwgNTgsIDddKSxcbiAgICBieXRlTGVuZ3RoOiAzMixcbiAgfSxcbiAgLy8gc2VjcDI1NmsxIHNlY3JldCBrZXlcbiAgc3Bzazoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzE3LCAxNjIsIDIyNCwgMjAxXSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIHAyNTYgc2VjcmV0IGtleVxuICBwMnNrOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMTYsIDgxLCAyMzgsIDE4OV0pLFxuICAgIGJ5dGVMZW5ndGg6IDMyLFxuICB9LFxuICAvLyBibG9jayBoYXNoXG4gIGI6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsxLCA1Ml0pLFxuICAgIGJ5dGVMZW5ndGg6IDMyLFxuICB9LFxuICAvLyBvcGVyYXRpb24gaGFzaFxuICBvOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbNSwgMTE2XSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIG9wZXJhdGlvbiBsaXN0IGhhc2hcbiAgTG86IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsxMzMsIDIzM10pLFxuICAgIGJ5dGVMZW5ndGg6IDMyLFxuICB9LFxuICAvLyBvcGVyYXRpb24gbGlzdCBsaXN0IGhhc2hcbiAgTExvOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMjksIDE1OSwgMTA5XSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIHByb3RvY29sIGhhc2hcbiAgUDoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzIsIDE3MF0pLFxuICAgIGJ5dGVMZW5ndGg6IDMyLFxuICB9LFxuICAvLyBjb250ZXh0IGhhc2hcbiAgQ286IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs3OSwgMTc5XSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8qIDMzIGJ5dGVzIGxvbmcgKi9cbiAgLy8gc2VjcDI1NmsxIHB1YmxpYyBrZXlcbiAgc3Bwazoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzMsIDI1NCwgMjI2LCA4Nl0pLFxuICAgIGJ5dGVMZW5ndGg6IDMzLFxuICB9LFxuICAvLyBwMjU2IHB1YmxpYyBrZXlcbiAgcDJwazoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzMsIDE3OCwgMTM5LCAxMjddKSxcbiAgICBieXRlTGVuZ3RoOiAzMyxcbiAgfSxcbiAgLyogNTYgYnl0ZXMgbG9uZyAqL1xuICAvLyBlZDI1NTE5IGVuY3J5cHRlZCBzZWVkXG4gIGVkZXNrOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbNywgOTAsIDYwLCAxNzksIDQxXSksXG4gICAgYnl0ZUxlbmd0aDogNTYsXG4gIH0sXG4gIC8qIDYzIGJ5dGVzIGxvbmcgKi9cbiAgLy8gZWQyNTUxOSBzZWNyZXQga2V5XG4gIGVkc2s6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs0MywgMjQ2LCA3OCwgN10pLFxuICAgIGJ5dGVMZW5ndGg6IDY0LFxuICB9LFxuICAvLyBlZDI1NTE5IHNpZ25hdHVyZVxuICBlZHNpZzoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzksIDI0NSwgMjA1LCAxMzQsIDE4XSksXG4gICAgYnl0ZUxlbmd0aDogNjQsXG4gIH0sXG4gIC8vIHNlY3AyNTZrMSBzaWduYXR1cmVcbiAgc3BzaWcxOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMTMsIDExNSwgMTAxLCAxOSwgNjNdKSxcbiAgICBieXRlTGVuZ3RoOiA2NCxcbiAgfSxcbiAgLy8gcDI1Nl9zaWduYXR1cmVcbiAgcDJzaWc6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs1NCwgMjQwLCA0NCwgNTJdKSxcbiAgICBieXRlTGVuZ3RoOiA2NCxcbiAgfSxcbiAgLy8gZ2VuZXJpYyBzaWduYXR1cmVcbiAgc2lnOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbNCwgMTMwLCA0M10pLFxuICAgIGJ5dGVMZW5ndGg6IDY0LFxuICB9LFxuICAvKiAxNSBieXRlcyBsb25nICovXG4gIC8vIG5ldHdvcmsgaGFzaFxuICBOZXQ6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs4NywgODIsIDBdKSxcbiAgICBieXRlTGVuZ3RoOiAxNSxcbiAgfSxcbiAgLy8gbm9uY2UgaGFzaFxuICBuY2U6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs2OSwgMjIwLCAxNjldKSxcbiAgICBieXRlTGVuZ3RoOiAxNSxcbiAgfSxcbiAgLyogNCBieXRlcyBsb25nICovXG4gIC8vIGNoYWluIGlkXG4gIGlkOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMTUzLCAxMDNdKSxcbiAgICBieXRlTGVuZ3RoOiA0LFxuICB9LFxufTtcblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZWNhZGxhYnMvdGFxdWl0by9ibG9iL21hc3Rlci9wYWNrYWdlcy90YXF1aXRvL3NyYy9jb25zdGFudHMudHNcblxuZXhwb3J0IGVudW0gREVGQVVMVF9HQVNfTElNSVQge1xuICBERUxFR0FUSU9OID0gMTA2MDAsXG4gIE9SSUdJTkFUSU9OID0gMTA2MDAsXG4gIFRSQU5TRkVSID0gMTA2MDAsXG4gIFJFVkVBTCA9IDEwNjAwLFxufVxuXG5leHBvcnQgZW51bSBERUZBVUxUX0ZFRSB7XG4gIERFTEVHQVRJT04gPSAxMjU3LFxuICBPUklHSU5BVElPTiA9IDEwMDAwLFxuICBUUkFOU0ZFUiA9IDEwMDAwLFxuICBSRVZFQUwgPSAxNDIwLFxufVxuXG5leHBvcnQgZW51bSBERUZBVUxUX1NUT1JBR0VfTElNSVQge1xuICBERUxFR0FUSU9OID0gMCxcbiAgT1JJR0lOQVRJT04gPSAyNTcsXG4gIFRSQU5TRkVSID0gMjU3LFxuICBSRVZFQUwgPSAwLFxufVxuIl19