"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
var local_forging_1 = require("@taquito/local-forging");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var multisigUtils_1 = require("./multisigUtils");
var Utils = __importStar(require("./utils"));
/**
 * Tezos transaction model.
 */
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     */
    function Transaction(coinConfig) {
        var _this = _super.call(this, coinConfig) || this;
        _this._owners = [];
        return _this;
    }
    /**
     * Initialize the transaction fields based on another serialized transaction.
     *
     * @param serializedTransaction Transaction in broadcast format.
     */
    Transaction.prototype.initFromSerializedTransaction = function (serializedTransaction) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedTransaction, e_1, unsignedSerializedTransaction, signature, parsedTransaction, transactionId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._encodedTransaction = serializedTransaction;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 8]);
                        return [4 /*yield*/, local_forging_1.localForger.parse(serializedTransaction)];
                    case 2:
                        parsedTransaction = _a.sent();
                        return [4 /*yield*/, this.initFromParsedTransaction(parsedTransaction)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 4:
                        e_1 = _a.sent();
                        unsignedSerializedTransaction = serializedTransaction.slice(0, -128);
                        signature = serializedTransaction.slice(-128);
                        if (Utils.isValidSignature(signature)) {
                            throw new errors_1.ParseTransactionError('Invalid transaction');
                        }
                        return [4 /*yield*/, local_forging_1.localForger.parse(unsignedSerializedTransaction)];
                    case 5:
                        parsedTransaction = _a.sent();
                        return [4 /*yield*/, Utils.calculateTransactionId(serializedTransaction)];
                    case 6:
                        transactionId = _a.sent();
                        return [4 /*yield*/, this.initFromParsedTransaction(parsedTransaction, transactionId)];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Initialize the transaction fields based on another parsed transaction.
     *
     * @param {ParsedTransaction} parsedTransaction A Tezos transaction object
     * @param {string} transactionId The transaction id of the parsedTransaction if it is signed
     */
    Transaction.prototype.initFromParsedTransaction = function (parsedTransaction, transactionId) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, operationIndex, _i, _b, operation, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!!this._encodedTransaction) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, local_forging_1.localForger.forge(parsedTransaction)];
                    case 1:
                        _a._encodedTransaction = _d.sent();
                        _d.label = 2;
                    case 2:
                        if (transactionId) {
                            // If the transaction id is passed, save it and clean up the entries since they will be
                            // recalculated
                            this._id = transactionId;
                            this._inputs = [];
                            this._outputs = [];
                        }
                        else {
                            this._id = '';
                        }
                        this._parsedTransaction = parsedTransaction;
                        operationIndex = 0;
                        _i = 0, _b = parsedTransaction.contents;
                        _d.label = 3;
                    case 3:
                        if (!(_i < _b.length)) return [3 /*break*/, 10];
                        operation = _b[_i];
                        if (this._source && this._source !== operation.source) {
                            throw new errors_1.InvalidTransactionError('Source must be the same for every operation but it changed from ' + this._source + ' to ' + operation.source);
                        }
                        else {
                            this._source = operation.source;
                        }
                        _c = operation.kind;
                        switch (_c) {
                            case local_forging_1.CODEC.OP_ORIGINATION: return [3 /*break*/, 4];
                            case local_forging_1.CODEC.OP_REVEAL: return [3 /*break*/, 6];
                            case local_forging_1.CODEC.OP_TRANSACTION: return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 8];
                    case 4: return [4 /*yield*/, this.recordOriginationOpFields(operation, operationIndex)];
                    case 5:
                        _d.sent();
                        operationIndex++;
                        return [3 /*break*/, 9];
                    case 6:
                        this.recordRevealOpFields(operation);
                        return [3 /*break*/, 9];
                    case 7:
                        this.recordTransactionOpFields(operation);
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 9];
                    case 9:
                        _i++;
                        return [3 /*break*/, 3];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Record the most important fields from an origination operation.
     *
     * @param {Operation} operation An operation object from a Tezos transaction
     * @param {number} index The origination operation index in the transaction. Used to calculate the
     *      originated address
     */
    Transaction.prototype.recordOriginationOpFields = function (operation, index) {
        return __awaiter(this, void 0, void 0, function () {
            var originationData, _a, _b, _c;
            var _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        originationData = multisigUtils_1.getOriginationDataFromOperation(operation);
                        if (originationData.forwarderDestination) {
                            this._type = baseCoin_1.TransactionType.AddressInitialization;
                            this._forwarderDestination = originationData.forwarderDestination;
                        }
                        else {
                            this._type = baseCoin_1.TransactionType.WalletInitialization;
                            this._owners = multisigUtils_1.getOwnersPublicKeys(operation);
                        }
                        this._delegate = operation.delegate;
                        _b = (_a = this._outputs).push;
                        _d = {};
                        if (!this._id) return [3 /*break*/, 2];
                        return [4 /*yield*/, Utils.calculateOriginatedAddress(this._id, index)];
                    case 1:
                        _c = _e.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _c = '';
                        _e.label = 3;
                    case 3:
                        _b.apply(_a, [(
                            // Kt addresses can only be calculated for signed transactions with an id
                            _d.address = _c,
                                // Balance
                                _d.value = operation.balance,
                                _d)]);
                        this._inputs.push({
                            address: operation.source,
                            // Balance + fees + max gas + max storage are paid by the source account
                            value: new bignumber_js_1.default(operation.balance).plus(operation.fee).toString(),
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Record the most important fields from a reveal operation.
     *
     * @param {RevealOp} operation A reveal operation object from a Tezos transaction
     */
    Transaction.prototype.recordRevealOpFields = function (operation) {
        this._type = baseCoin_1.TransactionType.AccountUpdate;
        this._publicKeyToReveal = operation.public_key;
        this._inputs.push({
            address: operation.source,
            // Balance + fees + max gas + max storage are paid by the source account
            value: operation.fee,
        });
    };
    /**
     * Record the most important fields for a Transaction operation.
     *
     * @param {TransactionOp} operation A transaction object from a Tezos operation
     */
    Transaction.prototype.recordTransactionOpFields = function (operation) {
        if (operation.parameters) {
            this._type = baseCoin_1.TransactionType.Send;
        }
        else {
            this._type = baseCoin_1.TransactionType.SingleSigSend;
        }
        var transferData = multisigUtils_1.getMultisigTransferDataFromOperation(operation);
        // Fees are paid by the source account, along with the amount in the transaction
        this._inputs.push({
            address: operation.source,
            value: new bignumber_js_1.default(transferData.fee.fee).toFixed(0),
        });
        if (transferData.coin === 'mutez') {
            this._outputs.push({
                // Kt addresses can only be calculated for signed transactions with an id
                address: transferData.to,
                // Balance
                value: transferData.amount,
            });
            // The funds being transferred from the wallet
            this._inputs.push({
                address: transferData.from,
                // Balance + fees + max gas + max storage are paid by the source account
                value: transferData.amount,
            });
        }
    };
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    Transaction.prototype.sign = function (keyPair) {
        return __awaiter(this, void 0, void 0, function () {
            var encodedTransaction, signedTransaction, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // TODO: fail if the transaction is already signed
                        // Check if there is a transaction to sign
                        if (!this._parsedTransaction) {
                            throw new errors_1.InvalidTransactionError('Empty transaction');
                        }
                        return [4 /*yield*/, local_forging_1.localForger.forge(this._parsedTransaction)];
                    case 1:
                        encodedTransaction = _b.sent();
                        return [4 /*yield*/, Utils.sign(keyPair, encodedTransaction)];
                    case 2:
                        signedTransaction = _b.sent();
                        this._encodedTransaction = signedTransaction.sbytes;
                        // The transaction id can only be calculated for signed transactions
                        _a = this;
                        return [4 /*yield*/, Utils.calculateTransactionId(this._encodedTransaction)];
                    case 3:
                        // The transaction id can only be calculated for signed transactions
                        _a._id = _b.sent();
                        return [4 /*yield*/, this.initFromParsedTransaction(this._parsedTransaction, this._id)];
                    case 4:
                        _b.sent();
                        this._signatures.push(signedTransaction.sig);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update the list of signatures for a multisig transaction operation.
     *
     * @param {IndexedSignature[]} signatures List of signatures and the index they should be put on
     *    in the multisig transfer
     * @param {number} index The transfer index to add the signatures to
     */
    Transaction.prototype.addTransferSignature = function (signatures, index) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this._parsedTransaction) {
                            throw new errors_1.InvalidTransactionError('Empty transaction');
                        }
                        multisigUtils_1.updateMultisigTransferSignatures(this._parsedTransaction.contents[index], signatures);
                        _a = this;
                        return [4 /*yield*/, local_forging_1.localForger.forge(this._parsedTransaction)];
                    case 1:
                        _a._encodedTransaction = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        // TODO: check the key belongs to the _source account in _parsedTransaction
        return true;
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        if (!this._parsedTransaction) {
            throw new errors_1.InvalidTransactionError('Empty transaction');
        }
        return this._parsedTransaction;
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        if (!this._encodedTransaction) {
            throw new errors_1.InvalidTransactionError('Missing encoded transaction');
        }
        return this._encodedTransaction;
    };
    Object.defineProperty(Transaction.prototype, "source", {
        /**
         * Get the transaction source if it is available.
         *
         * @returns {string} Source of the transaction
         */
        get: function () {
            if (!this._source) {
                throw new errors_1.InvalidTransactionError('Transaction not initialized');
            }
            return this._source;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "delegate", {
        /**
         * Get the transaction delegation address if it is available.
         *
         * @returns {string} transaction delegation address
         */
        get: function () {
            return this._delegate;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "publicKeyToReveal", {
        /**
         * Get the public key revealed by the transaction if it exists
         *
         * @returns {string} public key
         */
        get: function () {
            return this._publicKeyToReveal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "forwarderDestination", {
        /**
         * Get the destination of an address initialization transaction if it exists
         *
         * @returns {string} forwarder destination
         */
        get: function () {
            return this._forwarderDestination;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "owners", {
        get: function () {
            return this._owners;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get the signatures for the given multisig transfer,
     *
     * @param {number} transferIndex The transfer script index in the Tezos transaction
     * @returns {IndexedSignature[]} A list of signatures with their index inside the multisig transfer
     *      script
     */
    Transaction.prototype.getTransferSignatures = function (transferIndex) {
        if (transferIndex === void 0) { transferIndex = 0; }
        if (!this._parsedTransaction) {
            return [];
        }
        return multisigUtils_1.getMultisigTransferSignatures(this._parsedTransaction.contents[transferIndex]);
    };
    /**
     * Get the list of index per tezos transaction type. This is useful to locate specific operations
     * within the transaction and verify or sign them.
     *
     * @returns {{[p: string]: number[]}} List of indexes where the key is the transaction kind
     */
    Transaction.prototype.getIndexesByTransactionType = function () {
        if (!this._parsedTransaction) {
            return {};
        }
        var indexes = {};
        for (var i = 0; i < this._parsedTransaction.contents.length; i++) {
            var kind = this._parsedTransaction.contents[i].kind;
            indexes[kind] = indexes[kind] ? indexes[kind].concat([i]) : [i];
        }
        return indexes;
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi94dHovdHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdEQUE0RDtBQUM1RCw4REFBcUM7QUFFckMsd0NBQStEO0FBQy9ELDZDQUFvRjtBQUVwRixpREFNeUI7QUFHekIsNkNBQWlDO0FBRWpDOztHQUVHO0FBQ0g7SUFBaUMsK0JBQWU7SUFTOUM7Ozs7T0FJRztJQUNILHFCQUFZLFVBQWdDO1FBQTVDLFlBQ0Usa0JBQU0sVUFBVSxDQUFDLFNBRWxCO1FBREMsS0FBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7O0lBQ3BCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0csbURBQTZCLEdBQW5DLFVBQW9DLHFCQUE2Qjs7Ozs7O3dCQUMvRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcscUJBQXFCLENBQUM7Ozs7d0JBRXJCLHFCQUFNLDJCQUFXLENBQUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLEVBQUE7O3dCQUFsRSxpQkFBaUIsR0FBRyxTQUE4Qzt3QkFDeEUscUJBQU0sSUFBSSxDQUFDLHlCQUF5QixDQUFDLGlCQUFpQixDQUFDLEVBQUE7O3dCQUF2RCxTQUF1RCxDQUFDOzs7O3dCQUlsRCw2QkFBNkIsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ3JFLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDcEQsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEVBQUU7NEJBQ3JDLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO3lCQUN4RDt3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Ozs7OztPQU1HO0lBQ0gsMkNBQXFCLEdBQXJCLFVBQXNCLGFBQWlCO1FBQWpCLDhCQUFBLEVBQUEsaUJBQWlCO1FBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDNUIsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUNELE9BQU8sNkNBQTZCLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQWtCLENBQUMsQ0FBQztJQUN6RyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxpREFBMkIsR0FBM0I7UUFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQzVCLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3RELE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pFO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUNILGtCQUFDO0FBQUQsQ0FBQyxBQWxURCxDQUFpQywwQkFBZSxHQWtUL0M7QUFsVFksa0NBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT0RFQywgbG9jYWxGb3JnZXIgfSBmcm9tICdAdGFxdWl0by9sb2NhbC1mb3JnaW5nJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBCYXNlVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEludmFsaWRUcmFuc2FjdGlvbkVycm9yLCBQYXJzZVRyYW5zYWN0aW9uRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7XG4gIGdldE11bHRpc2lnVHJhbnNmZXJEYXRhRnJvbU9wZXJhdGlvbixcbiAgZ2V0TXVsdGlzaWdUcmFuc2ZlclNpZ25hdHVyZXMsXG4gIGdldE9yaWdpbmF0aW9uRGF0YUZyb21PcGVyYXRpb24sXG4gIGdldE93bmVyc1B1YmxpY0tleXMsXG4gIHVwZGF0ZU11bHRpc2lnVHJhbnNmZXJTaWduYXR1cmVzLFxufSBmcm9tICcuL211bHRpc2lnVXRpbHMnO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgeyBJbmRleGVkU2lnbmF0dXJlLCBPcmlnaW5hdGlvbk9wLCBQYXJzZWRUcmFuc2FjdGlvbiwgUmV2ZWFsT3AsIFRyYW5zYWN0aW9uT3AgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFRlem9zIHRyYW5zYWN0aW9uIG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICBwcml2YXRlIF9wYXJzZWRUcmFuc2FjdGlvbj86IFBhcnNlZFRyYW5zYWN0aW9uOyAvLyB0cmFuc2FjdGlvbiBpbiBKU09OIGZvcm1hdFxuICBwcml2YXRlIF9lbmNvZGVkVHJhbnNhY3Rpb24/OiBzdHJpbmc7IC8vIHRyYW5zYWN0aW9uIGluIGhleCBmb3JtYXRcbiAgcHJpdmF0ZSBfc291cmNlOiBzdHJpbmc7XG4gIHByaXZhdGUgX2RlbGVnYXRlPzogc3RyaW5nO1xuICBwcml2YXRlIF9mb3J3YXJkZXJEZXN0aW5hdGlvbj86IHN0cmluZztcbiAgcHJpdmF0ZSBfcHVibGljS2V5VG9SZXZlYWw/OiBzdHJpbmc7XG4gIHByaXZhdGUgX293bmVyczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkb25seTxDb2luQ29uZmlnPn0gY29pbkNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihjb2luQ29uZmlnKTtcbiAgICB0aGlzLl9vd25lcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBmaWVsZHMgYmFzZWQgb24gYW5vdGhlciBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2VyaWFsaXplZFRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIGluIGJyb2FkY2FzdCBmb3JtYXQuXG4gICAqL1xuICBhc3luYyBpbml0RnJvbVNlcmlhbGl6ZWRUcmFuc2FjdGlvbihzZXJpYWxpemVkVHJhbnNhY3Rpb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbiA9IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVHJhbnNhY3Rpb24gPSBhd2FpdCBsb2NhbEZvcmdlci5wYXJzZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgICAgYXdhaXQgdGhpcy5pbml0RnJvbVBhcnNlZFRyYW5zYWN0aW9uKHBhcnNlZFRyYW5zYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiBpdCB0aHJvd3MsIGl0IGlzIHBvc3NpYmxlIHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGlzIHNpZ25lZCwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZFxuICAgICAgLy8gYnkgbG9jYWwtZm9yZ2luZy4gVHJ5IGV4dHJhY3RpbmcgdGhlIGxhc3QgNjQgYnl0ZXMgYW5kIHBhcnNlIGl0IGFnYWluLlxuICAgICAgY29uc3QgdW5zaWduZWRTZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgLTEyOCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoLTEyOCk7XG4gICAgICBpZiAoVXRpbHMuaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGVuY29kZSB0aGUgc2lnbmF0dXJlIGFuZCBzYXZlIGl0IGluIF9zaWduYXR1cmVcbiAgICAgIGNvbnN0IHBhcnNlZFRyYW5zYWN0aW9uID0gYXdhaXQgbG9jYWxGb3JnZXIucGFyc2UodW5zaWduZWRTZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IGF3YWl0IFV0aWxzLmNhbGN1bGF0ZVRyYW5zYWN0aW9uSWQoc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdEZyb21QYXJzZWRUcmFuc2FjdGlvbihwYXJzZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25JZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGZpZWxkcyBiYXNlZCBvbiBhbm90aGVyIHBhcnNlZCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJzZWRUcmFuc2FjdGlvbn0gcGFyc2VkVHJhbnNhY3Rpb24gQSBUZXpvcyB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgVGhlIHRyYW5zYWN0aW9uIGlkIG9mIHRoZSBwYXJzZWRUcmFuc2FjdGlvbiBpZiBpdCBpcyBzaWduZWRcbiAgICovXG4gIGFzeW5jIGluaXRGcm9tUGFyc2VkVHJhbnNhY3Rpb24ocGFyc2VkVHJhbnNhY3Rpb246IFBhcnNlZFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbklkPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbiA9IGF3YWl0IGxvY2FsRm9yZ2VyLmZvcmdlKHBhcnNlZFRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uSWQpIHtcbiAgICAgIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBpZCBpcyBwYXNzZWQsIHNhdmUgaXQgYW5kIGNsZWFuIHVwIHRoZSBlbnRyaWVzIHNpbmNlIHRoZXkgd2lsbCBiZVxuICAgICAgLy8gcmVjYWxjdWxhdGVkXG4gICAgICB0aGlzLl9pZCA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICB0aGlzLl9pbnB1dHMgPSBbXTtcbiAgICAgIHRoaXMuX291dHB1dHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faWQgPSAnJztcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24gPSBwYXJzZWRUcmFuc2FjdGlvbjtcbiAgICBsZXQgb3BlcmF0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIHBhcnNlZFRyYW5zYWN0aW9uLmNvbnRlbnRzKSB7XG4gICAgICBpZiAodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZSAhPT0gb3BlcmF0aW9uLnNvdXJjZSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZSBtdXN0IGJlIHRoZSBzYW1lIGZvciBldmVyeSBvcGVyYXRpb24gYnV0IGl0IGNoYW5nZWQgZnJvbSAnICsgdGhpcy5fc291cmNlICsgJyB0byAnICsgb3BlcmF0aW9uLnNvdXJjZSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG9wZXJhdGlvbi5zb3VyY2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9wZXJhdGlvbi5raW5kKSB7XG4gICAgICAgIGNhc2UgQ09ERUMuT1BfT1JJR0lOQVRJT046XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZWNvcmRPcmlnaW5hdGlvbk9wRmllbGRzKG9wZXJhdGlvbiBhcyBPcmlnaW5hdGlvbk9wLCBvcGVyYXRpb25JbmRleCk7XG4gICAgICAgICAgb3BlcmF0aW9uSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDT0RFQy5PUF9SRVZFQUw6XG4gICAgICAgICAgdGhpcy5yZWNvcmRSZXZlYWxPcEZpZWxkcyhvcGVyYXRpb24gYXMgUmV2ZWFsT3ApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENPREVDLk9QX1RSQU5TQUNUSU9OOlxuICAgICAgICAgIHRoaXMucmVjb3JkVHJhbnNhY3Rpb25PcEZpZWxkcyhvcGVyYXRpb24gYXMgVHJhbnNhY3Rpb25PcCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCB0aGUgbW9zdCBpbXBvcnRhbnQgZmllbGRzIGZyb20gYW4gb3JpZ2luYXRpb24gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09wZXJhdGlvbn0gb3BlcmF0aW9uIEFuIG9wZXJhdGlvbiBvYmplY3QgZnJvbSBhIFRlem9zIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgb3JpZ2luYXRpb24gb3BlcmF0aW9uIGluZGV4IGluIHRoZSB0cmFuc2FjdGlvbi4gVXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICAqICAgICAgb3JpZ2luYXRlZCBhZGRyZXNzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlY29yZE9yaWdpbmF0aW9uT3BGaWVsZHMob3BlcmF0aW9uOiBPcmlnaW5hdGlvbk9wLCBpbmRleDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3JpZ2luYXRpb25EYXRhID0gZ2V0T3JpZ2luYXRpb25EYXRhRnJvbU9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgIGlmIChvcmlnaW5hdGlvbkRhdGEuZm9yd2FyZGVyRGVzdGluYXRpb24pIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuQWRkcmVzc0luaXRpYWxpemF0aW9uO1xuICAgICAgdGhpcy5fZm9yd2FyZGVyRGVzdGluYXRpb24gPSBvcmlnaW5hdGlvbkRhdGEuZm9yd2FyZGVyRGVzdGluYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb247XG4gICAgICB0aGlzLl9vd25lcnMgPSBnZXRPd25lcnNQdWJsaWNLZXlzKG9wZXJhdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVsZWdhdGUgPSBvcGVyYXRpb24uZGVsZWdhdGU7XG4gICAgdGhpcy5fb3V0cHV0cy5wdXNoKHtcbiAgICAgIC8vIEt0IGFkZHJlc3NlcyBjYW4gb25seSBiZSBjYWxjdWxhdGVkIGZvciBzaWduZWQgdHJhbnNhY3Rpb25zIHdpdGggYW4gaWRcbiAgICAgIGFkZHJlc3M6IHRoaXMuX2lkID8gYXdhaXQgVXRpbHMuY2FsY3VsYXRlT3JpZ2luYXRlZEFkZHJlc3ModGhpcy5faWQsIGluZGV4KSA6ICcnLFxuICAgICAgLy8gQmFsYW5jZVxuICAgICAgdmFsdWU6IG9wZXJhdGlvbi5iYWxhbmNlLFxuICAgIH0pO1xuICAgIHRoaXMuX2lucHV0cy5wdXNoKHtcbiAgICAgIGFkZHJlc3M6IG9wZXJhdGlvbi5zb3VyY2UsXG4gICAgICAvLyBCYWxhbmNlICsgZmVlcyArIG1heCBnYXMgKyBtYXggc3RvcmFnZSBhcmUgcGFpZCBieSB0aGUgc291cmNlIGFjY291bnRcbiAgICAgIHZhbHVlOiBuZXcgQmlnTnVtYmVyKG9wZXJhdGlvbi5iYWxhbmNlKS5wbHVzKG9wZXJhdGlvbi5mZWUpLnRvU3RyaW5nKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoZSBtb3N0IGltcG9ydGFudCBmaWVsZHMgZnJvbSBhIHJldmVhbCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7UmV2ZWFsT3B9IG9wZXJhdGlvbiBBIHJldmVhbCBvcGVyYXRpb24gb2JqZWN0IGZyb20gYSBUZXpvcyB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSByZWNvcmRSZXZlYWxPcEZpZWxkcyhvcGVyYXRpb246IFJldmVhbE9wKTogdm9pZCB7XG4gICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5BY2NvdW50VXBkYXRlO1xuICAgIHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsID0gb3BlcmF0aW9uLnB1YmxpY19rZXk7XG4gICAgdGhpcy5faW5wdXRzLnB1c2goe1xuICAgICAgYWRkcmVzczogb3BlcmF0aW9uLnNvdXJjZSxcbiAgICAgIC8vIEJhbGFuY2UgKyBmZWVzICsgbWF4IGdhcyArIG1heCBzdG9yYWdlIGFyZSBwYWlkIGJ5IHRoZSBzb3VyY2UgYWNjb3VudFxuICAgICAgdmFsdWU6IG9wZXJhdGlvbi5mZWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoZSBtb3N0IGltcG9ydGFudCBmaWVsZHMgZm9yIGEgVHJhbnNhY3Rpb24gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uT3B9IG9wZXJhdGlvbiBBIHRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIGEgVGV6b3Mgb3BlcmF0aW9uXG4gICAqL1xuICBwcml2YXRlIHJlY29yZFRyYW5zYWN0aW9uT3BGaWVsZHMob3BlcmF0aW9uOiBUcmFuc2FjdGlvbk9wKTogdm9pZCB7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLlNlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuU2luZ2xlU2lnU2VuZDtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmZXJEYXRhID0gZ2V0TXVsdGlzaWdUcmFuc2ZlckRhdGFGcm9tT3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgLy8gRmVlcyBhcmUgcGFpZCBieSB0aGUgc291cmNlIGFjY291bnQsIGFsb25nIHdpdGggdGhlIGFtb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICB0aGlzLl9pbnB1dHMucHVzaCh7XG4gICAgICBhZGRyZXNzOiBvcGVyYXRpb24uc291cmNlLFxuICAgICAgdmFsdWU6IG5ldyBCaWdOdW1iZXIodHJhbnNmZXJEYXRhLmZlZS5mZWUpLnRvRml4ZWQoMCksXG4gICAgfSk7XG5cbiAgICBpZiAodHJhbnNmZXJEYXRhLmNvaW4gPT09ICdtdXRleicpIHtcbiAgICAgIHRoaXMuX291dHB1dHMucHVzaCh7XG4gICAgICAgIC8vIEt0IGFkZHJlc3NlcyBjYW4gb25seSBiZSBjYWxjdWxhdGVkIGZvciBzaWduZWQgdHJhbnNhY3Rpb25zIHdpdGggYW4gaWRcbiAgICAgICAgYWRkcmVzczogdHJhbnNmZXJEYXRhLnRvLFxuICAgICAgICAvLyBCYWxhbmNlXG4gICAgICAgIHZhbHVlOiB0cmFuc2ZlckRhdGEuYW1vdW50LFxuICAgICAgfSk7XG4gICAgICAvLyBUaGUgZnVuZHMgYmVpbmcgdHJhbnNmZXJyZWQgZnJvbSB0aGUgd2FsbGV0XG4gICAgICB0aGlzLl9pbnB1dHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IHRyYW5zZmVyRGF0YS5mcm9tLFxuICAgICAgICAvLyBCYWxhbmNlICsgZmVlcyArIG1heCBnYXMgKyBtYXggc3RvcmFnZSBhcmUgcGFpZCBieSB0aGUgc291cmNlIGFjY291bnRcbiAgICAgICAgdmFsdWU6IHRyYW5zZmVyRGF0YS5hbW91bnQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQga2V5LiBJdCBkb2VzIG5vdCBjaGVjayBpZiB0aGUgc2lnbmVyIGlzIGFsbG93ZWQgdG8gc2lnblxuICAgKiBpdCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5UGFpcn0ga2V5UGFpciBUaGUga2V5IHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGhcbiAgICovXG4gIGFzeW5jIHNpZ24oa2V5UGFpcjogS2V5UGFpcik6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFRPRE86IGZhaWwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2lnbmVkXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSB0cmFuc2FjdGlvbiB0byBzaWduXG4gICAgaWYgKCF0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHRyYW5zYWN0aW9uIGJvZHkgdG8gc2lnblxuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IGF3YWl0IGxvY2FsRm9yZ2VyLmZvcmdlKHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKTtcblxuICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgVXRpbHMuc2lnbihrZXlQYWlyLCBlbmNvZGVkVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbiA9IHNpZ25lZFRyYW5zYWN0aW9uLnNieXRlcztcblxuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiBpZCBjYW4gb25seSBiZSBjYWxjdWxhdGVkIGZvciBzaWduZWQgdHJhbnNhY3Rpb25zXG4gICAgdGhpcy5faWQgPSBhd2FpdCBVdGlscy5jYWxjdWxhdGVUcmFuc2FjdGlvbklkKHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbik7XG4gICAgYXdhaXQgdGhpcy5pbml0RnJvbVBhcnNlZFRyYW5zYWN0aW9uKHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uLCB0aGlzLl9pZCk7XG5cbiAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2goc2lnbmVkVHJhbnNhY3Rpb24uc2lnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2Ygc2lnbmF0dXJlcyBmb3IgYSBtdWx0aXNpZyB0cmFuc2FjdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7SW5kZXhlZFNpZ25hdHVyZVtdfSBzaWduYXR1cmVzIExpc3Qgb2Ygc2lnbmF0dXJlcyBhbmQgdGhlIGluZGV4IHRoZXkgc2hvdWxkIGJlIHB1dCBvblxuICAgKiAgICBpbiB0aGUgbXVsdGlzaWcgdHJhbnNmZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSB0cmFuc2ZlciBpbmRleCB0byBhZGQgdGhlIHNpZ25hdHVyZXMgdG9cbiAgICovXG4gIGFzeW5jIGFkZFRyYW5zZmVyU2lnbmF0dXJlKHNpZ25hdHVyZXM6IEluZGV4ZWRTaWduYXR1cmVbXSwgaW5kZXg6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignRW1wdHkgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgdXBkYXRlTXVsdGlzaWdUcmFuc2ZlclNpZ25hdHVyZXModGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24uY29udGVudHNbaW5kZXhdIGFzIFRyYW5zYWN0aW9uT3AsIHNpZ25hdHVyZXMpO1xuICAgIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbiA9IGF3YWl0IGxvY2FsRm9yZ2VyLmZvcmdlKHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBjYW5TaWduKGtleTogQmFzZUtleSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IGNoZWNrIHRoZSBrZXkgYmVsb25ncyB0byB0aGUgX3NvdXJjZSBhY2NvdW50IGluIF9wYXJzZWRUcmFuc2FjdGlvblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHRvSnNvbigpOiBQYXJzZWRUcmFuc2FjdGlvbiB7XG4gICAgaWYgKCF0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Ccm9hZGNhc3RGb3JtYXQoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdNaXNzaW5nIGVuY29kZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRyYW5zYWN0aW9uIHNvdXJjZSBpZiBpdCBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFNvdXJjZSBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldCBzb3VyY2UoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX3NvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRyYW5zYWN0aW9uIGRlbGVnYXRpb24gYWRkcmVzcyBpZiBpdCBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRyYW5zYWN0aW9uIGRlbGVnYXRpb24gYWRkcmVzc1xuICAgKi9cbiAgZ2V0IGRlbGVnYXRlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljIGtleSByZXZlYWxlZCBieSB0aGUgdHJhbnNhY3Rpb24gaWYgaXQgZXhpc3RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHB1YmxpYyBrZXlcbiAgICovXG4gIGdldCBwdWJsaWNLZXlUb1JldmVhbCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXlUb1JldmVhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlc3RpbmF0aW9uIG9mIGFuIGFkZHJlc3MgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb24gaWYgaXQgZXhpc3RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcndhcmRlciBkZXN0aW5hdGlvblxuICAgKi9cbiAgZ2V0IGZvcndhcmRlckRlc3RpbmF0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcndhcmRlckRlc3RpbmF0aW9uO1xuICB9XG5cbiAgZ2V0IG93bmVycygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX293bmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpZ25hdHVyZXMgZm9yIHRoZSBnaXZlbiBtdWx0aXNpZyB0cmFuc2ZlcixcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zZmVySW5kZXggVGhlIHRyYW5zZmVyIHNjcmlwdCBpbmRleCBpbiB0aGUgVGV6b3MgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge0luZGV4ZWRTaWduYXR1cmVbXX0gQSBsaXN0IG9mIHNpZ25hdHVyZXMgd2l0aCB0aGVpciBpbmRleCBpbnNpZGUgdGhlIG11bHRpc2lnIHRyYW5zZmVyXG4gICAqICAgICAgc2NyaXB0XG4gICAqL1xuICBnZXRUcmFuc2ZlclNpZ25hdHVyZXModHJhbnNmZXJJbmRleCA9IDApOiBJbmRleGVkU2lnbmF0dXJlW10ge1xuICAgIGlmICghdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE11bHRpc2lnVHJhbnNmZXJTaWduYXR1cmVzKHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uLmNvbnRlbnRzW3RyYW5zZmVySW5kZXhdIGFzIFRyYW5zYWN0aW9uT3ApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBpbmRleCBwZXIgdGV6b3MgdHJhbnNhY3Rpb24gdHlwZS4gVGhpcyBpcyB1c2VmdWwgdG8gbG9jYXRlIHNwZWNpZmljIG9wZXJhdGlvbnNcbiAgICogd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBhbmQgdmVyaWZ5IG9yIHNpZ24gdGhlbS5cbiAgICpcbiAgICogQHJldHVybnMge3tbcDogc3RyaW5nXTogbnVtYmVyW119fSBMaXN0IG9mIGluZGV4ZXMgd2hlcmUgdGhlIGtleSBpcyB0aGUgdHJhbnNhY3Rpb24ga2luZFxuICAgKi9cbiAgZ2V0SW5kZXhlc0J5VHJhbnNhY3Rpb25UeXBlKCk6IHsgW2tpbmQ6IHN0cmluZ106IG51bWJlcltdIH0ge1xuICAgIGlmICghdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24uY29udGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbi5jb250ZW50c1tpXS5raW5kO1xuICAgICAgaW5kZXhlc1traW5kXSA9IGluZGV4ZXNba2luZF0gPyBpbmRleGVzW2tpbmRdLmNvbmNhdChbaV0pIDogW2ldO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxufVxuIl19