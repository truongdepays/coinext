import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { BaseTransaction } from '../baseCoin';
import { BaseKey } from '../baseCoin/iface';
import { KeyPair } from './keyPair';
import { IndexedSignature, ParsedTransaction } from './iface';
/**
 * Tezos transaction model.
 */
export declare class Transaction extends BaseTransaction {
    private _parsedTransaction?;
    private _encodedTransaction?;
    private _source;
    private _delegate?;
    private _forwarderDestination?;
    private _publicKeyToReveal?;
    private _owners;
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     */
    constructor(coinConfig: Readonly<CoinConfig>);
    /**
     * Initialize the transaction fields based on another serialized transaction.
     *
     * @param serializedTransaction Transaction in broadcast format.
     */
    initFromSerializedTransaction(serializedTransaction: string): Promise<void>;
    /**
     * Initialize the transaction fields based on another parsed transaction.
     *
     * @param {ParsedTransaction} parsedTransaction A Tezos transaction object
     * @param {string} transactionId The transaction id of the parsedTransaction if it is signed
     */
    initFromParsedTransaction(parsedTransaction: ParsedTransaction, transactionId?: string): Promise<void>;
    /**
     * Record the most important fields from an origination operation.
     *
     * @param {Operation} operation An operation object from a Tezos transaction
     * @param {number} index The origination operation index in the transaction. Used to calculate the
     *      originated address
     */
    private recordOriginationOpFields;
    /**
     * Record the most important fields from a reveal operation.
     *
     * @param {RevealOp} operation A reveal operation object from a Tezos transaction
     */
    private recordRevealOpFields;
    /**
     * Record the most important fields for a Transaction operation.
     *
     * @param {TransactionOp} operation A transaction object from a Tezos operation
     */
    private recordTransactionOpFields;
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    sign(keyPair: KeyPair): Promise<void>;
    /**
     * Update the list of signatures for a multisig transaction operation.
     *
     * @param {IndexedSignature[]} signatures List of signatures and the index they should be put on
     *    in the multisig transfer
     * @param {number} index The transfer index to add the signatures to
     */
    addTransferSignature(signatures: IndexedSignature[], index: number): Promise<void>;
    /** @inheritdoc */
    canSign(key: BaseKey): boolean;
    /** @inheritdoc */
    toJson(): ParsedTransaction;
    /** @inheritdoc */
    toBroadcastFormat(): string;
    /**
     * Get the transaction source if it is available.
     *
     * @returns {string} Source of the transaction
     */
    get source(): string;
    /**
     * Get the transaction delegation address if it is available.
     *
     * @returns {string} transaction delegation address
     */
    get delegate(): string | undefined;
    /**
     * Get the public key revealed by the transaction if it exists
     *
     * @returns {string} public key
     */
    get publicKeyToReveal(): string | undefined;
    /**
     * Get the destination of an address initialization transaction if it exists
     *
     * @returns {string} forwarder destination
     */
    get forwarderDestination(): string | undefined;
    get owners(): string[];
    /**
     * Get the signatures for the given multisig transfer,
     *
     * @param {number} transferIndex The transfer script index in the Tezos transaction
     * @returns {IndexedSignature[]} A list of signatures with their index inside the multisig transfer
     *      script
     */
    getTransferSignatures(transferIndex?: number): IndexedSignature[];
    /**
     * Get the list of index per tezos transaction type. This is useful to locate specific operations
     * within the transaction and verify or sign them.
     *
     * @returns {{[p: string]: number[]}} List of indexes where the key is the transaction kind
     */
    getIndexesByTransactionType(): {
        [kind: string]: number[];
    };
}
//# sourceMappingURL=transaction.d.ts.map