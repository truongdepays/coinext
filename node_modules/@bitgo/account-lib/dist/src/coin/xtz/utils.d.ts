/// <reference types="node" />
import { HashType, SignResponse } from './iface';
import { KeyPair } from './keyPair';
export declare const DEFAULT_WATERMARK: Uint8Array;
/**
 * Encode the payload to base58 with a specific Tezos prefix.
 *
 * @param {Buffer} prefix to add to the encoded payload
 * @param {Buffer} payload to encode
 * @returns {any} base58 payload with a Tezos prefix
 */
export declare function base58encode(prefix: Buffer, payload: Buffer): string;
/**
 * Calculate the transaction id for a for a signed transaction.
 *
 * @param {string} encodedTransaction Signed transaction in hexadecimal
 * @returns {Promise<string>} The transaction id
 */
export declare function calculateTransactionId(encodedTransaction: string): Promise<string>;
/**
 * Calculate the address of a new originated account.
 *
 * @param {string} transactionId The transaction id
 * @param {number} index The index of the origination operation inside the transaction (starts at 0)
 * @returns {Promise<string>} An originated address with the KT prefix
 */
export declare function calculateOriginatedAddress(transactionId: string, index: number): Promise<string>;
/**
 * Generic data signing using Tezos library.
 *
 * @param {KeyPair} keyPair A Key Pair with a private key set
 * @param {string} data The data in hexadecimal to sign
 * @param {Uint8Array} watermark Magic byte: 1 for block, 2 for endorsement, 3 for generic
 * @returns {Promise<SignResponse>}
 */
export declare function sign(keyPair: KeyPair, data: string, watermark?: Uint8Array): Promise<SignResponse>;
/**
 * Verifies the signature produced for a given message belongs to a secp256k1 public key.
 *
 * @param {string} message Message in hex format to verify
 * @param {string} publicKey secp256k1 public key with "sppk" prefix to verify the signature with
 * @param {string} signature Tezos signature with "sig" prefix
 * @param {Uint8Array} watermark Optional watermark used to generate the signature
 * @returns {Promise<boolean>}
 */
export declare function verifySignature(message: string, publicKey: string, signature: string, watermark?: Uint8Array): Promise<boolean>;
/**
 * Useful wrapper to create the generic multisig contract data to sign when moving funds.
 *
 * @param {string} contractAddress The wallet contract address with the funds to withdraw
 * @param {string} destinationAddress The address to transfer the funds to
 * @param {number} amount Number mutez to transfer
 * @param {string} contractCounter Wallet counter to use in the transaction
 * @returns {any} A JSON representation of the Michelson script to sign and approve a transfer
 */
export declare function generateDataToSign(contractAddress: string, destinationAddress: string, amount: string, contractCounter: string): any;
/**
 * Returns whether or not the string is a valid Tezos hash of the given type
 *
 * @param {string} hash - the string to validate
 * @param {HashType} hashType - the type of the provided hash
 * @returns {boolean}
 */
export declare function isValidHash(hash: string, hashType: HashType): boolean;
/**
 * Returns whether or not the string is a valid Tezos address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
export declare function isValidAddress(hash: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos implicit account address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
export declare function isValidImplicitAddress(hash: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos originated account address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
export declare function isValidOriginatedAddress(hash: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos signature
 *
 * @param {string} hash - the signature to validate
 * @returns {boolean}
 */
export declare function isValidSignature(hash: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos public key
 *
 * @param {string} publicKey The public key to validate
 * @returns {boolean}
 */
export declare function isValidPublicKey(publicKey: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos private key
 *
 * @param {string} privateKey The private key to validate
 * @returns {boolean}
 */
export declare function isValidPrivateKey(privateKey: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos block hash
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
export declare function isValidBlockHash(hash: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos transaction hash
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
export declare function isValidTransactionHash(hash: string): boolean;
/**
 * Returns whether or not the string is a valid Tezos key given a prefix
 *
 * @param {string} hash - the key to validate
 * @param {HashType} hashType - the type of the provided hash
 * @returns {boolean}
 */
export declare function isValidKey(hash: string, hashType: HashType): boolean;
/**
 * Get the original key form the text without the given prefix.
 *
 * @param {string} hash - base58 encoded key with a Tezos prefix
 * @param {HashType} hashType - the type of the provided hash
 * @returns {Buffer} the original decoded key
 */
export declare function decodeKey(hash: string, hashType: HashType): Buffer;
/**
 * Get the raw signature from a Tezos encoded one.
 *
 * @param {string} signature Tezos signatures prefixed with sig, edsig, p2sig or spsig
 * @param {HashType} hashType The prefix of remove
 * @returns {Buffer} The decoded signature without prefix
 */
export declare function decodeSignature(signature: string, hashType: HashType): Buffer;
export declare const hashTypes: {
    tz1: {
        prefix: Buffer;
        byteLength: number;
    };
    tz2: {
        prefix: Buffer;
        byteLength: number;
    };
    tz3: {
        prefix: Buffer;
        byteLength: number;
    };
    KT: {
        prefix: Buffer;
        byteLength: number;
    };
    edpk: {
        prefix: Buffer;
        byteLength: number;
    };
    edsk2: {
        prefix: Buffer;
        byteLength: number;
    };
    spsk: {
        prefix: Buffer;
        byteLength: number;
    };
    p2sk: {
        prefix: Buffer;
        byteLength: number;
    };
    b: {
        prefix: Buffer;
        byteLength: number;
    };
    o: {
        prefix: Buffer;
        byteLength: number;
    };
    Lo: {
        prefix: Buffer;
        byteLength: number;
    };
    LLo: {
        prefix: Buffer;
        byteLength: number;
    };
    P: {
        prefix: Buffer;
        byteLength: number;
    };
    Co: {
        prefix: Buffer;
        byteLength: number;
    };
    sppk: {
        prefix: Buffer;
        byteLength: number;
    };
    p2pk: {
        prefix: Buffer;
        byteLength: number;
    };
    edesk: {
        prefix: Buffer;
        byteLength: number;
    };
    edsk: {
        prefix: Buffer;
        byteLength: number;
    };
    edsig: {
        prefix: Buffer;
        byteLength: number;
    };
    spsig1: {
        prefix: Buffer;
        byteLength: number;
    };
    p2sig: {
        prefix: Buffer;
        byteLength: number;
    };
    sig: {
        prefix: Buffer;
        byteLength: number;
    };
    Net: {
        prefix: Buffer;
        byteLength: number;
    };
    nce: {
        prefix: Buffer;
        byteLength: number;
    };
    id: {
        prefix: Buffer;
        byteLength: number;
    };
};
export declare enum DEFAULT_GAS_LIMIT {
    DELEGATION = 10600,
    ORIGINATION = 10600,
    TRANSFER = 10600,
    REVEAL = 10600
}
export declare enum DEFAULT_FEE {
    DELEGATION = 1257,
    ORIGINATION = 10000,
    TRANSFER = 10000,
    REVEAL = 1420
}
export declare enum DEFAULT_STORAGE_LIMIT {
    DELEGATION = 0,
    ORIGINATION = 257,
    TRANSFER = 257,
    REVEAL = 0
}
//# sourceMappingURL=utils.d.ts.map