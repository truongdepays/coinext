/// <reference types="node" />
import { BaseKeyPair } from './baseKeyPair';
import { AddressFormat } from './enum';
import { BlsKeys, KeyPairOptions } from './iface';
/**
 * Base class for BLS keypairs.
 */
export declare abstract class BlsKeyPair implements BaseKeyPair {
    protected keyPair: BlsKeys;
    /**
     * Public constructor. By default, creates a key pair with a random polynomial.
     *
     * @param {KeyPairOptions} source Either a dkg options, a public and secret shares, or a private key
     */
    protected constructor(source?: KeyPairOptions);
    createShares(threshold: number, participants: number): void;
    /**
     * Note - this is not possible using BLS. BLS does not support prvkey derived key gen
     *
     * @param {string[]} prv a hexadecimal private key
     */
    recordKeysFromPrivateKey(prv: string): void;
    /**
     * Note - this is not possible using BLS. BLS does not support pubkey derived key gen
     *
     * @param {string} pub - An extended, compressed, or uncompressed public key
     */
    recordKeysFromPublicKey(pub: string): void;
    getAddress(format?: AddressFormat): string;
    getKeys(): any;
    /**
     * Signs bytes using the key pair
     *
     * @param msg The message bytes to sign
     * @return signature of the bytes using this keypair
     */
    sign(msg: Buffer): Promise<string>;
    /**
     * Aggregates the secret shares of different key pairs into one private key
     *
     * @param prvKeys an array of secret shares
     * @returns a private key
     */
    static aggregatePrvkeys(prvKeys: string[]): string;
    /**
     * Aggregates the public shares of different key pairs into a common public key
     *
     * @param pubKeys an array of public shares
     * @returns a common public key
     */
    static aggregatePubkeys(pubKeys: string[]): string;
    /**
     * Aggregates the message signed by different key pairs into one sign
     *
     * @param signatures the message signed by different key pairs. The signer id is relevant to ensure a valid signature.
     * @example <caption> E.g., the message is signed by user and wallet, then signatures would be:</caption>
     * {
     *   1: BigInt(messageSignedWithUserPrv),
     *   3: BigInt(messageSignedWithWalletPrv),
     * }
     * @returns a signature combining all the provided signed messages
     */
    static aggregateSignatures(signatures: {
        [n: number]: bigint;
    }): string;
    /**
     * Verifies the signature for this key pair
     * @param pub The public key with which to verify the signature
     * @param msg The message to verify the signature with
     * @param signature the signature to verify
     * @return true if the signature is valid, else false
     */
    static verifySignature(pub: string, msg: Buffer, signature: string): Promise<boolean>;
}
//# sourceMappingURL=blsKeyPair.d.ts.map