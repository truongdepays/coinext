"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519KeyPair = void 0;
var nacl = __importStar(require("tweetnacl"));
var utils_1 = require("../hbar/utils");
var crypto_1 = require("../../utils/crypto");
var ed25519KeyDeriver_1 = require("../../utils/ed25519KeyDeriver");
var iface_1 = require("./iface");
var DEFAULT_SEED_SIZE_BYTES = 32;
var Ed25519KeyPair = /** @class */ (function () {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param {KeyPairOptions} source Either a master seed, a private key, or a public key
     */
    function Ed25519KeyPair(source) {
        var naclKeyPair;
        if (!source) {
            var seed = nacl.randomBytes(DEFAULT_SEED_SIZE_BYTES);
            naclKeyPair = nacl.sign.keyPair.fromSeed(seed);
            this.setKeyPair(naclKeyPair);
        }
        else if (iface_1.isSeed(source)) {
            naclKeyPair = nacl.sign.keyPair.fromSeed(source.seed);
            this.setKeyPair(naclKeyPair);
        }
        else if (iface_1.isPrivateKey(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if (iface_1.isPublicKey(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
    }
    Ed25519KeyPair.prototype.getKeyPair = function (naclKeyPair) {
        return {
            prv: utils_1.toHex(naclKeyPair.secretKey.slice(0, 32)),
            pub: utils_1.toHex(naclKeyPair.publicKey),
        };
    };
    Ed25519KeyPair.prototype.setKeyPair = function (naclKeyPair) {
        this.keyPair = this.getKeyPair(naclKeyPair);
    };
    /** @inheritdoc */
    Ed25519KeyPair.prototype.recordKeysFromPrivateKey = function (prv) {
        if (crypto_1.isValidEd25519Seed(prv)) {
            var decodedPrv = utils_1.toUint8Array(prv);
            var naclKeyPair = nacl.sign.keyPair.fromSeed(decodedPrv);
            this.setKeyPair(naclKeyPair);
        }
        else if (crypto_1.isValidEd25519SecretKey(prv)) {
            var decodedPrv = utils_1.toUint8Array(prv);
            var naclKeyPair = nacl.sign.keyPair.fromSecretKey(decodedPrv);
            this.setKeyPair(naclKeyPair);
        }
        else {
            this.keyPair = this.recordKeysFromPrivateKeyInProtocolFormat(prv);
        }
    };
    /** @inheritdoc */
    Ed25519KeyPair.prototype.recordKeysFromPublicKey = function (pub) {
        if (crypto_1.isValidEd25519PublicKey(pub)) {
            this.keyPair = { pub: pub };
        }
        else {
            this.keyPair = this.recordKeysFromPublicKeyInProtocolFormat(pub);
        }
    };
    /**
     * Generates a signature for an arbitrary string with the current private key using the ed25519 public-key signature
     * system.
     *
     * @param {string} message to produce a signature for
     * @returns {Uint8Array} The signature produced for the message
     * @throws if there is no private key
     */
    Ed25519KeyPair.prototype.signMessage = function (message) {
        var messageToSign = utils_1.toUint8Array(Buffer.from(message).toString('hex'));
        var prv = this.keyPair.prv;
        if (!prv) {
            throw new Error('Missing private key');
        }
        return nacl.sign.detached(messageToSign, nacl.sign.keyPair.fromSeed(utils_1.toUint8Array(prv)).secretKey);
    };
    /**
     * Verifies a message signature using the current public key.
     *
     * @param {string} message signed
     * @param {Uint8Array} signature to verify
     * @returns {boolean} True if the message was signed with the current key pair
     */
    Ed25519KeyPair.prototype.verifySignature = function (message, signature) {
        var messageToVerify;
        if (typeof message === 'string') {
            messageToVerify = utils_1.toUint8Array(Buffer.from(message).toString('hex'));
        }
        else {
            messageToVerify = message;
        }
        var publicKey = utils_1.toUint8Array(this.keyPair.pub);
        return nacl.sign.detached.verify(messageToVerify, signature, publicKey);
    };
    /**
     * Derives a hardened child key pair using this key pair's secret key
     * as the seed.
     *
     * @param path derivation path
     */
    Ed25519KeyPair.prototype.deriveHardened = function (path) {
        if (!this.keyPair.prv) {
            throw new Error('need private key to derive hardened keypair');
        }
        var seed = ed25519KeyDeriver_1.Ed25519KeyDeriver.derivePath(path, this.keyPair.prv).key;
        var derivedKeyPair = nacl.sign.keyPair.fromSeed(seed);
        return this.getKeyPair(derivedKeyPair);
    };
    return Ed25519KeyPair;
}());
exports.Ed25519KeyPair = Ed25519KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWQyNTUxOUtleVBhaXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9iYXNlQ29pbi9lZDI1NTE5S2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBQWtDO0FBQ2xDLHVDQUFvRDtBQUNwRCw2Q0FBMEc7QUFDMUcsbUVBQWtFO0FBR2xFLGlDQUF5RjtBQUV6RixJQUFNLHVCQUF1QixHQUFHLEVBQUUsQ0FBQztBQUVuQztJQUlFOzs7O09BSUc7SUFDSCx3QkFBc0IsTUFBdUI7UUFDM0MsSUFBSSxXQUFXLENBQUM7UUFDaEIsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsdUJBQXVCLENBQUMsQ0FBQztZQUN2RCxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDOUI7YUFBTSxJQUFJLGNBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQzlCO2FBQU0sSUFBSSxvQkFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLG1CQUFXLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQzthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FB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QztRQUNqRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHVDQUFjLEdBQWQsVUFBZSxJQUFZO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7U0FDaEU7UUFFRCxJQUFNLElBQUksR0FBRyxxQ0FBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ3RFLElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV4RCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQyxBQTNIRCxJQTJIQztBQTNIcUIsd0NBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBuYWNsIGZyb20gJ3R3ZWV0bmFjbCc7XG5pbXBvcnQgeyB0b0hleCwgdG9VaW50OEFycmF5IH0gZnJvbSAnLi4vaGJhci91dGlscyc7XG5pbXBvcnQgeyBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleSwgaXNWYWxpZEVkMjU1MTlTZWNyZXRLZXksIGlzVmFsaWRFZDI1NTE5U2VlZCB9IGZyb20gJy4uLy4uL3V0aWxzL2NyeXB0byc7XG5pbXBvcnQgeyBFZDI1NTE5S2V5RGVyaXZlciB9IGZyb20gJy4uLy4uL3V0aWxzL2VkMjU1MTlLZXlEZXJpdmVyJztcbmltcG9ydCB7IEJhc2VLZXlQYWlyIH0gZnJvbSAnLi9iYXNlS2V5UGFpcic7XG5pbXBvcnQgeyBBZGRyZXNzRm9ybWF0IH0gZnJvbSAnLi9lbnVtJztcbmltcG9ydCB7IGlzUHJpdmF0ZUtleSwgaXNQdWJsaWNLZXksIGlzU2VlZCwgRGVmYXVsdEtleXMsIEtleVBhaXJPcHRpb25zIH0gZnJvbSAnLi9pZmFjZSc7XG5cbmNvbnN0IERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTID0gMzI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFZDI1NTE5S2V5UGFpciBpbXBsZW1lbnRzIEJhc2VLZXlQYWlyIHtcbiAgcHJvdGVjdGVkIGtleVBhaXI6IERlZmF1bHRLZXlzO1xuICBwcm90ZWN0ZWQgc291cmNlPzogS2V5UGFpck9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5UGFpck9wdGlvbnN9IHNvdXJjZSBFaXRoZXIgYSBtYXN0ZXIgc2VlZCwgYSBwcml2YXRlIGtleSwgb3IgYSBwdWJsaWMga2V5XG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBsZXQgbmFjbEtleVBhaXI7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIGNvbnN0IHNlZWQgPSBuYWNsLnJhbmRvbUJ5dGVzKERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTKTtcbiAgICAgIG5hY2xLZXlQYWlyID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc2VlZCk7XG4gICAgICB0aGlzLnNldEtleVBhaXIobmFjbEtleVBhaXIpO1xuICAgIH0gZWxzZSBpZiAoaXNTZWVkKHNvdXJjZSkpIHtcbiAgICAgIG5hY2xLZXlQYWlyID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc291cmNlLnNlZWQpO1xuICAgICAgdGhpcy5zZXRLZXlQYWlyKG5hY2xLZXlQYWlyKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpdmF0ZUtleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShzb3VyY2UucHJ2KTtcbiAgICB9IGVsc2UgaWYgKGlzUHVibGljS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMucmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkoc291cmNlLnB1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFpciBvcHRpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRLZXlQYWlyKG5hY2xLZXlQYWlyOiBuYWNsLlNpZ25LZXlQYWlyKTogRGVmYXVsdEtleXMge1xuICAgIHJldHVybiB7XG4gICAgICBwcnY6IHRvSGV4KG5hY2xLZXlQYWlyLnNlY3JldEtleS5zbGljZSgwLCAzMikpLFxuICAgICAgcHViOiB0b0hleChuYWNsS2V5UGFpci5wdWJsaWNLZXkpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHNldEtleVBhaXIobmFjbEtleVBhaXI6IG5hY2wuU2lnbktleVBhaXIpOiB2b2lkIHtcbiAgICB0aGlzLmtleVBhaXIgPSB0aGlzLmdldEtleVBhaXIobmFjbEtleVBhaXIpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShwcnY6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChpc1ZhbGlkRWQyNTUxOVNlZWQocHJ2KSkge1xuICAgICAgY29uc3QgZGVjb2RlZFBydiA9IHRvVWludDhBcnJheShwcnYpO1xuICAgICAgY29uc3QgbmFjbEtleVBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZChkZWNvZGVkUHJ2KTtcbiAgICAgIHRoaXMuc2V0S2V5UGFpcihuYWNsS2V5UGFpcik7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWQyNTUxOVNlY3JldEtleShwcnYpKSB7XG4gICAgICBjb25zdCBkZWNvZGVkUHJ2ID0gdG9VaW50OEFycmF5KHBydik7XG4gICAgICBjb25zdCBuYWNsS2V5UGFpciA9IG5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkoZGVjb2RlZFBydik7XG4gICAgICB0aGlzLnNldEtleVBhaXIobmFjbEtleVBhaXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSB0aGlzLnJlY29yZEtleXNGcm9tUHJpdmF0ZUtleUluUHJvdG9jb2xGb3JtYXQocHJ2KTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkocHViOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHViKSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0geyBwdWIgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlQYWlyID0gdGhpcy5yZWNvcmRLZXlzRnJvbVB1YmxpY0tleUluUHJvdG9jb2xGb3JtYXQocHViKTtcbiAgICB9XG4gIH1cblxuICBhYnN0cmFjdCByZWNvcmRLZXlzRnJvbVByaXZhdGVLZXlJblByb3RvY29sRm9ybWF0KHBydjogc3RyaW5nKTogRGVmYXVsdEtleXM7XG5cbiAgYWJzdHJhY3QgcmVjb3JkS2V5c0Zyb21QdWJsaWNLZXlJblByb3RvY29sRm9ybWF0KHB1Yjogc3RyaW5nKTogRGVmYXVsdEtleXM7XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGFic3RyYWN0IGdldEFkZHJlc3MoZm9ybWF0PzogQWRkcmVzc0Zvcm1hdCk6IHN0cmluZztcblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgYWJzdHJhY3QgZ2V0S2V5cygpOiBhbnk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNpZ25hdHVyZSBmb3IgYW4gYXJiaXRyYXJ5IHN0cmluZyB3aXRoIHRoZSBjdXJyZW50IHByaXZhdGUga2V5IHVzaW5nIHRoZSBlZDI1NTE5IHB1YmxpYy1rZXkgc2lnbmF0dXJlXG4gICAqIHN5c3RlbS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdG8gcHJvZHVjZSBhIHNpZ25hdHVyZSBmb3JcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFRoZSBzaWduYXR1cmUgcHJvZHVjZWQgZm9yIHRoZSBtZXNzYWdlXG4gICAqIEB0aHJvd3MgaWYgdGhlcmUgaXMgbm8gcHJpdmF0ZSBrZXlcbiAgICovXG4gIHNpZ25NZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSB0b1VpbnQ4QXJyYXkoQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBjb25zdCB7IHBydiB9ID0gdGhpcy5rZXlQYWlyO1xuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZChtZXNzYWdlVG9TaWduLCBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCh0b1VpbnQ4QXJyYXkocHJ2KSkuc2VjcmV0S2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIG1lc3NhZ2Ugc2lnbmF0dXJlIHVzaW5nIHRoZSBjdXJyZW50IHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIHNpZ25lZFxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1lc3NhZ2Ugd2FzIHNpZ25lZCB3aXRoIHRoZSBjdXJyZW50IGtleSBwYWlyXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUobWVzc2FnZTogVWludDhBcnJheSB8IHN0cmluZywgc2lnbmF0dXJlOiBVaW50OEFycmF5KTogYm9vbGVhbiB7XG4gICAgbGV0IG1lc3NhZ2VUb1ZlcmlmeTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtZXNzYWdlVG9WZXJpZnkgPSB0b1VpbnQ4QXJyYXkoQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZVRvVmVyaWZ5ID0gbWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gdG9VaW50OEFycmF5KHRoaXMua2V5UGFpci5wdWIpO1xuICAgIHJldHVybiBuYWNsLnNpZ24uZGV0YWNoZWQudmVyaWZ5KG1lc3NhZ2VUb1ZlcmlmeSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZXMgYSBoYXJkZW5lZCBjaGlsZCBrZXkgcGFpciB1c2luZyB0aGlzIGtleSBwYWlyJ3Mgc2VjcmV0IGtleVxuICAgKiBhcyB0aGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggZGVyaXZhdGlvbiBwYXRoXG4gICAqL1xuICBkZXJpdmVIYXJkZW5lZChwYXRoOiBzdHJpbmcpOiBEZWZhdWx0S2V5cyB7XG4gICAgaWYgKCF0aGlzLmtleVBhaXIucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgcHJpdmF0ZSBrZXkgdG8gZGVyaXZlIGhhcmRlbmVkIGtleXBhaXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWVkID0gRWQyNTUxOUtleURlcml2ZXIuZGVyaXZlUGF0aChwYXRoLCB0aGlzLmtleVBhaXIucHJ2KS5rZXk7XG4gICAgY29uc3QgZGVyaXZlZEtleVBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZChzZWVkKTtcblxuICAgIHJldHVybiB0aGlzLmdldEtleVBhaXIoZGVyaXZlZEtleVBhaXIpO1xuICB9XG59XG4iXX0=