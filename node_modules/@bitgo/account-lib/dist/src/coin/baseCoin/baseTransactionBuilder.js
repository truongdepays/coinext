"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransactionBuilder = void 0;
var errors_1 = require("./errors");
/**
 * Generic transaction builder to be extended with coin specific logic.
 * Provide a set of default steps (i.e. from, sign, build) and enforces mandatory validations.
 */
var BaseTransactionBuilder = /** @class */ (function () {
    /**
     * Base constructor.
     *
     * @param _coinConfig BaseCoin from statics library
     */
    function BaseTransactionBuilder(_coinConfig) {
        this._coinConfig = _coinConfig;
    }
    /**
     * Parse a transaction based on existing data. The input format is determined by the coin
     * extending this class. Some examples are hex, base64, or JSON.
     *
     * @param rawTransaction A raw transaction to be parsed
     */
    BaseTransactionBuilder.prototype.from = function (rawTransaction) {
        this.validateRawTransaction(rawTransaction);
        this.transaction = this.fromImplementation(rawTransaction);
    };
    /**
     * Validate keys and sign the transaction.
     *
     * @param key One of the keys associated with this transaction
     */
    BaseTransactionBuilder.prototype.sign = function (key) {
        this.validateKey(key);
        if (!this.transaction.canSign(key)) {
            throw new errors_1.SigningError('Private key cannot sign the transaction');
        }
        this.transaction = this.signImplementation(key);
    };
    /**
     * Adds a signature to the transaction.
     *
     * @param publicKey public key that produced the signature
     * @param signature raw signature as a hex encoded Buffer
     */
    BaseTransactionBuilder.prototype.addSignature = function (publicKey, signature) {
        throw new errors_1.SigningError(this.coinName() + " does not support adding signatures directly.");
    };
    /**
     * Finalize the transaction by performing any extra step like calculating hashes, verifying
     * integrity, or adding default values.
     *
     * @returns valid coin specific transaction (signed or unsigned)
     */
    BaseTransactionBuilder.prototype.build = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.validateTransaction(this.transaction);
                return [2 /*return*/, this.buildImplementation()];
            });
        });
    };
    /**
     * Get the underlying coin full name as specified in the statics library.
     */
    BaseTransactionBuilder.prototype.displayName = function () {
        return this._coinConfig.fullName;
    };
    /**
     * Get the underlying coin full name as specified in the statics library.
     */
    BaseTransactionBuilder.prototype.coinName = function () {
        return this._coinConfig.name;
    };
    /**
     * Verified validity windows params if them exist and return a valid validity windows.
     * Unit param must be specified
     * If params are not consistent, default params will be return based on firstValid and minDuration
     * @param {ValidityWindow} params validity windows parameters to validate.
     * @param {String} params.unit Parameter that could be 'blockheight' or 'timestamp'
     * @param {Number} [params.minDuration] Optional - Minimum duration of the window
     * @param {Number} [params.maxDuration] Optional - Maximum duration of the window
     * @param {Number} [params.firstValid] Optional - First valid value
     * @param {Number} [params.lastValid] Optional - Last valid value
     * @returns {ValidityWindow} verified validity windows or default values
     */
    BaseTransactionBuilder.prototype.getValidityWindow = function (params) {
        if (!params.unit || (params.unit !== 'timestamp' && params.unit !== 'blockheight')) {
            throw new Error('Unit parameter must be specified as blockheight or timestamp');
        }
        var unit = params.unit;
        var defaultMinDuration;
        var defaultMaxDuration;
        var defaultFirstValid;
        var defaultLastValid;
        /* Set Default Params
          minimum duration is set as 1 hr (3600000 msec) if unit is timestamp or 20 blocks if it is blockheight
          maximum duration is set as 1 year (31536000000 msec) if unit is timestamp or 1000000 blocks if it is blockheight.
         */
        if (unit === 'timestamp') {
            defaultMinDuration = 0;
            defaultMaxDuration = 31536000000;
            defaultFirstValid = Date.now();
            defaultLastValid = defaultFirstValid + defaultMaxDuration;
        }
        else {
            defaultMinDuration = 0;
            defaultMaxDuration = 1000000;
            defaultFirstValid = 0;
            defaultLastValid = defaultFirstValid + defaultMaxDuration;
        }
        // If any params exist, they will be used, otherwise it will be used default params.
        var firstValid = params.firstValid || defaultFirstValid;
        var lastValid = params.lastValid || defaultLastValid;
        var minDuration = params.minDuration || defaultMinDuration;
        var maxDuration = params.maxDuration || defaultMaxDuration;
        /* Validate Params:
          minDuration < maxDuration
          firstValid < lastValid
          firstValid + minDuration <= lastValid <= firstValid + maxDuration
         */
        if (minDuration >= maxDuration) {
            throw new Error("Expected maxDuration (" + maxDuration + ") to be grather than minDuration (" + minDuration + ")");
        }
        firstValid = firstValid >= 0 ? firstValid : defaultFirstValid;
        minDuration = minDuration >= 0 ? minDuration : defaultMinDuration;
        maxDuration = maxDuration > minDuration ? maxDuration : defaultMaxDuration;
        lastValid =
            lastValid >= firstValid + minDuration && lastValid <= firstValid + maxDuration
                ? lastValid
                : firstValid + maxDuration;
        return {
            firstValid: firstValid,
            lastValid: lastValid,
            minDuration: minDuration,
            maxDuration: maxDuration,
            unit: unit,
        };
    };
    return BaseTransactionBuilder;
}());
exports.BaseTransactionBuilder = BaseTransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZVRyYW5zYWN0aW9uQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2luL2Jhc2VDb2luL2Jhc2VUcmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsbUNBQXdDO0FBRXhDOzs7R0FHRztBQUNIO0lBRUU7Ozs7T0FJRztJQUNILGdDQUFzQixXQUFpQztRQUNyRCxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQ0FBSSxHQUFKLFVBQUssY0FBbUI7UUFDdEIsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFVRDs7OztPQUlHO0lBQ0gscUNBQUksR0FBSixVQUFLLEdBQVk7UUFDZixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNsQyxNQUFNLElBQUkscUJBQVksQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1NBQ25FO1FBRUQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsNkNBQVksR0FBWixVQUFhLFNBQW9CLEVBQUUsU0FBaUI7UUFDbEQsTUFBTSxJQUFJLHFCQUFZLENBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxrREFBK0MsQ0FBQyxDQUFDO0lBQzVGLENBQUM7SUFVRDs7Ozs7T0FLRztJQUNHLHNDQUFLLEdBQVg7OztnQkFDRSxJQUFJLENBQUMs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ICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJhc2VBZGRyZXNzLCBCYXNlS2V5LCBQdWJsaWNLZXksIFZhbGlkaXR5V2luZG93IH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBCYXNlVHJhbnNhY3Rpb24gfSBmcm9tICcuL2Jhc2VUcmFuc2FjdGlvbic7XG5pbXBvcnQgeyBTaWduaW5nRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogR2VuZXJpYyB0cmFuc2FjdGlvbiBidWlsZGVyIHRvIGJlIGV4dGVuZGVkIHdpdGggY29pbiBzcGVjaWZpYyBsb2dpYy5cbiAqIFByb3ZpZGUgYSBzZXQgb2YgZGVmYXVsdCBzdGVwcyAoaS5lLiBmcm9tLCBzaWduLCBidWlsZCkgYW5kIGVuZm9yY2VzIG1hbmRhdG9yeSB2YWxpZGF0aW9ucy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcm90ZWN0ZWQgX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+O1xuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIF9jb2luQ29uZmlnIEJhc2VDb2luIGZyb20gc3RhdGljcyBsaWJyYXJ5XG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgdGhpcy5fY29pbkNvbmZpZyA9IF9jb2luQ29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgdHJhbnNhY3Rpb24gYmFzZWQgb24gZXhpc3RpbmcgZGF0YS4gVGhlIGlucHV0IGZvcm1hdCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjb2luXG4gICAqIGV4dGVuZGluZyB0aGlzIGNsYXNzLiBTb21lIGV4YW1wbGVzIGFyZSBoZXgsIGJhc2U2NCwgb3IgSlNPTi5cbiAgICpcbiAgICogQHBhcmFtIHJhd1RyYW5zYWN0aW9uIEEgcmF3IHRyYW5zYWN0aW9uIHRvIGJlIHBhcnNlZFxuICAgKi9cbiAgZnJvbShyYXdUcmFuc2FjdGlvbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy52YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdGhpcy5mcm9tSW1wbGVtZW50YXRpb24ocmF3VHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2Yge0Bjb2RlIGZyb219LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgKiBAcmV0dXJucyB0aGUgcGFyc2VkIGNvaW4gc3BlY2lmaWMgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZnJvbUltcGxlbWVudGF0aW9uKHJhd1RyYW5zYWN0aW9uOiBhbnkpOiBCYXNlVHJhbnNhY3Rpb247XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGtleXMgYW5kIHNpZ24gdGhlIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IE9uZSBvZiB0aGUga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2lnbihrZXk6IEJhc2VLZXkpOiB2b2lkIHtcbiAgICB0aGlzLnZhbGlkYXRlS2V5KGtleSk7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLmNhblNpZ24oa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignUHJpdmF0ZSBrZXkgY2Fubm90IHNpZ24gdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRoaXMuc2lnbkltcGxlbWVudGF0aW9uKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHNpZ25hdHVyZSB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXkgcHVibGljIGtleSB0aGF0IHByb2R1Y2VkIHRoZSBzaWduYXR1cmVcbiAgICogQHBhcmFtIHNpZ25hdHVyZSByYXcgc2lnbmF0dXJlIGFzIGEgaGV4IGVuY29kZWQgQnVmZmVyXG4gICAqL1xuICBhZGRTaWduYXR1cmUocHVibGljS2V5OiBQdWJsaWNLZXksIHNpZ25hdHVyZTogQnVmZmVyKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcihgJHt0aGlzLmNvaW5OYW1lKCl9IGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nIHNpZ25hdHVyZXMgZGlyZWN0bHkuYCk7XG4gIH1cblxuICAvKipcbiAgICogQ29pbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiB7QGNvZGUgc2lnbn0uXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIHNpZ259XG4gICAqIEByZXR1cm5zIGNvaW4gc3BlY2lmaWMgdHJhbnNhY3Rpb24gd2l0aCBzaWduYXR1cmUgZGF0YVxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNpZ25JbXBsZW1lbnRhdGlvbihrZXk6IEJhc2VLZXkpOiBCYXNlVHJhbnNhY3Rpb247XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIHRoZSB0cmFuc2FjdGlvbiBieSBwZXJmb3JtaW5nIGFueSBleHRyYSBzdGVwIGxpa2UgY2FsY3VsYXRpbmcgaGFzaGVzLCB2ZXJpZnlpbmdcbiAgICogaW50ZWdyaXR5LCBvciBhZGRpbmcgZGVmYXVsdCB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHZhbGlkIGNvaW4gc3BlY2lmaWMgdHJhbnNhY3Rpb24gKHNpZ25lZCBvciB1bnNpZ25lZClcbiAgICovXG4gIGFzeW5jIGJ1aWxkKCk6IFByb21pc2U8QmFzZVRyYW5zYWN0aW9uPiB7XG4gICAgdGhpcy52YWxpZGF0ZVRyYW5zYWN0aW9uKHRoaXMudHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2luIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIHtAY29kZSBidWlsZH0uXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGJ1aWxkfVxuICAgKiBAcmV0dXJucyB2YWxpZCBjb2luIHNwZWNpZmljIHRyYW5zYWN0aW9uIChzaWduZWQgb3IgdW5zaWduZWQpXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPEJhc2VUcmFuc2FjdGlvbj47XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBwcml2YXRlIGtleSBpcyBwcmVzZW50IGFuZCBpcyB2YWxpZCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUtleX0ga2V5IFByaXZhdGUga2V5IHRvIHZhbGlkYXRlXG4gICAqL1xuICBhYnN0cmFjdCB2YWxpZGF0ZUtleShrZXk6IEJhc2VLZXkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgYWRkcmVzcyBwcm92aWRlZCBpcyB2YWxpZCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIEFkZHJlc3MgZGF0YSB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHBhcmFtIGFkZHJlc3NGb3JtYXQgVGhlIGZvcm1hdCB0aGUgYWRkcmVzcyBzaG91bGQgYmUgaW4gaWYgbW9yZSB0aGFuIG9uZSBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIGFic3RyYWN0IHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBCYXNlQWRkcmVzcywgYWRkcmVzc0Zvcm1hdD86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBhbW91bnQgcHJvdmlkZWQgaXMgdmFsaWQgaW4gdGhlIGJsb2NrY2hhaW4gY29udGV4dCwgdGhyb3cgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gdmFsdWUgVHJhbnNhY3Rpb24gYW1vdW50XG4gICAqL1xuICBhYnN0cmFjdCB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSByYXdUcmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBpbiBhbnkgZm9ybWF0XG4gICAqL1xuICBhYnN0cmFjdCB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBhbnkpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgdHJhbnNhY3Rpb24gbWFuZGF0b3J5IGZpZWxkcyBwZXIgdHJhbnNhY3Rpb24gdHlwZSBhbmQgZW5zdXJlcyBpdCBpcyB2YWxpZCwgdGhyb3dcbiAgICogb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGFic3RyYWN0IHZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24/OiBCYXNlVHJhbnNhY3Rpb24pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgY29pbiBmdWxsIG5hbWUgYXMgc3BlY2lmaWVkIGluIHRoZSBzdGF0aWNzIGxpYnJhcnkuXG4gICAqL1xuICBkaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb2luQ29uZmlnLmZ1bGxOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5kZXJseWluZyBjb2luIGZ1bGwgbmFtZSBhcyBzcGVjaWZpZWQgaW4gdGhlIHN0YXRpY3MgbGlicmFyeS5cbiAgICovXG4gIGNvaW5OYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvaW5Db25maWcubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllZCB2YWxpZGl0eSB3aW5kb3dzIHBhcmFtcyBpZiB0aGVtIGV4aXN0IGFuZCByZXR1cm4gYSB2YWxpZCB2YWxpZGl0eSB3aW5kb3dzLlxuICAgKiBVbml0IHBhcmFtIG11c3QgYmUgc3BlY2lmaWVkXG4gICAqIElmIHBhcmFtcyBhcmUgbm90IGNvbnNpc3RlbnQsIGRlZmF1bHQgcGFyYW1zIHdpbGwgYmUgcmV0dXJuIGJhc2VkIG9uIGZpcnN0VmFsaWQgYW5kIG1pbkR1cmF0aW9uXG4gICAqIEBwYXJhbSB7VmFsaWRpdHlXaW5kb3d9IHBhcmFtcyB2YWxpZGl0eSB3aW5kb3dzIHBhcmFtZXRlcnMgdG8gdmFsaWRhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudW5pdCBQYXJhbWV0ZXIgdGhhdCBjb3VsZCBiZSAnYmxvY2toZWlnaHQnIG9yICd0aW1lc3RhbXAnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbkR1cmF0aW9uXSBPcHRpb25hbCAtIE1pbmltdW0gZHVyYXRpb24gb2YgdGhlIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhEdXJhdGlvbl0gT3B0aW9uYWwgLSBNYXhpbXVtIGR1cmF0aW9uIG9mIHRoZSB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZmlyc3RWYWxpZF0gT3B0aW9uYWwgLSBGaXJzdCB2YWxpZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5sYXN0VmFsaWRdIE9wdGlvbmFsIC0gTGFzdCB2YWxpZCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7VmFsaWRpdHlXaW5kb3d9IHZlcmlmaWVkIHZhbGlkaXR5IHdpbmRvd3Mgb3IgZGVmYXVsdCB2YWx1ZXNcbiAgICovXG4gIGdldFZhbGlkaXR5V2luZG93KHBhcmFtczogVmFsaWRpdHlXaW5kb3cpOiBWYWxpZGl0eVdpbmRvdyB7XG4gICAgaWYgKCFwYXJhbXMudW5pdCB8fCAocGFyYW1zLnVuaXQgIT09ICd0aW1lc3RhbXAnICYmIHBhcmFtcy51bml0ICE9PSAnYmxvY2toZWlnaHQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbml0IHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZCBhcyBibG9ja2hlaWdodCBvciB0aW1lc3RhbXAnKTtcbiAgICB9XG4gICAgY29uc3QgdW5pdCA9IHBhcmFtcy51bml0O1xuICAgIGxldCBkZWZhdWx0TWluRHVyYXRpb246IG51bWJlcjtcbiAgICBsZXQgZGVmYXVsdE1heER1cmF0aW9uOiBudW1iZXI7XG4gICAgbGV0IGRlZmF1bHRGaXJzdFZhbGlkOiBudW1iZXI7XG4gICAgbGV0IGRlZmF1bHRMYXN0VmFsaWQ6IG51bWJlcjtcblxuICAgIC8qIFNldCBEZWZhdWx0IFBhcmFtc1xuICAgICAgbWluaW11bSBkdXJhdGlvbiBpcyBzZXQgYXMgMSBociAoMzYwMDAwMCBtc2VjKSBpZiB1bml0IGlzIHRpbWVzdGFtcCBvciAyMCBibG9ja3MgaWYgaXQgaXMgYmxvY2toZWlnaHRcbiAgICAgIG1heGltdW0gZHVyYXRpb24gaXMgc2V0IGFzIDEgeWVhciAoMzE1MzYwMDAwMDAgbXNlYykgaWYgdW5pdCBpcyB0aW1lc3RhbXAgb3IgMTAwMDAwMCBibG9ja3MgaWYgaXQgaXMgYmxvY2toZWlnaHQuXG4gICAgICovXG4gICAgaWYgKHVuaXQgPT09ICd0aW1lc3RhbXAnKSB7XG4gICAgICBkZWZhdWx0TWluRHVyYXRpb24gPSAwO1xuICAgICAgZGVmYXVsdE1heER1cmF0aW9uID0gMzE1MzYwMDAwMDA7XG4gICAgICBkZWZhdWx0Rmlyc3RWYWxpZCA9IERhdGUubm93KCk7XG4gICAgICBkZWZhdWx0TGFzdFZhbGlkID0gZGVmYXVsdEZpcnN0VmFsaWQgKyBkZWZhdWx0TWF4RHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRNaW5EdXJhdGlvbiA9IDA7XG4gICAgICBkZWZhdWx0TWF4RHVyYXRpb24gPSAxMDAwMDAwO1xuICAgICAgZGVmYXVsdEZpcnN0VmFsaWQgPSAwO1xuICAgICAgZGVmYXVsdExhc3RWYWxpZCA9IGRlZmF1bHRGaXJzdFZhbGlkICsgZGVmYXVsdE1heER1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBwYXJhbXMgZXhpc3QsIHRoZXkgd2lsbCBiZSB1c2VkLCBvdGhlcndpc2UgaXQgd2lsbCBiZSB1c2VkIGRlZmF1bHQgcGFyYW1zLlxuICAgIGxldCBmaXJzdFZhbGlkOiBudW1iZXIgPSBwYXJhbXMuZmlyc3RWYWxpZCB8fCBkZWZhdWx0Rmlyc3RWYWxpZDtcbiAgICBsZXQgbGFzdFZhbGlkOiBudW1iZXIgPSBwYXJhbXMubGFzdFZhbGlkIHx8IGRlZmF1bHRMYXN0VmFsaWQ7XG4gICAgbGV0IG1pbkR1cmF0aW9uOiBudW1iZXIgPSBwYXJhbXMubWluRHVyYXRpb24gfHwgZGVmYXVsdE1pbkR1cmF0aW9uO1xuICAgIGxldCBtYXhEdXJhdGlvbjogbnVtYmVyID0gcGFyYW1zLm1heER1cmF0aW9uIHx8IGRlZmF1bHRNYXhEdXJhdGlvbjtcblxuICAgIC8qIFZhbGlkYXRlIFBhcmFtczpcbiAgICAgIG1pbkR1cmF0aW9uIDwgbWF4RHVyYXRpb25cbiAgICAgIGZpcnN0VmFsaWQgPCBsYXN0VmFsaWRcbiAgICAgIGZpcnN0VmFsaWQgKyBtaW5EdXJhdGlvbiA8PSBsYXN0VmFsaWQgPD0gZmlyc3RWYWxpZCArIG1heER1cmF0aW9uXG4gICAgICovXG4gICAgaWYgKG1pbkR1cmF0aW9uID49IG1heER1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG1heER1cmF0aW9uICgke21heER1cmF0aW9ufSkgdG8gYmUgZ3JhdGhlciB0aGFuIG1pbkR1cmF0aW9uICgke21pbkR1cmF0aW9ufSlgKTtcbiAgICB9XG4gICAgZmlyc3RWYWxpZCA9IGZpcnN0VmFsaWQgPj0gMCA/IGZpcnN0VmFsaWQgOiBkZWZhdWx0Rmlyc3RWYWxpZDtcbiAgICBtaW5EdXJhdGlvbiA9IG1pbkR1cmF0aW9uID49IDAgPyBtaW5EdXJhdGlvbiA6IGRlZmF1bHRNaW5EdXJhdGlvbjtcbiAgICBtYXhEdXJhdGlvbiA9IG1heER1cmF0aW9uID4gbWluRHVyYXRpb24gPyBtYXhEdXJhdGlvbiA6IGRlZmF1bHRNYXhEdXJhdGlvbjtcbiAgICBsYXN0VmFsaWQgPVxuICAgICAgbGFzdFZhbGlkID49IGZpcnN0VmFsaWQgKyBtaW5EdXJhdGlvbiAmJiBsYXN0VmFsaWQgPD0gZmlyc3RWYWxpZCArIG1heER1cmF0aW9uXG4gICAgICAgID8gbGFzdFZhbGlkXG4gICAgICAgIDogZmlyc3RWYWxpZCArIG1heER1cmF0aW9uO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0VmFsaWQsXG4gICAgICBsYXN0VmFsaWQsXG4gICAgICBtaW5EdXJhdGlvbixcbiAgICAgIG1heER1cmF0aW9uLFxuICAgICAgdW5pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgYnVpbHQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHRyYW5zYWN0aW9uKCk6IEJhc2VUcmFuc2FjdGlvbjtcblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiBiZWluZyBidWlsdC5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzZXQgdHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IEJhc2VUcmFuc2FjdGlvbik7XG59XG4iXX0=