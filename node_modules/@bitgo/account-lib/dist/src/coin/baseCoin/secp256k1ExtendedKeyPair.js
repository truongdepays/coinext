"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1ExtendedKeyPair = void 0;
var bip32 = __importStar(require("bip32"));
var bitcoinjs_lib_1 = require("bitcoinjs-lib");
var Crypto = __importStar(require("../../utils/crypto"));
var errors_1 = require("./errors");
/**
 * Base class for SECP256K1 extended keypairs.
 */
var Secp256k1ExtendedKeyPair = /** @class */ (function () {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param {KeyPairOptions} source Either a master seed, a private key (extended or raw), or a public key
     *     (extended, compressed, or uncompressed)
     */
    function Secp256k1ExtendedKeyPair(source) {
        this.source = source;
    }
    Secp256k1ExtendedKeyPair.toKeyPair = function (hdNode) {
        if (hdNode.privateKey) {
            return bitcoinjs_lib_1.ECPair.fromPrivateKey(hdNode.privateKey);
        }
        else {
            return bitcoinjs_lib_1.ECPair.fromPublicKey(hdNode.publicKey);
        }
    };
    /**
     * @param compressed
     * @return Buffer 33 bytes if `compressed` is set, 65 bytes otherwise. Standard libsecp256k1 format.
     */
    Secp256k1ExtendedKeyPair.prototype.getPublicKey = function (_a) {
        var compressed = _a.compressed;
        return bitcoinjs_lib_1.ECPair.fromPublicKey(this.keyPair.publicKey, { compressed: compressed }).publicKey;
    };
    /**
     * @return Buffer 32 bytes in standard libsecp256k1 format
     */
    Secp256k1ExtendedKeyPair.prototype.getPrivateKey = function () {
        return this.keyPair.privateKey;
    };
    /**
     * Build a Hierarchical Deterministic node or an ECPair from a private key.
     *
     * @param {string} prv An extended or raw private key
     */
    Secp256k1ExtendedKeyPair.prototype.recordKeysFromPrivateKey = function (prv) {
        if (Crypto.isValidXprv(prv)) {
            this.hdNode = bip32.fromBase58(prv);
        }
        else if (Crypto.isValidPrv(prv)) {
            // Cannot create the HD node without the chain code, so create a regular Key Chain
            this.keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(prv, 'hex'));
        }
        else {
            throw new Error('Unsupported private key');
        }
    };
    /**
     * Build a Hierarchical Deterministic node or an ECPair from a public key.
     *
     * @param {string} pub - An extended, compressed, or uncompressed public key
     */
    Secp256k1ExtendedKeyPair.prototype.recordKeysFromPublicKey = function (pub) {
        if (Crypto.isValidXpub(pub)) {
            this.hdNode = bip32.fromBase58(pub);
        }
        else if (Crypto.isValidPub(pub)) {
            // Cannot create an HD node without the chain code, so create a regular Key Chain
            this.keyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
        }
        else {
            throw new Error('Unsupported public key: ' + pub);
        }
    };
    /**
     * Get the extended public key, and the private key if one is available. This is only possible
     * when the key pair was created from a seed or extended keys.
     *
     * @returns {ExtendedKeys} The Extended keys object
     */
    Secp256k1ExtendedKeyPair.prototype.getExtendedKeys = function () {
        if (!this.hdNode) {
            throw new Error('Cannot get extended keys');
        }
        var result = {
            xpub: this.hdNode.neutered().toBase58(),
        };
        // A neutered HD node means it only contains the public key information
        if (!this.hdNode.isNeutered()) {
            result.xprv = this.hdNode.toBase58();
        }
        return result;
    };
    Secp256k1ExtendedKeyPair.prototype.getAddress = function (format) {
        throw new errors_1.NotImplementedError('getAddress not implemented');
    };
    Secp256k1ExtendedKeyPair.prototype.getKeys = function () {
        throw new errors_1.NotImplementedError('getKeys not implemented');
    };
    return Secp256k1ExtendedKeyPair;
}());
exports.Secp256k1ExtendedKeyPair = Secp256k1ExtendedKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vYmFzZUNvaW4vc2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBK0I7QUFDL0IsK0NBQXVDO0FBQ3ZDLHlEQUE2QztBQUk3QyxtQ0FBK0M7QUFFL0M7O0dBRUc7QUFDSDtJQWNFOzs7OztPQUtHO0lBQ0gsa0NBQXNCLE1BQXVCO1FBQzNDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFyQk0sa0NBQVMsR0FBaEIsVUFBaUIsTUFBNEI7UUFDM0MsSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFO1lBQ3JCLE9BQU8sc0JBQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ2pEO2FBQU07WUFDTCxPQUFPLHNCQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMvQztJQUNILENBQUM7SUFpQkQ7OztPQUdHO0lBQ0gsK0NBQVksR0FBWixVQUFhLEVBQXVDO1lBQXJDLFVBQVUsZ0JBQUE7UUFDdkIsT0FBTyxzQkFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLFVBQVUsWUFBQSxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDaEYsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0RBQWEsR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwyREFBd0IsR0FBeEIsVUFBeUIsR0FBVztRQUNsQyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JDO2FBQU0sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2pDLGtGQUFrRjtZQUNsRixJQUFJLENBQUMsT0FBTyxHQUFHLHNCQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDL0Q7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUM1QztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsMERBQXVCLEdBQXZCLFVBQXdCLEdBQVc7UUFDakMsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNyQzthQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNqQyxpRkFBaUY7WUFDakYsSUFBSSxDQUFDLE9BQU8sR0FBRyxzQkFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzlEO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBQ25EO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsa0RBQWUsR0FBZjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUM3QztRQUNELElBQU0sTUFBTSxHQUFpQjtZQUMzQixJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUU7U0FDeEMsQ0FBQztRQUNGLHVFQUF1RTtRQUN2RSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUM3QixNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDdEM7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsNkNBQVUsR0FBVixVQUFXLE1BQXNCO1FBQy9CLE1BQU0sSUFBSSw0QkFBbUIsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRCwwQ0FBTyxHQUFQO1FBQ0UsTUFBTSxJQUFJLDRCQUFtQixDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUNILCtCQUFDO0FBQUQsQ0FBQyxBQWxHRCxJQWtHQztBQWxHcUIsNERBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0IHsgRUNQYWlyIH0gZnJvbSAnYml0Y29pbmpzLWxpYic7XG5pbXBvcnQgKiBhcyBDcnlwdG8gZnJvbSAnLi4vLi4vdXRpbHMvY3J5cHRvJztcbmltcG9ydCB7IEtleVBhaXJPcHRpb25zLCBFeHRlbmRlZEtleXMgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEJhc2VLZXlQYWlyIH0gZnJvbSAnLi9iYXNlS2V5UGFpcic7XG5pbXBvcnQgeyBBZGRyZXNzRm9ybWF0IH0gZnJvbSAnLi9lbnVtJztcbmltcG9ydCB7IE5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU0VDUDI1NksxIGV4dGVuZGVkIGtleXBhaXJzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIGltcGxlbWVudHMgQmFzZUtleVBhaXIge1xuICBzdGF0aWMgdG9LZXlQYWlyKGhkTm9kZTogYmlwMzIuQklQMzJJbnRlcmZhY2UpOiBFQ1BhaXIuRUNQYWlySW50ZXJmYWNlIHtcbiAgICBpZiAoaGROb2RlLnByaXZhdGVLZXkpIHtcbiAgICAgIHJldHVybiBFQ1BhaXIuZnJvbVByaXZhdGVLZXkoaGROb2RlLnByaXZhdGVLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRUNQYWlyLmZyb21QdWJsaWNLZXkoaGROb2RlLnB1YmxpY0tleSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgdGhlIEhEIHByb3RvY29sIChCSVAzMikuIE9ubHkgYXZhaWxhYmxlIHdoZW4gY3JlYXRpbmcgYSBLZXlQYWlyIGZyb20gYSBzZWVkLFxuICAvLyBvciBleHRlbmRlZCBrZXlzXG4gIHByb3RlY3RlZCBoZE5vZGU/OiBiaXAzMi5CSVAzMkludGVyZmFjZTtcbiAgcHJvdGVjdGVkIGtleVBhaXI6IEVDUGFpci5FQ1BhaXJJbnRlcmZhY2U7XG4gIHByb3RlY3RlZCBzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucztcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5UGFpck9wdGlvbnN9IHNvdXJjZSBFaXRoZXIgYSBtYXN0ZXIgc2VlZCwgYSBwcml2YXRlIGtleSAoZXh0ZW5kZWQgb3IgcmF3KSwgb3IgYSBwdWJsaWMga2V5XG4gICAqICAgICAoZXh0ZW5kZWQsIGNvbXByZXNzZWQsIG9yIHVuY29tcHJlc3NlZClcbiAgICovXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjb21wcmVzc2VkXG4gICAqIEByZXR1cm4gQnVmZmVyIDMzIGJ5dGVzIGlmIGBjb21wcmVzc2VkYCBpcyBzZXQsIDY1IGJ5dGVzIG90aGVyd2lzZS4gU3RhbmRhcmQgbGlic2VjcDI1NmsxIGZvcm1hdC5cbiAgICovXG4gIGdldFB1YmxpY0tleSh7IGNvbXByZXNzZWQgfTogeyBjb21wcmVzc2VkOiBib29sZWFuIH0pOiBCdWZmZXIge1xuICAgIHJldHVybiBFQ1BhaXIuZnJvbVB1YmxpY0tleSh0aGlzLmtleVBhaXIucHVibGljS2V5LCB7IGNvbXByZXNzZWQgfSkucHVibGljS2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gQnVmZmVyIDMyIGJ5dGVzIGluIHN0YW5kYXJkIGxpYnNlY3AyNTZrMSBmb3JtYXRcbiAgICovXG4gIGdldFByaXZhdGVLZXkoKTogQnVmZmVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5rZXlQYWlyLnByaXZhdGVLZXk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBIaWVyYXJjaGljYWwgRGV0ZXJtaW5pc3RpYyBub2RlIG9yIGFuIEVDUGFpciBmcm9tIGEgcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgQW4gZXh0ZW5kZWQgb3IgcmF3IHByaXZhdGUga2V5XG4gICAqL1xuICByZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkocHJ2OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoQ3J5cHRvLmlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwcnYpO1xuICAgIH0gZWxzZSBpZiAoQ3J5cHRvLmlzVmFsaWRQcnYocHJ2KSkge1xuICAgICAgLy8gQ2Fubm90IGNyZWF0ZSB0aGUgSEQgbm9kZSB3aXRob3V0IHRoZSBjaGFpbiBjb2RlLCBzbyBjcmVhdGUgYSByZWd1bGFyIEtleSBDaGFpblxuICAgICAgdGhpcy5rZXlQYWlyID0gRUNQYWlyLmZyb21Qcml2YXRlS2V5KEJ1ZmZlci5mcm9tKHBydiwgJ2hleCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIEhpZXJhcmNoaWNhbCBEZXRlcm1pbmlzdGljIG5vZGUgb3IgYW4gRUNQYWlyIGZyb20gYSBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHViIC0gQW4gZXh0ZW5kZWQsIGNvbXByZXNzZWQsIG9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAqL1xuICByZWNvcmRLZXlzRnJvbVB1YmxpY0tleShwdWI6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChDcnlwdG8uaXNWYWxpZFhwdWIocHViKSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KHB1Yik7XG4gICAgfSBlbHNlIGlmIChDcnlwdG8uaXNWYWxpZFB1YihwdWIpKSB7XG4gICAgICAvLyBDYW5ub3QgY3JlYXRlIGFuIEhEIG5vZGUgd2l0aG91dCB0aGUgY2hhaW4gY29kZSwgc28gY3JlYXRlIGEgcmVndWxhciBLZXkgQ2hhaW5cbiAgICAgIHRoaXMua2V5UGFpciA9IEVDUGFpci5mcm9tUHVibGljS2V5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwdWJsaWMga2V5OiAnICsgcHViKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbmRlZCBwdWJsaWMga2V5LCBhbmQgdGhlIHByaXZhdGUga2V5IGlmIG9uZSBpcyBhdmFpbGFibGUuIFRoaXMgaXMgb25seSBwb3NzaWJsZVxuICAgKiB3aGVuIHRoZSBrZXkgcGFpciB3YXMgY3JlYXRlZCBmcm9tIGEgc2VlZCBvciBleHRlbmRlZCBrZXlzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RXh0ZW5kZWRLZXlzfSBUaGUgRXh0ZW5kZWQga2V5cyBvYmplY3RcbiAgICovXG4gIGdldEV4dGVuZGVkS2V5cygpOiBFeHRlbmRlZEtleXMge1xuICAgIGlmICghdGhpcy5oZE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBleHRlbmRlZCBrZXlzJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdDogRXh0ZW5kZWRLZXlzID0ge1xuICAgICAgeHB1YjogdGhpcy5oZE5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgIH07XG4gICAgLy8gQSBuZXV0ZXJlZCBIRCBub2RlIG1lYW5zIGl0IG9ubHkgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgaW5mb3JtYXRpb25cbiAgICBpZiAoIXRoaXMuaGROb2RlLmlzTmV1dGVyZWQoKSkge1xuICAgICAgcmVzdWx0LnhwcnYgPSB0aGlzLmhkTm9kZS50b0Jhc2U1OCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0QWRkcmVzcyhmb3JtYXQ/OiBBZGRyZXNzRm9ybWF0KTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0QWRkcmVzcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEtleXMoKTogYW55IHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0S2V5cyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIl19