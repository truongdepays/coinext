"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameBaseAddress = exports.getBaseAddress = exports.xpubToSTXPubkey = exports.getAddressVersion = exports.functionArgsToSendParams = exports.stringifyCv = exports.isValidAddressWithPaymentId = exports.normalizeAddress = exports.getAddressDetails = exports.verifySignature = exports.signMessage = exports.getSTXAddressFromPubKeys = exports.unpadMemo = exports.isValidContractFunctionName = exports.isValidContractAddress = exports.isValidMemo = exports.isValidRawTransaction = exports.isValidPrivateKey = exports.isValidPublicKey = exports.isValidTransactionId = exports.isValidAddress = exports.isValidAmount = exports.getTxSenderAddress = exports.removeHexPrefix = exports.bufferToHexPrefixString = void 0;
var querystring = __importStar(require("querystring"));
var url = __importStar(require("url"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var ethereumjs_utils_old_1 = require("ethereumjs-utils-old");
var transactions_1 = require("@stacks/transactions");
var elliptic_1 = require("elliptic");
var _ = __importStar(require("lodash"));
var crypto_1 = require("../../utils/crypto");
var errors_1 = require("../baseCoin/errors");
var _1 = require(".");
var constants_1 = require("./constants");
/**
 * Encodes a buffer as a "0x" prefixed lower-case hex string.
 *
 * @param {Buffer} buff - a buffer with a hexadecimal string
 * @returns {string} - the hexadecimal string prefixed with "0x"
 */
function bufferToHexPrefixString(buff) {
    return ethereumjs_utils_old_1.bufferToHex(buff);
}
exports.bufferToHexPrefixString = bufferToHexPrefixString;
/**
 * Remove the "0x" prefix from the given string, if present.
 *
 * @param {string} hex - a hexadecimal string
 * @returns {string} - the hexadecimal string without a leading "0x"
 */
function removeHexPrefix(hex) {
    return ethereumjs_utils_old_1.stripHexPrefix(hex);
}
exports.removeHexPrefix = removeHexPrefix;
/**
 * Get stacks address from public key hash
 *
 * @param {Buffer} publicKeyHash - hash of public key
 * @param {AddressHashMode} hashMode - hash mode
 * @param {TransactionVersion} transactionVersion - tx version
 * @returns {string} stacks address
 */
function getAddressFromPublicKeyHash(publicKeyHash, hashMode, transactionVersion) {
    if (publicKeyHash.length !== 20) {
        throw new Error('expected 20-byte pubkeyhash');
    }
    var addrVer = transactions_1.addressHashModeToVersion(hashMode, transactionVersion);
    var addr = transactions_1.addressFromVersionHash(addrVer, publicKeyHash.toString('hex'));
    var addrString = transactions_1.addressToString(addr);
    return addrString;
}
/**
 * @param tx
 */
function getTxSenderAddress(tx) {
    if (tx.auth.spendingCondition !== null && tx.auth.spendingCondition !== undefined) {
        var spendingCondition = tx.auth.spendingCondition;
        var txSender = getAddressFromPublicKeyHash(Buffer.from(spendingCondition.signer, 'hex'), spendingCondition.hashMode, tx.version);
        return txSender;
    }
    else
        throw new Error('spendingCondition should not be null');
}
exports.getTxSenderAddress = getTxSenderAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    var bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns whether or not the string is a valid protocol address
 *
 * @param {string} address - the address to be validated
 * @returns {boolean} - the validation result
 */
function isValidAddress(address) {
    return transactions_1.validateStacksAddress(address);
}
exports.isValidAddress = isValidAddress;
/**
 * Returns whether or not the string is a valid protocol transaction id or not.
 *
 * A valid transaction id is a SHA-512/256 hash of a serialized transaction; see
 * the txidFromData function in @stacks/transaction:
 * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/utils.ts#L97
 *
 * @param {string} txId - the transaction id to be validated
 * @returns {boolean} - the validation result
 */
function isValidTransactionId(txId) {
    if (txId.length !== 64 && txId.length !== 66)
        return false;
    var noPrefix = removeHexPrefix(txId);
    if (noPrefix.length !== 64)
        return false;
    return allHexChars(noPrefix);
}
exports.isValidTransactionId = isValidTransactionId;
/**
 * Returns whether or not the string is a valid protocol public key or
 * extended public key.
 *
 * The key format is documented at
 * https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-authorization
 *
 * @param {string} pub - the  public key to be validated
 * @returns {boolean} - the validation result
 */
function isValidPublicKey(pub) {
    if (crypto_1.isValidXpub(pub))
        return true;
    if (pub.length !== 66 && pub.length !== 130)
        return false;
    var firstByte = pub.slice(0, 2);
    // uncompressed public key
    if (pub.length === 130 && firstByte !== '04')
        return false;
    // compressed public key
    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
        return false;
    if (!allHexChars(pub))
        return false;
    // validate the public key
    var secp256k1 = new elliptic_1.ec('secp256k1');
    try {
        var keyPair = secp256k1.keyFromPublic(Buffer.from(pub, 'hex'));
        var result = keyPair.validate().result;
        return result;
    }
    catch (e) {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Returns whether or not the string is a valid protocol private key, or extended
 * private key.
 *
 * The protocol key format is described in the @stacks/transactions npm package, in the
 * createStacksPrivateKey function:
 * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/keys.ts#L125
 *
 * @param {string} prv - the private key (or extended private key) to be validated
 * @returns {boolean} - the validation result
 */
function isValidPrivateKey(prv) {
    if (crypto_1.isValidXprv(prv))
        return true;
    if (prv.length !== 64 && prv.length !== 66)
        return false;
    if (prv.length === 66 && prv.slice(64) !== '01')
        return false;
    return allHexChars(prv);
}
exports.isValidPrivateKey = isValidPrivateKey;
/**
 * Returns whether or not the string is a composed of hex chars only
 *
 * @param {string} maybe - the  string to be validated
 * @returns {boolean} - the validation result
 */
function allHexChars(maybe) {
    return /^([0-9a-f])+$/i.test(maybe);
}
/**
 * Checks if raw transaction can be deserialized
 *
 * @param {unknown} rawTransaction - transaction in raw hex format
 * @returns {boolean} - the validation result
 */
function isValidRawTransaction(rawTransaction) {
    try {
        if (typeof rawTransaction === 'string') {
            transactions_1.deserializeTransaction(transactions_1.BufferReader.fromBuffer(Buffer.from(removeHexPrefix(rawTransaction), 'hex')));
        }
        else {
            return false;
        }
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidRawTransaction = isValidRawTransaction;
/**
 * Returns whether or not the memo string is valid
 *
 * @param {string} memo - the string to be validated
 * @returns {boolean} - the validation result
 */
function isValidMemo(memo) {
    try {
        transactions_1.createMemoString(memo);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidMemo = isValidMemo;
/**
 * Checks for valid contract address
 *
 * @param {string} addr - contract deployer address
 * @param {BitgoStacksNetwork} network - network object
 * @returns {boolean} - the validation result
 */
function isValidContractAddress(addr, network) {
    return addr === network.stakingContractAddress || addr === network.sendmanymemoContractAddress;
}
exports.isValidContractAddress = isValidContractAddress;
/**
 * Check if the name is one of valid contract names
 *
 * @param {string} name - function name
 * @returns {boolean} - validation result
 */
function isValidContractFunctionName(name) {
    return constants_1.VALID_CONTRACT_FUNCTION_NAMES.includes(name);
}
exports.isValidContractFunctionName = isValidContractFunctionName;
/**
 * Unpads a memo string, so it removes nulls.
 *
 * Useful when memo is fill up the length. Result is becomes readable.
 *
 * @param {string} memo - the string to be validated
 * @returns {boolean} - the validation result
 */
function unpadMemo(memo) {
    var end = memo.indexOf('\u0000');
    if (end < 0)
        return memo;
    return memo.slice(0, end);
}
exports.unpadMemo = unpadMemo;
/**
 * Generate a multisig address from multiple STX public keys
 *
 * @param {string[]} pubKeys - list of public keys as strings
 * @param {AddressVersion} addressVersion - MainnetMultiSig, TestnetMultiSig
 * @param {AddressHashMode} addressHashMode - SerializeP2SH
 * @param {number} [signaturesRequired] - number of signatures required, default value its 2
 * @returns {address: string, hash160: string} - a multisig address
 */
function getSTXAddressFromPubKeys(pubKeys, addressVersion, addressHashMode, signaturesRequired) {
    if (addressVersion === void 0) { addressVersion = transactions_1.AddressVersion.MainnetMultiSig; }
    if (addressHashMode === void 0) { addressHashMode = transactions_1.AddressHashMode.SerializeP2SH; }
    if (signaturesRequired === void 0) { signaturesRequired = 2; }
    if (pubKeys.length === 0) {
        throw new Error('Invalid number of public keys');
    }
    if (!pubKeys.every(isValidPublicKey)) {
        throw new Error('Invalid public keys');
    }
    if (signaturesRequired > pubKeys.length) {
        throw new Error('Number of signatures required must be lower or equal to the number of Public Keys');
    }
    var stxPubKeys = pubKeys.map(transactions_1.createStacksPublicKey);
    var address = transactions_1.addressFromPublicKeys(addressVersion, addressHashMode, signaturesRequired, stxPubKeys);
    return { address: transactions_1.addressToString(address), hash160: address.hash160 };
}
exports.getSTXAddressFromPubKeys = getSTXAddressFromPubKeys;
/**
 * signs a string message
 *
 * @param keyPair
 * @param data  - message to be signed
 * @returns signed message string
 */
function signMessage(keyPair, data) {
    var prv = keyPair.getKeys().prv;
    if (prv) {
        return transactions_1.signWithKey(transactions_1.createStacksPrivateKey(prv), data).data;
    }
    else {
        throw new errors_1.SigningError('Missing private key');
    }
}
exports.signMessage = signMessage;
/**
 * Verifies a signed message
 *
 * The signature must be 130 bytes long -- see RECOVERABLE_ECDSA_SIG_LENGTH_BYTES
 * in @stacks/transactions/src/constants.ts
 *
 * @param {string} message - message to verify the signature
 * @param {string} signature - signature to verify
 * @param {string} publicKey - public key as hex string used to verify the signature
 * @returns {boolean} - verification result
 */
function verifySignature(message, signature, publicKey) {
    if (!isValidPublicKey(publicKey))
        return false;
    if (signature.length !== 130)
        return false;
    if (!allHexChars(signature))
        throw new errors_1.UtilsError('Invalid signature input to verifySignature');
    if (_.isEmpty(message))
        throw new errors_1.UtilsError('Cannot verify empty messages');
    // provided publicKey can be compressed or uncompressed
    var keyEncoding = publicKey.length === 66 ? transactions_1.PubKeyEncoding.Compressed : transactions_1.PubKeyEncoding.Uncompressed;
    var messageSig = transactions_1.createMessageSignature(signature);
    var foundKey = transactions_1.publicKeyFromSignature(message, messageSig, keyEncoding);
    return foundKey === publicKey;
}
exports.verifySignature = verifySignature;
/**
 * Process address into address and memo id
 *
 * @param {string} address the address to process
 * @returns {Object} object containing address and memo id
 */
function getAddressDetails(address) {
    var addressDetails = url.parse(address);
    var queryDetails = addressDetails.query ? querystring.parse(addressDetails.query) : {};
    var baseAddress = addressDetails.pathname;
    if (!isValidAddress(baseAddress)) {
        throw new errors_1.UtilsError("invalid address: " + address);
    }
    // address doesn't have a memo id
    if (baseAddress === address) {
        return {
            address: address,
            memoId: undefined,
        };
    }
    if (_.isUndefined(queryDetails.memoId)) {
        // if there are more properties, the query details need to contain the memo id property
        throw new errors_1.UtilsError("invalid address with memo id: " + address);
    }
    var memoId = queryDetails.memoId;
    var intMemoId = parseInt(memoId, 10);
    if (isNaN(intMemoId) || intMemoId < 0) {
        throw new Error("invalid memo id: " + memoId);
    }
    return {
        address: baseAddress,
        memoId: memoId,
    };
}
exports.getAddressDetails = getAddressDetails;
/**
 * Validate and return address with appended memo id
 *
 * @param {AddressDetails} addressDetails
 * @returns {string} address with memo id
 */
function normalizeAddress(_a) {
    var address = _a.address, memoId = _a.memoId;
    if (!isValidAddress(address)) {
        throw new errors_1.UtilsError("invalid address: " + address);
    }
    if (!_.isUndefined(memoId)) {
        var intMemoId = parseInt(memoId, 10);
        if (isNaN(intMemoId) || intMemoId < 0) {
            throw new Error("invalid memo id: " + memoId);
        }
        return address + "?memoId=" + memoId;
    }
    return address;
}
exports.normalizeAddress = normalizeAddress;
/**
 * Return boolean indicating whether input is a valid address with memo id
 *
 * @param {string} address address in the form <address>?memoId=<memoId>
 * @returns {boolean} true is input is a valid address
 */
function isValidAddressWithPaymentId(address) {
    try {
        var addressDetails = getAddressDetails(address);
        return address === normalizeAddress(addressDetails);
    }
    catch (e) {
        return false;
    }
}
exports.isValidAddressWithPaymentId = isValidAddressWithPaymentId;
/**
 * Return string representation of clarity value input
 *
 * @param {ClarityValue} cv clarity value function argument
 * @returns {String} stringified clarity value
 */
function stringifyCv(cv) {
    switch (cv.type) {
        case transactions_1.ClarityType.Int:
        case transactions_1.ClarityType.UInt:
            return { type: cv.type, value: cv.value.toString() };
        case transactions_1.ClarityType.OptionalSome:
            return { type: cv.type, value: stringifyCv(cv.value) };
        case transactions_1.ClarityType.Tuple:
            return {
                type: cv.type,
                data: _.mapValues(cv.data, function (value) { return stringifyCv(value); }),
            };
        case transactions_1.ClarityType.List:
            return {
                type: cv.type,
                list: cv.list.map(stringifyCv),
            };
        default:
            return cv;
    }
}
exports.stringifyCv = stringifyCv;
/**
 * Parse functionArgs into send params for send-many-memo contract calls
 *
 * @param {ClarityValue[]} args functionArgs from a contract call payload
 * @returns {SendParams[]} An array of sendParams
 */
function functionArgsToSendParams(args) {
    if (args.length !== 1 || args[0].type !== transactions_1.ClarityType.List) {
        throw new errors_1.InvalidTransactionError("function args don't match send-many-memo type declaration");
    }
    return args[0].list.map(function (tuple) {
        var _a, _b, _c;
        if (tuple.type !== transactions_1.ClarityType.Tuple ||
            ((_a = tuple.data.to) === null || _a === void 0 ? void 0 : _a.type) !== transactions_1.ClarityType.PrincipalStandard ||
            ((_b = tuple.data.ustx) === null || _b === void 0 ? void 0 : _b.type) !== transactions_1.ClarityType.UInt ||
            ((_c = tuple.data.memo) === null || _c === void 0 ? void 0 : _c.type) !== transactions_1.ClarityType.Buffer) {
            throw new errors_1.InvalidTransactionError("function args don't match send-many-memo type declaration");
        }
        return {
            address: transactions_1.cvToString(tuple.data.to),
            amount: transactions_1.cvToValue(tuple.data.ustx, true),
            memo: tuple.data.memo.buffer.toString('ascii'),
        };
    });
}
exports.functionArgsToSendParams = functionArgsToSendParams;
/**
 * Gets the version of an address
 *
 * @param {String} address the address with or without the memoId
 * @returns {AddressVersion} A number that represent the Address Version
 */
function getAddressVersion(address) {
    var baseAddress = getAddressDetails(address).address;
    return transactions_1.createAddress(baseAddress).version;
}
exports.getAddressVersion = getAddressVersion;
/**
 * Returns a STX pub key from an xpub
 *
 * @param {String} xpub an xpub
 * @returns {String} a compressed STX pub key
 */
function xpubToSTXPubkey(xpub, compressed) {
    if (compressed === void 0) { compressed = true; }
    return new _1.KeyPair({ pub: xpub }).getKeys(compressed).pub;
}
exports.xpubToSTXPubkey = xpubToSTXPubkey;
/**
 * Returns the base address portion of an address
 *
 * @param {String} address - an address
 * @returns {String} - the base address
 */
function getBaseAddress(address) {
    var addressDetails = getAddressDetails(address);
    return addressDetails.address;
}
exports.getBaseAddress = getBaseAddress;
/**
 * Compares an address to the base address to check if matchs.
 *
 * @param {String} address - an address
 * @param {String} baseAddress - a base address
 * @returns {boolean}
 */
function isSameBaseAddress(address, baseAddress) {
    if (!isValidAddressWithPaymentId(address)) {
        throw new errors_1.UtilsError("invalid address: " + address);
    }
    return getBaseAddress(address) === getBaseAddress(baseAddress);
}
exports.isSameBaseAddress = isSameBaseAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9zdHgvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHVEQUEyQztBQUMzQyx1Q0FBMkI7QUFDM0IsOERBQXFDO0FBQ3JDLDZEQUFtRTtBQUNuRSxxREF3QjhCO0FBQzlCLHFDQUE4QjtBQUM5Qix3Q0FBNEI7QUFDNUIsNkNBQThEO0FBQzlELDZDQUF1RjtBQUV2RixzQkFBNEI7QUFFNUIseUNBQTREO0FBRTVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQUMsSUFBWTtJQUNsRCxPQUFPLGtDQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQUZELDBEQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixlQUFlLENBQUMsR0FBVztJQUN6QyxPQUFPLHFDQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUZELDBDQUVDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQVMsMkJBQTJCLENBQ2xDLGFBQXFCLEVBQ3JCLFFBQXlCLEVBQ3pCLGtCQUFzQztJQUV0QyxJQUFJLGFBQWEsQ0FBQyxNQUFNLEtBQUssRUFBRSxFQUFFO1FBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztLQUNoRDtJQUVELElBQU0sT0FBTyxHQUFHLHVDQUF3QixDQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3ZFLElBQU0sSUFBSSxHQUFHLHFDQUFzQixDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDNUUsSUFBTSxVQUFVLEdBQUcsOEJBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxFQUFxQjtJQUN0RCxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEtBQUssU0FBUyxFQUFFO1FBQ2pGLElBQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztRQUNwRCxJQUFNLFFBQVEsR0FBRywyQkFBMkIsQ0FDMUMsTUFBTSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQzVDLGlCQUFpQixDQUFDLFFBQWtCLEVBQ3BDLEVBQUUsQ0FBQyxPQUFPLENBQ1gsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDO0tBQ2pCOztRQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBVkQsZ0RBVUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGFBQWEsQ0FBQyxNQUFjO0lBQzFDLElBQU0sZUFBZSxHQUFHLElBQUksc0JBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxPQUFPLGVBQWUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxlQUFlLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEYsQ0FBQztBQUhELHNDQUdDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixjQUFjLENBQUMsT0FBZTtJQUM1QyxPQUFPLG9DQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFGRCx3Q0FFQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLElBQVk7SUFDL0MsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLEVBQUU7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUMzRCxJQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEVBQUU7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUV6QyxPQUFPLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBTkQsb0RBTUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxHQUFXO0lBQzFDLElBQUksb0JBQVcsQ0FBQyxHQUFHLENBQUM7UUFBRSxPQUFPLElBQUksQ0FBQztJQUVsQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssRUFBRSxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRztRQUFFLE9BQU8sS0FBSyxDQUFDO0lBRTFELElBQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRWxDLDBCQUEwQjtJQUMxQixJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRyxJQUFJLFNBQVMsS0FBSyxJQUFJO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFFM0Qsd0JBQXdCO0lBQ3hCLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxFQUFFLElBQUksU0FBUyxLQUFLLElBQUksSUFBSSxTQUFTLEtBQUssSUFBSTtRQUFFLE9BQU8sS0FBSyxDQUFDO0lBRWhGLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFFcEMsMEJBQTBCO0lBQzFCLElBQU0sU0FBUyxHQUFHLElBQUksYUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLElBQUk7UUFDRixJQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDekQsSUFBQSxNQUFNLEdBQUssT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUF2QixDQUF3QjtRQUN0QyxPQUFPLE1BQU0sQ0FBQztLQUNmO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQXhCRCw0Q0F3QkM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsR0FBVztJQUMzQyxJQUFJLG9CQUFXLENBQUMsR0FBRyxDQUFDO1FBQUUsT0FBTyxJQUFJLENBQUM7SUFFbEMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEVBQUUsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEVBQUU7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUV6RCxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssRUFBRSxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssSUFBSTtRQUFFLE9BQU8sS0FBSyxDQUFDO0lBRTlELE9BQU8sV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLENBQUM7QUFSRCw4Q0FRQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxXQUFXLENBQUMsS0FBYTtJQUNoQyxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0QyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxjQUF1QjtJQUMzRCxJQUFJO1FBQ0YsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7WUFDdEMscUNBQXNCLENBQUMsMkJBQVksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsY0FBYyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RHO2FBQU07WUFDTCxPQUFPLEtBQUssQ0FBQztTQUNkO0tBQ0Y7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFaRCxzREFZQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsV0FBVyxDQUFDLElBQVk7SUFDdEMsSUFBSTtRQUNGLCtCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3hCO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBUkQsa0NBUUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixzQkFBc0IsQ0FBQyxJQUFZLEVBQUUsT0FBMkI7SUFDOUUsT0FBTyxJQUFJLEtBQUssT0FBTyxDQUFDLHNCQUFzQixJQUFJLElBQUksS0FBSyxPQUFPLENBQUMsMkJBQTJCLENBQUM7QUFDakcsQ0FBQztBQUZELHdEQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQiwyQkFBMkIsQ0FBQyxJQUFZO0lBQ3RELE9BQU8seUNBQTZCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RELENBQUM7QUFGRCxrRUFFQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixTQUFTLENBQUMsSUFBWTtJQUNwQyxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ25DLElBQUksR0FBRyxHQUFHLENBQUM7UUFBRSxPQUFPLElBQUksQ0FBQztJQUN6QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLENBQUM7QUFKRCw4QkFJQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsU0FBZ0Isd0JBQXdCLENBQ3RDLE9BQWlCLEVBQ2pCLGNBQStELEVBQy9ELGVBQWdFLEVBQ2hFLGtCQUFzQjtJQUZ0QiwrQkFBQSxFQUFBLGlCQUFpQyw2QkFBYyxDQUFDLGVBQWU7SUFDL0QsZ0NBQUEsRUFBQSxrQkFBbUMsOEJBQWUsQ0FBQyxhQUFhO0lBQ2hFLG1DQUFBLEVBQUEsc0JBQXNCO0lBRXRCLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0tBQ2xEO0lBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7S0FDeEM7SUFDRCxJQUFJLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7UUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtRkFBbUYsQ0FBQyxDQUFDO0tBQ3RHO0lBRUQsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBcUIsQ0FBQyxDQUFDO0lBQ3RELElBQU0sT0FBTyxHQUFHLG9DQUFxQixDQUFDLGNBQWMsRUFBRSxlQUFlLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFdkcsT0FBTyxFQUFFLE9BQU8sRUFBRSw4QkFBZSxDQUFDLE9BQU8sQ0FBQyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDekUsQ0FBQztBQXBCRCw0REFvQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixXQUFXLENBQUMsT0FBZ0IsRUFBRSxJQUFZO0lBQ3hELElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUFDbEMsSUFBSSxHQUFHLEVBQUU7UUFDUCxPQUFPLDBCQUFXLENBQUMscUNBQXNCLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDO0tBQzVEO1NBQU07UUFDTCxNQUFNLElBQUkscUJBQVksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0tBQy9DO0FBQ0gsQ0FBQztBQVBELGtDQU9DO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxPQUFlLEVBQUUsU0FBaUIsRUFBRSxTQUFpQjtJQUNuRixJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFDL0MsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLEdBQUc7UUFBRSxPQUFPLEtBQUssQ0FBQztJQUMzQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQztRQUFFLE1BQU0sSUFBSSxtQkFBVSxDQUFDLDRDQUE0QyxDQUFDLENBQUM7SUFDaEcsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUFFLE1BQU0sSUFBSSxtQkFBVSxDQUFDLDhCQUE4QixDQUFDLENBQUM7SUFFN0UsdURBQXVEO0lBQ3ZELElBQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyw2QkFBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsNkJBQWMsQ0FBQyxZQUFZLENBQUM7SUFFdEcsSUFBTSxVQUFVLEdBQUcscUNBQXNCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFckQsSUFBTSxRQUFRLEdBQUcscUNBQXNCLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUUxRSxPQUFPLFFBQVEsS0FBSyxTQUFTLENBQUM7QUFDaEMsQ0FBQztBQWRELDBDQWNDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxPQUFlO0lBQy9DLElBQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDMUMsSUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUN6RixJQUFNLFdBQVcsR0FBVyxjQUFjLENBQUMsUUFBUSxDQUFDO0lBQ3BELElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLG1CQUFVLENBQUMsc0JBQW9CLE9BQVMsQ0FBQyxDQUFDO0tBQ3JEO0lBQ0QsaUNBQWlDO0lBQ2pDLElBQUksV0FBVyxLQUFLLE9BQU8sRUFBRTtRQUMzQixPQUFPO1lBQ0wsT0FBTyxFQUFFLE9BQU87WUFDaEIsTUFBTSxFQUFFLFNBQVM7U0FDbEIsQ0FBQztLQUNIO0lBRUQsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUN0Qyx1RkFBdUY7UUFDdkYsTUFBTSxJQUFJLG1CQUFVLENBQUMsbUNBQWlDLE9BQVMsQ0FBQyxDQUFDO0tBQ2xFO0lBQ0QsSUFBTSxNQUFNLEdBQVcsWUFBWSxDQUFDLE1BQU0sQ0FBQztJQUMzQyxJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZDLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7UUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBb0IsTUFBUSxDQUFDLENBQUM7S0FDL0M7SUFFRCxPQUFPO1FBQ0wsT0FBTyxFQUFFLFdBQVc7UUFDcEIsTUFBTSxRQUFBO0tBQ1AsQ0FBQztBQUNKLENBQUM7QUE3QkQsOENBNkJDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxFQUFtQztRQUFqQyxPQUFPLGFBQUEsRUFBRSxNQUFNLFlBQUE7SUFDaEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUM1QixNQUFNLElBQUksbUJBQVUsQ0FBQyxzQkFBb0IsT0FBUyxDQUFDLENBQUM7S0FDckQ7SUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUMxQixJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBb0IsTUFBUSxDQUFDLENBQUM7U0FDL0M7UUFDRCxPQUFVLE9BQU8sZ0JBQVcsTUFBUSxDQUFDO0tBQ3RDO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQVpELDRDQVlDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQiwyQkFBMkIsQ0FBQyxPQUFlO0lBQ3pELElBQUk7UUFDRixJQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsRCxPQUFPLE9BQU8sS0FBSyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNyRDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsT0FBTyxLQUFLLENBQUM7S0FDZDtBQUNILENBQUM7QUFQRCxrRUFPQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsV0FBVyxDQUFDLEVBQWdCO0lBQzFDLFFBQVEsRUFBRSxDQUFDLElBQUksRUFBRTtRQUNmLEtBQUssMEJBQVcsQ0FBQyxHQUFHLENBQUM7UUFDckIsS0FBSywwQkFBVyxDQUFDLElBQUk7WUFDbkIsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUM7UUFDdkQsS0FBSywwQkFBVyxDQUFDLFlBQVk7WUFDM0IsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDekQsS0FBSywwQkFBVyxDQUFDLEtBQUs7WUFDcEIsT0FBTztnQkFDTCxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUk7Z0JBQ2IsSUFBSSxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxVQUFDLEtBQUssSUFBSyxPQUFBLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQzthQUMxRCxDQUFDO1FBQ0osS0FBSywwQkFBVyxDQUFDLElBQUk7WUFDbkIsT0FBTztnQkFDTCxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUk7Z0JBQ2IsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQzthQUMvQixDQUFDO1FBQ0o7WUFDRSxPQUFPLEVBQUUsQ0FBQztLQUNiO0FBQ0gsQ0FBQztBQXBCRCxrQ0FvQkM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLElBQW9CO0lBQzNELElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSywwQkFBVyxDQUFDLElBQUksRUFBRTtRQUMxRCxNQUFNLElBQUksZ0NBQXVCLENBQUMsMkRBQTJELENBQUMsQ0FBQztLQUNoRztJQUNELE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBQyxLQUFLOztRQUM1QixJQUNFLEtBQUssQ0FBQyxJQUFJLEtBQUssMEJBQVcsQ0FBQyxLQUFLO1lBQ2hDLENBQUEsTUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsMENBQUUsSUFBSSxNQUFLLDBCQUFXLENBQUMsaUJBQWlCO1lBQ3JELENBQUEsTUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLDBCQUFXLENBQUMsSUFBSTtZQUMxQyxDQUFBLE1BQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLDBDQUFFLElBQUksTUFBSywwQkFBVyxDQUFDLE1BQU0sRUFDNUM7WUFDQSxNQUFNLElBQUksZ0NBQXVCLENBQUMsMkRBQTJELENBQUMsQ0FBQztTQUNoRztRQUNELE9BQU87WUFDTCxPQUFPLEVBQUUseUJBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUNsQyxNQUFNLEVBQUUsd0JBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7WUFDeEMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO1NBQy9DLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFuQkQsNERBbUJDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxPQUFlO0lBQy9DLElBQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUN2RCxPQUFPLDRCQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQzVDLENBQUM7QUFIRCw4Q0FHQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLElBQVksRUFBRSxVQUFpQjtJQUFqQiwyQkFBQSxFQUFBLGlCQUFpQjtJQUM3RCxPQUFPLElBQUksVUFBTyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUM1RCxDQUFDO0FBRkQsMENBRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGNBQWMsQ0FBQyxPQUFlO0lBQzVDLElBQU0sY0FBYyxHQUFHLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xELE9BQU8sY0FBYyxDQUFDLE9BQU8sQ0FBQztBQUNoQyxDQUFDO0FBSEQsd0NBR0M7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxPQUFlLEVBQUUsV0FBbUI7SUFDcEUsSUFBSSxDQUFDLDJCQUEyQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3pDLE1BQU0sSUFBSSxtQkFBVSxDQUFDLHNCQUFvQixPQUFTLENBQUMsQ0FBQztLQUNyRDtJQUNELE9BQU8sY0FBYyxDQUFDLE9BQU8sQ0FBQyxLQUFLLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBTEQsOENBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGJ1ZmZlclRvSGV4LCBzdHJpcEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbHMtb2xkJztcbmltcG9ydCB7XG4gIGFkZHJlc3NGcm9tUHVibGljS2V5cyxcbiAgYWRkcmVzc0Zyb21WZXJzaW9uSGFzaCxcbiAgQWRkcmVzc0hhc2hNb2RlLFxuICBhZGRyZXNzSGFzaE1vZGVUb1ZlcnNpb24sXG4gIGFkZHJlc3NUb1N0cmluZyxcbiAgQWRkcmVzc1ZlcnNpb24sXG4gIEJ1ZmZlclJlYWRlcixcbiAgQ2xhcml0eVR5cGUsXG4gIENsYXJpdHlWYWx1ZSxcbiAgY3JlYXRlQWRkcmVzcyxcbiAgY3JlYXRlTWVtb1N0cmluZyxcbiAgY3JlYXRlTWVzc2FnZVNpZ25hdHVyZSxcbiAgY3JlYXRlU3RhY2tzUHJpdmF0ZUtleSxcbiAgY3JlYXRlU3RhY2tzUHVibGljS2V5LFxuICBjdlRvU3RyaW5nLFxuICBjdlRvVmFsdWUsXG4gIGRlc2VyaWFsaXplVHJhbnNhY3Rpb24sXG4gIFB1YktleUVuY29kaW5nLFxuICBwdWJsaWNLZXlGcm9tU2lnbmF0dXJlLFxuICBzaWduV2l0aEtleSxcbiAgU3RhY2tzVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uVmVyc2lvbixcbiAgdmFsaWRhdGVTdGFja3NBZGRyZXNzLFxufSBmcm9tICdAc3RhY2tzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgeyBlYyB9IGZyb20gJ2VsbGlwdGljJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGlzVmFsaWRYcHJ2LCBpc1ZhbGlkWHB1YiB9IGZyb20gJy4uLy4uL3V0aWxzL2NyeXB0byc7XG5pbXBvcnQgeyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvciwgU2lnbmluZ0Vycm9yLCBVdGlsc0Vycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IEFkZHJlc3NEZXRhaWxzLCBTZW5kUGFyYW1zIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLic7XG5pbXBvcnQgeyBTdGFja3NOZXR3b3JrIGFzIEJpdGdvU3RhY2tzTmV0d29yayB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IFZBTElEX0NPTlRSQUNUX0ZVTkNUSU9OX05BTUVTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEVuY29kZXMgYSBidWZmZXIgYXMgYSBcIjB4XCIgcHJlZml4ZWQgbG93ZXItY2FzZSBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmIC0gYSBidWZmZXIgd2l0aCBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHByZWZpeGVkIHdpdGggXCIweFwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUb0hleFByZWZpeFN0cmluZyhidWZmOiBCdWZmZXIpOiBzdHJpbmcge1xuICByZXR1cm4gYnVmZmVyVG9IZXgoYnVmZik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBcIjB4XCIgcHJlZml4IGZyb20gdGhlIGdpdmVuIHN0cmluZywgaWYgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4IC0gYSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleGFkZWNpbWFsIHN0cmluZyB3aXRob3V0IGEgbGVhZGluZyBcIjB4XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUhleFByZWZpeChoZXg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpcEhleFByZWZpeChoZXgpO1xufVxuXG4vKipcbiAqIEdldCBzdGFja3MgYWRkcmVzcyBmcm9tIHB1YmxpYyBrZXkgaGFzaFxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlIYXNoIC0gaGFzaCBvZiBwdWJsaWMga2V5XG4gKiBAcGFyYW0ge0FkZHJlc3NIYXNoTW9kZX0gaGFzaE1vZGUgLSBoYXNoIG1vZGVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25WZXJzaW9ufSB0cmFuc2FjdGlvblZlcnNpb24gLSB0eCB2ZXJzaW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdGFja3MgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBnZXRBZGRyZXNzRnJvbVB1YmxpY0tleUhhc2goXG4gIHB1YmxpY0tleUhhc2g6IEJ1ZmZlcixcbiAgaGFzaE1vZGU6IEFkZHJlc3NIYXNoTW9kZSxcbiAgdHJhbnNhY3Rpb25WZXJzaW9uOiBUcmFuc2FjdGlvblZlcnNpb24sXG4pOiBzdHJpbmcge1xuICBpZiAocHVibGljS2V5SGFzaC5sZW5ndGggIT09IDIwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAyMC1ieXRlIHB1YmtleWhhc2gnKTtcbiAgfVxuXG4gIGNvbnN0IGFkZHJWZXIgPSBhZGRyZXNzSGFzaE1vZGVUb1ZlcnNpb24oaGFzaE1vZGUsIHRyYW5zYWN0aW9uVmVyc2lvbik7XG4gIGNvbnN0IGFkZHIgPSBhZGRyZXNzRnJvbVZlcnNpb25IYXNoKGFkZHJWZXIsIHB1YmxpY0tleUhhc2gudG9TdHJpbmcoJ2hleCcpKTtcbiAgY29uc3QgYWRkclN0cmluZyA9IGFkZHJlc3NUb1N0cmluZyhhZGRyKTtcbiAgcmV0dXJuIGFkZHJTdHJpbmc7XG59XG5cbi8qKlxuICogQHBhcmFtIHR4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeFNlbmRlckFkZHJlc3ModHg6IFN0YWNrc1RyYW5zYWN0aW9uKTogc3RyaW5nIHtcbiAgaWYgKHR4LmF1dGguc3BlbmRpbmdDb25kaXRpb24gIT09IG51bGwgJiYgdHguYXV0aC5zcGVuZGluZ0NvbmRpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc3BlbmRpbmdDb25kaXRpb24gPSB0eC5hdXRoLnNwZW5kaW5nQ29uZGl0aW9uO1xuICAgIGNvbnN0IHR4U2VuZGVyID0gZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXlIYXNoKFxuICAgICAgQnVmZmVyLmZyb20oc3BlbmRpbmdDb25kaXRpb24uc2lnbmVyLCAnaGV4JyksXG4gICAgICBzcGVuZGluZ0NvbmRpdGlvbi5oYXNoTW9kZSBhcyBudW1iZXIsXG4gICAgICB0eC52ZXJzaW9uLFxuICAgICk7XG4gICAgcmV0dXJuIHR4U2VuZGVyO1xuICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdzcGVuZGluZ0NvbmRpdGlvbiBzaG91bGQgbm90IGJlIG51bGwnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBhbW91bnQgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEFtb3VudChhbW91bnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBiaWdOdW1iZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XG4gIHJldHVybiBiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgJiYgYmlnTnVtYmVyQW1vdW50LmlzR3JlYXRlclRoYW5PckVxdWFsVG8oMCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgcHJvdG9jb2wgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsaWRhdGVTdGFja3NBZGRyZXNzKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHRyYW5zYWN0aW9uIGlkIG9yIG5vdC5cbiAqXG4gKiBBIHZhbGlkIHRyYW5zYWN0aW9uIGlkIGlzIGEgU0hBLTUxMi8yNTYgaGFzaCBvZiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb247IHNlZVxuICogdGhlIHR4aWRGcm9tRGF0YSBmdW5jdGlvbiBpbiBAc3RhY2tzL3RyYW5zYWN0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Jsb2Nrc3RhY2svc3RhY2tzLmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3RyYW5zYWN0aW9ucy9zcmMvdXRpbHMudHMjTDk3XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR4SWQgLSB0aGUgdHJhbnNhY3Rpb24gaWQgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUcmFuc2FjdGlvbklkKHR4SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodHhJZC5sZW5ndGggIT09IDY0ICYmIHR4SWQubGVuZ3RoICE9PSA2NikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub1ByZWZpeCA9IHJlbW92ZUhleFByZWZpeCh0eElkKTtcbiAgaWYgKG5vUHJlZml4Lmxlbmd0aCAhPT0gNjQpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gYWxsSGV4Q2hhcnMobm9QcmVmaXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHB1YmxpYyBrZXkgb3JcbiAqIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gKlxuICogVGhlIGtleSBmb3JtYXQgaXMgZG9jdW1lbnRlZCBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N0YWNrc2dvdi9zaXBzL2Jsb2IvbWFpbi9zaXBzL3NpcC0wMDUvc2lwLTAwNS1ibG9ja3MtYW5kLXRyYW5zYWN0aW9ucy5tZCN0cmFuc2FjdGlvbi1hdXRob3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YiAtIHRoZSAgcHVibGljIGtleSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoaXNWYWxpZFhwdWIocHViKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHB1Yi5sZW5ndGggIT09IDY2ICYmIHB1Yi5sZW5ndGggIT09IDEzMCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGZpcnN0Qnl0ZSA9IHB1Yi5zbGljZSgwLCAyKTtcblxuICAvLyB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICBpZiAocHViLmxlbmd0aCA9PT0gMTMwICYmIGZpcnN0Qnl0ZSAhPT0gJzA0JykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNvbXByZXNzZWQgcHVibGljIGtleVxuICBpZiAocHViLmxlbmd0aCA9PT0gNjYgJiYgZmlyc3RCeXRlICE9PSAnMDInICYmIGZpcnN0Qnl0ZSAhPT0gJzAzJykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghYWxsSGV4Q2hhcnMocHViKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHZhbGlkYXRlIHRoZSBwdWJsaWMga2V5XG4gIGNvbnN0IHNlY3AyNTZrMSA9IG5ldyBlYygnc2VjcDI1NmsxJyk7XG4gIHRyeSB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlY3AyNTZrMS5rZXlGcm9tUHVibGljKEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0ga2V5UGFpci52YWxpZGF0ZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBwcm90b2NvbCBwcml2YXRlIGtleSwgb3IgZXh0ZW5kZWRcbiAqIHByaXZhdGUga2V5LlxuICpcbiAqIFRoZSBwcm90b2NvbCBrZXkgZm9ybWF0IGlzIGRlc2NyaWJlZCBpbiB0aGUgQHN0YWNrcy90cmFuc2FjdGlvbnMgbnBtIHBhY2thZ2UsIGluIHRoZVxuICogY3JlYXRlU3RhY2tzUHJpdmF0ZUtleSBmdW5jdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibG9ja3N0YWNrL3N0YWNrcy5qcy9ibG9iL21hc3Rlci9wYWNrYWdlcy90cmFuc2FjdGlvbnMvc3JjL2tleXMudHMjTDEyNVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgKG9yIGV4dGVuZGVkIHByaXZhdGUga2V5KSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKGlzVmFsaWRYcHJ2KHBydikpIHJldHVybiB0cnVlO1xuXG4gIGlmIChwcnYubGVuZ3RoICE9PSA2NCAmJiBwcnYubGVuZ3RoICE9PSA2NikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChwcnYubGVuZ3RoID09PSA2NiAmJiBwcnYuc2xpY2UoNjQpICE9PSAnMDEnKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGFsbEhleENoYXJzKHBydik7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgY29tcG9zZWQgb2YgaGV4IGNoYXJzIG9ubHlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF5YmUgLSB0aGUgIHN0cmluZyB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhbGxIZXhDaGFycyhtYXliZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAvXihbMC05YS1mXSkrJC9pLnRlc3QobWF5YmUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiByYXcgdHJhbnNhY3Rpb24gY2FuIGJlIGRlc2VyaWFsaXplZFxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gcmF3VHJhbnNhY3Rpb24gLSB0cmFuc2FjdGlvbiBpbiByYXcgaGV4IGZvcm1hdFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IHVua25vd24pOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHJhd1RyYW5zYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgZGVzZXJpYWxpemVUcmFuc2FjdGlvbihCdWZmZXJSZWFkZXIuZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShyZW1vdmVIZXhQcmVmaXgocmF3VHJhbnNhY3Rpb24pLCAnaGV4JykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1lbW8gc3RyaW5nIGlzIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lbW8gLSB0aGUgc3RyaW5nIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWVtbyhtZW1vOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjcmVhdGVNZW1vU3RyaW5nKG1lbW8pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGZvciB2YWxpZCBjb250cmFjdCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSBjb250cmFjdCBkZXBsb3llciBhZGRyZXNzXG4gKiBAcGFyYW0ge0JpdGdvU3RhY2tzTmV0d29ya30gbmV0d29yayAtIG5ldHdvcmsgb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDb250cmFjdEFkZHJlc3MoYWRkcjogc3RyaW5nLCBuZXR3b3JrOiBCaXRnb1N0YWNrc05ldHdvcmspOiBib29sZWFuIHtcbiAgcmV0dXJuIGFkZHIgPT09IG5ldHdvcmsuc3Rha2luZ0NvbnRyYWN0QWRkcmVzcyB8fCBhZGRyID09PSBuZXR3b3JrLnNlbmRtYW55bWVtb0NvbnRyYWN0QWRkcmVzcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbmFtZSBpcyBvbmUgb2YgdmFsaWQgY29udHJhY3QgbmFtZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGZ1bmN0aW9uIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQ29udHJhY3RGdW5jdGlvbk5hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBWQUxJRF9DT05UUkFDVF9GVU5DVElPTl9OQU1FUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBVbnBhZHMgYSBtZW1vIHN0cmluZywgc28gaXQgcmVtb3ZlcyBudWxscy5cbiAqXG4gKiBVc2VmdWwgd2hlbiBtZW1vIGlzIGZpbGwgdXAgdGhlIGxlbmd0aC4gUmVzdWx0IGlzIGJlY29tZXMgcmVhZGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lbW8gLSB0aGUgc3RyaW5nIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhZE1lbW8obWVtbzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZW5kID0gbWVtby5pbmRleE9mKCdcXHUwMDAwJyk7XG4gIGlmIChlbmQgPCAwKSByZXR1cm4gbWVtbztcbiAgcmV0dXJuIG1lbW8uc2xpY2UoMCwgZW5kKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG11bHRpc2lnIGFkZHJlc3MgZnJvbSBtdWx0aXBsZSBTVFggcHVibGljIGtleXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwdWJLZXlzIC0gbGlzdCBvZiBwdWJsaWMga2V5cyBhcyBzdHJpbmdzXG4gKiBAcGFyYW0ge0FkZHJlc3NWZXJzaW9ufSBhZGRyZXNzVmVyc2lvbiAtIE1haW5uZXRNdWx0aVNpZywgVGVzdG5ldE11bHRpU2lnXG4gKiBAcGFyYW0ge0FkZHJlc3NIYXNoTW9kZX0gYWRkcmVzc0hhc2hNb2RlIC0gU2VyaWFsaXplUDJTSFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWduYXR1cmVzUmVxdWlyZWRdIC0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQsIGRlZmF1bHQgdmFsdWUgaXRzIDJcbiAqIEByZXR1cm5zIHthZGRyZXNzOiBzdHJpbmcsIGhhc2gxNjA6IHN0cmluZ30gLSBhIG11bHRpc2lnIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNUWEFkZHJlc3NGcm9tUHViS2V5cyhcbiAgcHViS2V5czogc3RyaW5nW10sXG4gIGFkZHJlc3NWZXJzaW9uOiBBZGRyZXNzVmVyc2lvbiA9IEFkZHJlc3NWZXJzaW9uLk1haW5uZXRNdWx0aVNpZyxcbiAgYWRkcmVzc0hhc2hNb2RlOiBBZGRyZXNzSGFzaE1vZGUgPSBBZGRyZXNzSGFzaE1vZGUuU2VyaWFsaXplUDJTSCxcbiAgc2lnbmF0dXJlc1JlcXVpcmVkID0gMixcbik6IHsgYWRkcmVzczogc3RyaW5nOyBoYXNoMTYwOiBzdHJpbmcgfSB7XG4gIGlmIChwdWJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgcHVibGljIGtleXMnKTtcbiAgfVxuICBpZiAoIXB1YktleXMuZXZlcnkoaXNWYWxpZFB1YmxpY0tleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleXMnKTtcbiAgfVxuICBpZiAoc2lnbmF0dXJlc1JlcXVpcmVkID4gcHViS2V5cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIG11c3QgYmUgbG93ZXIgb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBQdWJsaWMgS2V5cycpO1xuICB9XG5cbiAgY29uc3Qgc3R4UHViS2V5cyA9IHB1YktleXMubWFwKGNyZWF0ZVN0YWNrc1B1YmxpY0tleSk7XG4gIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzRnJvbVB1YmxpY0tleXMoYWRkcmVzc1ZlcnNpb24sIGFkZHJlc3NIYXNoTW9kZSwgc2lnbmF0dXJlc1JlcXVpcmVkLCBzdHhQdWJLZXlzKTtcblxuICByZXR1cm4geyBhZGRyZXNzOiBhZGRyZXNzVG9TdHJpbmcoYWRkcmVzcyksIGhhc2gxNjA6IGFkZHJlc3MuaGFzaDE2MCB9O1xufVxuXG4vKipcbiAqIHNpZ25zIGEgc3RyaW5nIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0ga2V5UGFpclxuICogQHBhcmFtIGRhdGEgIC0gbWVzc2FnZSB0byBiZSBzaWduZWRcbiAqIEByZXR1cm5zIHNpZ25lZCBtZXNzYWdlIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbk1lc3NhZ2Uoa2V5UGFpcjogS2V5UGFpciwgZGF0YTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgcHJ2ID0ga2V5UGFpci5nZXRLZXlzKCkucHJ2O1xuICBpZiAocHJ2KSB7XG4gICAgcmV0dXJuIHNpZ25XaXRoS2V5KGNyZWF0ZVN0YWNrc1ByaXZhdGVLZXkocHJ2KSwgZGF0YSkuZGF0YTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJpZmllcyBhIHNpZ25lZCBtZXNzYWdlXG4gKlxuICogVGhlIHNpZ25hdHVyZSBtdXN0IGJlIDEzMCBieXRlcyBsb25nIC0tIHNlZSBSRUNPVkVSQUJMRV9FQ0RTQV9TSUdfTEVOR1RIX0JZVEVTXG4gKiBpbiBAc3RhY2tzL3RyYW5zYWN0aW9ucy9zcmMvY29uc3RhbnRzLnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBtZXNzYWdlIHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gc2lnbmF0dXJlIHRvIHZlcmlmeVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleSAtIHB1YmxpYyBrZXkgYXMgaGV4IHN0cmluZyB1c2VkIHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB2ZXJpZmljYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUobWVzc2FnZTogc3RyaW5nLCBzaWduYXR1cmU6IHN0cmluZywgcHVibGljS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCFpc1ZhbGlkUHVibGljS2V5KHB1YmxpY0tleSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWFsbEhleENoYXJzKHNpZ25hdHVyZSkpIHRocm93IG5ldyBVdGlsc0Vycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnB1dCB0byB2ZXJpZnlTaWduYXR1cmUnKTtcbiAgaWYgKF8uaXNFbXB0eShtZXNzYWdlKSkgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0Nhbm5vdCB2ZXJpZnkgZW1wdHkgbWVzc2FnZXMnKTtcblxuICAvLyBwcm92aWRlZCBwdWJsaWNLZXkgY2FuIGJlIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkXG4gIGNvbnN0IGtleUVuY29kaW5nID0gcHVibGljS2V5Lmxlbmd0aCA9PT0gNjYgPyBQdWJLZXlFbmNvZGluZy5Db21wcmVzc2VkIDogUHViS2V5RW5jb2RpbmcuVW5jb21wcmVzc2VkO1xuXG4gIGNvbnN0IG1lc3NhZ2VTaWcgPSBjcmVhdGVNZXNzYWdlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG5cbiAgY29uc3QgZm91bmRLZXkgPSBwdWJsaWNLZXlGcm9tU2lnbmF0dXJlKG1lc3NhZ2UsIG1lc3NhZ2VTaWcsIGtleUVuY29kaW5nKTtcblxuICByZXR1cm4gZm91bmRLZXkgPT09IHB1YmxpY0tleTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgdGhlIGFkZHJlc3MgdG8gcHJvY2Vzc1xuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgYWRkcmVzcyBhbmQgbWVtbyBpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzczogc3RyaW5nKTogQWRkcmVzc0RldGFpbHMge1xuICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHVybC5wYXJzZShhZGRyZXNzKTtcbiAgY29uc3QgcXVlcnlEZXRhaWxzID0gYWRkcmVzc0RldGFpbHMucXVlcnkgPyBxdWVyeXN0cmluZy5wYXJzZShhZGRyZXNzRGV0YWlscy5xdWVyeSkgOiB7fTtcbiAgY29uc3QgYmFzZUFkZHJlc3MgPSA8c3RyaW5nPmFkZHJlc3NEZXRhaWxzLnBhdGhuYW1lO1xuICBpZiAoIWlzVmFsaWRBZGRyZXNzKGJhc2VBZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgfVxuICAvLyBhZGRyZXNzIGRvZXNuJ3QgaGF2ZSBhIG1lbW8gaWRcbiAgaWYgKGJhc2VBZGRyZXNzID09PSBhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICBtZW1vSWQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQocXVlcnlEZXRhaWxzLm1lbW9JZCkpIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIG1lbW8gaWQgcHJvcGVydHlcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcihgaW52YWxpZCBhZGRyZXNzIHdpdGggbWVtbyBpZDogJHthZGRyZXNzfWApO1xuICB9XG4gIGNvbnN0IG1lbW9JZCA9IDxzdHJpbmc+cXVlcnlEZXRhaWxzLm1lbW9JZDtcbiAgY29uc3QgaW50TWVtb0lkID0gcGFyc2VJbnQobWVtb0lkLCAxMCk7XG4gIGlmIChpc05hTihpbnRNZW1vSWQpIHx8IGludE1lbW9JZCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbWVtbyBpZDogJHttZW1vSWR9YCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkZHJlc3M6IGJhc2VBZGRyZXNzLFxuICAgIG1lbW9JZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbmQgcmV0dXJuIGFkZHJlc3Mgd2l0aCBhcHBlbmRlZCBtZW1vIGlkXG4gKlxuICogQHBhcmFtIHtBZGRyZXNzRGV0YWlsc30gYWRkcmVzc0RldGFpbHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGFkZHJlc3Mgd2l0aCBtZW1vIGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVBZGRyZXNzKHsgYWRkcmVzcywgbWVtb0lkIH06IEFkZHJlc3NEZXRhaWxzKTogc3RyaW5nIHtcbiAgaWYgKCFpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQobWVtb0lkKSkge1xuICAgIGNvbnN0IGludE1lbW9JZCA9IHBhcnNlSW50KG1lbW9JZCwgMTApO1xuICAgIGlmIChpc05hTihpbnRNZW1vSWQpIHx8IGludE1lbW9JZCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBtZW1vIGlkOiAke21lbW9JZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke2FkZHJlc3N9P21lbW9JZD0ke21lbW9JZH1gO1xuICB9XG4gIHJldHVybiBhZGRyZXNzO1xufVxuXG4vKipcbiAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyBhIHZhbGlkIGFkZHJlc3Mgd2l0aCBtZW1vIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgYWRkcmVzcyBpbiB0aGUgZm9ybSA8YWRkcmVzcz4/bWVtb0lkPTxtZW1vSWQ+XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBpbnB1dCBpcyBhIHZhbGlkIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzV2l0aFBheW1lbnRJZChhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgIHJldHVybiBhZGRyZXNzID09PSBub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY2xhcml0eSB2YWx1ZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7Q2xhcml0eVZhbHVlfSBjdiBjbGFyaXR5IHZhbHVlIGZ1bmN0aW9uIGFyZ3VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmdpZmllZCBjbGFyaXR5IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlDdihjdjogQ2xhcml0eVZhbHVlKTogYW55IHtcbiAgc3dpdGNoIChjdi50eXBlKSB7XG4gICAgY2FzZSBDbGFyaXR5VHlwZS5JbnQ6XG4gICAgY2FzZSBDbGFyaXR5VHlwZS5VSW50OlxuICAgICAgcmV0dXJuIHsgdHlwZTogY3YudHlwZSwgdmFsdWU6IGN2LnZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICBjYXNlIENsYXJpdHlUeXBlLk9wdGlvbmFsU29tZTpcbiAgICAgIHJldHVybiB7IHR5cGU6IGN2LnR5cGUsIHZhbHVlOiBzdHJpbmdpZnlDdihjdi52YWx1ZSkgfTtcbiAgICBjYXNlIENsYXJpdHlUeXBlLlR1cGxlOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogY3YudHlwZSxcbiAgICAgICAgZGF0YTogXy5tYXBWYWx1ZXMoY3YuZGF0YSwgKHZhbHVlKSA9PiBzdHJpbmdpZnlDdih2YWx1ZSkpLFxuICAgICAgfTtcbiAgICBjYXNlIENsYXJpdHlUeXBlLkxpc3Q6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBjdi50eXBlLFxuICAgICAgICBsaXN0OiBjdi5saXN0Lm1hcChzdHJpbmdpZnlDdiksXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3Y7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBmdW5jdGlvbkFyZ3MgaW50byBzZW5kIHBhcmFtcyBmb3Igc2VuZC1tYW55LW1lbW8gY29udHJhY3QgY2FsbHNcbiAqXG4gKiBAcGFyYW0ge0NsYXJpdHlWYWx1ZVtdfSBhcmdzIGZ1bmN0aW9uQXJncyBmcm9tIGEgY29udHJhY3QgY2FsbCBwYXlsb2FkXG4gKiBAcmV0dXJucyB7U2VuZFBhcmFtc1tdfSBBbiBhcnJheSBvZiBzZW5kUGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvbkFyZ3NUb1NlbmRQYXJhbXMoYXJnczogQ2xhcml0eVZhbHVlW10pOiBTZW5kUGFyYW1zW10ge1xuICBpZiAoYXJncy5sZW5ndGggIT09IDEgfHwgYXJnc1swXS50eXBlICE9PSBDbGFyaXR5VHlwZS5MaXN0KSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKFwiZnVuY3Rpb24gYXJncyBkb24ndCBtYXRjaCBzZW5kLW1hbnktbWVtbyB0eXBlIGRlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHJldHVybiBhcmdzWzBdLmxpc3QubWFwKCh0dXBsZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHR1cGxlLnR5cGUgIT09IENsYXJpdHlUeXBlLlR1cGxlIHx8XG4gICAgICB0dXBsZS5kYXRhLnRvPy50eXBlICE9PSBDbGFyaXR5VHlwZS5QcmluY2lwYWxTdGFuZGFyZCB8fFxuICAgICAgdHVwbGUuZGF0YS51c3R4Py50eXBlICE9PSBDbGFyaXR5VHlwZS5VSW50IHx8XG4gICAgICB0dXBsZS5kYXRhLm1lbW8/LnR5cGUgIT09IENsYXJpdHlUeXBlLkJ1ZmZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKFwiZnVuY3Rpb24gYXJncyBkb24ndCBtYXRjaCBzZW5kLW1hbnktbWVtbyB0eXBlIGRlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogY3ZUb1N0cmluZyh0dXBsZS5kYXRhLnRvKSxcbiAgICAgIGFtb3VudDogY3ZUb1ZhbHVlKHR1cGxlLmRhdGEudXN0eCwgdHJ1ZSksXG4gICAgICBtZW1vOiB0dXBsZS5kYXRhLm1lbW8uYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScpLFxuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZlcnNpb24gb2YgYW4gYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBhZGRyZXNzIHdpdGggb3Igd2l0aG91dCB0aGUgbWVtb0lkXG4gKiBAcmV0dXJucyB7QWRkcmVzc1ZlcnNpb259IEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50IHRoZSBBZGRyZXNzIFZlcnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3NWZXJzaW9uKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NWZXJzaW9uIHtcbiAgY29uc3QgYmFzZUFkZHJlc3MgPSBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKS5hZGRyZXNzO1xuICByZXR1cm4gY3JlYXRlQWRkcmVzcyhiYXNlQWRkcmVzcykudmVyc2lvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgU1RYIHB1YiBrZXkgZnJvbSBhbiB4cHViXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHhwdWIgYW4geHB1YlxuICogQHJldHVybnMge1N0cmluZ30gYSBjb21wcmVzc2VkIFNUWCBwdWIga2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4cHViVG9TVFhQdWJrZXkoeHB1Yjogc3RyaW5nLCBjb21wcmVzc2VkID0gdHJ1ZSk6IHN0cmluZyB7XG4gIHJldHVybiBuZXcgS2V5UGFpcih7IHB1YjogeHB1YiB9KS5nZXRLZXlzKGNvbXByZXNzZWQpLnB1Yjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIGFkZHJlc3MgcG9ydGlvbiBvZiBhbiBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBhbiBhZGRyZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIHRoZSBiYXNlIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2VBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gIHJldHVybiBhZGRyZXNzRGV0YWlscy5hZGRyZXNzO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIGFuIGFkZHJlc3MgdG8gdGhlIGJhc2UgYWRkcmVzcyB0byBjaGVjayBpZiBtYXRjaHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBhbiBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZUFkZHJlc3MgLSBhIGJhc2UgYWRkcmVzc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhbWVCYXNlQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIGJhc2VBZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCFpc1ZhbGlkQWRkcmVzc1dpdGhQYXltZW50SWQoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gIH1cbiAgcmV0dXJuIGdldEJhc2VBZGRyZXNzKGFkZHJlc3MpID09PSBnZXRCYXNlQWRkcmVzcyhiYXNlQWRkcmVzcyk7XG59XG4iXX0=