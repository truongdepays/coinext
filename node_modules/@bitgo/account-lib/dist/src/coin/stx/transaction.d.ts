import { StacksTransaction } from '@stacks/transactions';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { BaseKey } from '../baseCoin/iface';
import { BaseTransaction, TransactionType } from '../baseCoin';
import { SignatureData, TxData } from './iface';
import { KeyPair } from './keyPair';
export declare class Transaction extends BaseTransaction {
    private _stxTransaction;
    protected _type: TransactionType;
    private _sigHash;
    constructor(_coinConfig: Readonly<CoinConfig>);
    /** @inheritdoc */
    canSign(key: BaseKey): boolean;
    sign(keyPair: KeyPair[] | KeyPair, sigHash?: string): Promise<void>;
    appendOrigin(pubKeyString: string[] | string): Promise<void>;
    signWithSignatures(signature: SignatureData[] | SignatureData, isMultiSig: boolean): Promise<void>;
    get signature(): string[];
    /** @inheritdoc */
    toJson(): TxData;
    private getPayloadData;
    /**
     * Return the length of a transaction.  This is needed to calculate
     * the transaction fee.
     *
     * @returns {number} size in bytes of the serialized transaction
     */
    transactionSize(): number;
    toBroadcastFormat(): string;
    get stxTransaction(): StacksTransaction;
    set stxTransaction(t: StacksTransaction);
    private getNonce;
    /**
     * Sets this transaction payload
     *
     * @param rawTransaction
     */
    fromRawTransaction(rawTransaction: string): void;
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType: TransactionType): void;
    /**
     * Load the input and output data on this transaction using the transaction json
     * if there are outputs.
     */
    loadInputsAndOutputs(): void;
}
//# sourceMappingURL=transaction.d.ts.map