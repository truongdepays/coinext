"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var bn_js_1 = __importDefault(require("bn.js"));
var statics_1 = require("@bitgo/statics");
var transactions_1 = require("@stacks/transactions");
var network_1 = require("@stacks/network");
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var crypto_1 = require("../../utils/crypto");
var transaction_1 = require("./transaction");
var keyPair_1 = require("./keyPair");
var utils_1 = require("./utils");
var constants_1 = require("./constants");
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    function TransactionBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this.getSignature = function (_, index) {
            return _this._signatures.find(function (s) { return s.index === index; });
        };
        _this.getPrivateKey = function (pubKey, _) {
            return _this._multiSignerKeyPairs.find(function (kp) { return kp.getKeys(true).pub === pubKey || kp.getKeys().pub === pubKey; });
        };
        _this._anchorMode = constants_1.ANCHOR_MODE;
        _this._multiSignerKeyPairs = [];
        _this._fromPubKeys = [];
        _this._signatures = [];
        _this._numberSignatures = constants_1.DEFAULT_MULTISIG_SIG_NUMBER;
        _this._network = _coinConfig.network.type === statics_1.NetworkType.MAINNET ? new network_1.StacksMainnet() : new network_1.StacksTestnet();
        _this._transaction = new transaction_1.Transaction(_coinConfig);
        return _this;
    }
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     */
    TransactionBuilder.prototype.initBuilder = function (tx) {
        var _this = this;
        this.transaction = tx;
        // check if it is signed or unsigned tx
        if (tx.stxTransaction.auth.spendingCondition === undefined) {
            throw new errors_1.InvalidTransactionError('spending condition cannot be undefined');
        }
        var txData = tx.toJson();
        this.fee({ fee: txData.fee.toString() });
        this.nonce(txData.nonce);
        var sigHash = tx.stxTransaction.verifyBegin();
        var authType = tx.stxTransaction.auth.authType ? tx.stxTransaction.auth.authType : transactions_1.AuthType.Standard;
        if (transactions_1.isSingleSig(tx.stxTransaction.auth.spendingCondition)) {
            this._numberSignatures = 1;
            if (tx.stxTransaction.auth.spendingCondition.signature.data !== transactions_1.emptyMessageSignature().data) {
                var signature = tx.stxTransaction.auth.spendingCondition.signature;
                sigHash = transactions_1.makeSigHashPreSign(sigHash, authType, new bn_js_1.default(this._fee.fee), new bn_js_1.default(this._nonce));
                this._signatures.push(__assign(__assign({}, signature), { index: 0, sigHash: sigHash }));
                this._fromPubKeys = [transactions_1.publicKeyFromSignature(sigHash, signature)];
            }
        }
        else {
            this._numberSignatures = tx.stxTransaction.auth.spendingCondition.signaturesRequired;
            tx.stxTransaction.auth.spendingCondition.fields.forEach(function (field, index) {
                if (field.contents.type === transactions_1.StacksMessageType.MessageSignature) {
                    var signature = field.contents;
                    var nextVerify = transactions_1.nextVerification(sigHash, authType, new bn_js_1.default(_this._fee.fee), new bn_js_1.default(_this._nonce), transactions_1.PubKeyEncoding.Compressed, // useless param as Compressed is hardcoded in stacks lib
                    signature);
                    sigHash = nextVerify.nextSigHash;
                    _this._signatures.push(__assign(__assign({}, signature), { index: index, sigHash: sigHash }));
                    _this._fromPubKeys.push(nextVerify.pubKey.data.toString('hex'));
                }
                else {
                    _this._fromPubKeys.push(field.contents.data.toString('hex'));
                }
            });
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        var tx = new transaction_1.Transaction(this._coinConfig);
        this.validateRawTransaction(rawTransaction);
        var stackstransaction = transactions_1.deserializeTransaction(transactions_1.BufferReader.fromBuffer(Buffer.from(utils_1.removeHexPrefix(rawTransaction), 'hex')));
        tx.stxTransaction = stackstransaction;
        this.initBuilder(tx);
        return this.transaction;
    };
    // region Base Builder
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            var isMultiSig, index, pubKey, signature, prvKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isMultiSig = this._fromPubKeys.length > 1;
                        this._transaction.stxTransaction.setFee(new bn_js_1.default(this._fee.fee));
                        this._transaction.stxTransaction.setNonce(new bn_js_1.default(this._nonce));
                        index = 0;
                        _a.label = 1;
                    case 1:
                        if (!(index < this._fromPubKeys.length)) return [3 /*break*/, 8];
                        pubKey = this._fromPubKeys[index];
                        signature = this.getSignature(pubKey, index);
                        if (!signature) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.transaction.signWithSignatures(signature, isMultiSig)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 3:
                        prvKey = this.getPrivateKey(pubKey, index);
                        if (!prvKey) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.transaction.sign(prvKey)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        if (!isMultiSig) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.transaction.appendOrigin(pubKey)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        index++;
                        return [3 /*break*/, 1];
                    case 8:
                        this._transaction.loadInputsAndOutputs();
                        return [2 /*return*/, this._transaction];
                }
            });
        });
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        this.checkDuplicatedKeys(key);
        var prv = key.key;
        if (prv.startsWith('xprv')) {
            var rawPrv = crypto_1.xprvToRawPrv(prv);
            prv = new keyPair_1.KeyPair({ prv: rawPrv }).getKeys(true).prv;
        }
        var signer = new keyPair_1.KeyPair({ prv: prv });
        // Signing the transaction is an operation that relies on all the data being set,
        // so we set the source here and leave the actual signing for the build step
        this._multiSignerKeyPairs.push(signer);
        var publicKey = signer.getKeys(signer.getCompressed()).pub;
        if (!this._fromPubKeys.includes(publicKey)) {
            this._fromPubKeys.push(publicKey);
        }
        return this.transaction;
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Validates that the given key is not already in this._multiSignerKeyPairs
     *
     * @param {BaseKey} key - The key to check
     */
    TransactionBuilder.prototype.checkDuplicatedKeys = function (key) {
        this._multiSignerKeyPairs.forEach(function (_sourceKeyPair) {
            if (_sourceKeyPair.getKeys().prv === key.key) {
                throw new errors_1.SigningError('Repeated sign: ' + key.key);
            }
        });
    };
    /**
     * Set the transaction fees
     *
     * @param {BaseFee} fee The maximum gas to pay
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.fee = function (fee) {
        this.validateValue(new bignumber_js_1.default(fee.fee));
        this._fee = fee;
        return this;
    };
    TransactionBuilder.prototype.nonce = function (n) {
        this._nonce = n;
        return this;
    };
    TransactionBuilder.prototype.fromPubKey = function (senderPubKey) {
        var _this = this;
        var pubKeys = senderPubKey instanceof Array ? senderPubKey : [senderPubKey];
        this._fromPubKeys = [];
        pubKeys.forEach(function (key) {
            if (utils_1.isValidPublicKey(key)) {
                _this._fromPubKeys.push(key);
            }
            else {
                throw new errors_1.InvalidParameterValueError('Invalid public key');
            }
        });
        return this;
    };
    /**
     *  Set the memo
     *
     * @param {string} memo
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.memo = function (memo) {
        if (!utils_1.isValidMemo(memo)) {
            throw new errors_1.BuildTransactionError('Memo is too long');
        }
        this._memo = memo;
        return this;
    };
    /**
     *  Set the number of signatures for multi-sig
     *
     * @param {number} numSigns
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.numberSignatures = function (numSigns) {
        this.validateValue(new bignumber_js_1.default(numSigns));
        this._numberSignatures = numSigns;
        return this;
    };
    // region Validators
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address, addressFormat) {
        if (!utils_1.isValidAddress(address.address)) {
            throw new errors_1.BuildTransactionError('Invalid address ' + address.address);
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        var keyPair = new keyPair_1.KeyPair({ prv: key.key });
        if (!keyPair.getKeys().prv) {
            throw new errors_1.BuildTransactionError('Invalid key');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        if (!rawTransaction) {
            throw new errors_1.InvalidTransactionError('Raw transaction is empty');
        }
        try {
            transactions_1.deserializeTransaction(transactions_1.BufferReader.fromBuffer(Buffer.from(utils_1.removeHexPrefix(rawTransaction), 'hex')));
        }
        catch (e) {
            throw new errors_1.ParseTransactionError('There was an error parsing the raw transaction');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        this.validateFee();
        this.validateNonce();
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThan(0)) {
            throw new errors_1.BuildTransactionError('Value cannot be less than zero');
        }
    };
    /**
     * Validates that the fee field is defined
     */
    TransactionBuilder.prototype.validateFee = function () {
        if (this._fee === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing fee');
        }
        try {
            this.validateValue(new bignumber_js_1.default(this._fee.fee));
        }
        catch (e) {
            throw new errors_1.BuildTransactionError('Invalid fee');
        }
    };
    /**
     * Validates that nonce is defined
     */
    TransactionBuilder.prototype.validateNonce = function () {
        if (this._nonce === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing nonce');
        }
        try {
            this.validateValue(new bignumber_js_1.default(this._nonce));
        }
        catch (e) {
            throw new errors_1.BuildTransactionError("Invalid nonce " + this._nonce);
        }
    };
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vc3R4L3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhEQUFxQztBQUNyQyxnREFBMkI7QUFDM0IsMENBQXFFO0FBQ3JFLHFEQVc4QjtBQUM5QiwyQ0FBOEU7QUFDOUUsd0NBQXFEO0FBQ3JELDZDQU00QjtBQUU1Qiw2Q0FBa0Q7QUFDbEQsNkNBQTRDO0FBQzVDLHFDQUFvQztBQUVwQyxpQ0FBeUY7QUFDekYseUNBQXVFO0FBRXZFO0lBQWlELHNDQUFzQjtJQVlyRSw0QkFBWSxXQUFpQztRQUE3QyxZQUNFLGtCQUFNLFdBQVcsQ0FBQyxTQVFuQjtRQXdGTyxrQkFBWSxHQUFHLFVBQUMsQ0FBUyxFQUFFLEtBQWE7WUFDOUMsT0FBQSxLQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFqQixDQUFpQixDQUFDO1FBQS9DLENBQStDLENBQUM7UUFDMUMsbUJBQWEsR0FBRyxVQUFDLE1BQWMsRUFBRSxDQUFTO1lBQ2hELE9BQUEsS0FBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxVQUFDLEVBQUUsSUFBSyxPQUFBLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLE1BQU0sSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxLQUFLLE1BQU0sRUFBOUQsQ0FBOEQsQ0FBQztRQUF0RyxDQUFzRyxDQUFDO1FBbEd2RyxLQUFJLENBQUMsV0FBVyxHQUFHLHVCQUFXLENBQUM7UUFDL0IsS0FBSSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztR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QUFDO1NBQ2hEO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssMENBQWEsR0FBckI7UUFDRSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQzdCLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1NBQ3ZFO1FBQ0QsSUFBSTtZQUNGLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxzQkFBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ2hEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksOEJBQXFCLENBQUMsbUJBQWlCLElBQUksQ0FBQyxNQUFRLENBQUMsQ0FBQztTQUNqRTtJQUNILENBQUM7SUFDSCx5QkFBQztBQUFELENBQUMsQUF6UkQsQ0FBaUQsaUNBQXNCLEdBeVJ0RTtBQXpScUIsZ0RBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IEJpZ051bSBmcm9tICdibi5qcyc7XG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnLCBOZXR3b3JrVHlwZSB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7XG4gIEF1dGhUeXBlLFxuICBCdWZmZXJSZWFkZXIsXG4gIGRlc2VyaWFsaXplVHJhbnNhY3Rpb24sXG4gIGVtcHR5TWVzc2FnZVNpZ25hdHVyZSxcbiAgaXNTaW5nbGVTaWcsXG4gIG1ha2VTaWdIYXNoUHJlU2lnbixcbiAgbmV4dFZlcmlmaWNhdGlvbixcbiAgcHVibGljS2V5RnJvbVNpZ25hdHVyZSxcbiAgU3RhY2tzTWVzc2FnZVR5cGUsXG4gIFB1YktleUVuY29kaW5nLFxufSBmcm9tICdAc3RhY2tzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgeyBTdGFja3NOZXR3b3JrLCBTdGFja3NUZXN0bmV0LCBTdGFja3NNYWlubmV0IH0gZnJvbSAnQHN0YWNrcy9uZXR3b3JrJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQge1xuICBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsXG4gIFBhcnNlVHJhbnNhY3Rpb25FcnJvcixcbiAgU2lnbmluZ0Vycm9yLFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IsXG59IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBCYXNlQWRkcmVzcywgQmFzZUZlZSwgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IHhwcnZUb1Jhd1BydiB9IGZyb20gJy4uLy4uL3V0aWxzL2NyeXB0byc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgeyBTaWduYXR1cmVEYXRhIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBpc1ZhbGlkQWRkcmVzcywgcmVtb3ZlSGV4UHJlZml4LCBpc1ZhbGlkTWVtbywgaXNWYWxpZFB1YmxpY0tleSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgQU5DSE9SX01PREUsIERFRkFVTFRfTVVMVElTSUdfU0lHX05VTUJFUiB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYW5zYWN0aW9uQnVpbGRlciBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcml2YXRlIF90cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247XG4gIHByb3RlY3RlZCBfYW5jaG9yTW9kZTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX2ZlZTogQmFzZUZlZTtcbiAgcHJvdGVjdGVkIF9ub25jZTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX21lbW86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9udW1iZXJTaWduYXR1cmVzOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfbXVsdGlTaWduZXJLZXlQYWlyczogS2V5UGFpcltdO1xuICBwcm90ZWN0ZWQgX3NpZ25hdHVyZXM6IFNpZ25hdHVyZURhdGFbXTtcbiAgcHJvdGVjdGVkIF9uZXR3b3JrOiBTdGFja3NOZXR3b3JrO1xuICBwcm90ZWN0ZWQgX2Zyb21QdWJLZXlzOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gICAgdGhpcy5fYW5jaG9yTW9kZSA9IEFOQ0hPUl9NT0RFO1xuICAgIHRoaXMuX211bHRpU2lnbmVyS2V5UGFpcnMgPSBbXTtcbiAgICB0aGlzLl9mcm9tUHViS2V5cyA9IFtdO1xuICAgIHRoaXMuX3NpZ25hdHVyZXMgPSBbXTtcbiAgICB0aGlzLl9udW1iZXJTaWduYXR1cmVzID0gREVGQVVMVF9NVUxUSVNJR19TSUdfTlVNQkVSO1xuICAgIHRoaXMuX25ldHdvcmsgPSBfY29pbkNvbmZpZy5uZXR3b3JrLnR5cGUgPT09IE5ldHdvcmtUeXBlLk1BSU5ORVQgPyBuZXcgU3RhY2tzTWFpbm5ldCgpIDogbmV3IFN0YWNrc1Rlc3RuZXQoKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gYnVpbGRlciBmaWVsZHMgdXNpbmcgdGhlIGRlY29kZWQgdHJhbnNhY3Rpb24gZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0eCB0aGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHR4O1xuICAgIC8vIGNoZWNrIGlmIGl0IGlzIHNpZ25lZCBvciB1bnNpZ25lZCB0eFxuICAgIGlmICh0eC5zdHhUcmFuc2FjdGlvbi5hdXRoLnNwZW5kaW5nQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignc3BlbmRpbmcgY29uZGl0aW9uIGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3QgdHhEYXRhID0gdHgudG9Kc29uKCk7XG4gICAgdGhpcy5mZWUoeyBmZWU6IHR4RGF0YS5mZWUudG9TdHJpbmcoKSB9KTtcbiAgICB0aGlzLm5vbmNlKHR4RGF0YS5ub25jZSk7XG4gICAgbGV0IHNpZ0hhc2ggPSB0eC5zdHhUcmFuc2FjdGlvbi52ZXJpZnlCZWdpbigpO1xuXG4gICAgY29uc3QgYXV0aFR5cGUgPSB0eC5zdHhUcmFuc2FjdGlvbi5hdXRoLmF1dGhUeXBlID8gdHguc3R4VHJhbnNhY3Rpb24uYXV0aC5hdXRoVHlwZSA6IEF1dGhUeXBlLlN0YW5kYXJkO1xuICAgIGlmIChpc1NpbmdsZVNpZyh0eC5zdHhUcmFuc2FjdGlvbi5hdXRoLnNwZW5kaW5nQ29uZGl0aW9uKSkge1xuICAgICAgdGhpcy5fbnVtYmVyU2lnbmF0dXJlcyA9IDE7XG4gICAgICBpZiAodHguc3R4VHJhbnNhY3Rpb24uYXV0aC5zcGVuZGluZ0NvbmRpdGlvbi5zaWduYXR1cmUuZGF0YSAhPT0gZW1wdHlNZXNzYWdlU2lnbmF0dXJlKCkuZGF0YSkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0eC5zdHhUcmFuc2FjdGlvbi5hdXRoLnNwZW5kaW5nQ29uZGl0aW9uLnNpZ25hdHVyZTtcbiAgICAgICAgc2lnSGFzaCA9IG1ha2VTaWdIYXNoUHJlU2lnbihzaWdIYXNoLCBhdXRoVHlwZSwgbmV3IEJpZ051bSh0aGlzLl9mZWUuZmVlKSwgbmV3IEJpZ051bSh0aGlzLl9ub25jZSkpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2goeyAuLi5zaWduYXR1cmUsIGluZGV4OiAwLCBzaWdIYXNoIH0pO1xuICAgICAgICB0aGlzLl9mcm9tUHViS2V5cyA9IFtwdWJsaWNLZXlGcm9tU2lnbmF0dXJlKHNpZ0hhc2gsIHNpZ25hdHVyZSldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9udW1iZXJTaWduYXR1cmVzID0gdHguc3R4VHJhbnNhY3Rpb24uYXV0aC5zcGVuZGluZ0NvbmRpdGlvbi5zaWduYXR1cmVzUmVxdWlyZWQ7XG4gICAgICB0eC5zdHhUcmFuc2FjdGlvbi5hdXRoLnNwZW5kaW5nQ29uZGl0aW9uLmZpZWxkcy5mb3JFYWNoKChmaWVsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkLmNvbnRlbnRzLnR5cGUgPT09IFN0YWNrc01lc3NhZ2VUeXBlLk1lc3NhZ2VTaWduYXR1cmUpIHtcbiAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBmaWVsZC5jb250ZW50cztcbiAgICAgICAgICBjb25zdCBuZXh0VmVyaWZ5ID0gbmV4dFZlcmlmaWNhdGlvbihcbiAgICAgICAgICAgIHNpZ0hhc2gsXG4gICAgICAgICAgICBhdXRoVHlwZSxcbiAgICAgICAgICAgIG5ldyBCaWdOdW0odGhpcy5fZmVlLmZlZSksXG4gICAgICAgICAgICBuZXcgQmlnTnVtKHRoaXMuX25vbmNlKSxcbiAgICAgICAgICAgIFB1YktleUVuY29kaW5nLkNvbXByZXNzZWQsIC8vIHVzZWxlc3MgcGFyYW0gYXMgQ29tcHJlc3NlZCBpcyBoYXJkY29kZWQgaW4gc3RhY2tzIGxpYlxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2lnSGFzaCA9IG5leHRWZXJpZnkubmV4dFNpZ0hhc2g7XG4gICAgICAgICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHsgLi4uc2lnbmF0dXJlLCBpbmRleCwgc2lnSGFzaCB9KTtcbiAgICAgICAgICB0aGlzLl9mcm9tUHViS2V5cy5wdXNoKG5leHRWZXJpZnkucHViS2V5LmRhdGEudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9mcm9tUHViS2V5cy5wdXNoKGZpZWxkLmNvbnRlbnRzLmRhdGEudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBmcm9tSW1wbGVtZW50YXRpb24ocmF3VHJhbnNhY3Rpb246IHN0cmluZyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnKTtcbiAgICB0aGlzLnZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHN0YWNrc3RyYW5zYWN0aW9uID0gZGVzZXJpYWxpemVUcmFuc2FjdGlvbihcbiAgICAgIEJ1ZmZlclJlYWRlci5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKHJlbW92ZUhleFByZWZpeChyYXdUcmFuc2FjdGlvbiksICdoZXgnKSksXG4gICAgKTtcbiAgICB0eC5zdHhUcmFuc2FjdGlvbiA9IHN0YWNrc3RyYW5zYWN0aW9uO1xuICAgIHRoaXMuaW5pdEJ1aWxkZXIodHgpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLy8gcmVnaW9uIEJhc2UgQnVpbGRlclxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IGlzTXVsdGlTaWc6IGJvb2xlYW4gPSB0aGlzLl9mcm9tUHViS2V5cy5sZW5ndGggPiAxO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLnN0eFRyYW5zYWN0aW9uLnNldEZlZShuZXcgQmlnTnVtKHRoaXMuX2ZlZS5mZWUpKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbi5zdHhUcmFuc2FjdGlvbi5zZXROb25jZShuZXcgQmlnTnVtKHRoaXMuX25vbmNlKSk7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZnJvbVB1YktleXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwdWJLZXkgPSB0aGlzLl9mcm9tUHViS2V5c1tpbmRleF07XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmdldFNpZ25hdHVyZShwdWJLZXksIGluZGV4KTtcbiAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc2FjdGlvbi5zaWduV2l0aFNpZ25hdHVyZXMoc2lnbmF0dXJlLCBpc011bHRpU2lnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBydktleSA9IHRoaXMuZ2V0UHJpdmF0ZUtleShwdWJLZXksIGluZGV4KTtcbiAgICAgICAgaWYgKHBydktleSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNhY3Rpb24uc2lnbihwcnZLZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTXVsdGlTaWcpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uLmFwcGVuZE9yaWdpbihwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhbnNhY3Rpb24ubG9hZElucHV0c0FuZE91dHB1dHMoKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICBwcml2YXRlIGdldFNpZ25hdHVyZSA9IChfOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBTaWduYXR1cmVEYXRhIHwgdW5kZWZpbmVkID0+XG4gICAgdGhpcy5fc2lnbmF0dXJlcy5maW5kKChzKSA9PiBzLmluZGV4ID09PSBpbmRleCk7XG4gIHByaXZhdGUgZ2V0UHJpdmF0ZUtleSA9IChwdWJLZXk6IHN0cmluZywgXzogbnVtYmVyKTogS2V5UGFpciB8IHVuZGVmaW5lZCA9PlxuICAgIHRoaXMuX211bHRpU2lnbmVyS2V5UGFpcnMuZmluZCgoa3ApID0+IGtwLmdldEtleXModHJ1ZSkucHViID09PSBwdWJLZXkgfHwga3AuZ2V0S2V5cygpLnB1YiA9PT0gcHViS2V5KTtcblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIHNpZ25JbXBsZW1lbnRhdGlvbihrZXk6IEJhc2VLZXkpOiBUcmFuc2FjdGlvbiB7XG4gICAgdGhpcy5jaGVja0R1cGxpY2F0ZWRLZXlzKGtleSk7XG4gICAgbGV0IHBydiA9IGtleS5rZXk7XG4gICAgaWYgKHBydi5zdGFydHNXaXRoKCd4cHJ2JykpIHtcbiAgICAgIGNvbnN0IHJhd1BydiA9IHhwcnZUb1Jhd1BydihwcnYpO1xuICAgICAgcHJ2ID0gbmV3IEtleVBhaXIoeyBwcnY6IHJhd1BydiB9KS5nZXRLZXlzKHRydWUpLnBydjtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVyID0gbmV3IEtleVBhaXIoeyBwcnY6IHBydiB9KTtcblxuICAgIC8vIFNpZ25pbmcgdGhlIHRyYW5zYWN0aW9uIGlzIGFuIG9wZXJhdGlvbiB0aGF0IHJlbGllcyBvbiBhbGwgdGhlIGRhdGEgYmVpbmcgc2V0LFxuICAgIC8vIHNvIHdlIHNldCB0aGUgc291cmNlIGhlcmUgYW5kIGxlYXZlIHRoZSBhY3R1YWwgc2lnbmluZyBmb3IgdGhlIGJ1aWxkIHN0ZXBcbiAgICB0aGlzLl9tdWx0aVNpZ25lcktleVBhaXJzLnB1c2goc2lnbmVyKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWduZXIuZ2V0S2V5cyhzaWduZXIuZ2V0Q29tcHJlc3NlZCgpKS5wdWI7XG4gICAgaWYgKCF0aGlzLl9mcm9tUHViS2V5cy5pbmNsdWRlcyhwdWJsaWNLZXkpKSB7XG4gICAgICB0aGlzLl9mcm9tUHViS2V5cy5wdXNoKHB1YmxpY0tleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2V0IHRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIGtleSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzLl9tdWx0aVNpZ25lcktleVBhaXJzXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUtleX0ga2V5IC0gVGhlIGtleSB0byBjaGVja1xuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0R1cGxpY2F0ZWRLZXlzKGtleTogQmFzZUtleSkge1xuICAgIHRoaXMuX211bHRpU2lnbmVyS2V5UGFpcnMuZm9yRWFjaCgoX3NvdXJjZUtleVBhaXIpID0+IHtcbiAgICAgIGlmIChfc291cmNlS2V5UGFpci5nZXRLZXlzKCkucHJ2ID09PSBrZXkua2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ1JlcGVhdGVkIHNpZ246ICcgKyBrZXkua2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlRmVlfSBmZWUgVGhlIG1heGltdW0gZ2FzIHRvIHBheVxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSBUaGlzIHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIGZlZShmZWU6IEJhc2VGZWUpOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcihmZWUuZmVlKSk7XG4gICAgdGhpcy5fZmVlID0gZmVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbm9uY2UobjogbnVtYmVyKTogdGhpcyB7XG4gICAgdGhpcy5fbm9uY2UgPSBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbVB1YktleShzZW5kZXJQdWJLZXk6IHN0cmluZyB8IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgY29uc3QgcHViS2V5cyA9IHNlbmRlclB1YktleSBpbnN0YW5jZW9mIEFycmF5ID8gc2VuZGVyUHViS2V5IDogW3NlbmRlclB1YktleV07XG4gICAgdGhpcy5fZnJvbVB1YktleXMgPSBbXTtcbiAgICBwdWJLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGlzVmFsaWRQdWJsaWNLZXkoa2V5KSkge1xuICAgICAgICB0aGlzLl9mcm9tUHViS2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleScpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqICBTZXQgdGhlIG1lbW9cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lbW9cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBtZW1vKG1lbW86IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICghaXNWYWxpZE1lbW8obWVtbykpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ01lbW8gaXMgdG9vIGxvbmcnKTtcbiAgICB9XG4gICAgdGhpcy5fbWVtbyA9IG1lbW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogIFNldCB0aGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgZm9yIG11bHRpLXNpZ1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtU2lnbnNcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBudW1iZXJTaWduYXR1cmVzKG51bVNpZ25zOiBudW1iZXIpOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcihudW1TaWducykpO1xuICAgIHRoaXMuX251bWJlclNpZ25hdHVyZXMgPSBudW1TaWducztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlZ2lvbiBWYWxpZGF0b3JzXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQmFzZUFkZHJlc3MsIGFkZHJlc3NGb3JtYXQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWlzVmFsaWRBZGRyZXNzKGFkZHJlc3MuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyAnICsgYWRkcmVzcy5hZGRyZXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVLZXkoa2V5OiBCYXNlS2V5KTogdm9pZCB7XG4gICAgY29uc3Qga2V5UGFpciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIGlmICgha2V5UGFpci5nZXRLZXlzKCkucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXJhd1RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1JhdyB0cmFuc2FjdGlvbiBpcyBlbXB0eScpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGVzZXJpYWxpemVUcmFuc2FjdGlvbihCdWZmZXJSZWFkZXIuZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShyZW1vdmVIZXhQcmVmaXgocmF3VHJhbnNhY3Rpb24pLCAnaGV4JykpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgcmF3IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHRoaXMudmFsaWRhdGVGZWUoKTtcbiAgICB0aGlzLnZhbGlkYXRlTm9uY2UoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUuaXNMZXNzVGhhbigwKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVmFsdWUgY2Fubm90IGJlIGxlc3MgdGhhbiB6ZXJvJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBmZWUgZmllbGQgaXMgZGVmaW5lZFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZUZlZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZmVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3NpbmcgZmVlJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcih0aGlzLl9mZWUuZmVlKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBmZWUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgbm9uY2UgaXMgZGVmaW5lZFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZU5vbmNlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIG5vbmNlJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcih0aGlzLl9ub25jZSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgbm9uY2UgJHt0aGlzLl9ub25jZX1gKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==