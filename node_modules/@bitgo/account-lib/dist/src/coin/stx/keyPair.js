"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
var crypto_1 = require("crypto");
var bip32 = __importStar(require("bip32"));
var bitcoinjs_lib_1 = require("bitcoinjs-lib");
var transactions_1 = require("@stacks/transactions");
var iface_1 = require("../baseCoin/iface");
var secp256k1ExtendedKeyPair_1 = require("../baseCoin/secp256k1ExtendedKeyPair");
var crypto_2 = require("../../utils/crypto");
var utils_1 = require("./utils");
var constants_1 = require("./constants");
var KeyPair = /** @class */ (function (_super) {
    __extends(KeyPair, _super);
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    function KeyPair(source) {
        var _this = _super.call(this, source) || this;
        if (!source) {
            var seed = crypto_1.randomBytes(constants_1.DEFAULT_SEED_SIZE_BYTES);
            _this.hdNode = bip32.fromSeed(seed);
        }
        else if (iface_1.isSeed(source)) {
            _this.hdNode = bip32.fromSeed(source.seed);
        }
        else if (iface_1.isPrivateKey(source)) {
            _this.recordKeysFromPrivateKey(source.prv);
        }
        else if (iface_1.isPublicKey(source)) {
            _this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (_this.hdNode) {
            _this.keyPair = secp256k1ExtendedKeyPair_1.Secp256k1ExtendedKeyPair.toKeyPair(_this.hdNode);
        }
        return _this;
    }
    /**
     * Build a keypair from a protocol private key or extended private key.
     *
     * The protocol private key is either 32 or 33 bytes long (64 or 66
     * characters hex).  If it is 32 bytes long, set the keypair's "compressed"
     * field to false to later generate uncompressed public keys (the default).
     * A 33 byte key has 0x01 as the last byte.
     *
     * @param {string} prv A raw private key
     */
    KeyPair.prototype.recordKeysFromPrivateKey = function (prv) {
        if (!utils_1.isValidPrivateKey(prv)) {
            throw new Error('Unsupported private key');
        }
        if (crypto_2.isValidXprv(prv)) {
            this.hdNode = bip32.fromBase58(prv);
        }
        else {
            this.keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(prv.slice(0, 64), 'hex'));
        }
    };
    /**
     * Build an ECPair from a protocol public key or extended public key.
     *
     * The protocol public key is either 32 bytes or 64 bytes long, with a
     * one-byte prefix (a total of 66 or 130 characters in hex).  If the
     * prefix is 0x02 or 0x03, it is a compressed public key.  A prefix of 0x04
     * denotes an uncompressed public key.
     *
     * @param {string} pub A raw public key
     */
    KeyPair.prototype.recordKeysFromPublicKey = function (pub) {
        if (!utils_1.isValidPublicKey(pub)) {
            throw new Error('Unsupported public key');
        }
        if (crypto_2.isValidXpub(pub)) {
            this.hdNode = bip32.fromBase58(pub);
        }
        else {
            this.keyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
        }
    };
    /**
     * Stacks default keys format is raw private and uncompressed public key
     *
     * @param {boolean} compressed - Compress public key (defaults to false)
     * @returns {DefaultKeys} The keys in the protocol default key format
     */
    KeyPair.prototype.getKeys = function (compressed) {
        var _a;
        if (compressed === void 0) { compressed = false; }
        var prv = (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex');
        if (prv && compressed) {
            prv += '01';
        }
        return {
            pub: this.getPublicKey({ compressed: compressed }).toString('hex'),
            prv: prv,
        };
    };
    KeyPair.prototype.getCompressed = function () {
        return this.keyPair.compressed;
    };
    /**
     * Get a public address of an uncompressed public key.
     *
     * @returns {string} The public address
     */
    KeyPair.prototype.getAddress = function () {
        return this.getSTXAddress(false, transactions_1.TransactionVersion.Mainnet);
    };
    /**
     * Get a public address of an uncompressed public key.
     *
     * @param {boolean} compressed - Compress public key (defaults to false)
     * @param {TransactionVersion} network - select Mainnet or Testnet for the address
     * @returns {string} The public address
     */
    KeyPair.prototype.getSTXAddress = function (compressed, network) {
        if (compressed === void 0) { compressed = false; }
        if (network === void 0) { network = transactions_1.TransactionVersion.Mainnet; }
        return transactions_1.getAddressFromPublicKey(this.getKeys(compressed).pub, network);
    };
    return KeyPair;
}(secp256k1ExtendedKeyPair_1.Secp256k1ExtendedKeyPair));
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2luL3N0eC9rZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQ0FBcUM7QUFDckMsMkNBQStCO0FBQy9CLCtDQUF1QztBQUN2QyxxREFBbUY7QUFDbkYsMkNBQW1HO0FBQ25HLGlGQUFnRjtBQUNoRiw2Q0FBOEQ7QUFDOUQsaUNBQThEO0FBQzlELHlDQUFzRDtBQUV0RDtJQUE2QiwyQkFBd0I7SUFDbkQ7Ozs7T0FJRztJQUNILGlCQUFZLE1BQXVCO1FBQW5DLFlBQ0Usa0JBQU0sTUFBTSxDQUFDLFNBaUJkO1FBaEJDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxJQUFNLElBQUksR0FBRyxvQkFBVyxDQUFDLG1DQUF1QixDQUFDLENBQUM7WUFDbEQsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BDO2FBQU0sSUFBSSxjQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDekIsS0FBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksb0JBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMvQixLQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSxtQkFBVyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzlCLEtBQUksQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDMUM7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUM3QztRQUVELElBQUksS0FBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLEtBQUksQ0FBQyxPQUFPLEdBQUcsbURBQXdCLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoRTs7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsMENBQXdCLEdBQXhCLFVBQXlCLEdBQVc7UUFDbEMsSUFBSSxDQUFDLHlCQUFpQixDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUM1QztRQUVELElBQUksb0JBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDckM7YUFBTTtZQUNMLElBQUksQ0FBQyxPQUFPLEdBQUcsc0JBQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzVFO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILHlDQUF1QixHQUF2QixVQUF3QixHQUFXO1FBQ2pDLElBQUksQ0FBQyx3QkFBZ0IsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLG9CQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JDO2FBQU07WUFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLHNCQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDOUQ7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCx5QkFBTyxHQUFQLFVBQVEsVUFBa0I7O1FBQWxCLDJCQUFBLEVBQUEsa0JBQWtCO1FBQ3hCLElBQUksR0FBRyxHQUFHLE1BQUEsSUFBSSxDQUFDLGFBQWEsRUFBRSwwQ0FBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEQsSUFBSSxHQUFHLElBQUksVUFBVSxFQUFFO1lBQ3JCLEdBQUcsSUFBSSxJQUFJLENBQUM7U0FDYjtRQUVELE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLFVBQVUsWUFBQSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQ3RELEdBQUcsS0FBQTtTQUNKLENBQUM7SUFDSixDQUFDO0lBRUQsK0JBQWEsR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw0QkFBVSxHQUFWO1FBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxpQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsK0JBQWEsR0FBYixVQUFjLFVBQWtCLEVBQUUsT0FBd0Q7UUFBNUUsMkJBQUEsRUFBQSxrQkFBa0I7UUFBRSx3QkFBQSxFQUFBLFVBQThCLGlDQUFrQixDQUFDLE9BQU87UUFDeEYsT0FBTyxzQ0FBdUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBQ0gsY0FBQztBQUFELENBQUMsQUEvR0QsQ0FBNkIsbURBQXdCLEdBK0dwRDtBQS9HWSwwQkFBTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIGJpcDMyIGZyb20gJ2JpcDMyJztcbmltcG9ydCB7IEVDUGFpciB9IGZyb20gJ2JpdGNvaW5qcy1saWInO1xuaW1wb3J0IHsgZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXksIFRyYW5zYWN0aW9uVmVyc2lvbiB9IGZyb20gJ0BzdGFja3MvdHJhbnNhY3Rpb25zJztcbmltcG9ydCB7IERlZmF1bHRLZXlzLCBpc1ByaXZhdGVLZXksIGlzUHVibGljS2V5LCBpc1NlZWQsIEtleVBhaXJPcHRpb25zIH0gZnJvbSAnLi4vYmFzZUNvaW4vaWZhY2UnO1xuaW1wb3J0IHsgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIH0gZnJvbSAnLi4vYmFzZUNvaW4vc2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyJztcbmltcG9ydCB7IGlzVmFsaWRYcHJ2LCBpc1ZhbGlkWHB1YiB9IGZyb20gJy4uLy4uL3V0aWxzL2NyeXB0byc7XG5pbXBvcnQgeyBpc1ZhbGlkUHJpdmF0ZUtleSwgaXNWYWxpZFB1YmxpY0tleSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgREVGQVVMVF9TRUVEX1NJWkVfQllURVMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZT86IEtleVBhaXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgY29uc3Qgc2VlZCA9IHJhbmRvbUJ5dGVzKERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTKTtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1NlZWQoc291cmNlKSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzb3VyY2Uuc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1ByaXZhdGVLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkoc291cmNlLnBydik7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHVibGljS2V5KHNvdXJjZS5wdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHBhaXIgb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhkTm9kZSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0gU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRvS2V5UGFpcih0aGlzLmhkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEga2V5cGFpciBmcm9tIGEgcHJvdG9jb2wgcHJpdmF0ZSBrZXkgb3IgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIFRoZSBwcm90b2NvbCBwcml2YXRlIGtleSBpcyBlaXRoZXIgMzIgb3IgMzMgYnl0ZXMgbG9uZyAoNjQgb3IgNjZcbiAgICogY2hhcmFjdGVycyBoZXgpLiAgSWYgaXQgaXMgMzIgYnl0ZXMgbG9uZywgc2V0IHRoZSBrZXlwYWlyJ3MgXCJjb21wcmVzc2VkXCJcbiAgICogZmllbGQgdG8gZmFsc2UgdG8gbGF0ZXIgZ2VuZXJhdGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlzICh0aGUgZGVmYXVsdCkuXG4gICAqIEEgMzMgYnl0ZSBrZXkgaGFzIDB4MDEgYXMgdGhlIGxhc3QgYnl0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiBBIHJhdyBwcml2YXRlIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFpc1ZhbGlkUHJpdmF0ZUtleShwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwcnYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20ocHJ2LnNsaWNlKDAsIDY0KSwgJ2hleCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gRUNQYWlyIGZyb20gYSBwcm90b2NvbCBwdWJsaWMga2V5IG9yIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIFRoZSBwcm90b2NvbCBwdWJsaWMga2V5IGlzIGVpdGhlciAzMiBieXRlcyBvciA2NCBieXRlcyBsb25nLCB3aXRoIGFcbiAgICogb25lLWJ5dGUgcHJlZml4IChhIHRvdGFsIG9mIDY2IG9yIDEzMCBjaGFyYWN0ZXJzIGluIGhleCkuICBJZiB0aGVcbiAgICogcHJlZml4IGlzIDB4MDIgb3IgMHgwMywgaXQgaXMgYSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuICBBIHByZWZpeCBvZiAweDA0XG4gICAqIGRlbm90ZXMgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgQSByYXcgcHVibGljIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkocHViOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWlzVmFsaWRQdWJsaWNLZXkocHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwdWJsaWMga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRYcHViKHB1YikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YWNrcyBkZWZhdWx0IGtleXMgZm9ybWF0IGlzIHJhdyBwcml2YXRlIGFuZCB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWQgLSBDb21wcmVzcyBwdWJsaWMga2V5IChkZWZhdWx0cyB0byBmYWxzZSlcbiAgICogQHJldHVybnMge0RlZmF1bHRLZXlzfSBUaGUga2V5cyBpbiB0aGUgcHJvdG9jb2wgZGVmYXVsdCBrZXkgZm9ybWF0XG4gICAqL1xuICBnZXRLZXlzKGNvbXByZXNzZWQgPSBmYWxzZSk6IERlZmF1bHRLZXlzIHtcbiAgICBsZXQgcHJ2ID0gdGhpcy5nZXRQcml2YXRlS2V5KCk/LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAocHJ2ICYmIGNvbXByZXNzZWQpIHtcbiAgICAgIHBydiArPSAnMDEnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHRoaXMuZ2V0UHVibGljS2V5KHsgY29tcHJlc3NlZCB9KS50b1N0cmluZygnaGV4JyksXG4gICAgICBwcnYsXG4gICAgfTtcbiAgfVxuXG4gIGdldENvbXByZXNzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMua2V5UGFpci5jb21wcmVzc2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHB1YmxpYyBhZGRyZXNzIG9mIGFuIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcHVibGljIGFkZHJlc3NcbiAgICovXG4gIGdldEFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTVFhBZGRyZXNzKGZhbHNlLCBUcmFuc2FjdGlvblZlcnNpb24uTWFpbm5ldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcHVibGljIGFkZHJlc3Mgb2YgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZCAtIENvbXByZXNzIHB1YmxpYyBrZXkgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVmVyc2lvbn0gbmV0d29yayAtIHNlbGVjdCBNYWlubmV0IG9yIFRlc3RuZXQgZm9yIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwdWJsaWMgYWRkcmVzc1xuICAgKi9cbiAgZ2V0U1RYQWRkcmVzcyhjb21wcmVzc2VkID0gZmFsc2UsIG5ldHdvcms6IFRyYW5zYWN0aW9uVmVyc2lvbiA9IFRyYW5zYWN0aW9uVmVyc2lvbi5NYWlubmV0KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkodGhpcy5nZXRLZXlzKGNvbXByZXNzZWQpLnB1YiwgbmV0d29yayk7XG4gIH1cbn1cbiJdfQ==