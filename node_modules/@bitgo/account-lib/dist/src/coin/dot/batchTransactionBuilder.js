"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchTransactionBuilder = void 0;
var transactionBuilder_1 = require("./transactionBuilder");
var txwrapper_polkadot_1 = require("@substrate/txwrapper-polkadot");
var baseCoin_1 = require("../baseCoin");
var iface_1 = require("./iface");
var errors_1 = require("../baseCoin/errors");
var txnSchema_1 = require("./txnSchema");
var BatchTransactionBuilder = /** @class */ (function (_super) {
    __extends(BatchTransactionBuilder, _super);
    function BatchTransactionBuilder(_coinConfig) {
        return _super.call(this, _coinConfig) || this;
    }
    /** @inheritDoc */
    BatchTransactionBuilder.prototype.buildTransaction = function () {
        return this.buildBatchTransaction();
    };
    /**
     * Build a transaction which batches together multiple transactions.
     * The transactions which are batched together are passed in as an array of hex strings
     * which are composed of the method to call and the arguments to pass into the method.
     *
     * @returns {UnsignedTransaction}
     *
     * @see https://polkadot.js.org/docs/substrate/extrinsics/#batchcalls-veccall
     */
    BatchTransactionBuilder.prototype.buildBatchTransaction = function () {
        var baseTxInfo = this.createBaseTxInfo();
        return txwrapper_polkadot_1.methods.utility.batch({
            calls: this._calls,
        }, baseTxInfo.baseTxInfo, baseTxInfo.options);
    };
    Object.defineProperty(BatchTransactionBuilder.prototype, "transactionType", {
        get: function () {
            return baseCoin_1.TransactionType.Batch;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Set multiple unsigned transactions to be batched and broadcast as a single transaction
     *
     * @param {BatchCall[]} calls unsigned transactions
     * @returns {BatchTransactionBuilder} This batch transaction builder.
     */
    BatchTransactionBuilder.prototype.calls = function (calls) {
        this.validateCalls(calls);
        this._calls = calls;
        return this;
    };
    /** @inheritdoc */
    BatchTransactionBuilder.prototype.validateDecodedTransaction = function (decodedTxn) {
        var txMethod = decodedTxn.method.args;
        var validationResult = this.validateBatchTransactionFields(txMethod.calls);
        if (validationResult.error) {
            throw new errors_1.InvalidTransactionError("Transaction validation failed: " + validationResult.error.message);
        }
    };
    /** @inheritdoc */
    BatchTransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        var _this = this;
        var _a, _b;
        var tx = _super.prototype.fromImplementation.call(this, rawTransaction);
        if (((_a = this._method) === null || _a === void 0 ? void 0 : _a.name) === iface_1.MethodNames.Batch) {
            var txMethod = this._method.args;
            if (!txMethod.calls) {
                throw new errors_1.InvalidTransactionError('failed to decode calls from batch transaction');
            }
            var callsToBatch_1 = [];
            txMethod.calls.forEach(function (call) {
                var method = call.callIndex;
                if (method === '0x1604') {
                    callsToBatch_1.push(_this.getAnonymousProxyCall(call));
                }
                else {
                    throw new errors_1.NotImplementedError("batching of transactions with index " + method + " unsupported");
                }
            });
            this.calls(callsToBatch_1);
        }
        else {
            throw new errors_1.InvalidTransactionError("Invalid Transaction Type: " + ((_b = this._method) === null || _b === void 0 ? void 0 : _b.name) + ". Expected " + iface_1.MethodNames.Batch);
        }
        return tx;
    };
    /** @inheritdoc */
    BatchTransactionBuilder.prototype.validateTransaction = function (_) {
        _super.prototype.validateTransaction.call(this, _);
        this.validateFields();
    };
    /**
     * Validate list of unsigned transactions added to batch
     *
     * @param {string[]} calls
     *
     */
    BatchTransactionBuilder.prototype.validateCalls = function (calls) {
        calls.forEach(function (call) {
            if (call.slice(0, 2) !== '0x') {
                // example: '0x160400000000000000'
                throw new errors_1.BuildTransactionError('call in string format must be hex format of a method and its arguments');
            }
        });
    };
    BatchTransactionBuilder.prototype.validateFields = function () {
        var validationResult = this.validateBatchTransactionFields(this._calls);
        if (validationResult.error) {
            throw new errors_1.InvalidTransactionError("AddressInitialization Transaction validation failed: " + validationResult.error.message);
        }
    };
    BatchTransactionBuilder.prototype.validateBatchTransactionFields = function (calls) {
        return txnSchema_1.BatchTransactionSchema.validate({
            calls: calls,
        });
    };
    BatchTransactionBuilder.prototype.getAnonymousProxyCall = function (callObject) {
        var _a, _b, _c;
        var baseTxInfo = this.createBaseTxInfo();
        var unsigned = txwrapper_polkadot_1.methods.proxy.anonymous({
            proxyType: (_a = callObject.args) === null || _a === void 0 ? void 0 : _a.proxy_type,
            index: (_b = callObject.args) === null || _b === void 0 ? void 0 : _b.index,
            delay: (_c = callObject.args) === null || _c === void 0 ? void 0 : _c.delay,
        }, baseTxInfo.baseTxInfo, baseTxInfo.options);
        return unsigned.method;
    };
    return BatchTransactionBuilder;
}(transactionBuilder_1.TransactionBuilder));
exports.BatchTransactionBuilder = BatchTransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmF0Y2hUcmFuc2FjdGlvbkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9kb3QvYmF0Y2hUcmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsMkRBQTBEO0FBRTFELG9FQUF3RDtBQUN4RCx3Q0FBOEM7QUFDOUMsaUNBQWtFO0FBQ2xFLDZDQUF5RztBQUN6Ryx5Q0FBcUQ7QUFJckQ7SUFBNkMsMkNBQWtCO0lBSTdELGlDQUFZLFdBQWlDO2VBQzNDLGtCQUFNLFdBQVcsQ0FBQztJQUNwQixDQUFDO0lBRUQsa0JBQWtCO0lBQ1Isa0RBQWdCLEdBQTFCO1FBQ0UsT0FBTyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDTyx1REFBcUIsR0FBL0I7UUFDRSxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUMzQyxPQUFPLDRCQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FDMUI7WUFDRSxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDbkIsRUFDRCxVQUFVLENBQUMsVUFBVSxFQUNyQixVQUFVLENBQUMsT0FBTyxDQUNuQixDQUFDO0lBQ0osQ0FBQztJQUVELHNCQUFjLG9EQUFlO2FBQTdCO1lBQ0UsT0FBTywwQkFBZSxDQUFDLEtBQUssQ0FBQztRQUMvQixDQUFDOzs7T0FBQTtJQUVEOzs7OztPQUtHO0lBQ0gsdUNBQUssR0FBTCxVQUFNLEtBQWU7UUFDbkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsNERBQTBCLEdBQTFCLFVBQTJCLFVBQW1EO1FBQzVFLElBQU0sUUFBUSxH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QUM7UUFDM0MsSUFBTSxRQUFRLEdBQUcsNEJBQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUN0QztZQUNFLFNBQVMsRUFBRSxNQUFBLFVBQVUsQ0FBQyxJQUFJLDBDQUFFLFVBQVU7WUFDdEMsS0FBSyxFQUFFLE1BQUEsVUFBVSxDQUFDLElBQUksMENBQUUsS0FBSztZQUM3QixLQUFLLEVBQUUsTUFBQSxVQUFVLENBQUMsSUFBSSwwQ0FBRSxLQUFLO1NBQzlCLEVBQ0QsVUFBVSxDQUFDLFVBQVUsRUFDckIsVUFBVSxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUN6QixDQUFDO0lBQ0gsOEJBQUM7QUFBRCxDQUFDLEFBcklELENBQTZDLHVDQUFrQixHQXFJOUQ7QUFySVksMERBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IERlY29kZWRTaWduZWRUeCwgRGVjb2RlZFNpZ25pbmdQYXlsb2FkLCBVbnNpZ25lZFRyYW5zYWN0aW9uIH0gZnJvbSAnQHN1YnN0cmF0ZS90eHdyYXBwZXItY29yZSc7XG5pbXBvcnQgeyBtZXRob2RzIH0gZnJvbSAnQHN1YnN0cmF0ZS90eHdyYXBwZXItcG9sa2Fkb3QnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQmF0Y2hDYWxsT2JqZWN0LCBCYXRjaEFyZ3MsIE1ldGhvZE5hbWVzIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLCBOb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IEJhdGNoVHJhbnNhY3Rpb25TY2hlbWEgfSBmcm9tICcuL3R4blNjaGVtYSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVmFsaWRhdGlvblJlc3VsdCB9IGZyb20gJ2pvaSc7XG5cbmV4cG9ydCBjbGFzcyBCYXRjaFRyYW5zYWN0aW9uQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByb3RlY3RlZCBfY2FsbHM6IHN0cmluZ1tdO1xuICBwcm90ZWN0ZWQgX3R5cGU6IFRyYW5zYWN0aW9uVHlwZTtcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkVHJhbnNhY3Rpb24oKTogVW5zaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRCYXRjaFRyYW5zYWN0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSB0cmFuc2FjdGlvbiB3aGljaCBiYXRjaGVzIHRvZ2V0aGVyIG11bHRpcGxlIHRyYW5zYWN0aW9ucy5cbiAgICogVGhlIHRyYW5zYWN0aW9ucyB3aGljaCBhcmUgYmF0Y2hlZCB0b2dldGhlciBhcmUgcGFzc2VkIGluIGFzIGFuIGFycmF5IG9mIGhleCBzdHJpbmdzXG4gICAqIHdoaWNoIGFyZSBjb21wb3NlZCBvZiB0aGUgbWV0aG9kIHRvIGNhbGwgYW5kIHRoZSBhcmd1bWVudHMgdG8gcGFzcyBpbnRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtVbnNpZ25lZFRyYW5zYWN0aW9ufVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcG9sa2Fkb3QuanMub3JnL2RvY3Mvc3Vic3RyYXRlL2V4dHJpbnNpY3MvI2JhdGNoY2FsbHMtdmVjY2FsbFxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkQmF0Y2hUcmFuc2FjdGlvbigpOiBVbnNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCBiYXNlVHhJbmZvID0gdGhpcy5jcmVhdGVCYXNlVHhJbmZvKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMudXRpbGl0eS5iYXRjaChcbiAgICAgIHtcbiAgICAgICAgY2FsbHM6IHRoaXMuX2NhbGxzLFxuICAgICAgfSxcbiAgICAgIGJhc2VUeEluZm8uYmFzZVR4SW5mbyxcbiAgICAgIGJhc2VUeEluZm8ub3B0aW9ucyxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvblR5cGUoKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLkJhdGNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBtdWx0aXBsZSB1bnNpZ25lZCB0cmFuc2FjdGlvbnMgdG8gYmUgYmF0Y2hlZCBhbmQgYnJvYWRjYXN0IGFzIGEgc2luZ2xlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QmF0Y2hDYWxsW119IGNhbGxzIHVuc2lnbmVkIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7QmF0Y2hUcmFuc2FjdGlvbkJ1aWxkZXJ9IFRoaXMgYmF0Y2ggdHJhbnNhY3Rpb24gYnVpbGRlci5cbiAgICovXG4gIGNhbGxzKGNhbGxzOiBzdHJpbmdbXSk6IHRoaXMge1xuICAgIHRoaXMudmFsaWRhdGVDYWxscyhjYWxscyk7XG4gICAgdGhpcy5fY2FsbHMgPSBjYWxscztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZURlY29kZWRUcmFuc2FjdGlvbihkZWNvZGVkVHhuOiBEZWNvZGVkU2lnbmluZ1BheWxvYWQgfCBEZWNvZGVkU2lnbmVkVHgpOiB2b2lkIHtcbiAgICBjb25zdCB0eE1ldGhvZCA9IGRlY29kZWRUeG4ubWV0aG9kLmFyZ3MgYXMgdW5rbm93biBhcyBCYXRjaEFyZ3M7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGVCYXRjaFRyYW5zYWN0aW9uRmllbGRzKHR4TWV0aG9kLmNhbGxzKTtcbiAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGBUcmFuc2FjdGlvbiB2YWxpZGF0aW9uIGZhaWxlZDogJHt2YWxpZGF0aW9uUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBmcm9tSW1wbGVtZW50YXRpb24ocmF3VHJhbnNhY3Rpb246IHN0cmluZyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0eCA9IHN1cGVyLmZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRoaXMuX21ldGhvZD8ubmFtZSA9PT0gTWV0aG9kTmFtZXMuQmF0Y2gpIHtcbiAgICAgIGNvbnN0IHR4TWV0aG9kID0gdGhpcy5fbWV0aG9kLmFyZ3MgYXMgQmF0Y2hBcmdzO1xuICAgICAgaWYgKCF0eE1ldGhvZC5jYWxscykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ2ZhaWxlZCB0byBkZWNvZGUgY2FsbHMgZnJvbSBiYXRjaCB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbHNUb0JhdGNoOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgdHhNZXRob2QuY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAoY2FsbCBhcyBCYXRjaENhbGxPYmplY3QpLmNhbGxJbmRleDtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJzB4MTYwNCcpIHtcbiAgICAgICAgICBjYWxsc1RvQmF0Y2gucHVzaCh0aGlzLmdldEFub255bW91c1Byb3h5Q2FsbChjYWxsIGFzIEJhdGNoQ2FsbE9iamVjdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKGBiYXRjaGluZyBvZiB0cmFuc2FjdGlvbnMgd2l0aCBpbmRleCAke21ldGhvZH0gdW5zdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNhbGxzKGNhbGxzVG9CYXRjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgVHJhbnNhY3Rpb24gVHlwZTogJHt0aGlzLl9tZXRob2Q/Lm5hbWV9LiBFeHBlY3RlZCAke01ldGhvZE5hbWVzLkJhdGNofWAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbihfOiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHN1cGVyLnZhbGlkYXRlVHJhbnNhY3Rpb24oXyk7XG4gICAgdGhpcy52YWxpZGF0ZUZpZWxkcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGxpc3Qgb2YgdW5zaWduZWQgdHJhbnNhY3Rpb25zIGFkZGVkIHRvIGJhdGNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNhbGxzXG4gICAqXG4gICAqL1xuICB2YWxpZGF0ZUNhbGxzKGNhbGxzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICAgIGlmIChjYWxsLnNsaWNlKDAsIDIpICE9PSAnMHgnKSB7XG4gICAgICAgIC8vIGV4YW1wbGU6ICcweDE2MDQwMDAwMDAwMDAwMDAwMCdcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignY2FsbCBpbiBzdHJpbmcgZm9ybWF0IG11c3QgYmUgaGV4IGZvcm1hdCBvZiBhIG1ldGhvZCBhbmQgaXRzIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZUZpZWxkcygpOiB2b2lkIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gdGhpcy52YWxpZGF0ZUJhdGNoVHJhbnNhY3Rpb25GaWVsZHModGhpcy5fY2FsbHMpO1xuICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBBZGRyZXNzSW5pdGlhbGl6YXRpb24gVHJhbnNhY3Rpb24gdmFsaWRhdGlvbiBmYWlsZWQ6ICR7dmFsaWRhdGlvblJlc3VsdC5lcnJvci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVCYXRjaFRyYW5zYWN0aW9uRmllbGRzKGNhbGxzOiAoc3RyaW5nIHwgQmF0Y2hDYWxsT2JqZWN0KVtdKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgcmV0dXJuIEJhdGNoVHJhbnNhY3Rpb25TY2hlbWEudmFsaWRhdGUoe1xuICAgICAgY2FsbHMsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldEFub255bW91c1Byb3h5Q2FsbChjYWxsT2JqZWN0OiBCYXRjaENhbGxPYmplY3QpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhc2VUeEluZm8gPSB0aGlzLmNyZWF0ZUJhc2VUeEluZm8oKTtcbiAgICBjb25zdCB1bnNpZ25lZCA9IG1ldGhvZHMucHJveHkuYW5vbnltb3VzKFxuICAgICAge1xuICAgICAgICBwcm94eVR5cGU6IGNhbGxPYmplY3QuYXJncz8ucHJveHlfdHlwZSxcbiAgICAgICAgaW5kZXg6IGNhbGxPYmplY3QuYXJncz8uaW5kZXgsXG4gICAgICAgIGRlbGF5OiBjYWxsT2JqZWN0LmFyZ3M/LmRlbGF5LFxuICAgICAgfSxcbiAgICAgIGJhc2VUeEluZm8uYmFzZVR4SW5mbyxcbiAgICAgIGJhc2VUeEluZm8ub3B0aW9ucyxcbiAgICApO1xuICAgIHJldHVybiB1bnNpZ25lZC5tZXRob2Q7XG4gIH1cbn1cbiJdfQ==