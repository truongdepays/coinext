import { KeyringPair } from '@polkadot/keyring/types';
import { UnsignedTransaction } from '@substrate/txwrapper-core';
import { DecodedSignedTx, DecodedSigningPayload, TypeRegistry } from '@substrate/txwrapper-core/lib/types';
import { KeyPair } from '.';
import { BaseUtils } from '../baseCoin';
import { Seed } from '../baseCoin/iface';
import { HexString, Material, ProxyArgs, TransferArgs, TxMethod } from './iface';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
export declare class Utils implements BaseUtils {
    /** @inheritdoc */
    isValidAddress(address: string): boolean;
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /** @inheritdoc */
    isValidPrivateKey(key: string): boolean;
    /** @inheritdoc */
    isValidPublicKey(key: string): boolean;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /**
     * Verifies the signature on a given message
     *
     * @param {string} signedMessage the signed message for the signature
     * @param {string} signature the signature to verify
     * @param {string} address the address of the signer
     * @returns {boolean} whether the signature is valid or not
     */
    verifySignature(signedMessage: string, signature: string, address: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    /**
     * decodeSeed decodes a dot seed
     *
     * @param {string} seed - the seed to be validated.
     * @returns {Seed} - the object Seed
     */
    decodeSeed(seed: string): Seed;
    /**
     * Helper function to capitalize the first letter of a string
     *
     * @param {string} val
     * @returns {string}
     */
    capitalizeFirstLetter(val: string): string;
    /**
     * Helper function to decode the internal method hex in case of a proxy transaction
     *
     * @param {string | UnsignedTransaction} tx
     * @param { metadataRpc: string; registry: TypeRegistry } options
     * @returns {TransferArgs}
     */
    decodeCallMethod(tx: string | UnsignedTransaction, options: {
        metadataRpc: string;
        registry: TypeRegistry;
    }): TransferArgs;
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the polkadot sdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    keyPairFromSeed(seed: Uint8Array): KeyPair;
    /**
     * Signing function. Implement this on the OFFLINE signing device.
     *
     * @param {KeyringPair} pair - The signing pair.
     * @param {string} signingPayload - Payload to sign.
     * @param {UnsignedTransaction} transaction - raw transaction to sign
     * @param {Object} options
     * @param {HexString} options.metadataRpc - metadata that is needed for dot to sign
     * @param {TypeRegistry} options.registry - metadata that is needed for dot to sign
     */
    createSignedTx(pair: KeyringPair, signingPayload: string, transaction: UnsignedTransaction, options: {
        metadataRpc: HexString;
        registry: TypeRegistry;
    }): string;
    /**
     * Serializes the signed transaction
     *
     * @param transaction Transaction to serialize
     * @param signature Signature of the message
     * @param metadataRpc Network metadata
     * @param registry Transaction registry
     * @returns string Serialized transaction
     */
    serializeSignedTransaction(transaction: any, signature: any, metadataRpc: `0x${string}`, registry: any): string;
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    decodeDotAddress(address: string, ss58Format?: number): string;
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    encodeDotAddress(address: string, ss58Format?: number): string;
    /**
     * Retrieves the txHash of a signed txHex
     *
     * @param txHex signed transaction hex
     * @returns {string}
     */
    getTxHash(txHex: string): string;
    getMaterial(coinConfig: Readonly<CoinConfig>): Material;
    isSigningPayload(payload: DecodedSigningPayload | DecodedSignedTx): payload is DecodedSigningPayload;
    isProxyTransfer(arg: TxMethod['args']): arg is ProxyArgs;
    isTransfer(arg: TxMethod['args']): arg is TransferArgs;
    /**
     * extracts and returns the signature in hex format given a raw signed transaction
     *
     * @param {string} rawTx signed raw transaction
     * @param options registry dot registry used to retrieve the signature
     */
    recoverSignatureFromRawTx(rawTx: string, options: {
        registry: TypeRegistry;
    }): string;
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {KeyPair}
     */
    decodeDotAddressToKeyPair(address: string, ss58Format?: number): KeyPair;
    /**
     * Checks whether the given input is a hex string with with 0 value
     * used to check whether a given transaction is immortal or mortal
     * @param hexValue
     */
    isZeroHex(hexValue: string): boolean;
}
declare const utils: Utils;
export default utils;
//# sourceMappingURL=utils.d.ts.map