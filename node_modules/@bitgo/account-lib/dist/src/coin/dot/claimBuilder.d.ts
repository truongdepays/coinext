import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { DecodedSignedTx, DecodedSigningPayload, UnsignedTransaction } from '@substrate/txwrapper-core';
import { TransactionType } from '../baseCoin';
import { Transaction } from './transaction';
import { TransactionBuilder } from './transactionBuilder';
import { BaseAddress } from '../baseCoin/iface';
export declare class ClaimBuilder extends TransactionBuilder {
    protected _validatorStash: string;
    protected _claimEra: string;
    constructor(_coinConfig: Readonly<CoinConfig>);
    /**
     *
     * Pay out all the stakers behind a single validator for a single era.
     * Any account can create this transaction.
     *
     * @returns {UnsignedTransaction} an unsigned Dot transaction
     *
     * @see https://polkadot.js.org/docs/substrate/extrinsics/#payoutstakersvalidator_stash-accountid32-era-u32
     */
    protected buildTransaction(): UnsignedTransaction;
    /**
     * Get the transaction type.
     */
    protected get transactionType(): TransactionType;
    /**
     *
     * The stash account of the validator.
     *
     * @param {string} validatorStash
     * @returns {ClaimBuilder} This claim builder.
     *
     */
    validatorStash(validatorStash: BaseAddress): this;
    /**
     * The era to claim.
     *
     * @param {string} claimEra
     * @returns {ClaimBuilder} This claim builder.
     *
     */
    claimEra(claimEra: string): this;
    /** @inheritdoc */
    validateDecodedTransaction(decodedTxn: DecodedSigningPayload | DecodedSignedTx): void;
    /** @inheritdoc */
    protected fromImplementation(rawTransaction: string): Transaction;
    /** @inheritdoc */
    validateTransaction(_: Transaction): void;
    /**
     *
     * The stash account of the validator.
     *
     * @param {string} claimEra
     * @param {string} validatorStash
     * @throws {Error} If the expected fields are not valid.
     *
     */
    private validateFields;
}
//# sourceMappingURL=claimBuilder.d.ts.map