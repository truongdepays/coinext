/// <reference types="node" />
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { BaseTransaction, TransactionType } from '../baseCoin';
import { BaseKey } from '../baseCoin/iface';
import { UnsignedTransaction } from '@substrate/txwrapper-core';
import { TypeRegistry } from '@substrate/txwrapper-core/lib/types';
import { KeyPair } from './keyPair';
import { TransactionExplanation, TxData } from './iface';
export declare class Transaction extends BaseTransaction {
    protected _dotTransaction: UnsignedTransaction;
    private _signedTransaction?;
    private _registry;
    private _chainName;
    private _sender;
    constructor(coinConfig: Readonly<CoinConfig>);
    /** @inheritdoc */
    canSign({ key }: BaseKey): boolean;
    /**
     * Sign a polkadot transaction and update the transaction hex
     *
     * @param {KeyPair} keyPair - ed signature
     */
    sign(keyPair: KeyPair): void;
    /**
     * Adds the signature to the DOT Transaction
     * @param {string} signature
     */
    addSignature(signature: string): void;
    registry(registry: TypeRegistry): void;
    chainName(chainName: string): void;
    sender(sender: string): void;
    /** @inheritdoc */
    toBroadcastFormat(): string;
    transactionSize(): number;
    /** @inheritdoc */
    toJson(): TxData;
    explainTransferTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    explainStakingActivateTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    explainAddressInitializationTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    explainStakingUnlockTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    /** @inheritdoc */
    explainTransaction(): TransactionExplanation;
    /**
     * Load the input and output data on this transaction.
     */
    loadInputsAndOutputs(): void;
    /**
     * Constructs a signed payload using construct.signTx
     * This method will be called during the build step if a TSS signature
     * is added and will set the signTransaction which is the txHex that will be broadcasted
     * As well as add the signature used to sign to the signature array in hex format
     *
     * @param {Buffer} signature The signature to be added to a dot transaction
     */
    constructSignedPayload(signature: Buffer): void;
    setTransaction(tx: UnsignedTransaction): void;
    /** @inheritdoc **/
    get signablePayload(): Buffer;
    /**
     * Set the transaction type.
     *
     * @param {TransactionType} transactionType The transaction type to be set.
     */
    transactionType(transactionType: TransactionType): void;
}
//# sourceMappingURL=transaction.d.ts.map