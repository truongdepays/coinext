"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
var keyring_1 = require("@polkadot/keyring");
var pair_1 = require("@polkadot/keyring/pair");
var baseCoin_1 = require("../baseCoin");
var utils_1 = __importDefault(require("./utils"));
var crypto_1 = require("../../utils/crypto");
var bs58_1 = __importDefault(require("bs58"));
var TYPE = 'ed25519';
var MAINNET_FORMAT = 0;
var keyring = new keyring_1.Keyring({ type: TYPE });
var KeyPair = /** @class */ (function (_super) {
    __extends(KeyPair, _super);
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    function KeyPair(source) {
        return _super.call(this, source) || this;
    }
    /**
     * Helper function to create the KeyringPair for signing a dot transaction.
     *
     * @returns {KeyringPair} dot KeyringPair
     *
     * @see https://polkadot.js.org/docs/api/start/keyring
     */
    KeyPair.prototype.createPolkadotPair = function () {
        var secretKey = this.keyPair.prv ? new Uint8Array(Buffer.from(this.keyPair.prv, 'hex')) : undefined;
        var publicKey = new Uint8Array(Buffer.from(this.keyPair.pub, 'hex'));
        return pair_1.createPair({ toSS58: keyring.encodeAddress, type: TYPE }, { secretKey: secretKey, publicKey: publicKey });
    };
    /**
     // https://wiki.polkadot.network/docs/learn-accounts#address-format
     * Returns the address in either mainnet polkadot format (starts with 1)
     * or substrate format used for westend (starts with 5)
     */
    KeyPair.prototype.getAddress = function (format) {
        var substrateAddress = this.createPolkadotPair().address;
        // generate polkadot (mainnet) address format
        if (format && format === baseCoin_1.AddressFormat.polkadot) {
            return keyring.encodeAddress(substrateAddress, MAINNET_FORMAT);
        }
        return substrateAddress;
    };
    /** @inheritdoc */
    KeyPair.prototype.getKeys = function () {
        var result = { pub: this.keyPair.pub };
        if (this.keyPair.prv) {
            result.prv = this.keyPair.prv;
        }
        return result;
    };
    /** @inheritdoc */
    KeyPair.prototype.recordKeysFromPrivateKeyInProtocolFormat = function (prv) {
        var decodedSeed = utils_1.default.decodeSeed(prv);
        var bufferFromSeed = Buffer.from(decodedSeed.seed);
        return utils_1.default.keyPairFromSeed(bufferFromSeed).keyPair;
    };
    /** @inheritdoc */
    KeyPair.prototype.recordKeysFromPublicKeyInProtocolFormat = function (pub) {
        var publicKey = keyring.addFromPair({
            // tss common pub is in base58 format and decodes to length of 32
            publicKey: crypto_1.isBase58(pub, 32) ? new Uint8Array(bs58_1.default.decode(pub)) : new Uint8Array(Buffer.from(pub, 'hex')),
            secretKey: new Uint8Array(),
        }).publicKey;
        return { pub: crypto_1.toHex(publicKey) };
    };
    return KeyPair;
}(baseCoin_1.Ed25519KeyPair));
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2luL2RvdC9rZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUE0QztBQUM1QywrQ0FBb0Q7QUFFcEQsd0NBQTREO0FBRTVELGtEQUE0QjtBQUM1Qiw2Q0FBcUQ7QUFDckQsOENBQXdCO0FBRXhCLElBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQztBQUN2QixJQUFNLGNBQWMsR0FBRyxDQUFDLENBQUM7QUFDekIsSUFBTSxPQUFPLEdBQUcsSUFBSSxpQkFBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7QUFFNUM7SUFBNkIsMkJBQWM7SUFDekM7Ozs7T0FJRztJQUNILGlCQUFZLE1BQXVCO2VBQ2pDLGtCQUFNLE1BQU0sQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTyxvQ0FBa0IsR0FBNUI7UUFDRSxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDdEcsSUFBTSxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLE9BQU8saUJBQVUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsYUFBYSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLFNBQVMsV0FBQSxFQUFFLFNBQVMsV0FBQSxFQUFFLENBQUMsQ0FBQztJQUM3RixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDRCQUFVLEdBQVYsVUFBVyxNQUFzQjtRQUMvQixJQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLE9BQU8sQ0FBQztRQUMzRCw2Q0FBNkM7UUFDN0MsSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLHdCQUFhLENBQUMsUUFBUSxFQUFFO1lBQy9DLE9BQU8sT0FBTyxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUNoRTtRQUVELE9BQU8sZ0JBQWdCLENBQUM7SUFDMUIsQ0FBQztJQUVELGtCQUFrQjtJQUNsQix5QkFBTyxHQUFQO1FBQ0UsSUFBTSxNQUFNLEdBQWdCLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdEQsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtZQUNwQixNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1NBQy9CO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELGtCQUFrQjtJQUNsQiwwREFBd0MsR0FBeEMsVUFBeUMsR0FBVztRQUNsRCxJQUFNLFdBQVcsR0FBRyxlQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLElBQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JELE9BQU8sZUFBSyxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDdkQsQ0FBQztJQUVELGtCQUFrQjtJQUNsQix5REFBdUMsR0FBdkMsVUFBd0MsR0FBVztRQUNqRCxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDO1lBQ3BDLGlFQUFpRTtZQUNqRSxTQUFTLEVBQUUsaUJBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLGNBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekcsU0FBUyxFQUFFLElBQUksVUFBVSxFQUFFO1NBQzVCLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDYixPQUFPLEVBQUUsR0FBRyxFQUFFLGNBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFDSCxjQUFDO0FBQUQsQ0FBQyxBQS9ERCxDQUE2Qix5QkFBYyxHQStEMUM7QUEvRFksMEJBQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBLZXlyaW5nIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nL3BhaXInO1xuaW1wb3J0IHsgS2V5cmluZ1BhaXIgfSBmcm9tICdAcG9sa2Fkb3Qva2V5cmluZy90eXBlcyc7XG5pbXBvcnQgeyBBZGRyZXNzRm9ybWF0LCBFZDI1NTE5S2V5UGFpciB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IERlZmF1bHRLZXlzLCBLZXlQYWlyT3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHRvSGV4LCBpc0Jhc2U1OCB9IGZyb20gJy4uLy4uL3V0aWxzL2NyeXB0byc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcblxuY29uc3QgVFlQRSA9ICdlZDI1NTE5JztcbmNvbnN0IE1BSU5ORVRfRk9STUFUID0gMDtcbmNvbnN0IGtleXJpbmcgPSBuZXcgS2V5cmluZyh7IHR5cGU6IFRZUEUgfSk7XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgRWQyNTUxOUtleVBhaXIge1xuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBtYXN0ZXIgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHsgS2V5UGFpck9wdGlvbnMgfSBzb3VyY2UgRWl0aGVyIGEgbWFzdGVyIHNlZWQsIGEgcHJpdmF0ZSBrZXksIG9yIGEgcHVibGljIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIEtleXJpbmdQYWlyIGZvciBzaWduaW5nIGEgZG90IHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cmluZ1BhaXJ9IGRvdCBLZXlyaW5nUGFpclxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcG9sa2Fkb3QuanMub3JnL2RvY3MvYXBpL3N0YXJ0L2tleXJpbmdcbiAgICovXG4gIHByb3RlY3RlZCBjcmVhdGVQb2xrYWRvdFBhaXIoKTogS2V5cmluZ1BhaXIge1xuICAgIGNvbnN0IHNlY3JldEtleSA9IHRoaXMua2V5UGFpci5wcnYgPyBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh0aGlzLmtleVBhaXIucHJ2LCAnaGV4JykpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHRoaXMua2V5UGFpci5wdWIsICdoZXgnKSk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhaXIoeyB0b1NTNTg6IGtleXJpbmcuZW5jb2RlQWRkcmVzcywgdHlwZTogVFlQRSB9LCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0pO1xuICB9XG5cbiAgLyoqXG4gICAvLyBodHRwczovL3dpa2kucG9sa2Fkb3QubmV0d29yay9kb2NzL2xlYXJuLWFjY291bnRzI2FkZHJlc3MtZm9ybWF0XG4gICAqIFJldHVybnMgdGhlIGFkZHJlc3MgaW4gZWl0aGVyIG1haW5uZXQgcG9sa2Fkb3QgZm9ybWF0IChzdGFydHMgd2l0aCAxKVxuICAgKiBvciBzdWJzdHJhdGUgZm9ybWF0IHVzZWQgZm9yIHdlc3RlbmQgKHN0YXJ0cyB3aXRoIDUpXG4gICAqL1xuICBnZXRBZGRyZXNzKGZvcm1hdD86IEFkZHJlc3NGb3JtYXQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHN1YnN0cmF0ZUFkZHJlc3MgPSB0aGlzLmNyZWF0ZVBvbGthZG90UGFpcigpLmFkZHJlc3M7XG4gICAgLy8gZ2VuZXJhdGUgcG9sa2Fkb3QgKG1haW5uZXQpIGFkZHJlc3MgZm9ybWF0XG4gICAgaWYgKGZvcm1hdCAmJiBmb3JtYXQgPT09IEFkZHJlc3NGb3JtYXQucG9sa2Fkb3QpIHtcbiAgICAgIHJldHVybiBrZXlyaW5nLmVuY29kZUFkZHJlc3Moc3Vic3RyYXRlQWRkcmVzcywgTUFJTk5FVF9GT1JNQVQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzdHJhdGVBZGRyZXNzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldEtleXMoKTogRGVmYXVsdEtleXMge1xuICAgIGNvbnN0IHJlc3VsdDogRGVmYXVsdEtleXMgPSB7IHB1YjogdGhpcy5rZXlQYWlyLnB1YiB9O1xuICAgIGlmICh0aGlzLmtleVBhaXIucHJ2KSB7XG4gICAgICByZXN1bHQucHJ2ID0gdGhpcy5rZXlQYWlyLnBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZWNvcmRLZXlzRnJvbVByaXZhdGVLZXlJblByb3RvY29sRm9ybWF0KHBydjogc3RyaW5nKTogRGVmYXVsdEtleXMge1xuICAgIGNvbnN0IGRlY29kZWRTZWVkID0gdXRpbHMuZGVjb2RlU2VlZChwcnYpO1xuICAgIGNvbnN0IGJ1ZmZlckZyb21TZWVkID0gQnVmZmVyLmZyb20oZGVjb2RlZFNlZWQuc2VlZCk7XG4gICAgcmV0dXJuIHV0aWxzLmtleVBhaXJGcm9tU2VlZChidWZmZXJGcm9tU2VlZCkua2V5UGFpcjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZWNvcmRLZXlzRnJvbVB1YmxpY0tleUluUHJvdG9jb2xGb3JtYXQocHViOiBzdHJpbmcpOiBEZWZhdWx0S2V5cyB7XG4gICAgY29uc3QgcHVibGljS2V5ID0ga2V5cmluZy5hZGRGcm9tUGFpcih7XG4gICAgICAvLyB0c3MgY29tbW9uIHB1YiBpcyBpbiBiYXNlNTggZm9ybWF0IGFuZCBkZWNvZGVzIHRvIGxlbmd0aCBvZiAzMlxuICAgICAgcHVibGljS2V5OiBpc0Jhc2U1OChwdWIsIDMyKSA/IG5ldyBVaW50OEFycmF5KGJzNTguZGVjb2RlKHB1YikpIDogbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20ocHViLCAnaGV4JykpLFxuICAgICAgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheSgpLFxuICAgIH0pLnB1YmxpY0tleTtcbiAgICByZXR1cm4geyBwdWI6IHRvSGV4KHB1YmxpY0tleSkgfTtcbiAgfVxufVxuIl19