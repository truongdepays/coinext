"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
var keyring_1 = require("@polkadot/keyring");
var decode_1 = require("@polkadot/keyring/pair/decode");
var Extrinsic_1 = require("@polkadot/types/extrinsic/v4/Extrinsic");
var util_1 = require("@polkadot/util");
var util_crypto_1 = require("@polkadot/util-crypto");
var crypto_1 = require("../../utils/crypto");
var txwrapper_polkadot_1 = require("@substrate/txwrapper-polkadot");
var hi_base32_1 = __importDefault(require("hi-base32"));
var _1 = require(".");
var tweetnacl_1 = __importDefault(require("tweetnacl"));
var types_1 = require("@polkadot/types");
var bs58_1 = __importDefault(require("bs58"));
var crypto_2 = require("./../../utils/crypto");
var PROXY_METHOD_ARG = 2;
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /** @inheritdoc */
    Utils.prototype.isValidAddress = function (address) {
        try {
            keyring_1.encodeAddress(util_1.isHex(address) ? util_1.hexToU8a(address) : keyring_1.decodeAddress(address));
            return true;
        }
        catch (error) {
            return false;
        }
    };
    /** @inheritdoc */
    Utils.prototype.isValidBlockId = function (hash) {
        return util_1.isHex(hash, 256);
    };
    /** @inheritdoc */
    Utils.prototype.isValidPrivateKey = function (key) {
        try {
            var decodedPrv = util_1.hexToU8a(key);
            return decodedPrv.length === tweetnacl_1.default.sign.secretKeyLength / 2;
        }
        catch (e) {
            return false;
        }
    };
    /** @inheritdoc */
    Utils.prototype.isValidPublicKey = function (key) {
        var pubKey = key;
        // convert base58 pub key to hex format
        // tss common pub is in base58 format and decodes to length of 32
        if (crypto_2.isBase58(pubKey, 32)) {
            var base58Decode = bs58_1.default.decode(pubKey);
            pubKey = base58Decode.toString('hex');
        }
        return crypto_1.isValidEd25519PublicKey(pubKey);
    };
    /** @inheritdoc */
    Utils.prototype.isValidSignature = function (signature) {
        var signatureU8a = util_1.u8aToU8a(signature);
        return [64, 65, 66].includes(signatureU8a.length);
    };
    /**
     * Verifies the signature on a given message
     *
     * @param {string} signedMessage the signed message for the signature
     * @param {string} signature the signature to verify
     * @param {string} address the address of the signer
     * @returns {boolean} whether the signature is valid or not
     */
    Utils.prototype.verifySignature = function (signedMessage, signature, address) {
        var publicKey = keyring_1.decodeAddress(address);
        var hexPublicKey = util_1.u8aToHex(publicKey);
        return util_crypto_1.signatureVerify(signedMessage, signature, hexPublicKey).isValid;
    };
    /** @inheritdoc */
    Utils.prototype.isValidTransactionId = function (txId) {
        return util_1.isHex(txId, 256);
    };
    /**
     * decodeSeed decodes a dot seed
     *
     * @param {string} seed - the seed to be validated.
     * @returns {Seed} - the object Seed
     */
    Utils.prototype.decodeSeed = function (seed) {
        var decoded = hi_base32_1.default.decode.asBytes(seed);
        return {
            seed: Buffer.from(decoded),
        };
    };
    /**
     * Helper function to capitalize the first letter of a string
     *
     * @param {string} val
     * @returns {string}
     */
    Utils.prototype.capitalizeFirstLetter = function (val) {
        return val.charAt(0).toUpperCase() + val.slice(1);
    };
    /**
     * Helper function to decode the internal method hex in case of a proxy transaction
     *
     * @param {string | UnsignedTransaction} tx
     * @param { metadataRpc: string; registry: TypeRegistry } options
     * @returns {TransferArgs}
     */
    Utils.prototype.decodeCallMethod = function (tx, options) {
        var registry = options.registry;
        var methodCall;
        if (typeof tx === 'string') {
            try {
                var payload = types_1.createTypeUnsafe(registry, 'ExtrinsicPayload', [
                    tx,
                    { version: Extrinsic_1.EXTRINSIC_VERSION },
                ]);
                methodCall = types_1.createTypeUnsafe(registry, 'Call', [payload.method]);
            }
            catch (e) {
                methodCall = registry.createType('Extrinsic', util_1.hexToU8a(tx), {
                    isSigned: true,
                });
            }
        }
        else {
            methodCall = registry.createType('Call', tx.method);
        }
        var method = methodCall.args[PROXY_METHOD_ARG];
        var decodedArgs = method.toJSON();
        return decodedArgs.args;
    };
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the polkadot sdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    Utils.prototype.keyPairFromSeed = function (seed) {
        var keyring = new keyring_1.Keyring({ type: 'ed25519' });
        var keyringPair = keyring.addFromSeed(seed);
        var pairJson = keyringPair.toJson();
        var decodedKeyPair = decode_1.decodePair('', util_crypto_1.base64Decode(pairJson.encoded), pairJson.encoding.type);
        return new _1.KeyPair({ prv: Buffer.from(decodedKeyPair.secretKey).toString('hex') });
    };
    /**
     * Signing function. Implement this on the OFFLINE signing device.
     *
     * @param {KeyringPair} pair - The signing pair.
     * @param {string} signingPayload - Payload to sign.
     * @param {UnsignedTransaction} transaction - raw transaction to sign
     * @param {Object} options
     * @param {HexString} options.metadataRpc - metadata that is needed for dot to sign
     * @param {TypeRegistry} options.registry - metadata that is needed for dot to sign
     */
    Utils.prototype.createSignedTx = function (pair, signingPayload, transaction, options) {
        var registry = options.registry, metadataRpc = options.metadataRpc;
        var signature = registry
            .createType('ExtrinsicPayload', signingPayload, {
            version: Extrinsic_1.EXTRINSIC_VERSION,
        })
            .sign(pair).signature;
        // Serialize a signed transaction.
        return this.serializeSignedTransaction(transaction, signature, metadataRpc, registry);
    };
    /**
     * Serializes the signed transaction
     *
     * @param transaction Transaction to serialize
     * @param signature Signature of the message
     * @param metadataRpc Network metadata
     * @param registry Transaction registry
     * @returns string Serialized transaction
     */
    Utils.prototype.serializeSignedTransaction = function (transaction, signature, metadataRpc, registry) {
        return txwrapper_polkadot_1.construct.signedTx(transaction, signature, {
            metadataRpc: metadataRpc,
            registry: registry,
        });
    };
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    Utils.prototype.decodeDotAddress = function (address, ss58Format) {
        var keypair = new _1.KeyPair({ pub: Buffer.from(keyring_1.decodeAddress(address, undefined, ss58Format)).toString('hex') });
        return keypair.getAddress();
    };
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    Utils.prototype.encodeDotAddress = function (address, ss58Format) {
        return keyring_1.encodeAddress(address, ss58Format);
    };
    /**
     * Retrieves the txHash of a signed txHex
     *
     * @param txHex signed transaction hex
     * @returns {string}
     */
    Utils.prototype.getTxHash = function (txHex) {
        return txwrapper_polkadot_1.construct.txHash(txHex);
    };
    Utils.prototype.getMaterial = function (coinConfig) {
        var networkConfig = coinConfig.network;
        var specName = networkConfig.specName, specVersion = networkConfig.specVersion, chainName = networkConfig.chainName, txVersion = networkConfig.txVersion, genesisHash = networkConfig.genesisHash;
        return {
            specName: specName,
            specVersion: specVersion,
            chainName: chainName,
            metadata: networkConfig.metadataRpc,
            txVersion: txVersion,
            genesisHash: genesisHash,
        };
    };
    Utils.prototype.isSigningPayload = function (payload) {
        return payload.blockHash !== undefined;
    };
    Utils.prototype.isProxyTransfer = function (arg) {
        return arg.real !== undefined;
    };
    Utils.prototype.isTransfer = function (arg) {
        var _a;
        return ((_a = arg.dest) === null || _a === void 0 ? void 0 : _a.id) !== undefined && arg.value !== undefined;
    };
    /**
     * extracts and returns the signature in hex format given a raw signed transaction
     *
     * @param {string} rawTx signed raw transaction
     * @param options registry dot registry used to retrieve the signature
     */
    Utils.prototype.recoverSignatureFromRawTx = function (rawTx, options) {
        var registry = options.registry;
        var methodCall = registry.createType('Extrinsic', rawTx, {
            isSigned: true,
        });
        var signature = util_1.u8aToHex(methodCall.signature);
        // remove 0x from the signature since this is how it's returned from TSS signing
        if (signature.startsWith('0x')) {
            signature = signature.substr(2);
        }
        return signature;
    };
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {KeyPair}
     */
    Utils.prototype.decodeDotAddressToKeyPair = function (address, ss58Format) {
        return new _1.KeyPair({ pub: Buffer.from(keyring_1.decodeAddress(address, undefined, ss58Format)).toString('hex') });
    };
    /**
     * Checks whether the given input is a hex string with with 0 value
     * used to check whether a given transaction is immortal or mortal
     * @param hexValue
     */
    Utils.prototype.isZeroHex = function (hexValue) {
        return hexValue === '0x00';
    };
    return Utils;
}());
exports.Utils = Utils;
var utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9kb3QvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNkNBQTBFO0FBQzFFLHdEQUEyRDtBQUUzRCxvRUFBMkU7QUFDM0UsdUNBQXFFO0FBQ3JFLHFEQUFzRTtBQUN0RSw2Q0FBNkQ7QUFHN0Qsb0VBQTBEO0FBQzFELHdEQUErQjtBQUMvQixzQkFBNEI7QUFJNUIsd0RBQTZCO0FBRTdCLHlDQUEyRztBQUMzRyw4Q0FBd0I7QUFDeEIsK0NBQWdEO0FBRWhELElBQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO0FBQzNCO0lBQUE7SUFvUkEsQ0FBQztJQW5SQyxrQkFBa0I7SUFDbEIsOEJBQWMsR0FBZCxVQUFlLE9BQWU7UUFDNUIsSUFBSTtZQUNGLHVCQUFhLENBQUMsWUFBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLHVCQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUMzRSxPQUFPLElBQUksQ0FBQztTQUNiO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDZCxPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVELGtCQUFrQjtJQUNsQiw4QkFBYyxHQUFkLFVBQWUsSUFBWTtRQUN6QixPQUFPLFlBQUssQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixpQ0FBaUIsR0FBakIsVUFBa0IsR0FBVztRQUMzQixJQUFJO1lBQ0YsSUFBTSxVQUFVLEdBQUcsZUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLE9BQU8sVUFBVSxDQUFDLE1BQU0sS0FBSyxtQkFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO1NBQzVEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLEtB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VUFBbUI7UUFDNUQsT0FBTyxJQUFJLFVBQU8sQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUFhLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDMUcsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx5QkFBUyxHQUFULFVBQVUsUUFBZ0I7UUFDeEIsT0FBTyxRQUFRLEtBQUssTUFBTSxDQUFDO0lBQzdCLENBQUM7SUFDSCxZQUFDO0FBQUQsQ0FBQyxBQXBSRCxJQW9SQztBQXBSWSxzQkFBSztBQXNSbEIsSUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztBQUUxQixrQkFBZSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvZGVBZGRyZXNzLCBlbmNvZGVBZGRyZXNzLCBLZXlyaW5nIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcnO1xuaW1wb3J0IHsgZGVjb2RlUGFpciB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nL3BhaXIvZGVjb2RlJztcbmltcG9ydCB7IEtleXJpbmdQYWlyIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcvdHlwZXMnO1xuaW1wb3J0IHsgRVhUUklOU0lDX1ZFUlNJT04gfSBmcm9tICdAcG9sa2Fkb3QvdHlwZXMvZXh0cmluc2ljL3Y0L0V4dHJpbnNpYyc7XG5pbXBvcnQgeyBoZXhUb1U4YSwgaXNIZXgsIHU4YVRvSGV4LCB1OGFUb1U4YSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcbmltcG9ydCB7IGJhc2U2NERlY29kZSwgc2lnbmF0dXJlVmVyaWZ5IH0gZnJvbSAnQHBvbGthZG90L3V0aWwtY3J5cHRvJztcbmltcG9ydCB7IGlzVmFsaWRFZDI1NTE5UHVibGljS2V5IH0gZnJvbSAnLi4vLi4vdXRpbHMvY3J5cHRvJztcbmltcG9ydCB7IFVuc2lnbmVkVHJhbnNhY3Rpb24gfSBmcm9tICdAc3Vic3RyYXRlL3R4d3JhcHBlci1jb3JlJztcbmltcG9ydCB7IERlY29kZWRTaWduZWRUeCwgRGVjb2RlZFNpZ25pbmdQYXlsb2FkLCBUeXBlUmVnaXN0cnkgfSBmcm9tICdAc3Vic3RyYXRlL3R4d3JhcHBlci1jb3JlL2xpYi90eXBlcyc7XG5pbXBvcnQgeyBjb25zdHJ1Y3QgfSBmcm9tICdAc3Vic3RyYXRlL3R4d3JhcHBlci1wb2xrYWRvdCc7XG5pbXBvcnQgYmFzZTMyIGZyb20gJ2hpLWJhc2UzMic7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLic7XG5pbXBvcnQgeyBCYXNlVXRpbHMgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBTZWVkIH0gZnJvbSAnLi4vYmFzZUNvaW4vaWZhY2UnO1xuaW1wb3J0IHsgSGV4U3RyaW5nLCBNYXRlcmlhbCwgUHJveHlBcmdzLCBQcm94eUNhbGxBcmdzLCBUcmFuc2ZlckFyZ3MsIFR4TWV0aG9kIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgbmFjbCBmcm9tICd0d2VldG5hY2wnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZywgRG90TmV0d29yayB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IGNyZWF0ZVR5cGVVbnNhZmUsIEdlbmVyaWNDYWxsLCBHZW5lcmljRXh0cmluc2ljLCBHZW5lcmljRXh0cmluc2ljUGF5bG9hZCB9IGZyb20gJ0Bwb2xrYWRvdC90eXBlcyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCB7IGlzQmFzZTU4IH0gZnJvbSAnLi8uLi8uLi91dGlscy9jcnlwdG8nO1xuXG5jb25zdCBQUk9YWV9NRVRIT0RfQVJHID0gMjtcbmV4cG9ydCBjbGFzcyBVdGlscyBpbXBsZW1lbnRzIEJhc2VVdGlscyB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgZW5jb2RlQWRkcmVzcyhpc0hleChhZGRyZXNzKSA/IGhleFRvVThhKGFkZHJlc3MpIDogZGVjb2RlQWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkQmxvY2tJZChoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNIZXgoaGFzaCwgMjU2KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHJpdmF0ZUtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNvZGVkUHJ2ID0gaGV4VG9VOGEoa2V5KTtcbiAgICAgIHJldHVybiBkZWNvZGVkUHJ2Lmxlbmd0aCA9PT0gbmFjbC5zaWduLnNlY3JldEtleUxlbmd0aCAvIDI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHVibGljS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgbGV0IHB1YktleSA9IGtleTtcblxuICAgIC8vIGNvbnZlcnQgYmFzZTU4IHB1YiBrZXkgdG8gaGV4IGZvcm1hdFxuICAgIC8vIHRzcyBjb21tb24gcHViIGlzIGluIGJhc2U1OCBmb3JtYXQgYW5kIGRlY29kZXMgdG8gbGVuZ3RoIG9mIDMyXG4gICAgaWYgKGlzQmFzZTU4KHB1YktleSwgMzIpKSB7XG4gICAgICBjb25zdCBiYXNlNThEZWNvZGUgPSBiczU4LmRlY29kZShwdWJLZXkpO1xuICAgICAgcHViS2V5ID0gYmFzZTU4RGVjb2RlLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHViS2V5KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2lnbmF0dXJlVThhID0gdThhVG9VOGEoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gWzY0LCA2NSwgNjZdLmluY2x1ZGVzKHNpZ25hdHVyZVU4YS5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSBzaWduYXR1cmUgb24gYSBnaXZlbiBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduZWRNZXNzYWdlIHRoZSBzaWduZWQgbWVzc2FnZSBmb3IgdGhlIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIHRoZSBhZGRyZXNzIG9mIHRoZSBzaWduZXJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBvciBub3RcbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZShzaWduZWRNZXNzYWdlOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBkZWNvZGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGhleFB1YmxpY0tleSA9IHU4YVRvSGV4KHB1YmxpY0tleSk7XG5cbiAgICByZXR1cm4gc2lnbmF0dXJlVmVyaWZ5KHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSwgaGV4UHVibGljS2V5KS5pc1ZhbGlkO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRUcmFuc2FjdGlvbklkKHR4SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0hleCh0eElkLCAyNTYpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZVNlZWQgZGVjb2RlcyBhIGRvdCBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkIC0gdGhlIHNlZWQgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJucyB7U2VlZH0gLSB0aGUgb2JqZWN0IFNlZWRcbiAgICovXG4gIGRlY29kZVNlZWQoc2VlZDogc3RyaW5nKTogU2VlZCB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGJhc2UzMi5kZWNvZGUuYXNCeXRlcyhzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VlZDogQnVmZmVyLmZyb20oZGVjb2RlZCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNhcGl0YWxpemVGaXJzdExldHRlcih2YWw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGVjb2RlIHRoZSBpbnRlcm5hbCBtZXRob2QgaGV4IGluIGNhc2Ugb2YgYSBwcm94eSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVuc2lnbmVkVHJhbnNhY3Rpb259IHR4XG4gICAqIEBwYXJhbSB7IG1ldGFkYXRhUnBjOiBzdHJpbmc7IHJlZ2lzdHJ5OiBUeXBlUmVnaXN0cnkgfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtUcmFuc2ZlckFyZ3N9XG4gICAqL1xuICBkZWNvZGVDYWxsTWV0aG9kKFxuICAgIHR4OiBzdHJpbmcgfCBVbnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIG9wdGlvbnM6IHsgbWV0YWRhdGFScGM6IHN0cmluZzsgcmVnaXN0cnk6IFR5cGVSZWdpc3RyeSB9LFxuICApOiBUcmFuc2ZlckFyZ3Mge1xuICAgIGNvbnN0IHsgcmVnaXN0cnkgfSA9IG9wdGlvbnM7XG4gICAgbGV0IG1ldGhvZENhbGw6IEdlbmVyaWNDYWxsIHwgR2VuZXJpY0V4dHJpbnNpYztcbiAgICBpZiAodHlwZW9mIHR4ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZDogR2VuZXJpY0V4dHJpbnNpY1BheWxvYWQgPSBjcmVhdGVUeXBlVW5zYWZlKHJlZ2lzdHJ5LCAnRXh0cmluc2ljUGF5bG9hZCcsIFtcbiAgICAgICAgICB0eCxcbiAgICAgICAgICB7IHZlcnNpb246IEVYVFJJTlNJQ19WRVJTSU9OIH0sXG4gICAgICAgIF0pO1xuICAgICAgICBtZXRob2RDYWxsID0gY3JlYXRlVHlwZVVuc2FmZShyZWdpc3RyeSwgJ0NhbGwnLCBbcGF5bG9hZC5tZXRob2RdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbWV0aG9kQ2FsbCA9IHJlZ2lzdHJ5LmNyZWF0ZVR5cGUoJ0V4dHJpbnNpYycsIGhleFRvVThhKHR4KSwge1xuICAgICAgICAgIGlzU2lnbmVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kQ2FsbCA9IHJlZ2lzdHJ5LmNyZWF0ZVR5cGUoJ0NhbGwnLCB0eC5tZXRob2QpO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBtZXRob2RDYWxsLmFyZ3NbUFJPWFlfTUVUSE9EX0FSR107XG4gICAgY29uc3QgZGVjb2RlZEFyZ3MgPSBtZXRob2QudG9KU09OKCkgYXMgdW5rbm93biBhcyBQcm94eUNhbGxBcmdzO1xuICAgIHJldHVybiBkZWNvZGVkQXJncy5hcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIGtleVBhaXJGcm9tU2VlZCBnZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggc2VjcmV0S2V5IGFuZCBwdWJsaWNLZXkgdXNpbmcgdGhlIHBvbGthZG90IHNka1xuICAgKiBAcGFyYW0gc2VlZCAzMiBieXRlcyBsb25nIHNlZWRcbiAgICogQHJldHVybnMgS2V5UGFpclxuICAgKi9cbiAga2V5UGFpckZyb21TZWVkKHNlZWQ6IFVpbnQ4QXJyYXkpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBrZXlyaW5nID0gbmV3IEtleXJpbmcoeyB0eXBlOiAnZWQyNTUxOScgfSk7XG4gICAgY29uc3Qga2V5cmluZ1BhaXIgPSBrZXlyaW5nLmFkZEZyb21TZWVkKHNlZWQpO1xuICAgIGNvbnN0IHBhaXJKc29uID0ga2V5cmluZ1BhaXIudG9Kc29uKCk7XG4gICAgY29uc3QgZGVjb2RlZEtleVBhaXIgPSBkZWNvZGVQYWlyKCcnLCBiYXNlNjREZWNvZGUocGFpckpzb24uZW5jb2RlZCksIHBhaXJKc29uLmVuY29kaW5nLnR5cGUpO1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHBydjogQnVmZmVyLmZyb20oZGVjb2RlZEtleVBhaXIuc2VjcmV0S2V5KS50b1N0cmluZygnaGV4JykgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbmluZyBmdW5jdGlvbi4gSW1wbGVtZW50IHRoaXMgb24gdGhlIE9GRkxJTkUgc2lnbmluZyBkZXZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5cmluZ1BhaXJ9IHBhaXIgLSBUaGUgc2lnbmluZyBwYWlyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmluZ1BheWxvYWQgLSBQYXlsb2FkIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7VW5zaWduZWRUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSByYXcgdHJhbnNhY3Rpb24gdG8gc2lnblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0hleFN0cmluZ30gb3B0aW9ucy5tZXRhZGF0YVJwYyAtIG1ldGFkYXRhIHRoYXQgaXMgbmVlZGVkIGZvciBkb3QgdG8gc2lnblxuICAgKiBAcGFyYW0ge1R5cGVSZWdpc3RyeX0gb3B0aW9ucy5yZWdpc3RyeSAtIG1ldGFkYXRhIHRoYXQgaXMgbmVlZGVkIGZvciBkb3QgdG8gc2lnblxuICAgKi9cbiAgY3JlYXRlU2lnbmVkVHgoXG4gICAgcGFpcjogS2V5cmluZ1BhaXIsXG4gICAgc2lnbmluZ1BheWxvYWQ6IHN0cmluZyxcbiAgICB0cmFuc2FjdGlvbjogVW5zaWduZWRUcmFuc2FjdGlvbixcbiAgICBvcHRpb25zOiB7IG1ldGFkYXRhUnBjOiBIZXhTdHJpbmc7IHJlZ2lzdHJ5OiBUeXBlUmVnaXN0cnkgfSxcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHJlZ2lzdHJ5LCBtZXRhZGF0YVJwYyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gcmVnaXN0cnlcbiAgICAgIC5jcmVhdGVUeXBlKCdFeHRyaW5zaWNQYXlsb2FkJywgc2lnbmluZ1BheWxvYWQsIHtcbiAgICAgICAgdmVyc2lvbjogRVhUUklOU0lDX1ZFUlNJT04sXG4gICAgICB9KVxuICAgICAgLnNpZ24ocGFpcik7XG5cbiAgICAvLyBTZXJpYWxpemUgYSBzaWduZWQgdHJhbnNhY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplU2lnbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgbWV0YWRhdGFScGMsIHJlZ2lzdHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIHNlcmlhbGl6ZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFNpZ25hdHVyZSBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0gbWV0YWRhdGFScGMgTmV0d29yayBtZXRhZGF0YVxuICAgKiBAcGFyYW0gcmVnaXN0cnkgVHJhbnNhY3Rpb24gcmVnaXN0cnlcbiAgICogQHJldHVybnMgc3RyaW5nIFNlcmlhbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNlcmlhbGl6ZVNpZ25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIG1ldGFkYXRhUnBjOiBgMHgke3N0cmluZ31gLCByZWdpc3RyeSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdC5zaWduZWRUeCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCB7XG4gICAgICBtZXRhZGF0YVJwYyxcbiAgICAgIHJlZ2lzdHJ5LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIGRvdCBhZGRyZXNzIGZyb20gdGhlIGdpdmVuIGZvcm1hdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3NzNThGb3JtYXRdXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBkZWNvZGVEb3RBZGRyZXNzKGFkZHJlc3M6IHN0cmluZywgc3M1OEZvcm1hdD86IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3Qga2V5cGFpciA9IG5ldyBLZXlQYWlyKHsgcHViOiBCdWZmZXIuZnJvbShkZWNvZGVBZGRyZXNzKGFkZHJlc3MsIHVuZGVmaW5lZCwgc3M1OEZvcm1hdCkpLnRvU3RyaW5nKCdoZXgnKSB9KTtcbiAgICByZXR1cm4ga2V5cGFpci5nZXRBZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgZG90IGFkZHJlc3MgZnJvbSB0aGUgZ2l2ZW4gZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3M1OEZvcm1hdF1cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuY29kZURvdEFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBzczU4Rm9ybWF0PzogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyhhZGRyZXNzLCBzczU4Rm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHR4SGFzaCBvZiBhIHNpZ25lZCB0eEhleFxuICAgKlxuICAgKiBAcGFyYW0gdHhIZXggc2lnbmVkIHRyYW5zYWN0aW9uIGhleFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VHhIYXNoKHR4SGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb25zdHJ1Y3QudHhIYXNoKHR4SGV4KTtcbiAgfVxuXG4gIGdldE1hdGVyaWFsKGNvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KTogTWF0ZXJpYWwge1xuICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBjb2luQ29uZmlnLm5ldHdvcmsgYXMgRG90TmV0d29yaztcbiAgICBjb25zdCB7IHNwZWNOYW1lLCBzcGVjVmVyc2lvbiwgY2hhaW5OYW1lLCB0eFZlcnNpb24sIGdlbmVzaXNIYXNoIH0gPSBuZXR3b3JrQ29uZmlnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwZWNOYW1lLFxuICAgICAgc3BlY1ZlcnNpb24sXG4gICAgICBjaGFpbk5hbWUsXG4gICAgICBtZXRhZGF0YTogbmV0d29ya0NvbmZpZy5tZXRhZGF0YVJwYyxcbiAgICAgIHR4VmVyc2lvbixcbiAgICAgIGdlbmVzaXNIYXNoLFxuICAgIH0gYXMgTWF0ZXJpYWw7XG4gIH1cblxuICBpc1NpZ25pbmdQYXlsb2FkKHBheWxvYWQ6IERlY29kZWRTaWduaW5nUGF5bG9hZCB8IERlY29kZWRTaWduZWRUeCk6IHBheWxvYWQgaXMgRGVjb2RlZFNpZ25pbmdQYXlsb2FkIHtcbiAgICByZXR1cm4gKHBheWxvYWQgYXMgRGVjb2RlZFNpZ25pbmdQYXlsb2FkKS5ibG9ja0hhc2ggIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlzUHJveHlUcmFuc2Zlcihhcmc6IFR4TWV0aG9kWydhcmdzJ10pOiBhcmcgaXMgUHJveHlBcmdzIHtcbiAgICByZXR1cm4gKGFyZyBhcyBQcm94eUFyZ3MpLnJlYWwgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlzVHJhbnNmZXIoYXJnOiBUeE1ldGhvZFsnYXJncyddKTogYXJnIGlzIFRyYW5zZmVyQXJncyB7XG4gICAgcmV0dXJuIChhcmcgYXMgVHJhbnNmZXJBcmdzKS5kZXN0Py5pZCAhPT0gdW5kZWZpbmVkICYmIChhcmcgYXMgVHJhbnNmZXJBcmdzKS52YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIGV4dHJhY3RzIGFuZCByZXR1cm5zIHRoZSBzaWduYXR1cmUgaW4gaGV4IGZvcm1hdCBnaXZlbiBhIHJhdyBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd1R4IHNpZ25lZCByYXcgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIG9wdGlvbnMgcmVnaXN0cnkgZG90IHJlZ2lzdHJ5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgcmVjb3ZlclNpZ25hdHVyZUZyb21SYXdUeChyYXdUeDogc3RyaW5nLCBvcHRpb25zOiB7IHJlZ2lzdHJ5OiBUeXBlUmVnaXN0cnkgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyByZWdpc3RyeSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBtZXRob2RDYWxsID0gcmVnaXN0cnkuY3JlYXRlVHlwZSgnRXh0cmluc2ljJywgcmF3VHgsIHtcbiAgICAgIGlzU2lnbmVkOiB0cnVlLFxuICAgIH0pO1xuICAgIGxldCBzaWduYXR1cmUgPSB1OGFUb0hleChtZXRob2RDYWxsLnNpZ25hdHVyZSkgYXMgc3RyaW5nO1xuXG4gICAgLy8gcmVtb3ZlIDB4IGZyb20gdGhlIHNpZ25hdHVyZSBzaW5jZSB0aGlzIGlzIGhvdyBpdCdzIHJldHVybmVkIGZyb20gVFNTIHNpZ25pbmdcbiAgICBpZiAoc2lnbmF0dXJlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5zdWJzdHIoMik7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgZG90IGFkZHJlc3MgZnJvbSB0aGUgZ2l2ZW4gZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3M1OEZvcm1hdF1cbiAgICogQHJldHVybnMge0tleVBhaXJ9XG4gICAqL1xuICBkZWNvZGVEb3RBZGRyZXNzVG9LZXlQYWlyKGFkZHJlc3M6IHN0cmluZywgc3M1OEZvcm1hdD86IG51bWJlcik6IEtleVBhaXIge1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHB1YjogQnVmZmVyLmZyb20oZGVjb2RlQWRkcmVzcyhhZGRyZXNzLCB1bmRlZmluZWQsIHNzNThGb3JtYXQpKS50b1N0cmluZygnaGV4JykgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgaGV4IHN0cmluZyB3aXRoIHdpdGggMCB2YWx1ZVxuICAgKiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiB0cmFuc2FjdGlvbiBpcyBpbW1vcnRhbCBvciBtb3J0YWxcbiAgICogQHBhcmFtIGhleFZhbHVlXG4gICAqL1xuICBpc1plcm9IZXgoaGV4VmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBoZXhWYWx1ZSA9PT0gJzB4MDAnO1xuICB9XG59XG5cbmNvbnN0IHV0aWxzID0gbmV3IFV0aWxzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxzO1xuIl19