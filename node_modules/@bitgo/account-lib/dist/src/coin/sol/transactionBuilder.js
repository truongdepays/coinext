"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var transaction_1 = require("./transaction");
var web3_js_1 = require("@solana/web3.js");
var utils_1 = require("./utils");
var _1 = require(".");
var constants_1 = require("./constants");
var solInstructionFactory_1 = require("./solInstructionFactory");
var assert_1 = __importDefault(require("assert"));
var instructionParamsFactory_1 = require("./instructionParamsFactory");
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    function TransactionBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._signatures = [];
        _this._instructionsData = [];
        _this._signers = [];
        _this.transaction = new transaction_1.Transaction(_coinConfig);
        return _this;
    }
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     */
    TransactionBuilder.prototype.initBuilder = function (tx) {
        this._transaction = tx;
        var txData = tx.toJson();
        this.sender(txData.feePayer);
        this.nonce(txData.nonce, txData.durableNonce);
        this._instructionsData = instructionParamsFactory_1.instructionParamsFactory(tx.type, tx.solTransaction.instructions);
        for (var _i = 0, _a = this._instructionsData; _i < _a.length; _i++) {
            var instruction = _a[_i];
            if (instruction.type === constants_1.InstructionBuilderTypes.Memo) {
                var memoInstruction = instruction;
                this.memo(memoInstruction.params.memo);
            }
            if (instruction.type === constants_1.InstructionBuilderTypes.NonceAdvance) {
                var advanceNonceInstruction = instruction;
                this.nonce(txData.nonce, advanceNonceInstruction.params);
            }
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        var tx = new transaction_1.Transaction(this._coinConfig);
        this.validateRawTransaction(rawTransaction);
        tx.fromRawTransaction(rawTransaction);
        this.initBuilder(tx);
        return this.transaction;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.transaction.solTransaction = this.buildSolTransaction();
                this.transaction.setTransactionType(this.transactionType);
                this.transaction.loadInputsAndOutputs();
                return [2 /*return*/, this.transaction];
            });
        });
    };
    /**
     * Builds the solana transaction.
     */
    TransactionBuilder.prototype.buildSolTransaction = function () {
        var _a, _b, _c, _d;
        assert_1.default(this._sender, new errors_1.BuildTransactionError('sender is required before building'));
        assert_1.default(this._recentBlockhash, new errors_1.BuildTransactionError('recent blockhash is required before building'));
        var tx = new web3_js_1.Transaction();
        if ((_b = (_a = this._transaction) === null || _a === void 0 ? void 0 : _a.solTransaction) === null || _b === void 0 ? void 0 : _b.signatures) {
            tx.signatures = (_d = (_c = this._transaction) === null || _c === void 0 ? void 0 : _c.solTransaction) === null || _d === void 0 ? void 0 : _d.signatures;
        }
        tx.feePayer = new web3_js_1.PublicKey(this._sender);
        if (this._nonceInfo) {
            tx.nonceInfo = {
                nonce: this._recentBlockhash,
                nonceInstruction: solInstructionFactory_1.solInstructionFactory(this._nonceInfo)[0],
            };
        }
        else {
            tx.recentBlockhash = this._recentBlockhash;
        }
        for (var _i = 0, _e = this._instructionsData; _i < _e.length; _i++) {
            var instruction = _e[_i];
            tx.add.apply(tx, solInstructionFactory_1.solInstructionFactory(instruction));
        }
        if (this._memo) {
            var memoData = {
                type: constants_1.InstructionBuilderTypes.Memo,
                params: {
                    memo: this._memo,
                },
            };
            this._instructionsData.push(memoData);
            tx.add.apply(tx, solInstructionFactory_1.solInstructionFactory(memoData));
        }
        this._transaction.lamportsPerSignature = this._lamportsPerSignature;
        for (var _f = 0, _g = this._signers; _f < _g.length; _f++) {
            var signer = _g[_f];
            var publicKey = new web3_js_1.PublicKey(signer.getKeys().pub);
            var secretKey = signer.getKeys(true).prv;
            assert_1.default(secretKey instanceof Uint8Array);
            tx.partialSign({ publicKey: publicKey, secretKey: secretKey });
        }
        for (var _h = 0, _j = this._signatures; _h < _j.length; _h++) {
            var signature = _j[_h];
            var solPublicKey = new web3_js_1.PublicKey(signature.publicKey.pub);
            tx.addSignature(solPublicKey, signature.signature);
        }
        return tx;
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        // region Getters and Setters
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: false,
        configurable: true
    });
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        this.validateKey(key);
        this.checkDuplicatedSigner(key);
        var prv = key.key;
        var signer = new _1.KeyPair({ prv: prv });
        this._signers.push(signer);
        return this._transaction;
    };
    /** @inheritDoc */
    TransactionBuilder.prototype.addSignature = function (publicKey, signature) {
        this._signatures.push({ publicKey: publicKey, signature: signature });
    };
    /**
     * Sets the sender of this transaction.
     * This account will be responsible for paying transaction fees.
     *
     * @param {string} senderAddress the account that is sending this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.sender = function (senderAddress) {
        utils_1.validateAddress(senderAddress, 'sender');
        this._sender = senderAddress;
        return this;
    };
    /**
     * Set the transaction nonce
     * Requires both optional params in order to use the durable nonce
     *
     * @param {Blockhash} blockHash The latest blockHash
     * @param {DurableNonceParams} [durableNonceParams] An object containing the walletNonceAddress and the authWalletAddress (required for durable nonce)
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.nonce = function (blockHash, durableNonceParams) {
        if (!blockHash || !utils_1.isValidBlockId(blockHash)) {
            throw new errors_1.BuildTransactionError('Invalid or missing blockHash, got: ' + blockHash);
        }
        if (durableNonceParams) {
            utils_1.validateAddress(durableNonceParams.walletNonceAddress, 'walletNonceAddress');
            utils_1.validateAddress(durableNonceParams.authWalletAddress, 'authWalletAddress');
            if (durableNonceParams.walletNonceAddress === durableNonceParams.authWalletAddress) {
                throw new errors_1.BuildTransactionError('Invalid params: walletNonceAddress cannot be equal to authWalletAddress');
            }
            this._nonceInfo = {
                type: constants_1.InstructionBuilderTypes.NonceAdvance,
                params: durableNonceParams,
            };
        }
        this._recentBlockhash = blockHash;
        return this;
    };
    /**
     *  Set the memo
     *
     * @param {string} memo
     * @returns {TransactionBuilder} This transaction builder
     */
    TransactionBuilder.prototype.memo = function (memo) {
        this.validateMemo(memo);
        this._memo = memo;
        return this;
    };
    TransactionBuilder.prototype.fee = function (feeOptions) {
        this._lamportsPerSignature = Number(feeOptions.amount);
        return this;
    };
    // endregion
    // region Validators
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address, addressFormat) {
        if (!utils_1.isValidAddress(address.address)) {
            throw new errors_1.BuildTransactionError('Invalid address ' + address.address);
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        var keyPair;
        try {
            keyPair = new _1.KeyPair({ prv: key.key });
        }
        catch (_a) {
            throw new errors_1.BuildTransactionError('Invalid key');
        }
        if (!keyPair.getKeys().prv) {
            throw new errors_1.BuildTransactionError('Invalid key');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        utils_1.validateRawTransaction(rawTransaction);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        this.validateSender();
        this.validateNonce();
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThan(0)) {
            throw new errors_1.BuildTransactionError('Value cannot be less than zero');
        }
    };
    /** Validates the memo
     *
     * @param {string} memo - the memo as string
     */
    TransactionBuilder.prototype.validateMemo = function (memo) {
        if (!memo) {
            throw new errors_1.BuildTransactionError('Invalid memo, got: ' + memo);
        }
        if (!utils_1.isValidMemo(memo)) {
            throw new errors_1.BuildTransactionError('Memo is too long');
        }
    };
    /**
     * Validates that the given key is not already in this._signers
     *
     * @param {BaseKey} key - The key to check
     */
    TransactionBuilder.prototype.checkDuplicatedSigner = function (key) {
        this._signers.forEach(function (kp) {
            if (kp.getKeys().prv === key.key) {
                throw new errors_1.SigningError('Duplicated signer: ' + key.key);
            }
        });
    };
    /**
     * Validates that the sender field is defined
     */
    TransactionBuilder.prototype.validateSender = function () {
        if (this._sender === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing sender');
        }
    };
    /**
     * Validates that the nonce field is defined
     */
    TransactionBuilder.prototype.validateNonce = function () {
        if (this._recentBlockhash === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing nonce blockhash');
        }
    };
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vc29sL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSx3Q0FBaUY7QUFDakYsNkNBQXlFO0FBRXpFLDZDQUE0QztBQUM1QywyQ0FBc0Y7QUFDdEYsaUNBQStHO0FBQy9HLHNCQUE0QjtBQUM1Qix5Q0FBc0Q7QUFDdEQsaUVBQWdFO0FBQ2hFLGtEQUE0QjtBQUU1Qix1RUFBc0U7QUFFdEU7SUFBaUQsc0NBQXNCO0lBWXJFLDRCQUFZLFdBQWlDO1FBQTdDLFlBQ0Usa0JBQU0sV0FBVyxDQUFDLFNBRW5CO1FBYk8saUJBQVcsR0FBMEIsRUFBRSxDQUFDO1FBTXRDLHVCQUFpQixHQUF3QixFQUFFLENBQUM7UUFDNUMsY0FBUSxHQUFjLEVBQUUsQ0FBQztRQUtqQyxLQUFJLENBQUMsV0FBVyxHQUFHLElBQUkseUJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7SUFDbEQsQ0FBQztJQU9EOzs7O09BSUc7SUFDSCx3Q0FBVyxHQUFYLFVBQVksRUFBZTtRQUN6QixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBa0IsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLG1EQUF3QixDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUUzRixLQUEw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QyxFQUFFO1lBQ3RCLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxrREFBcUIsR0FBN0IsVUFBOEIsR0FBWTtRQUN4QyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEVBQUU7WUFDdkIsSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2hDLE1BQU0sSUFBSSxxQkFBWSxDQUFDLHFCQUFxQixHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN6RDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ssMkNBQWMsR0FBdEI7UUFDRSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFFO1lBQzlCLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1NBQ3hFO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssMENBQWEsR0FBckI7UUFDRSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTLEVBQUU7WUFDdkMsTUFBTSxJQUFJLDhCQUFxQixDQUFDLDhDQUE4QyxDQUFDLENBQUM7U0FDakY7SUFDSCxDQUFDO0lBRUgseUJBQUM7QUFBRCxDQUFDLEFBL1JELENBQWlELGlDQUFzQixHQStSdEU7QUEvUnFCLGdEQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyLCBJbnRlcmZhY2UsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciwgU2lnbmluZ0Vycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IEJhc2VBZGRyZXNzLCBCYXNlS2V5LCBGZWVPcHRpb25zLCBQdWJsaWNLZXkgYXMgQmFzZVB1YmxpY0tleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBCbG9ja2hhc2gsIFB1YmxpY0tleSwgVHJhbnNhY3Rpb24gYXMgU29sVHJhbnNhY3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgaXNWYWxpZEFkZHJlc3MsIGlzVmFsaWRCbG9ja0lkLCBpc1ZhbGlkTWVtbywgdmFsaWRhdGVBZGRyZXNzLCB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLic7XG5pbXBvcnQgeyBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IHNvbEluc3RydWN0aW9uRmFjdG9yeSB9IGZyb20gJy4vc29sSW5zdHJ1Y3Rpb25GYWN0b3J5JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IER1cmFibGVOb25jZVBhcmFtcywgSW5zdHJ1Y3Rpb25QYXJhbXMsIE1lbW8sIE5vbmNlIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBpbnN0cnVjdGlvblBhcmFtc0ZhY3RvcnkgfSBmcm9tICcuL2luc3RydWN0aW9uUGFyYW1zRmFjdG9yeSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJvdGVjdGVkIF90cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247XG4gIHByaXZhdGUgX3NpZ25hdHVyZXM6IEludGVyZmFjZS5TaWduYXR1cmVbXSA9IFtdO1xuICBwcml2YXRlIF9sYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBfc2VuZGVyOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfcmVjZW50QmxvY2toYXNoOiBCbG9ja2hhc2g7XG4gIHByb3RlY3RlZCBfbm9uY2VJbmZvOiBOb25jZTtcbiAgcHJvdGVjdGVkIF9pbnN0cnVjdGlvbnNEYXRhOiBJbnN0cnVjdGlvblBhcmFtc1tdID0gW107XG4gIHByb3RlY3RlZCBfc2lnbmVyczogS2V5UGFpcltdID0gW107XG4gIHByb3RlY3RlZCBfbWVtbz86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGJ1aWxkZXIgZmllbGRzIHVzaW5nIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggdGhlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICovXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHg7XG4gICAgY29uc3QgdHhEYXRhID0gdHgudG9Kc29uKCk7XG4gICAgdGhpcy5zZW5kZXIodHhEYXRhLmZlZVBheWVyIGFzIHN0cmluZyk7XG4gICAgdGhpcy5ub25jZSh0eERhdGEubm9uY2UsIHR4RGF0YS5kdXJhYmxlTm9uY2UpO1xuICAgIHRoaXMuX2luc3RydWN0aW9uc0RhdGEgPSBpbnN0cnVjdGlvblBhcmFtc0ZhY3RvcnkodHgudHlwZSwgdHguc29sVHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSkge1xuICAgICAgaWYgKGluc3RydWN0aW9uLnR5cGUgPT09IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLk1lbW8pIHtcbiAgICAgICAgY29uc3QgbWVtb0luc3RydWN0aW9uOiBNZW1vID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMubWVtbyhtZW1vSW5zdHJ1Y3Rpb24ucGFyYW1zLm1lbW8pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24udHlwZSA9PT0gSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuTm9uY2VBZHZhbmNlKSB7XG4gICAgICAgIGNvbnN0IGFkdmFuY2VOb25jZUluc3RydWN0aW9uOiBOb25jZSA9IGluc3RydWN0aW9uO1xuICAgICAgICB0aGlzLm5vbmNlKHR4RGF0YS5ub25jZSwgYWR2YW5jZU5vbmNlSW5zdHJ1Y3Rpb24ucGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcpO1xuICAgIHRoaXMudmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gICAgdHguZnJvbVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uKTtcbiAgICB0aGlzLmluaXRCdWlsZGVyKHR4KTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5zb2xUcmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRTb2xUcmFuc2FjdGlvbigpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb25UeXBlKHRoaXMudHJhbnNhY3Rpb25UeXBlKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLmxvYWRJbnB1dHNBbmRPdXRwdXRzKCk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBzb2xhbmEgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRTb2xUcmFuc2FjdGlvbigpOiBTb2xUcmFuc2FjdGlvbiB7XG4gICAgYXNzZXJ0KHRoaXMuX3NlbmRlciwgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignc2VuZGVyIGlzIHJlcXVpcmVkIGJlZm9yZSBidWlsZGluZycpKTtcbiAgICBhc3NlcnQodGhpcy5fcmVjZW50QmxvY2toYXNoLCBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdyZWNlbnQgYmxvY2toYXNoIGlzIHJlcXVpcmVkIGJlZm9yZSBidWlsZGluZycpKTtcblxuICAgIGNvbnN0IHR4ID0gbmV3IFNvbFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uPy5zb2xUcmFuc2FjdGlvbj8uc2lnbmF0dXJlcykge1xuICAgICAgdHguc2lnbmF0dXJlcyA9IHRoaXMuX3RyYW5zYWN0aW9uPy5zb2xUcmFuc2FjdGlvbj8uc2lnbmF0dXJlcztcbiAgICB9XG5cbiAgICB0eC5mZWVQYXllciA9IG5ldyBQdWJsaWNLZXkodGhpcy5fc2VuZGVyKTtcblxuICAgIGlmICh0aGlzLl9ub25jZUluZm8pIHtcbiAgICAgIHR4Lm5vbmNlSW5mbyA9IHtcbiAgICAgICAgbm9uY2U6IHRoaXMuX3JlY2VudEJsb2NraGFzaCxcbiAgICAgICAgbm9uY2VJbnN0cnVjdGlvbjogc29sSW5zdHJ1Y3Rpb25GYWN0b3J5KHRoaXMuX25vbmNlSW5mbylbMF0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0eC5yZWNlbnRCbG9ja2hhc2ggPSB0aGlzLl9yZWNlbnRCbG9ja2hhc2g7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSkge1xuICAgICAgdHguYWRkKC4uLnNvbEluc3RydWN0aW9uRmFjdG9yeShpbnN0cnVjdGlvbikpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tZW1vKSB7XG4gICAgICBjb25zdCBtZW1vRGF0YTogTWVtbyA9IHtcbiAgICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuTWVtbyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbWVtbzogdGhpcy5fbWVtbyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhLnB1c2gobWVtb0RhdGEpO1xuICAgICAgdHguYWRkKC4uLnNvbEluc3RydWN0aW9uRmFjdG9yeShtZW1vRGF0YSkpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zYWN0aW9uLmxhbXBvcnRzUGVyU2lnbmF0dXJlID0gdGhpcy5fbGFtcG9ydHNQZXJTaWduYXR1cmU7XG5cbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiB0aGlzLl9zaWduZXJzKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KHNpZ25lci5nZXRLZXlzKCkucHViKTtcbiAgICAgIGNvbnN0IHNlY3JldEtleSA9IHNpZ25lci5nZXRLZXlzKHRydWUpLnBydjtcbiAgICAgIGFzc2VydChzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICAgIHR4LnBhcnRpYWxTaWduKHsgcHVibGljS2V5LCBzZWNyZXRLZXkgfSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5fc2lnbmF0dXJlcykge1xuICAgICAgY29uc3Qgc29sUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShzaWduYXR1cmUucHVibGljS2V5LnB1Yik7XG4gICAgICB0eC5hZGRTaWduYXR1cmUoc29sUHVibGljS2V5LCBzaWduYXR1cmUuc2lnbmF0dXJlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHg7XG4gIH1cblxuICAvLyByZWdpb24gR2V0dGVycyBhbmQgU2V0dGVyc1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzZXQgdHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2lnbkltcGxlbWVudGF0aW9uKGtleTogQmFzZUtleSk6IFRyYW5zYWN0aW9uIHtcbiAgICB0aGlzLnZhbGlkYXRlS2V5KGtleSk7XG4gICAgdGhpcy5jaGVja0R1cGxpY2F0ZWRTaWduZXIoa2V5KTtcbiAgICBjb25zdCBwcnYgPSBrZXkua2V5O1xuICAgIGNvbnN0IHNpZ25lciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBwcnYgfSk7XG4gICAgdGhpcy5fc2lnbmVycy5wdXNoKHNpZ25lcik7XG5cbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgYWRkU2lnbmF0dXJlKHB1YmxpY0tleTogQmFzZVB1YmxpY0tleSwgc2lnbmF0dXJlOiBCdWZmZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2goeyBwdWJsaWNLZXksIHNpZ25hdHVyZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICogVGhpcyBhY2NvdW50IHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIHBheWluZyB0cmFuc2FjdGlvbiBmZWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVyQWRkcmVzcyB0aGUgYWNjb3VudCB0aGF0IGlzIHNlbmRpbmcgdGhpcyB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSBUaGlzIHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIHNlbmRlcihzZW5kZXJBZGRyZXNzOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB2YWxpZGF0ZUFkZHJlc3Moc2VuZGVyQWRkcmVzcywgJ3NlbmRlcicpO1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlckFkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiBub25jZVxuICAgKiBSZXF1aXJlcyBib3RoIG9wdGlvbmFsIHBhcmFtcyBpbiBvcmRlciB0byB1c2UgdGhlIGR1cmFibGUgbm9uY2VcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja2hhc2h9IGJsb2NrSGFzaCBUaGUgbGF0ZXN0IGJsb2NrSGFzaFxuICAgKiBAcGFyYW0ge0R1cmFibGVOb25jZVBhcmFtc30gW2R1cmFibGVOb25jZVBhcmFtc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHdhbGxldE5vbmNlQWRkcmVzcyBhbmQgdGhlIGF1dGhXYWxsZXRBZGRyZXNzIChyZXF1aXJlZCBmb3IgZHVyYWJsZSBub25jZSlcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBub25jZShibG9ja0hhc2g6IEJsb2NraGFzaCwgZHVyYWJsZU5vbmNlUGFyYW1zPzogRHVyYWJsZU5vbmNlUGFyYW1zKTogdGhpcyB7XG4gICAgaWYgKCFibG9ja0hhc2ggfHwgIWlzVmFsaWRCbG9ja0lkKGJsb2NrSGFzaCkpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgb3IgbWlzc2luZyBibG9ja0hhc2gsIGdvdDogJyArIGJsb2NrSGFzaCk7XG4gICAgfVxuICAgIGlmIChkdXJhYmxlTm9uY2VQYXJhbXMpIHtcbiAgICAgIHZhbGlkYXRlQWRkcmVzcyhkdXJhYmxlTm9uY2VQYXJhbXMud2FsbGV0Tm9uY2VBZGRyZXNzLCAnd2FsbGV0Tm9uY2VBZGRyZXNzJyk7XG4gICAgICB2YWxpZGF0ZUFkZHJlc3MoZHVyYWJsZU5vbmNlUGFyYW1zLmF1dGhXYWxsZXRBZGRyZXNzLCAnYXV0aFdhbGxldEFkZHJlc3MnKTtcbiAgICAgIGlmIChkdXJhYmxlTm9uY2VQYXJhbXMud2FsbGV0Tm9uY2VBZGRyZXNzID09PSBkdXJhYmxlTm9uY2VQYXJhbXMuYXV0aFdhbGxldEFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBwYXJhbXM6IHdhbGxldE5vbmNlQWRkcmVzcyBjYW5ub3QgYmUgZXF1YWwgdG8gYXV0aFdhbGxldEFkZHJlc3MnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX25vbmNlSW5mbyA9IHtcbiAgICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuTm9uY2VBZHZhbmNlLFxuICAgICAgICBwYXJhbXM6IGR1cmFibGVOb25jZVBhcmFtcyxcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX3JlY2VudEJsb2NraGFzaCA9IGJsb2NrSGFzaDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiAgU2V0IHRoZSBtZW1vXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZW1vXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkJ1aWxkZXJ9IFRoaXMgdHJhbnNhY3Rpb24gYnVpbGRlclxuICAgKi9cbiAgbWVtbyhtZW1vOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlTWVtbyhtZW1vKTtcbiAgICB0aGlzLl9tZW1vID0gbWVtbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZlZShmZWVPcHRpb25zOiBGZWVPcHRpb25zKTogdGhpcyB7XG4gICAgdGhpcy5fbGFtcG9ydHNQZXJTaWduYXR1cmUgPSBOdW1iZXIoZmVlT3B0aW9ucy5hbW91bnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFZhbGlkYXRvcnNcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBCYXNlQWRkcmVzcywgYWRkcmVzc0Zvcm1hdD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghaXNWYWxpZEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBhZGRyZXNzICcgKyBhZGRyZXNzLmFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUtleShrZXk6IEJhc2VLZXkpOiB2b2lkIHtcbiAgICBsZXQga2V5UGFpcjogS2V5UGFpcjtcbiAgICB0cnkge1xuICAgICAga2V5UGFpciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBrZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIWtleVBhaXIuZ2V0S2V5cygpLnBydikge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBrZXknKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogdm9pZCB7XG4gICAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy52YWxpZGF0ZVNlbmRlcigpO1xuICAgIHRoaXMudmFsaWRhdGVOb25jZSgpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVmFsdWUodmFsdWU6IEJpZ051bWJlcik6IHZvaWQge1xuICAgIGlmICh2YWx1ZS5pc0xlc3NUaGFuKDApKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdWYWx1ZSBjYW5ub3QgYmUgbGVzcyB0aGFuIHplcm8nKTtcbiAgICB9XG4gIH1cbiAgLyoqIFZhbGlkYXRlcyB0aGUgbWVtb1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtbyAtIHRoZSBtZW1vIGFzIHN0cmluZ1xuICAgKi9cbiAgdmFsaWRhdGVNZW1vKG1lbW86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghbWVtbykge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBtZW1vLCBnb3Q6ICcgKyBtZW1vKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkTWVtbyhtZW1vKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignTWVtbyBpcyB0b28gbG9uZycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCBhbHJlYWR5IGluIHRoaXMuX3NpZ25lcnNcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlS2V5fSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrXG4gICAqL1xuICBwcml2YXRlIGNoZWNrRHVwbGljYXRlZFNpZ25lcihrZXk6IEJhc2VLZXkpIHtcbiAgICB0aGlzLl9zaWduZXJzLmZvckVhY2goKGtwKSA9PiB7XG4gICAgICBpZiAoa3AuZ2V0S2V5cygpLnBydiA9PT0ga2V5LmtleSkge1xuICAgICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdEdXBsaWNhdGVkIHNpZ25lcjogJyArIGtleS5rZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBzZW5kZXIgZmllbGQgaXMgZGVmaW5lZFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVNlbmRlcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VuZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3Npbmcgc2VuZGVyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBub25jZSBmaWVsZCBpcyBkZWZpbmVkXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlTm9uY2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3JlY2VudEJsb2NraGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIG5vbmNlIGJsb2NraGFzaCcpO1xuICAgIH1cbiAgfVxuICAvLyBlbmRyZWdpb25cbn1cbiJdfQ==