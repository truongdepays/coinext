import { SignaturePubkeyPair, Transaction as SolTransaction, TransactionInstruction } from '@solana/web3.js';
import { TransactionType } from '../baseCoin';
import { ValidInstructionTypes } from './iface';
import { BaseCoin, BaseNetwork, SolCoin } from '@bitgo/statics';
/** @inheritdoc */
export declare function isValidAddress(address: string): boolean;
/** @inheritdoc */
export declare function isValidBlockId(hash: string): boolean;
/** @inheritdoc */
export declare function isValidPrivateKey(prvKey: string | Uint8Array): boolean;
/** @inheritdoc */
export declare function isValidPublicKey(pubKey: string): boolean;
/** @inheritdoc */
export declare function isValidSignature(signature: string): boolean;
/** @inheritdoc */
export declare function isValidTransactionId(txId: string): boolean;
/**
 * Returns whether or not the string is a valid amount of lamports number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
export declare function isValidAmount(amount: string): boolean;
/**
 * Check if the string is a valid amount of lamports number on staking
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
export declare function isValidStakingAmount(amount: string): boolean;
/**
 * Check if this is a valid memo or not.
 *
 * @param memo - the memo string
 * @returns {boolean} - the validation result
 */
export declare function isValidMemo(memo: string): boolean;
/**
 * Checks if raw transaction can be deserialized
 *
 * @param {string} rawTransaction - transaction in base64 string format
 * @returns {boolean} - the validation result
 */
export declare function isValidRawTransaction(rawTransaction: string): boolean;
/**
 * Verifies if signature for message is valid.
 *
 * @param {Buffer} serializedTx - tx as a base64 string
 * @param {string} signature - signature as a string
 * @param {string} publicKey - public key as base 58
 * @returns {Boolean} true if signature is valid.
 */
export declare function verifySignature(serializedTx: string, signature: string, publicKey: string): boolean;
/**
 * Converts a base58 string into a Uint8Array.
 *
 * @param {string} input - a string in base58
 * @returns {Uint8Array} - an Uint8Array
 */
export declare function base58ToUint8Array(input: string): Uint8Array;
/**
 * Converts a Uint8Array to a base58 string.
 *
 * @param {Uint8Array} input - an Uint8Array
 * @returns {string} - a string in base58
 */
export declare function Uint8ArrayTobase58(input: Uint8Array): string;
/**
 * Count the amount of signatures are not null.
 *
 * @param {SignaturePubkeyPair[]} signatures - an array of SignaturePubkeyPair
 * @returns {number} - the amount of valid signatures
 */
export declare function countNotNullSignatures(signatures: SignaturePubkeyPair[]): number;
/**
 * Check if all signatures are completed.
 *
 * @param {SignaturePubkeyPair[]} signatures - signatures
 * @returns {boolean}
 */
export declare function requiresAllSignatures(signatures: SignaturePubkeyPair[]): boolean;
/**
 * Check the transaction type matching instructions by order.
 *
 * @param {TransactionInstruction[]} instructions - the array of supported Solana instructions to be parsed
 * @param {Record<string, number>} instructionIndexes - the instructions indexes of the current transaction
 * @returns true if it matchs by order.
 */
export declare function matchTransactionTypeByInstructionsOrder(instructions: TransactionInstruction[], instructionIndexes: Record<string, number>): boolean;
/**
 * Returns the transaction Type based on the  transaction instructions.
 * Wallet initialization, Transfer and Staking transactions are supported.
 *
 * @param {SolTransaction} transaction - the solana transaction
 * @returns {TransactionType} - the type of transaction
 */
export declare function getTransactionType(transaction: SolTransaction): TransactionType;
/**
 * Returns the instruction Type based on the solana instructions.
 * Throws if the solana instruction program is not supported
 *
 * @param {TransactionInstruction} instruction - a solana instruction
 * @returns {ValidInstructionTypes} - a solana instruction type
 */
export declare function getInstructionType(instruction: TransactionInstruction): ValidInstructionTypes;
/**
 * Validate solana instructions types to see if they are supported by the builder.
 * Throws if the instruction type is invalid.
 *
 * @param {TransactionInstruction} instructions - a solana instruction
 * @returns {void}
 */
export declare function validateIntructionTypes(instructions: TransactionInstruction[]): void;
/**
 * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
 *
 * @param {string} rawTransaction - Transaction in base64 string  format
 */
export declare function validateRawTransaction(rawTransaction: string): void;
/**
 * Validates address to check if it exists and is a valid Solana public key
 *
 * @param {string} address The address to be validated
 * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
 */
export declare function validateAddress(address: string, fieldName: string): void;
/**
 * Get the statics coin object matching a given Solana token address if it exists
 *
 * @param tokenAddress The token address to match against
 * @param network Solana Mainnet or Testnet
 * @returns statics BaseCoin object for the matching token
 */
export declare function getSolTokenFromAddress(tokenAddress: string, network: BaseNetwork): Readonly<BaseCoin> | undefined;
/**
 * Get the solana token object from token name
 * @param tokenName The token name to match against
 * */
export declare function getSolTokenFromTokenName(tokenName: string): Readonly<SolCoin> | undefined;
/**
 * Get the solana associated token account address
 * @param tokenAddress The token address
 * @param ownerAddress The owner of the associated token account
 * */
export declare function getAssociatedTokenAccountAddress(tokenAddress: string, ownerAddress: string): Promise<string>;
//# sourceMappingURL=utils.d.ts.map