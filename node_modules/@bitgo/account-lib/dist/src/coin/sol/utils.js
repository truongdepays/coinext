"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssociatedTokenAccountAddress = exports.getSolTokenFromTokenName = exports.getSolTokenFromAddress = exports.validateAddress = exports.validateRawTransaction = exports.validateIntructionTypes = exports.getInstructionType = exports.getTransactionType = exports.matchTransactionTypeByInstructionsOrder = exports.requiresAllSignatures = exports.countNotNullSignatures = exports.Uint8ArrayTobase58 = exports.base58ToUint8Array = exports.verifySignature = exports.isValidRawTransaction = exports.isValidMemo = exports.isValidStakingAmount = exports.isValidAmount = exports.isValidTransactionId = exports.isValidSignature = exports.isValidPublicKey = exports.isValidPrivateKey = exports.isValidBlockId = exports.isValidAddress = void 0;
var web3_js_1 = require("@solana/web3.js");
var bs58_1 = __importDefault(require("bs58"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var constants_1 = require("./constants");
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var tweetnacl_1 = __importDefault(require("tweetnacl"));
var Crypto = __importStar(require("./../../utils/crypto"));
var spl_token_1 = require("@solana/spl-token");
var statics_1 = require("@bitgo/statics");
var assert_1 = __importDefault(require("assert"));
var DECODED_BLOCK_HASH_LENGTH = 32; // https://docs.solana.com/developing/programming-model/transactions#blockhash-format
var DECODED_SIGNATURE_LENGTH = 64; // https://docs.solana.com/terminology#signature
var BASE_58_ENCONDING_REGEX = '[1-9A-HJ-NP-Za-km-z]';
/** @inheritdoc */
function isValidAddress(address) {
    return isValidPublicKey(address);
}
exports.isValidAddress = isValidAddress;
/** @inheritdoc */
function isValidBlockId(hash) {
    try {
        return (!!hash && new RegExp(BASE_58_ENCONDING_REGEX).test(hash) && bs58_1.default.decode(hash).length === DECODED_BLOCK_HASH_LENGTH);
    }
    catch (e) {
        return false;
    }
}
exports.isValidBlockId = isValidBlockId;
/** @inheritdoc */
function isValidPrivateKey(prvKey) {
    try {
        var key = typeof prvKey === 'string' ? this.base58ToUint8Array(prvKey) : prvKey;
        return !!web3_js_1.Keypair.fromSecretKey(key);
    }
    catch (e) {
        return false;
    }
}
exports.isValidPrivateKey = isValidPrivateKey;
/** @inheritdoc */
function isValidPublicKey(pubKey) {
    try {
        if (Crypto.isValidXpub(pubKey))
            return true;
        new web3_js_1.PublicKey(pubKey);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/** @inheritdoc */
function isValidSignature(signature) {
    try {
        return !!signature && bs58_1.default.decode(signature).length === DECODED_SIGNATURE_LENGTH;
    }
    catch (e) {
        return false;
    }
}
exports.isValidSignature = isValidSignature;
/** @inheritdoc */
// TransactionId are the first signature on a Transaction
function isValidTransactionId(txId) {
    return this.isValidSignature(txId);
}
exports.isValidTransactionId = isValidTransactionId;
/**
 * Returns whether or not the string is a valid amount of lamports number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    var bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Check if the string is a valid amount of lamports number on staking
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidStakingAmount(amount) {
    var bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThan(0);
}
exports.isValidStakingAmount = isValidStakingAmount;
/**
 * Check if this is a valid memo or not.
 *
 * @param memo - the memo string
 * @returns {boolean} - the validation result
 */
function isValidMemo(memo) {
    return Buffer.from(memo).length <= constants_1.MAX_MEMO_LENGTH;
}
exports.isValidMemo = isValidMemo;
/**
 * Checks if raw transaction can be deserialized
 *
 * @param {string} rawTransaction - transaction in base64 string format
 * @returns {boolean} - the validation result
 */
function isValidRawTransaction(rawTransaction) {
    try {
        var tx = web3_js_1.Transaction.from(Buffer.from(rawTransaction, 'base64'));
        tx.serialize({ requireAllSignatures: false });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isValidRawTransaction = isValidRawTransaction;
/**
 * Verifies if signature for message is valid.
 *
 * @param {Buffer} serializedTx - tx as a base64 string
 * @param {string} signature - signature as a string
 * @param {string} publicKey - public key as base 58
 * @returns {Boolean} true if signature is valid.
 */
function verifySignature(serializedTx, signature, publicKey) {
    if (!isValidRawTransaction(serializedTx)) {
        throw new errors_1.UtilsError('Invalid serializedTx');
    }
    if (!isValidPublicKey(publicKey)) {
        throw new errors_1.UtilsError('Invalid publicKey');
    }
    if (!isValidSignature(signature)) {
        throw new errors_1.UtilsError('Invalid signature');
    }
    var msg = web3_js_1.Transaction.from(Buffer.from(serializedTx, 'base64')).serializeMessage();
    var sig = base58ToUint8Array(signature);
    var pub = new web3_js_1.PublicKey(publicKey);
    return tweetnacl_1.default.sign.detached.verify(msg, sig, pub.toBuffer());
}
exports.verifySignature = verifySignature;
/**
 * Converts a base58 string into a Uint8Array.
 *
 * @param {string} input - a string in base58
 * @returns {Uint8Array} - an Uint8Array
 */
function base58ToUint8Array(input) {
    return new Uint8Array(bs58_1.default.decode(input));
}
exports.base58ToUint8Array = base58ToUint8Array;
/**
 * Converts a Uint8Array to a base58 string.
 *
 * @param {Uint8Array} input - an Uint8Array
 * @returns {string} - a string in base58
 */
function Uint8ArrayTobase58(input) {
    return bs58_1.default.encode(input);
}
exports.Uint8ArrayTobase58 = Uint8ArrayTobase58;
/**
 * Count the amount of signatures are not null.
 *
 * @param {SignaturePubkeyPair[]} signatures - an array of SignaturePubkeyPair
 * @returns {number} - the amount of valid signatures
 */
function countNotNullSignatures(signatures) {
    return signatures.filter(function (sig) { return !!sig.signature; }).length;
}
exports.countNotNullSignatures = countNotNullSignatures;
/**
 * Check if all signatures are completed.
 *
 * @param {SignaturePubkeyPair[]} signatures - signatures
 * @returns {boolean}
 */
function requiresAllSignatures(signatures) {
    return signatures.length > 0 && countNotNullSignatures(signatures) === signatures.length;
}
exports.requiresAllSignatures = requiresAllSignatures;
/**
 * Check the transaction type matching instructions by order.
 *
 * @param {TransactionInstruction[]} instructions - the array of supported Solana instructions to be parsed
 * @param {Record<string, number>} instructionIndexes - the instructions indexes of the current transaction
 * @returns true if it matchs by order.
 */
function matchTransactionTypeByInstructionsOrder(instructions, instructionIndexes) {
    var instructionsKeys = Object.keys(instructionIndexes);
    // Memo is optional and the last instruction added, it does not matter to match the type
    if (instructionsKeys[instructionsKeys.length - 1] === 'Memo') {
        instructionsKeys.pop();
    }
    // Check instructions by order using the index.
    for (var _i = 0, instructionsKeys_1 = instructionsKeys; _i < instructionsKeys_1.length; _i++) {
        var keyName = instructionsKeys_1[_i];
        if (getInstructionType(instructions[instructionIndexes[keyName]]) !== keyName) {
            return false;
        }
    }
    return true;
}
exports.matchTransactionTypeByInstructionsOrder = matchTransactionTypeByInstructionsOrder;
/**
 * Returns the transaction Type based on the  transaction instructions.
 * Wallet initialization, Transfer and Staking transactions are supported.
 *
 * @param {SolTransaction} transaction - the solana transaction
 * @returns {TransactionType} - the type of transaction
 */
function getTransactionType(transaction) {
    var instructions = transaction.instructions;
    validateIntructionTypes(instructions);
    if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.walletInitInstructionIndexes)) {
        return baseCoin_1.TransactionType.WalletInitialization;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingActivateInstructionsIndexes)) {
        return baseCoin_1.TransactionType.StakingActivate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingDeactivateInstructionsIndexes)) {
        return baseCoin_1.TransactionType.StakingDeactivate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingWithdrawInstructionsIndexes)) {
        return baseCoin_1.TransactionType.StakingWithdraw;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.ataInitInstructionIndexes)) {
        return baseCoin_1.TransactionType.AssociatedTokenAccountInitialization;
    }
    return baseCoin_1.TransactionType.Send;
}
exports.getTransactionType = getTransactionType;
/**
 * Returns the instruction Type based on the solana instructions.
 * Throws if the solana instruction program is not supported
 *
 * @param {TransactionInstruction} instruction - a solana instruction
 * @returns {ValidInstructionTypes} - a solana instruction type
 */
function getInstructionType(instruction) {
    switch (instruction.programId.toString()) {
        case new web3_js_1.PublicKey(constants_1.MEMO_PROGRAM_PK).toString():
            return 'Memo';
        case web3_js_1.SystemProgram.programId.toString():
            return web3_js_1.SystemInstruction.decodeInstructionType(instruction);
        case spl_token_1.TOKEN_PROGRAM_ID.toString():
            return 'TokenTransfer';
        case web3_js_1.StakeProgram.programId.toString():
            return web3_js_1.StakeInstruction.decodeInstructionType(instruction);
        case spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID.toString():
            // TODO: change this when @spl-token supports decoding associated token instructions
            if (instruction.data.length === 0) {
                return 'InitializeAssociatedTokenAccount';
            }
            else {
                throw new errors_1.NotSupported('Invalid transaction, instruction program id not supported: ' + instruction.programId.toString());
            }
        default:
            throw new errors_1.NotSupported('Invalid transaction, instruction program id not supported: ' + instruction.programId.toString());
    }
}
exports.getInstructionType = getInstructionType;
/**
 * Validate solana instructions types to see if they are supported by the builder.
 * Throws if the instruction type is invalid.
 *
 * @param {TransactionInstruction} instructions - a solana instruction
 * @returns {void}
 */
function validateIntructionTypes(instructions) {
    for (var _i = 0, instructions_1 = instructions; _i < instructions_1.length; _i++) {
        var instruction = instructions_1[_i];
        if (!constants_1.VALID_SYSTEM_INSTRUCTION_TYPES.includes(getInstructionType(instruction))) {
            throw new errors_1.NotSupported('Invalid transaction, instruction type not supported: ' + getInstructionType(instruction));
        }
    }
}
exports.validateIntructionTypes = validateIntructionTypes;
/**
 * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
 *
 * @param {string} rawTransaction - Transaction in base64 string  format
 */
function validateRawTransaction(rawTransaction) {
    if (!rawTransaction) {
        throw new errors_1.ParseTransactionError('Invalid raw transaction: Undefined');
    }
    if (!isValidRawTransaction(rawTransaction)) {
        throw new errors_1.ParseTransactionError('Invalid raw transaction');
    }
}
exports.validateRawTransaction = validateRawTransaction;
/**
 * Validates address to check if it exists and is a valid Solana public key
 *
 * @param {string} address The address to be validated
 * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
 */
function validateAddress(address, fieldName) {
    if (!address || !isValidPublicKey(address)) {
        throw new errors_1.BuildTransactionError("Invalid or missing " + fieldName + ", got: " + address);
    }
}
exports.validateAddress = validateAddress;
/**
 * Get the statics coin object matching a given Solana token address if it exists
 *
 * @param tokenAddress The token address to match against
 * @param network Solana Mainnet or Testnet
 * @returns statics BaseCoin object for the matching token
 */
function getSolTokenFromAddress(tokenAddress, network) {
    var tokens = statics_1.coins.filter(function (coin) {
        if (coin instanceof statics_1.SolCoin) {
            return coin.network.type === network.type && coin.tokenAddress.toLowerCase() === tokenAddress.toLowerCase();
        }
        return false;
    });
    var tokensArray = tokens.map(function (token) { return token; });
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        assert_1.default(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getSolTokenFromAddress = getSolTokenFromAddress;
/**
 * Get the solana token object from token name
 * @param tokenName The token name to match against
 * */
function getSolTokenFromTokenName(tokenName) {
    try {
        var token = statics_1.coins.get(tokenName);
        if (!(token.isToken && token instanceof statics_1.SolCoin)) {
            return undefined;
        }
        return token;
    }
    catch (e) {
        if (!(e instanceof statics_1.CoinNotDefinedError)) {
            throw e;
        }
        return undefined;
    }
}
exports.getSolTokenFromTokenName = getSolTokenFromTokenName;
/**
 * Get the solana associated token account address
 * @param tokenAddress The token address
 * @param ownerAddress The owner of the associated token account
 * */
function getAssociatedTokenAccountAddress(tokenAddress, ownerAddress) {
    return __awaiter(this, void 0, void 0, function () {
        var ataAddress;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, new web3_js_1.PublicKey(tokenAddress), new web3_js_1.PublicKey(ownerAddress))];
                case 1:
                    ataAddress = _a.sent();
                    return [2 /*return*/, ataAddress.toString()];
            }
        });
    });
}
exports.getAssociatedTokenAccountAddress = getAssociatedTokenAccountAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9zb2wvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQVV5QjtBQUN6Qiw4Q0FBd0I7QUFDeEIsOERBQXFDO0FBQ3JDLHlDQVNxQjtBQUNyQix3Q0FBOEM7QUFDOUMsNkNBQTRHO0FBRTVHLHdEQUE2QjtBQUM3QiwyREFBK0M7QUFDL0MsK0NBQXlGO0FBQ3pGLDBDQUE0RjtBQUM1RixrREFBNEI7QUFFNUIsSUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUMsQ0FBQyxxRkFBcUY7QUFDM0gsSUFBTSx3QkFBd0IsR0FBRyxFQUFFLENBQUMsQ0FBQyxnREFBZ0Q7QUFDckYsSUFBTSx1QkFBdUIsR0FBRyxzQkFBc0IsQ0FBQztBQUV2RCxrQkFBa0I7QUFDbEIsU0FBZ0IsY0FBYyxDQUFDLE9BQWU7SUFDNUMsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNuQyxDQUFDO0FBRkQsd0NBRUM7QUFFRCxrQkFBa0I7QUFDbEIsU0FBZ0IsY0FBYyxDQUFDLElBQVk7SUFDekMsSUFBSTtRQUNGLE9BQU8sQ0FDTCxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLGNBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLHlCQUF5QixDQUNuSCxDQUFDO0tBQ0g7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBUkQsd0NBUUM7QUFFRCxrQkFBa0I7QUFDbEIsU0FBZ0IsaUJBQWlCLENBQUMsTUFBMkI7SUFDM0QsSUFBSTtRQUNGLElBQU0sR0FBRyxHQUFlLE9BQU8s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QUNsQjtBQUNILENBQUM7QUFiRCw0REFhQztBQUVEOzs7O0tBSUs7QUFDTCxTQUFzQixnQ0FBZ0MsQ0FBQyxZQUFvQixFQUFFLFlBQW9COzs7Ozt3QkFDNUUscUJBQU0saUJBQUssQ0FBQyx5QkFBeUIsQ0FDdEQsdUNBQTJCLEVBQzNCLDRCQUFnQixFQUNoQixJQUFJLG1CQUFTLENBQUMsWUFBWSxDQUFDLEVBQzNCLElBQUksbUJBQVMsQ0FBQyxZQUFZLENBQUMsQ0FDNUIsRUFBQTs7b0JBTEssVUFBVSxHQUFHLFNBS2xCO29CQUNELHNCQUFPLFVBQVUsQ0FBQyxRQUFRLEVBQUUsRUFBQzs7OztDQUM5QjtBQVJELDRFQVFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgS2V5cGFpcixcbiAgUHVibGljS2V5LFxuICBTaWduYXR1cmVQdWJrZXlQYWlyLFxuICBTdGFrZUluc3RydWN0aW9uLFxuICBTdGFrZVByb2dyYW0sXG4gIFN5c3RlbUluc3RydWN0aW9uLFxuICBTeXN0ZW1Qcm9ncmFtLFxuICBUcmFuc2FjdGlvbiBhcyBTb2xUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbn0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHtcbiAgYXRhSW5pdEluc3RydWN0aW9uSW5kZXhlcyxcbiAgTUFYX01FTU9fTEVOR1RILFxuICBNRU1PX1BST0dSQU1fUEssXG4gIHN0YWtpbmdBY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdEZWFjdGl2YXRlSW5zdHJ1Y3Rpb25zSW5kZXhlcyxcbiAgc3Rha2luZ1dpdGhkcmF3SW5zdHJ1Y3Rpb25zSW5kZXhlcyxcbiAgVkFMSURfU1lTVEVNX0lOU1RSVUNUSU9OX1RZUEVTLFxuICB3YWxsZXRJbml0SW5zdHJ1Y3Rpb25JbmRleGVzLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIE5vdFN1cHBvcnRlZCwgUGFyc2VUcmFuc2FjdGlvbkVycm9yLCBVdGlsc0Vycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IFZhbGlkSW5zdHJ1Y3Rpb25UeXBlcyB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCAqIGFzIENyeXB0byBmcm9tICcuLy4uLy4uL3V0aWxzL2NyeXB0byc7XG5pbXBvcnQgeyBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSUQsIFRva2VuLCBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHsgQmFzZUNvaW4sIEJhc2VOZXR3b3JrLCBDb2luTm90RGVmaW5lZEVycm9yLCBjb2lucywgU29sQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgREVDT0RFRF9CTE9DS19IQVNIX0xFTkdUSCA9IDMyOyAvLyBodHRwczovL2RvY3Muc29sYW5hLmNvbS9kZXZlbG9waW5nL3Byb2dyYW1taW5nLW1vZGVsL3RyYW5zYWN0aW9ucyNibG9ja2hhc2gtZm9ybWF0XG5jb25zdCBERUNPREVEX1NJR05BVFVSRV9MRU5HVEggPSA2NDsgLy8gaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjc2lnbmF0dXJlXG5jb25zdCBCQVNFXzU4X0VOQ09ORElOR19SRUdFWCA9ICdbMS05QS1ISi1OUC1aYS1rbS16XSc7XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZFB1YmxpY0tleShhZGRyZXNzKTtcbn1cblxuLyoqIEBpbmhlcml0ZG9jICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEJsb2NrSWQoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChcbiAgICAgICEhaGFzaCAmJiBuZXcgUmVnRXhwKEJBU0VfNThfRU5DT05ESU5HX1JFR0VYKS50ZXN0KGhhc2gpICYmIGJzNTguZGVjb2RlKGhhc2gpLmxlbmd0aCA9PT0gREVDT0RFRF9CTE9DS19IQVNIX0xFTkdUSFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIEBpbmhlcml0ZG9jICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJ2S2V5OiBzdHJpbmcgfCBVaW50OEFycmF5KTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3Qga2V5OiBVaW50OEFycmF5ID0gdHlwZW9mIHBydktleSA9PT0gJ3N0cmluZycgPyB0aGlzLmJhc2U1OFRvVWludDhBcnJheShwcnZLZXkpIDogcHJ2S2V5O1xuICAgIHJldHVybiAhIUtleXBhaXIuZnJvbVNlY3JldEtleShrZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkocHViS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBpZiAoQ3J5cHRvLmlzVmFsaWRYcHViKHB1YktleSkpIHJldHVybiB0cnVlO1xuICAgIG5ldyBQdWJsaWNLZXkocHViS2V5KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFzaWduYXR1cmUgJiYgYnM1OC5kZWNvZGUoc2lnbmF0dXJlKS5sZW5ndGggPT09IERFQ09ERURfU0lHTkFUVVJFX0xFTkdUSDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKiogQGluaGVyaXRkb2MgKi9cbi8vIFRyYW5zYWN0aW9uSWQgYXJlIHRoZSBmaXJzdCBzaWduYXR1cmUgb24gYSBUcmFuc2FjdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUcmFuc2FjdGlvbklkKHR4SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gdGhpcy5pc1ZhbGlkU2lnbmF0dXJlKHR4SWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudCBvZiBsYW1wb3J0cyBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IC0gdGhlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQW1vdW50KGFtb3VudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYW1vdW50KTtcbiAgcmV0dXJuIGJpZ051bWJlckFtb3VudC5pc0ludGVnZXIoKSAmJiBiaWdOdW1iZXJBbW91bnQuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbygwKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgYW1vdW50IG9mIGxhbXBvcnRzIG51bWJlciBvbiBzdGFraW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFN0YWtpbmdBbW91bnQoYW1vdW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xuICByZXR1cm4gYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpICYmIGJpZ051bWJlckFtb3VudC5pc0dyZWF0ZXJUaGFuKDApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgaXMgYSB2YWxpZCBtZW1vIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gbWVtbyAtIHRoZSBtZW1vIHN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWVtbyhtZW1vOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG1lbW8pLmxlbmd0aCA8PSBNQVhfTUVNT19MRU5HVEg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHJhdyB0cmFuc2FjdGlvbiBjYW4gYmUgZGVzZXJpYWxpemVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd1RyYW5zYWN0aW9uIC0gdHJhbnNhY3Rpb24gaW4gYmFzZTY0IHN0cmluZyBmb3JtYXRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0eCA9IFNvbFRyYW5zYWN0aW9uLmZyb20oQnVmZmVyLmZyb20ocmF3VHJhbnNhY3Rpb24sICdiYXNlNjQnKSk7XG4gICAgdHguc2VyaWFsaXplKHsgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZpZXMgaWYgc2lnbmF0dXJlIGZvciBtZXNzYWdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzZXJpYWxpemVkVHggLSB0eCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgLSBzaWduYXR1cmUgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNLZXkgLSBwdWJsaWMga2V5IGFzIGJhc2UgNThcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShzZXJpYWxpemVkVHg6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIHB1YmxpY0tleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUeCkpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignSW52YWxpZCBzZXJpYWxpemVkVHgnKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdJbnZhbGlkIHB1YmxpY0tleScpO1xuICB9XG4gIGlmICghaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gIH1cbiAgY29uc3QgbXNnID0gU29sVHJhbnNhY3Rpb24uZnJvbShCdWZmZXIuZnJvbShzZXJpYWxpemVkVHgsICdiYXNlNjQnKSkuc2VyaWFsaXplTWVzc2FnZSgpO1xuICBjb25zdCBzaWcgPSBiYXNlNThUb1VpbnQ4QXJyYXkoc2lnbmF0dXJlKTtcbiAgY29uc3QgcHViID0gbmV3IFB1YmxpY0tleShwdWJsaWNLZXkpO1xuICByZXR1cm4gbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShtc2csIHNpZywgcHViLnRvQnVmZmVyKCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzZTU4IHN0cmluZyBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBhIHN0cmluZyBpbiBiYXNlNThcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSAtIGFuIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U1OFRvVWludDhBcnJheShpbnB1dDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShiczU4LmRlY29kZShpbnB1dCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGJhc2U1OCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dCAtIGFuIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gYSBzdHJpbmcgaW4gYmFzZTU4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBVaW50OEFycmF5VG9iYXNlNTgoaW5wdXQ6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gYnM1OC5lbmNvZGUoaW5wdXQpO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBhbW91bnQgb2Ygc2lnbmF0dXJlcyBhcmUgbm90IG51bGwuXG4gKlxuICogQHBhcmFtIHtTaWduYXR1cmVQdWJrZXlQYWlyW119IHNpZ25hdHVyZXMgLSBhbiBhcnJheSBvZiBTaWduYXR1cmVQdWJrZXlQYWlyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBhbW91bnQgb2YgdmFsaWQgc2lnbmF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnROb3ROdWxsU2lnbmF0dXJlcyhzaWduYXR1cmVzOiBTaWduYXR1cmVQdWJrZXlQYWlyW10pOiBudW1iZXIge1xuICByZXR1cm4gc2lnbmF0dXJlcy5maWx0ZXIoKHNpZykgPT4gISFzaWcuc2lnbmF0dXJlKS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYWxsIHNpZ25hdHVyZXMgYXJlIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge1NpZ25hdHVyZVB1YmtleVBhaXJbXX0gc2lnbmF0dXJlcyAtIHNpZ25hdHVyZXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZXNBbGxTaWduYXR1cmVzKHNpZ25hdHVyZXM6IFNpZ25hdHVyZVB1YmtleVBhaXJbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIGNvdW50Tm90TnVsbFNpZ25hdHVyZXMoc2lnbmF0dXJlcykgPT09IHNpZ25hdHVyZXMubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrIHRoZSB0cmFuc2FjdGlvbiB0eXBlIG1hdGNoaW5nIGluc3RydWN0aW9ucyBieSBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXX0gaW5zdHJ1Y3Rpb25zIC0gdGhlIGFycmF5IG9mIHN1cHBvcnRlZCBTb2xhbmEgaW5zdHJ1Y3Rpb25zIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSBpbnN0cnVjdGlvbkluZGV4ZXMgLSB0aGUgaW5zdHJ1Y3Rpb25zIGluZGV4ZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgbWF0Y2hzIGJ5IG9yZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKFxuICBpbnN0cnVjdGlvbnM6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXSxcbiAgaW5zdHJ1Y3Rpb25JbmRleGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGluc3RydWN0aW9uc0tleXMgPSBPYmplY3Qua2V5cyhpbnN0cnVjdGlvbkluZGV4ZXMpO1xuXG4gIC8vIE1lbW8gaXMgb3B0aW9uYWwgYW5kIHRoZSBsYXN0IGluc3RydWN0aW9uIGFkZGVkLCBpdCBkb2VzIG5vdCBtYXR0ZXIgdG8gbWF0Y2ggdGhlIHR5cGVcbiAgaWYgKGluc3RydWN0aW9uc0tleXNbaW5zdHJ1Y3Rpb25zS2V5cy5sZW5ndGggLSAxXSA9PT0gJ01lbW8nKSB7XG4gICAgaW5zdHJ1Y3Rpb25zS2V5cy5wb3AoKTtcbiAgfVxuXG4gIC8vIENoZWNrIGluc3RydWN0aW9ucyBieSBvcmRlciB1c2luZyB0aGUgaW5kZXguXG4gIGZvciAoY29uc3Qga2V5TmFtZSBvZiBpbnN0cnVjdGlvbnNLZXlzKSB7XG4gICAgaWYgKGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbnNbaW5zdHJ1Y3Rpb25JbmRleGVzW2tleU5hbWVdXSkgIT09IGtleU5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gVHlwZSBiYXNlZCBvbiB0aGUgIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucy5cbiAqIFdhbGxldCBpbml0aWFsaXphdGlvbiwgVHJhbnNmZXIgYW5kIFN0YWtpbmcgdHJhbnNhY3Rpb25zIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTb2xUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgc29sYW5hIHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25UeXBlfSAtIHRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb246IFNvbFRyYW5zYWN0aW9uKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgY29uc3QgeyBpbnN0cnVjdGlvbnMgfSA9IHRyYW5zYWN0aW9uO1xuICB2YWxpZGF0ZUludHJ1Y3Rpb25UeXBlcyhpbnN0cnVjdGlvbnMpO1xuICBpZiAobWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKGluc3RydWN0aW9ucywgd2FsbGV0SW5pdEluc3RydWN0aW9uSW5kZXhlcykpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uO1xuICB9IGVsc2UgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdBY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMpKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQWN0aXZhdGU7XG4gIH0gZWxzZSBpZiAobWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKGluc3RydWN0aW9ucywgc3Rha2luZ0RlYWN0aXZhdGVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0RlYWN0aXZhdGU7XG4gIH0gZWxzZSBpZiAobWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKGluc3RydWN0aW9ucywgc3Rha2luZ1dpdGhkcmF3SW5zdHJ1Y3Rpb25zSW5kZXhlcykpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdztcbiAgfSBlbHNlIGlmIChtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBhdGFJbml0SW5zdHJ1Y3Rpb25JbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuQXNzb2NpYXRlZFRva2VuQWNjb3VudEluaXRpYWxpemF0aW9uO1xuICB9XG4gIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnN0cnVjdGlvbiBUeXBlIGJhc2VkIG9uIHRoZSBzb2xhbmEgaW5zdHJ1Y3Rpb25zLlxuICogVGhyb3dzIGlmIHRoZSBzb2xhbmEgaW5zdHJ1Y3Rpb24gcHJvZ3JhbSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBpbnN0cnVjdGlvbiAtIGEgc29sYW5hIGluc3RydWN0aW9uXG4gKiBAcmV0dXJucyB7VmFsaWRJbnN0cnVjdGlvblR5cGVzfSAtIGEgc29sYW5hIGluc3RydWN0aW9uIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbjogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbik6IFZhbGlkSW5zdHJ1Y3Rpb25UeXBlcyB7XG4gIHN3aXRjaCAoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCkpIHtcbiAgICBjYXNlIG5ldyBQdWJsaWNLZXkoTUVNT19QUk9HUkFNX1BLKS50b1N0cmluZygpOlxuICAgICAgcmV0dXJuICdNZW1vJztcbiAgICBjYXNlIFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLnRvU3RyaW5nKCk6XG4gICAgICByZXR1cm4gU3lzdGVtSW5zdHJ1Y3Rpb24uZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKTtcbiAgICBjYXNlIFRPS0VOX1BST0dSQU1fSUQudG9TdHJpbmcoKTpcbiAgICAgIHJldHVybiAnVG9rZW5UcmFuc2Zlcic7XG4gICAgY2FzZSBTdGFrZVByb2dyYW0ucHJvZ3JhbUlkLnRvU3RyaW5nKCk6XG4gICAgICByZXR1cm4gU3Rha2VJbnN0cnVjdGlvbi5kZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pO1xuICAgIGNhc2UgQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lELnRvU3RyaW5nKCk6XG4gICAgICAvLyBUT0RPOiBjaGFuZ2UgdGhpcyB3aGVuIEBzcGwtdG9rZW4gc3VwcG9ydHMgZGVjb2RpbmcgYXNzb2NpYXRlZCB0b2tlbiBpbnN0cnVjdGlvbnNcbiAgICAgIGlmIChpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ0luaXRpYWxpemVBc3NvY2lhdGVkVG9rZW5BY2NvdW50JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQoXG4gICAgICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24sIGluc3RydWN0aW9uIHByb2dyYW0gaWQgbm90IHN1cHBvcnRlZDogJyArIGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKFxuICAgICAgICAnSW52YWxpZCB0cmFuc2FjdGlvbiwgaW5zdHJ1Y3Rpb24gcHJvZ3JhbSBpZCBub3Qgc3VwcG9ydGVkOiAnICsgaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCksXG4gICAgICApO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc29sYW5hIGluc3RydWN0aW9ucyB0eXBlcyB0byBzZWUgaWYgdGhleSBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBidWlsZGVyLlxuICogVGhyb3dzIGlmIHRoZSBpbnN0cnVjdGlvbiB0eXBlIGlzIGludmFsaWQuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBpbnN0cnVjdGlvbnMgLSBhIHNvbGFuYSBpbnN0cnVjdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUludHJ1Y3Rpb25UeXBlcyhpbnN0cnVjdGlvbnM6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXSk6IHZvaWQge1xuICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgIGlmICghVkFMSURfU1lTVEVNX0lOU1RSVUNUSU9OX1RZUEVTLmluY2x1ZGVzKGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikpKSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdJbnZhbGlkIHRyYW5zYWN0aW9uLCBpbnN0cnVjdGlvbiB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICcgKyBnZXRJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd1RyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gaW4gYmFzZTY0IHN0cmluZyAgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFyYXdUcmFuc2FjdGlvbikge1xuICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgcmF3IHRyYW5zYWN0aW9uOiBVbmRlZmluZWQnKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHJhdyB0cmFuc2FjdGlvbicpO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGFkZHJlc3MgdG8gY2hlY2sgaWYgaXQgZXhpc3RzIGFuZCBpcyBhIHZhbGlkIFNvbGFuYSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIE5hbWUgb2YgdGhlIGZpZWxkIHRvIHZhbGlkYXRlLCBpdHMgbmVlZGVkIHRvIHJldHVybiB3aGljaCBmaWVsZCBpcyBmYWlsaW5nIG9uIGNhc2Ugb2YgZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBmaWVsZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWFkZHJlc3MgfHwgIWlzVmFsaWRQdWJsaWNLZXkoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIG9yIG1pc3NpbmcgJHtmaWVsZE5hbWV9LCBnb3Q6ICR7YWRkcmVzc31gKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgc3RhdGljcyBjb2luIG9iamVjdCBtYXRjaGluZyBhIGdpdmVuIFNvbGFuYSB0b2tlbiBhZGRyZXNzIGlmIGl0IGV4aXN0c1xuICpcbiAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgVGhlIHRva2VuIGFkZHJlc3MgdG8gbWF0Y2ggYWdhaW5zdFxuICogQHBhcmFtIG5ldHdvcmsgU29sYW5hIE1haW5uZXQgb3IgVGVzdG5ldFxuICogQHJldHVybnMgc3RhdGljcyBCYXNlQ29pbiBvYmplY3QgZm9yIHRoZSBtYXRjaGluZyB0b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U29sVG9rZW5Gcm9tQWRkcmVzcyh0b2tlbkFkZHJlc3M6IHN0cmluZywgbmV0d29yazogQmFzZU5ldHdvcmspOiBSZWFkb25seTxCYXNlQ29pbj4gfCB1bmRlZmluZWQge1xuICBjb25zdCB0b2tlbnMgPSBjb2lucy5maWx0ZXIoKGNvaW4pID0+IHtcbiAgICBpZiAoY29pbiBpbnN0YW5jZW9mIFNvbENvaW4pIHtcbiAgICAgIHJldHVybiBjb2luLm5ldHdvcmsudHlwZSA9PT0gbmV0d29yay50eXBlICYmIGNvaW4udG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBjb25zdCB0b2tlbnNBcnJheSA9IHRva2Vucy5tYXAoKHRva2VuKSA9PiB0b2tlbik7XG4gIGlmICh0b2tlbnNBcnJheS5sZW5ndGggPj0gMSkge1xuICAgIC8vIHRoZXJlIHNob3VsZCBuZXZlciBiZSB0d28gdG9rZW5zIHdpdGggdGhlIHNhbWUgY29udHJhY3QgYWRkcmVzcywgc28gd2UgYXNzZXJ0IHRoYXQgaGVyZVxuICAgIGFzc2VydCh0b2tlbnNBcnJheS5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0b2tlbnNBcnJheVswXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc29sYW5hIHRva2VuIG9iamVjdCBmcm9tIHRva2VuIG5hbWVcbiAqIEBwYXJhbSB0b2tlbk5hbWUgVGhlIHRva2VuIG5hbWUgdG8gbWF0Y2ggYWdhaW5zdFxuICogKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb2xUb2tlbkZyb21Ub2tlbk5hbWUodG9rZW5OYW1lOiBzdHJpbmcpOiBSZWFkb25seTxTb2xDb2luPiB8IHVuZGVmaW5lZCB7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9rZW4gPSBjb2lucy5nZXQodG9rZW5OYW1lKTtcbiAgICBpZiAoISh0b2tlbi5pc1Rva2VuICYmIHRva2VuIGluc3RhbmNlb2YgU29sQ29pbikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiBDb2luTm90RGVmaW5lZEVycm9yKSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgc29sYW5hIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCBhZGRyZXNzXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIFRoZSB0b2tlbiBhZGRyZXNzXG4gKiBAcGFyYW0gb3duZXJBZGRyZXNzIFRoZSBvd25lciBvZiB0aGUgYXNzb2NpYXRlZCB0b2tlbiBhY2NvdW50XG4gKiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzKHRva2VuQWRkcmVzczogc3RyaW5nLCBvd25lckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGF0YUFkZHJlc3MgPSBhd2FpdCBUb2tlbi5nZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzKFxuICAgIEFTU09DSUFURURfVE9LRU5fUFJPR1JBTV9JRCxcbiAgICBUT0tFTl9QUk9HUkFNX0lELFxuICAgIG5ldyBQdWJsaWNLZXkodG9rZW5BZGRyZXNzKSxcbiAgICBuZXcgUHVibGljS2V5KG93bmVyQWRkcmVzcyksXG4gICk7XG4gIHJldHVybiBhdGFBZGRyZXNzLnRvU3RyaW5nKCk7XG59XG4iXX0=