"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeTransferCheckedInstruction = exports.TokenInvalidInstructionTypeError = exports.TokenInvalidInstructionKeysError = exports.TokenInvalidInstructionProgramError = exports.TokenError = exports.TokenInstruction = void 0;
var spl_token_1 = require("@solana/spl-token");
var BigNumber = require('bignumber.js');
/*
  IMPORTANT:

  Since token transfer encoding and decoding is in alpha (v 0.2.0-alpha.2), a version that is currently not functional due to typing bugs,
  this file is the cherry-picked methods that are required to complete the token transfer feature. When the Solana foundation releases a stable
  version, this file should be deleted and the spl-token methods should be used.
 */
var TokenInstruction;
(function (TokenInstruction) {
    TokenInstruction[TokenInstruction["InitializeMint"] = 0] = "InitializeMint";
    TokenInstruction[TokenInstruction["InitializeAccount"] = 1] = "InitializeAccount";
    TokenInstruction[TokenInstruction["InitializeMultisig"] = 2] = "InitializeMultisig";
    TokenInstruction[TokenInstruction["Transfer"] = 3] = "Transfer";
    TokenInstruction[TokenInstruction["Approve"] = 4] = "Approve";
    TokenInstruction[TokenInstruction["Revoke"] = 5] = "Revoke";
    TokenInstruction[TokenInstruction["SetAuthority"] = 6] = "SetAuthority";
    TokenInstruction[TokenInstruction["MintTo"] = 7] = "MintTo";
    TokenInstruction[TokenInstruction["Burn"] = 8] = "Burn";
    TokenInstruction[TokenInstruction["CloseAccount"] = 9] = "CloseAccount";
    TokenInstruction[TokenInstruction["FreezeAccount"] = 10] = "FreezeAccount";
    TokenInstruction[TokenInstruction["ThawAccount"] = 11] = "ThawAccount";
    TokenInstruction[TokenInstruction["TransferChecked"] = 12] = "TransferChecked";
    TokenInstruction[TokenInstruction["ApproveChecked"] = 13] = "ApproveChecked";
    TokenInstruction[TokenInstruction["MintToChecked"] = 14] = "MintToChecked";
    TokenInstruction[TokenInstruction["BurnChecked"] = 15] = "BurnChecked";
    TokenInstruction[TokenInstruction["InitializeAccount2"] = 16] = "InitializeAccount2";
    TokenInstruction[TokenInstruction["SyncNative"] = 17] = "SyncNative";
    TokenInstruction[TokenInstruction["InitializeAccount3"] = 18] = "InitializeAccount3";
    TokenInstruction[TokenInstruction["InitializeMultisig2"] = 19] = "InitializeMultisig2";
    TokenInstruction[TokenInstruction["InitializeMint2"] = 20] = "InitializeMint2";
})(TokenInstruction = exports.TokenInstruction || (exports.TokenInstruction = {}));
var TokenError = /** @class */ (function (_super) {
    __extends(TokenError, _super);
    function TokenError(message) {
        return _super.call(this, message) || this;
    }
    return TokenError;
}(Error));
exports.TokenError = TokenError;
/** Thrown if an instruction's program is invalid */
var TokenInvalidInstructionProgramError = /** @class */ (function (_super) {
    __extends(TokenInvalidInstructionProgramError, _super);
    function TokenInvalidInstructionProgramError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'TokenInvalidInstructionProgramError';
        return _this;
    }
    return TokenInvalidInstructionProgramError;
}(TokenError));
exports.TokenInvalidInstructionProgramError = TokenInvalidInstructionProgramError;
/** Thrown if an instruction's keys are invalid */
var TokenInvalidInstructionKeysError = /** @class */ (function (_super) {
    __extends(TokenInvalidInstructionKeysError, _super);
    function TokenInvalidInstructionKeysError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'TokenInvalidInstructionKeysError';
        return _this;
    }
    return TokenInvalidInstructionKeysError;
}(TokenError));
exports.TokenInvalidInstructionKeysError = TokenInvalidInstructionKeysError;
/** Thrown if an instruction's type is invalid */
var TokenInvalidInstructionTypeError = /** @class */ (function (_super) {
    __extends(TokenInvalidInstructionTypeError, _super);
    function TokenInvalidInstructionTypeError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'TokenInvalidInstructionTypeError';
        return _this;
    }
    return TokenInvalidInstructionTypeError;
}(TokenError));
exports.TokenInvalidInstructionTypeError = TokenInvalidInstructionTypeError;
/**
 * Decode a TransferChecked instruction and validate it
 *
 * @param instruction Transaction instruction to decode
 * @param programId   SPL Token program account
 *
 * @return Decoded, valid instruction
 */
function decodeTransferCheckedInstruction(instruction, programId) {
    if (programId === void 0) { programId = spl_token_1.TOKEN_PROGRAM_ID; }
    if (!instruction.programId.equals(programId))
        throw new TokenInvalidInstructionProgramError();
    var _a = decodeTransferCheckedInstructionUnchecked(instruction), _b = _a.keys, source = _b.source, mint = _b.mint, destination = _b.destination, owner = _b.owner, multiSigners = _b.multiSigners, data = _a.data;
    if (data.instruction !== TokenInstruction.TransferChecked)
        throw new TokenInvalidInstructionTypeError();
    if (!source || !mint || !destination || !owner)
        throw new TokenInvalidInstructionKeysError();
    return {
        programId: programId,
        keys: {
            source: source,
            mint: mint,
            destination: destination,
            owner: owner,
            multiSigners: multiSigners,
        },
        data: data,
    };
}
exports.decodeTransferCheckedInstruction = decodeTransferCheckedInstruction;
function readBigUInt64LE(buffer, offset) {
    if (offset === void 0) { offset = 0; }
    var first = buffer[offset];
    var last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        throw new Error('Out of bounds');
    }
    var lo = first + buffer[++offset] * Math.pow(2, 8) + buffer[++offset] * Math.pow(2, 16) + buffer[++offset] * Math.pow(2, 24);
    var hi = buffer[++offset] + buffer[++offset] * Math.pow(2, 8) + buffer[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return (BigNumber(lo) + (BigNumber(hi) << BigNumber(32))) / 10;
}
/**
 * Decode a TransferChecked instruction without validating it
 *
 * @param instruction Transaction instruction to decode
 *
 * @return Decoded, non-validated instruction
 */
function decodeTransferCheckedInstructionUnchecked(_a) {
    var programId = _a.programId, _b = _a.keys, source = _b[0], mint = _b[1], destination = _b[2], owner = _b[3], multiSigners = _b.slice(4), data = _a.data;
    var type = data.slice(0, 1).readUInt8(0);
    var amount = readBigUInt64LE(data.slice(1, 9), 0);
    var decimals = data.slice(9).readUInt8(0);
    return {
        programId: programId,
        keys: {
            source: source,
            mint: mint,
            destination: destination,
            owner: owner,
            multiSigners: multiSigners,
        },
        data: {
            instruction: type,
            amount: amount,
            decimals: decimals,
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5FbmNvZGVEZWNvZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9zb2wvdG9rZW5FbmNvZGVEZWNvZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsK0NBQXFEO0FBQ3JELElBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUUxQzs7Ozs7O0dBTUc7QUFFSCxJQUFZLGdCQXNCWDtBQXRCRCxXQUFZLGdCQUFnQjtJQUMxQiwyRUFBa0IsQ0FBQTtJQUNsQixpRkFBcUIsQ0FBQTtJQUNyQixtRkFBc0IsQ0FBQTtJQUN0QiwrREFBWSxDQUFBO0lBQ1osNkRBQVcsQ0FBQTtJQUNYLDJEQUFVLENBQUE7SUFDVix1RUFBZ0IsQ0FBQTtJQUNoQiwyREFBVSxDQUFBO0lBQ1YsdURBQVEsQ0FBQTtJQUNSLHVFQUFnQixDQUFBO0lBQ2hCLDBFQUFrQixDQUFBO0lBQ2xCLHNFQUFnQixDQUFBO0lBQ2hCLDhFQUFvQixDQUFBO0lBQ3BCLDRFQUFtQixDQUFBO0lBQ25CLDBFQUFrQixDQUFBO0lBQ2xCLHNFQUFnQixDQUFBO0lBQ2hCLG9GQUF1QixDQUFBO0lBQ3ZCLG9FQUFlLENBQUE7SUFDZixvRkFBdUIsQ0FBQTtJQUN2QixzRkFBd0IsQ0FBQTtJQUN4Qiw4RUFBb0IsQ0FBQTtBQUN0QixDQUFDLEVBdEJXLGdCQUFnQixHQUFoQix3QkFBZ0IsS0FBaEIsd0JBQWdCLFFBc0IzQjtBQUVEO0lBQXlDLDhCQUFLO0lBRTVDLG9CQUFZLE9BQWdCO2VBQzFCLGtCQUFNLE9BQU8sQ0FBQztJQUNoQixDQUFDO0lBQ0gsaUJBQUM7QUFBRCxDQUFDLEFBTEQsQ0FBeUMsS0FBSyxHQUs3QztBQUxxQixnQ0FBVTtBQU9oQyxvREFBb0Q7QUFDcEQ7SUFBeUQsdURBQVU7SUFBbkU7UUFBQSxxRUFFQztRQURDLFVBQUksR0FBRyxxQ0FBcUMsQ0FBQzs7SUFDL0MsQ0FB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QUFFLENBQUM7QUFDakUsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQVMseUNBQXlDLENBQUMsRUFJMUI7UUFIdkIsU0FBUyxlQUFBLEVBQ1QsWUFBeUQsRUFBbEQsTUFBTSxRQUFBLEVBQUUsSUFBSSxRQUFBLEVBQUUsV0FBVyxRQUFBLEVBQUUsS0FBSyxRQUFBLEVBQUssWUFBWSxjQUFBLEVBQ3hELElBQUksVUFBQTtJQUVKLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQyxJQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDcEQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUMsT0FBTztRQUNMLFNBQVMsV0FBQTtRQUNULElBQUksRUFBRTtZQUNKLE1BQU0sUUFBQTtZQUNOLElBQUksTUFBQTtZQUNKLFdBQVcsYUFBQTtZQUNYLEtBQUssT0FBQTtZQUNMLFlBQVksY0FBQTtTQUNiO1FBQ0QsSUFBSSxFQUFFO1lBQ0osV0FBVyxFQUFFLElBQUk7WUFDakIsTUFBTSxFQUFFLE1BQU07WUFDZCxRQUFRLEVBQUUsUUFBUTtTQUNuQjtLQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQWNjb3VudE1ldGEsIFB1YmxpY0tleSwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuY29uc3QgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5cbi8qXG4gIElNUE9SVEFOVDpcblxuICBTaW5jZSB0b2tlbiB0cmFuc2ZlciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgaXMgaW4gYWxwaGEgKHYgMC4yLjAtYWxwaGEuMiksIGEgdmVyc2lvbiB0aGF0IGlzIGN1cnJlbnRseSBub3QgZnVuY3Rpb25hbCBkdWUgdG8gdHlwaW5nIGJ1Z3MsXG4gIHRoaXMgZmlsZSBpcyB0aGUgY2hlcnJ5LXBpY2tlZCBtZXRob2RzIHRoYXQgYXJlIHJlcXVpcmVkIHRvIGNvbXBsZXRlIHRoZSB0b2tlbiB0cmFuc2ZlciBmZWF0dXJlLiBXaGVuIHRoZSBTb2xhbmEgZm91bmRhdGlvbiByZWxlYXNlcyBhIHN0YWJsZVxuICB2ZXJzaW9uLCB0aGlzIGZpbGUgc2hvdWxkIGJlIGRlbGV0ZWQgYW5kIHRoZSBzcGwtdG9rZW4gbWV0aG9kcyBzaG91bGQgYmUgdXNlZC5cbiAqL1xuXG5leHBvcnQgZW51bSBUb2tlbkluc3RydWN0aW9uIHtcbiAgSW5pdGlhbGl6ZU1pbnQgPSAwLFxuICBJbml0aWFsaXplQWNjb3VudCA9IDEsXG4gIEluaXRpYWxpemVNdWx0aXNpZyA9IDIsXG4gIFRyYW5zZmVyID0gMyxcbiAgQXBwcm92ZSA9IDQsXG4gIFJldm9rZSA9IDUsXG4gIFNldEF1dGhvcml0eSA9IDYsXG4gIE1pbnRUbyA9IDcsXG4gIEJ1cm4gPSA4LFxuICBDbG9zZUFjY291bnQgPSA5LFxuICBGcmVlemVBY2NvdW50ID0gMTAsXG4gIFRoYXdBY2NvdW50ID0gMTEsXG4gIFRyYW5zZmVyQ2hlY2tlZCA9IDEyLFxuICBBcHByb3ZlQ2hlY2tlZCA9IDEzLFxuICBNaW50VG9DaGVja2VkID0gMTQsXG4gIEJ1cm5DaGVja2VkID0gMTUsXG4gIEluaXRpYWxpemVBY2NvdW50MiA9IDE2LFxuICBTeW5jTmF0aXZlID0gMTcsXG4gIEluaXRpYWxpemVBY2NvdW50MyA9IDE4LFxuICBJbml0aWFsaXplTXVsdGlzaWcyID0gMTksXG4gIEluaXRpYWxpemVNaW50MiA9IDIwLFxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVG9rZW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqIFRocm93biBpZiBhbiBpbnN0cnVjdGlvbidzIHByb2dyYW0gaXMgaW52YWxpZCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuSW52YWxpZEluc3RydWN0aW9uUHJvZ3JhbUVycm9yIGV4dGVuZHMgVG9rZW5FcnJvciB7XG4gIG5hbWUgPSAnVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25Qcm9ncmFtRXJyb3InO1xufVxuXG4vKiogVGhyb3duIGlmIGFuIGluc3RydWN0aW9uJ3Mga2V5cyBhcmUgaW52YWxpZCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuSW52YWxpZEluc3RydWN0aW9uS2V5c0Vycm9yIGV4dGVuZHMgVG9rZW5FcnJvciB7XG4gIG5hbWUgPSAnVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25LZXlzRXJyb3InO1xufVxuXG4vKiogVGhyb3duIGlmIGFuIGluc3RydWN0aW9uJ3MgdHlwZSBpcyBpbnZhbGlkICovXG5leHBvcnQgY2xhc3MgVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25UeXBlRXJyb3IgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgbmFtZSA9ICdUb2tlbkludmFsaWRJbnN0cnVjdGlvblR5cGVFcnJvcic7XG59XG5cbi8qKiBBIGRlY29kZWQsIHZhbGlkIFRyYW5zZmVyQ2hlY2tlZCBpbnN0cnVjdGlvbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWNvZGVkVHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb24ge1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbiAga2V5czoge1xuICAgIHNvdXJjZTogQWNjb3VudE1ldGE7XG4gICAgbWludDogQWNjb3VudE1ldGE7XG4gICAgZGVzdGluYXRpb246IEFjY291bnRNZXRhO1xuICAgIG93bmVyOiBBY2NvdW50TWV0YTtcbiAgICBtdWx0aVNpZ25lcnM6IEFjY291bnRNZXRhW107XG4gIH07XG4gIGRhdGE6IHtcbiAgICBpbnN0cnVjdGlvbjogVG9rZW5JbnN0cnVjdGlvbi5UcmFuc2ZlckNoZWNrZWQ7XG4gICAgYW1vdW50OiBudW1iZXI7XG4gICAgZGVjaW1hbHM6IG51bWJlcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBUcmFuc2ZlckNoZWNrZWQgaW5zdHJ1Y3Rpb24gYW5kIHZhbGlkYXRlIGl0XG4gKlxuICogQHBhcmFtIGluc3RydWN0aW9uIFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRvIGRlY29kZVxuICogQHBhcmFtIHByb2dyYW1JZCAgIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqXG4gKiBAcmV0dXJuIERlY29kZWQsIHZhbGlkIGluc3RydWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbihcbiAgaW5zdHJ1Y3Rpb246IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG4gIHByb2dyYW1JZCA9IFRPS0VOX1BST0dSQU1fSUQsXG4pOiBEZWNvZGVkVHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb24ge1xuICBpZiAoIWluc3RydWN0aW9uLnByb2dyYW1JZC5lcXVhbHMocHJvZ3JhbUlkKSkgdGhyb3cgbmV3IFRva2VuSW52YWxpZEluc3RydWN0aW9uUHJvZ3JhbUVycm9yKCk7XG5cbiAgY29uc3Qge1xuICAgIGtleXM6IHsgc291cmNlLCBtaW50LCBkZXN0aW5hdGlvbiwgb3duZXIsIG11bHRpU2lnbmVycyB9LFxuICAgIGRhdGEsXG4gIH0gPSBkZWNvZGVUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvblVuY2hlY2tlZChpbnN0cnVjdGlvbik7XG4gIGlmIChkYXRhLmluc3RydWN0aW9uICE9PSBUb2tlbkluc3RydWN0aW9uLlRyYW5zZmVyQ2hlY2tlZCkgdGhyb3cgbmV3IFRva2VuSW52YWxpZEluc3RydWN0aW9uVHlwZUVycm9yKCk7XG4gIGlmICghc291cmNlIHx8ICFtaW50IHx8ICFkZXN0aW5hdGlvbiB8fCAhb3duZXIpIHRocm93IG5ldyBUb2tlbkludmFsaWRJbnN0cnVjdGlvbktleXNFcnJvcigpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvZ3JhbUlkLFxuICAgIGtleXM6IHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG1pbnQsXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIG93bmVyLFxuICAgICAgbXVsdGlTaWduZXJzLFxuICAgIH0sXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqIEEgZGVjb2RlZCwgbm9uLXZhbGlkYXRlZCBUcmFuc2ZlckNoZWNrZWQgaW5zdHJ1Y3Rpb24gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVjb2RlZFRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uVW5jaGVja2VkIHtcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXk7XG4gIGtleXM6IHtcbiAgICBzb3VyY2U6IEFjY291bnRNZXRhIHwgdW5kZWZpbmVkO1xuICAgIG1pbnQ6IEFjY291bnRNZXRhIHwgdW5kZWZpbmVkO1xuICAgIGRlc3RpbmF0aW9uOiBBY2NvdW50TWV0YSB8IHVuZGVmaW5lZDtcbiAgICBvd25lcjogQWNjb3VudE1ldGEgfCB1bmRlZmluZWQ7XG4gICAgbXVsdGlTaWduZXJzOiBBY2NvdW50TWV0YVtdO1xuICB9O1xuICBkYXRhOiB7XG4gICAgaW5zdHJ1Y3Rpb246IG51bWJlcjtcbiAgICBhbW91bnQ6IG51bWJlcjtcbiAgICBkZWNpbWFsczogbnVtYmVyO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQmlnVUludDY0TEUoYnVmZmVyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGZpcnN0ID0gYnVmZmVyW29mZnNldF07XG4gIGNvbnN0IGxhc3QgPSBidWZmZXJbb2Zmc2V0ICsgN107XG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArIGJ1ZmZlclsrK29mZnNldF0gKiAyICoqIDggKyBidWZmZXJbKytvZmZzZXRdICogMiAqKiAxNiArIGJ1ZmZlclsrK29mZnNldF0gKiAyICoqIDI0O1xuICBjb25zdCBoaSA9IGJ1ZmZlclsrK29mZnNldF0gKyBidWZmZXJbKytvZmZzZXRdICogMiAqKiA4ICsgYnVmZmVyWysrb2Zmc2V0XSAqIDIgKiogMTYgKyBsYXN0ICogMiAqKiAyNDtcblxuICByZXR1cm4gKEJpZ051bWJlcihsbykgKyAoQmlnTnVtYmVyKGhpKSA8PCBCaWdOdW1iZXIoMzIpKSkgLyAxMDtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBUcmFuc2ZlckNoZWNrZWQgaW5zdHJ1Y3Rpb24gd2l0aG91dCB2YWxpZGF0aW5nIGl0XG4gKlxuICogQHBhcmFtIGluc3RydWN0aW9uIFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRvIGRlY29kZVxuICpcbiAqIEByZXR1cm4gRGVjb2RlZCwgbm9uLXZhbGlkYXRlZCBpbnN0cnVjdGlvblxuICovXG5mdW5jdGlvbiBkZWNvZGVUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvblVuY2hlY2tlZCh7XG4gIHByb2dyYW1JZCxcbiAga2V5czogW3NvdXJjZSwgbWludCwgZGVzdGluYXRpb24sIG93bmVyLCAuLi5tdWx0aVNpZ25lcnNdLFxuICBkYXRhLFxufTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbik6IERlY29kZWRUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvblVuY2hlY2tlZCB7XG4gIGNvbnN0IHR5cGUgPSBkYXRhLnNsaWNlKDAsIDEpLnJlYWRVSW50OCgwKTtcbiAgY29uc3QgYW1vdW50ID0gcmVhZEJpZ1VJbnQ2NExFKGRhdGEuc2xpY2UoMSwgOSksIDApO1xuICBjb25zdCBkZWNpbWFscyA9IGRhdGEuc2xpY2UoOSkucmVhZFVJbnQ4KDApO1xuICByZXR1cm4ge1xuICAgIHByb2dyYW1JZCxcbiAgICBrZXlzOiB7XG4gICAgICBzb3VyY2UsXG4gICAgICBtaW50LFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgICBvd25lcixcbiAgICAgIG11bHRpU2lnbmVycyxcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIGluc3RydWN0aW9uOiB0eXBlLFxuICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICBkZWNpbWFsczogZGVjaW1hbHMsXG4gICAgfSxcbiAgfTtcbn1cbiJdfQ==