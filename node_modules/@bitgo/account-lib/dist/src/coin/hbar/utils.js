"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidAddressWithPaymentId = exports.normalizeAddress = exports.getAddressDetails = exports.getBaseAddress = exports.isSameBaseAddress = exports.convertFromStellarPub = exports.createRawKey = exports.isValidMemo = exports.removePrefix = exports.stringifyTxTime = exports.stringifyAccountId = exports.isValidRawTransactionFormat = exports.isValidAmount = exports.isValidTimeString = exports.getCurrentTime = exports.isNodeEnvironment = exports.toUint8Array = exports.toHex = exports.isValidPublicKey = exports.isValidTransactionId = exports.isValidAddress = void 0;
var _ = __importStar(require("lodash"));
var sdk_1 = require("@hashgraph/sdk");
var hex = __importStar(require("@stablelib/hex"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var stellar = __importStar(require("stellar-sdk"));
var errors_1 = require("../baseCoin/errors");
var url_1 = __importDefault(require("url"));
var querystring_1 = __importDefault(require("querystring"));
var MAX_TINYBARS_AMOUNT = new bignumber_js_1.default(2).pow(63).minus(1);
/**
 * Returns whether or not the string is a valid Hedera account.
 *
 * In any form, `shard` and `realm` are assumed to be 0 if not provided.
 *
 * @param {string} address - the address to be validated
 * @returns {boolean} - the validation result
 */
function isValidAddress(address) {
    if (_.isEmpty(address) || !address.match(/^[0-9]+(?:(?=\.)(\.[0-9]+){2}|(?!\.))$/)) {
        return false;
    }
    try {
        var acc = sdk_1.AccountId.fromString(address);
        return !_.isNaN(acc.num);
    }
    catch (e) {
        return false;
    }
}
exports.isValidAddress = isValidAddress;
/**
 * Returns whether or not the string is a valid Hedera transaction id or not.
 *
 * @param {string} txId - the transaction id to be validated
 * @returns {boolean} - the validation result
 */
function isValidTransactionId(txId) {
    if (_.isEmpty(txId)) {
        return false;
    }
    try {
        var tx = sdk_1.TransactionId.fromString(txId);
        if (_.isNil(tx.accountId)) {
            return false;
        }
        return !_.isNaN(tx.accountId.num);
    }
    catch (e) {
        return false;
    }
}
exports.isValidTransactionId = isValidTransactionId;
/**
 * Returns whether or not the string is a valid Hedera public key
 *
 * @param {string} key - the  public key to be validated
 * @returns {boolean} - the validation result
 */
function isValidPublicKey(key) {
    if (_.isEmpty(key)) {
        return false;
    }
    try {
        var pubKey = sdk_1.PublicKey.fromString(key.toLowerCase());
        return !_.isNaN(pubKey.toString());
    }
    catch (e) {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Returns an hex string of the given buffer
 *
 * @param {Buffer | Uint8Array} buffer - the buffer to be converted to hex
 * @returns {string} - the hex value
 */
function toHex(buffer) {
    return hex.encode(buffer, true);
}
exports.toHex = toHex;
/**
 * Returns a Uint8Array of the given hex string
 *
 * @param {string} str - the hex string to be converted
 * @returns {string} - the Uint8Array value
 */
function toUint8Array(str) {
    return hex.decode(str);
}
exports.toUint8Array = toUint8Array;
/**
 * Checks whether nodeJS.process exist and if a node version is defined to determine if this is an nodeJS environment
 *
 * @returns {boolean} - the validation result
 */
function isNodeEnvironment() {
    return typeof process !== 'undefined' && typeof process.versions.node !== 'undefined';
}
exports.isNodeEnvironment = isNodeEnvironment;
/**
 * Calculate the current time with nanoseconds precision
 *
 * @returns {string} the current time in seconds
 */
function getCurrentTime() {
    if (isNodeEnvironment()) {
        var nanos = process.hrtime()[1];
        var seconds = (Date.now() * 1000000 + nanos) / 1000000000;
        return seconds.toFixed(9);
    }
    else {
        return (performance.timeOrigin + performance.now()).toFixed(9);
    }
}
exports.getCurrentTime = getCurrentTime;
/**
 * Returns whether or not the string is a valid timestamp. Nanoseconds are optional and can be passed after a dot, for
 * example: 1595374723.356981689
 *
 * @param {string} time - the timestamp to be validated
 * @returns {boolean} the validation result
 */
function isValidTimeString(time) {
    return /^[0-9]+(\.[0-9]+)?$/.test(time);
}
exports.isValidTimeString = isValidTimeString;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    var bigNumberAmount = new bignumber_js_1.default(amount);
    return (bigNumberAmount.isInteger() &&
        bigNumberAmount.isGreaterThanOrEqualTo(0) &&
        bigNumberAmount.isLessThanOrEqualTo(MAX_TINYBARS_AMOUNT));
}
exports.isValidAmount = isValidAmount;
/**
 * Returns whether the provided raw transaction accommodates to bitgo's preferred format
 *
 * @param {any} rawTransaction - The raw transaction to be checked
 * @returns {boolean} the validation result
 */
function isValidRawTransactionFormat(rawTransaction) {
    if ((typeof rawTransaction === 'string' && /^[0-9a-fA-F]+$/.test(rawTransaction)) ||
        (Buffer.isBuffer(rawTransaction) && Uint8Array.from(rawTransaction))) {
        return true;
    }
    return false;
}
exports.isValidRawTransactionFormat = isValidRawTransactionFormat;
/**
 * Returns a string representation of an {proto.IAccountID} object
 *
 * @param {proto.IAccountID} - account id to be cast to string
 * @returns {string} - the string representation of the {proto.IAccountID}
 */
function stringifyAccountId(_a) {
    var shardNum = _a.shardNum, realmNum = _a.realmNum, accountNum = _a.accountNum;
    return (shardNum || 0) + "." + (realmNum || 0) + "." + accountNum;
}
exports.stringifyAccountId = stringifyAccountId;
/**
 * Returns a string representation of an {proto.ITimestamp} object
 *
 * @param {proto.ITimestamp} - timestamp to be cast to string
 * @returns {string} - the string representation of the {proto.ITimestamp}
 */
function stringifyTxTime(_a) {
    var seconds = _a.seconds, nanos = _a.nanos;
    return seconds + "." + nanos;
}
exports.stringifyTxTime = stringifyTxTime;
/**
 * Remove the specified prefix from a string only if it starts with that prefix
 *
 * @param {string} prefix The prefix to be removed
 * @param {string} key The original string, usually a private or public key
 * @returns {string} The string without prefix
 */
function removePrefix(prefix, key) {
    if (key.startsWith(prefix)) {
        return key.slice(prefix.length);
    }
    return key;
}
exports.removePrefix = removePrefix;
/**
 * Check if this is a valid memo or not.
 *
 * @param memo
 */
function isValidMemo(memo) {
    return !(_.isEmpty(memo) || Buffer.from(memo).length > 100);
}
exports.isValidMemo = isValidMemo;
/**
 * Uses the native hashgraph SDK function to get a raw key.
 *
 * @param prv
 */
function createRawKey(prv) {
    return sdk_1.PrivateKey.fromString(prv);
}
exports.createRawKey = createRawKey;
/**
 * Converts an stellar public key to a ed25519 hex format.
 *
 * @param stellarPub
 * @param prv
 */
function convertFromStellarPub(stellarPub) {
    if (!stellar.StrKey.isValidEd25519PublicKey(stellarPub)) {
        throw new Error('Not a valid stellar pub.');
    }
    var rawKey = stellar.StrKey.decodeEd25519PublicKey(stellarPub);
    return rawKey.toString('hex');
}
exports.convertFromStellarPub = convertFromStellarPub;
/**
 * Compares an address to the base address to check if matchs.
 *
 * @param {String} address - an address
 * @param {String} baseAddress - a base address
 * @returns {boolean}
 */
function isSameBaseAddress(address, baseAddress) {
    if (!isValidAddressWithPaymentId(address)) {
        throw new errors_1.UtilsError("invalid address: " + address);
    }
    return getBaseAddress(address) === getBaseAddress(baseAddress);
}
exports.isSameBaseAddress = isSameBaseAddress;
/**
 * Returns the base address portion of an address
 *
 * @param {String} address - an address
 * @returns {String} - the base address
 */
function getBaseAddress(address) {
    var addressDetails = getAddressDetails(address);
    return addressDetails.address;
}
exports.getBaseAddress = getBaseAddress;
/**
 * Process address into address and memo id
 *
 * @param rawAddress the address
 * @returns object containing address and memo id
 */
function getAddressDetails(rawAddress) {
    var addressDetails = url_1.default.parse(rawAddress);
    var queryDetails = addressDetails.query ? querystring_1.default.parse(addressDetails.query) : {};
    var baseAddress = addressDetails.pathname;
    if (!isValidAddress(baseAddress)) {
        throw new errors_1.UtilsError("invalid address: " + rawAddress);
    }
    // address doesn't have a memo id or memoId is empty
    if (baseAddress === rawAddress) {
        return {
            address: rawAddress,
            memoId: undefined,
        };
    }
    var memoId = queryDetails.memoId;
    if (!isValidMemo(memoId)) {
        throw new errors_1.UtilsError("invalid address: '" + rawAddress + "', memoId is not valid");
    }
    return {
        address: baseAddress,
        memoId: memoId,
    };
}
exports.getAddressDetails = getAddressDetails;
/**
 * Validate and return address with appended memo id
 *
 * @param {AddressDetails} addressDetails
 */
function normalizeAddress(_a) {
    var address = _a.address, memoId = _a.memoId;
    if (memoId && isValidMemo(memoId)) {
        return address + "?memoId=" + memoId;
    }
    return address;
}
exports.normalizeAddress = normalizeAddress;
/**
 * Return boolean indicating whether input is a valid address with memo id
 *
 * @param {string} address address in the form <address>?memoId=<memoId>
 * @returns {boolean} true is input is a valid address
 */
function isValidAddressWithPaymentId(address) {
    try {
        var addressDetails = getAddressDetails(address);
        return address === normalizeAddress(addressDetails);
    }
    catch (e) {
        return false;
    }
}
exports.isValidAddressWithPaymentId = isValidAddressWithPaymentId;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9oYmFyL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3Q0FBNEI7QUFDNUIsc0NBQWlGO0FBQ2pGLGtEQUFzQztBQUN0Qyw4REFBcUM7QUFDckMsbURBQXVDO0FBRXZDLDZDQUFnRDtBQUVoRCw0Q0FBc0I7QUFDdEIsNERBQXNDO0FBRXRDLElBQU0sbUJBQW1CLEdBQUcsSUFBSSxzQkFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFOUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGNBQWMsQ0FBQyxPQUFlO0lBQzVDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLENBQUMsRUFBRTtRQUNsRixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSTtRQUNGLElBQU0sR0FBRyxHQUFHLGVBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzFCO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQVZELHdDQVVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxJQUFZO0lBQy9DLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNuQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSTtRQUNGLElBQU0sRUFBRSxHQUFHLG1CQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FB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b20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbklkLCBBY2NvdW50SWQsIFB1YmxpY0tleSwgUHJpdmF0ZUtleSB9IGZyb20gJ0BoYXNoZ3JhcGgvc2RrJztcbmltcG9ydCAqIGFzIGhleCBmcm9tICdAc3RhYmxlbGliL2hleCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCB7IHByb3RvIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2VzL2hiYXIvcHJvdG9idWYvaGVkZXJhJztcbmltcG9ydCB7IFV0aWxzRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgQWRkcmVzc0RldGFpbHMgfSBmcm9tICcuL2lmYWNlcyc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuXG5jb25zdCBNQVhfVElOWUJBUlNfQU1PVU5UID0gbmV3IEJpZ051bWJlcigyKS5wb3coNjMpLm1pbnVzKDEpO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEhlZGVyYSBhY2NvdW50LlxuICpcbiAqIEluIGFueSBmb3JtLCBgc2hhcmRgIGFuZCBgcmVhbG1gIGFyZSBhc3N1bWVkIHRvIGJlIDAgaWYgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoXy5pc0VtcHR5KGFkZHJlc3MpIHx8ICFhZGRyZXNzLm1hdGNoKC9eWzAtOV0rKD86KD89XFwuKShcXC5bMC05XSspezJ9fCg/IVxcLikpJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYWNjID0gQWNjb3VudElkLmZyb21TdHJpbmcoYWRkcmVzcyk7XG4gICAgcmV0dXJuICFfLmlzTmFOKGFjYy5udW0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgSGVkZXJhIHRyYW5zYWN0aW9uIGlkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHhJZCAtIHRoZSB0cmFuc2FjdGlvbiBpZCB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChfLmlzRW1wdHkodHhJZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB0eCA9IFRyYW5zYWN0aW9uSWQuZnJvbVN0cmluZyh0eElkKTtcbiAgICBpZiAoXy5pc05pbCh0eC5hY2NvdW50SWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhXy5pc05hTih0eC5hY2NvdW50SWQubnVtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEhlZGVyYSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSAgcHVibGljIGtleSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoXy5pc0VtcHR5KGtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwdWJLZXkgPSBQdWJsaWNLZXkuZnJvbVN0cmluZyhrZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgcmV0dXJuICFfLmlzTmFOKHB1YktleS50b1N0cmluZygpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaGV4IHN0cmluZyBvZiB0aGUgZ2l2ZW4gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5fSBidWZmZXIgLSB0aGUgYnVmZmVyIHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoYnVmZmVyOiBCdWZmZXIgfCBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIGhleC5lbmNvZGUoYnVmZmVyLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgVWludDhBcnJheSBvZiB0aGUgZ2l2ZW4gaGV4IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSB0aGUgaGV4IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIFVpbnQ4QXJyYXkgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDhBcnJheShzdHI6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gaGV4LmRlY29kZShzdHIpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG5vZGVKUy5wcm9jZXNzIGV4aXN0IGFuZCBpZiBhIG5vZGUgdmVyc2lvbiBpcyBkZWZpbmVkIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFuIG5vZGVKUyBlbnZpcm9ubWVudFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlRW52aXJvbm1lbnQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjdXJyZW50IHRpbWUgd2l0aCBuYW5vc2Vjb25kcyBwcmVjaXNpb25cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCk6IHN0cmluZyB7XG4gIGlmIChpc05vZGVFbnZpcm9ubWVudCgpKSB7XG4gICAgY29uc3QgbmFub3MgPSBwcm9jZXNzLmhydGltZSgpWzFdO1xuICAgIGNvbnN0IHNlY29uZHMgPSAoRGF0ZS5ub3coKSAqIDEwMDAwMDAgKyBuYW5vcykgLyAxMDAwMDAwMDAwO1xuICAgIHJldHVybiBzZWNvbmRzLnRvRml4ZWQoOSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KCkpLnRvRml4ZWQoOSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCB0aW1lc3RhbXAuIE5hbm9zZWNvbmRzIGFyZSBvcHRpb25hbCBhbmQgY2FuIGJlIHBhc3NlZCBhZnRlciBhIGRvdCwgZm9yXG4gKiBleGFtcGxlOiAxNTk1Mzc0NzIzLjM1Njk4MTY4OVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lIC0gdGhlIHRpbWVzdGFtcCB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUaW1lU3RyaW5nKHRpbWU6IHN0cmluZykge1xuICByZXR1cm4gL15bMC05XSsoXFwuWzAtOV0rKT8kLy50ZXN0KHRpbWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudCBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IC0gdGhlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQW1vdW50KGFtb3VudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYW1vdW50KTtcbiAgcmV0dXJuIChcbiAgICBiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgJiZcbiAgICBiaWdOdW1iZXJBbW91bnQuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbygwKSAmJlxuICAgIGJpZ051bWJlckFtb3VudC5pc0xlc3NUaGFuT3JFcXVhbFRvKE1BWF9USU5ZQkFSU19BTU9VTlQpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCByYXcgdHJhbnNhY3Rpb24gYWNjb21tb2RhdGVzIHRvIGJpdGdvJ3MgcHJlZmVycmVkIGZvcm1hdFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdUcmFuc2FjdGlvbiAtIFRoZSByYXcgdHJhbnNhY3Rpb24gdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFJhd1RyYW5zYWN0aW9uRm9ybWF0KHJhd1RyYW5zYWN0aW9uOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKFxuICAgICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnICYmIC9eWzAtOWEtZkEtRl0rJC8udGVzdChyYXdUcmFuc2FjdGlvbikpIHx8XG4gICAgKEJ1ZmZlci5pc0J1ZmZlcihyYXdUcmFuc2FjdGlvbikgJiYgVWludDhBcnJheS5mcm9tKHJhd1RyYW5zYWN0aW9uKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4ge3Byb3RvLklBY2NvdW50SUR9IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7cHJvdG8uSUFjY291bnRJRH0gLSBhY2NvdW50IGlkIHRvIGJlIGNhc3QgdG8gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtwcm90by5JQWNjb3VudElEfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5QWNjb3VudElkKHsgc2hhcmROdW0sIHJlYWxtTnVtLCBhY2NvdW50TnVtIH06IHByb3RvLklBY2NvdW50SUQpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7c2hhcmROdW0gfHwgMH0uJHtyZWFsbU51bSB8fCAwfS4ke2FjY291bnROdW19YDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHtwcm90by5JVGltZXN0YW1wfSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3Byb3RvLklUaW1lc3RhbXB9IC0gdGltZXN0YW1wIHRvIGJlIGNhc3QgdG8gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtwcm90by5JVGltZXN0YW1wfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5VHhUaW1lKHsgc2Vjb25kcywgbmFub3MgfTogcHJvdG8uSVRpbWVzdGFtcCkge1xuICByZXR1cm4gYCR7c2Vjb25kc30uJHtuYW5vc31gO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIHByZWZpeCBmcm9tIGEgc3RyaW5nIG9ubHkgaWYgaXQgc3RhcnRzIHdpdGggdGhhdCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYmUgcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgb3JpZ2luYWwgc3RyaW5nLCB1c3VhbGx5IGEgcHJpdmF0ZSBvciBwdWJsaWMga2V5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHdpdGhvdXQgcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcmVmaXgocHJlZml4OiBzdHJpbmcsIGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKGtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICByZXR1cm4ga2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIHZhbGlkIG1lbW8gb3Igbm90LlxuICpcbiAqIEBwYXJhbSBtZW1vXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWVtbyhtZW1vOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICEoXy5pc0VtcHR5KG1lbW8pIHx8IEJ1ZmZlci5mcm9tKG1lbW8pLmxlbmd0aCA+IDEwMCk7XG59XG5cbi8qKlxuICogVXNlcyB0aGUgbmF0aXZlIGhhc2hncmFwaCBTREsgZnVuY3Rpb24gdG8gZ2V0IGEgcmF3IGtleS5cbiAqXG4gKiBAcGFyYW0gcHJ2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXdLZXkocHJ2OiBzdHJpbmcpOiBQcml2YXRlS2V5IHtcbiAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbVN0cmluZyhwcnYpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIHN0ZWxsYXIgcHVibGljIGtleSB0byBhIGVkMjU1MTkgaGV4IGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gc3RlbGxhclB1YlxuICogQHBhcmFtIHBydlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEZyb21TdGVsbGFyUHViKHN0ZWxsYXJQdWI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoc3RlbGxhclB1YikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIHN0ZWxsYXIgcHViLicpO1xuICB9XG5cbiAgY29uc3QgcmF3S2V5OiBCdWZmZXIgPSBzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5UHVibGljS2V5KHN0ZWxsYXJQdWIpO1xuICByZXR1cm4gcmF3S2V5LnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyBhbiBhZGRyZXNzIHRvIHRoZSBiYXNlIGFkZHJlc3MgdG8gY2hlY2sgaWYgbWF0Y2hzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gYW4gYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VBZGRyZXNzIC0gYSBiYXNlIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYW1lQmFzZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBiYXNlQWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZEFkZHJlc3NXaXRoUGF5bWVudElkKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICB9XG4gIHJldHVybiBnZXRCYXNlQWRkcmVzcyhhZGRyZXNzKSA9PT0gZ2V0QmFzZUFkZHJlc3MoYmFzZUFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgYWRkcmVzcyBwb3J0aW9uIG9mIGFuIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIGFuIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdGhlIGJhc2UgYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgcmV0dXJuIGFkZHJlc3NEZXRhaWxzLmFkZHJlc3M7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhZGRyZXNzIGludG8gYWRkcmVzcyBhbmQgbWVtbyBpZFxuICpcbiAqIEBwYXJhbSByYXdBZGRyZXNzIHRoZSBhZGRyZXNzXG4gKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzRGV0YWlscyhyYXdBZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzRGV0YWlscyB7XG4gIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdXJsLnBhcnNlKHJhd0FkZHJlc3MpO1xuICBjb25zdCBxdWVyeURldGFpbHMgPSBhZGRyZXNzRGV0YWlscy5xdWVyeSA/IHF1ZXJ5c3RyaW5nLnBhcnNlKGFkZHJlc3NEZXRhaWxzLnF1ZXJ5KSA6IHt9O1xuICBjb25zdCBiYXNlQWRkcmVzcyA9IDxzdHJpbmc+YWRkcmVzc0RldGFpbHMucGF0aG5hbWU7XG4gIGlmICghaXNWYWxpZEFkZHJlc3MoYmFzZUFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHtyYXdBZGRyZXNzfWApO1xuICB9XG5cbiAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkIG9yIG1lbW9JZCBpcyBlbXB0eVxuICBpZiAoYmFzZUFkZHJlc3MgPT09IHJhd0FkZHJlc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cbiAgY29uc3QgbWVtb0lkID0gPHN0cmluZz5xdWVyeURldGFpbHMubWVtb0lkO1xuICBpZiAoIWlzVmFsaWRNZW1vKG1lbW9JZCkpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAnJHtyYXdBZGRyZXNzfScsIG1lbW9JZCBpcyBub3QgdmFsaWRgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogYmFzZUFkZHJlc3MsXG4gICAgbWVtb0lkLFxuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuZCByZXR1cm4gYWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWRcbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3NEZXRhaWxzfSBhZGRyZXNzRGV0YWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIG1lbW9JZCB9OiBBZGRyZXNzRGV0YWlscyk6IHN0cmluZyB7XG4gIGlmIChtZW1vSWQgJiYgaXNWYWxpZE1lbW8obWVtb0lkKSkge1xuICAgIHJldHVybiBgJHthZGRyZXNzfT9tZW1vSWQ9JHttZW1vSWR9YDtcbiAgfVxuICByZXR1cm4gYWRkcmVzcztcbn1cblxuLyoqXG4gKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgYSB2YWxpZCBhZGRyZXNzIHdpdGggbWVtbyBpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIGFkZHJlc3MgaW4gdGhlIGZvcm0gPGFkZHJlc3M+P21lbW9JZD08bWVtb0lkPlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgaW5wdXQgaXMgYSB2YWxpZCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWRkcmVzc1dpdGhQYXltZW50SWQoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICByZXR1cm4gYWRkcmVzcyA9PT0gbm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdfQ==