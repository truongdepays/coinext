"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferBuilder = void 0;
var Long = __importStar(require("long"));
var sdk_1 = require("@hashgraph/sdk");
var hedera_1 = require("../../../resources/hbar/protobuf/hedera");
var errors_1 = require("../baseCoin/errors");
var transactionBuilder_1 = require("./transactionBuilder");
var utils_1 = require("./utils");
var baseCoin_1 = require("../baseCoin");
var TransferBuilder = /** @class */ (function (_super) {
    __extends(TransferBuilder, _super);
    function TransferBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._txBodyData = new hedera_1.proto.CryptoTransferTransactionBody();
        _this._txBody.cryptoTransfer = _this._txBodyData;
        return _this;
    }
    /** @inheritdoc */
    TransferBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._txBodyData.transfers = this.buildTransferData();
                        this.transaction.setTransactionType(baseCoin_1.TransactionType.Send);
                        return [4 /*yield*/, _super.prototype.buildImplementation.call(this)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    TransferBuilder.prototype.buildTransferData = function () {
        return {
            accountAmounts: [
                { accountID: this.buildAccountData(this._source.address), amount: Long.fromString(this._amount).negate() },
                { accountID: this.buildAccountData(this._toAddress), amount: Long.fromString(this._amount) }, // recipient
            ],
        };
    };
    TransferBuilder.prototype.buildAccountData = function (address) {
        var accountData = sdk_1.AccountId.fromString(address);
        return new hedera_1.proto.AccountID({
            accountNum: accountData.num,
            realmNum: accountData.realm,
            shardNum: accountData.shard,
        });
    };
    /** @inheritdoc */
    TransferBuilder.prototype.initBuilder = function (tx) {
        _super.prototype.initBuilder.call(this, tx);
        this.transaction.setTransactionType(baseCoin_1.TransactionType.Send);
        var transferData = tx.txBody.cryptoTransfer;
        if (transferData && transferData.transfers && transferData.transfers.accountAmounts) {
            this.initTransfers(transferData.transfers.accountAmounts);
        }
    };
    /**
     * Initialize the transfer specific data, getting the recipient account
     * represented by the element with a positive amount on the transfer element.
     * The negative amount represents the source account so it's ignored.
     *
     * @param {proto.IAccountAmount[]} transfers array of objects which contains accountID and transferred amount
     */
    TransferBuilder.prototype.initTransfers = function (transfers) {
        var _this = this;
        transfers.forEach(function (transferData) {
            var amount = Long.fromValue(transferData.amount);
            if (amount.isPositive()) {
                _this.to(utils_1.stringifyAccountId(transferData.accountID));
                _this.amount(amount.toString());
            }
        });
    };
    /** @inheritdoc */
    TransferBuilder.prototype.signImplementation = function (key) {
        if (this._multiSignerKeyPairs.length >= transactionBuilder_1.DEFAULT_M) {
            throw new errors_1.SigningError('A maximum of ' + transactionBuilder_1.DEFAULT_M + ' can sign the transaction.');
        }
        return _super.prototype.signImplementation.call(this, key);
    };
    // region Transfer fields
    /**
     * Set the destination address where the funds will be sent,
     * it may take the format `'<shard>.<realm>.<account>'` or `'<account>'`
     *
     * @param {string} address the address to transfer funds to
     * @returns {TransferBuilder} the builder with the new parameter set
     */
    TransferBuilder.prototype.to = function (address) {
        if (!utils_1.isValidAddress(address)) {
            throw new errors_1.InvalidParameterValueError('Invalid address');
        }
        this._toAddress = address;
        return this;
    };
    /**
     * Set the amount to be transferred
     *
     * @param {string} amount amount to transfer in tinyBars (there are 100,000,000 tinyBars in one Hbar)
     * @returns {TransferBuilder} the builder with the new parameter set
     */
    TransferBuilder.prototype.amount = function (amount) {
        if (!utils_1.isValidAmount(amount)) {
            throw new errors_1.InvalidParameterValueError('Invalid amount');
        }
        this._amount = amount;
        return this;
    };
    // endregion
    // region Validators
    TransferBuilder.prototype.validateMandatoryFields = function () {
        if (this._toAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing to');
        }
        if (this._amount === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing amount');
        }
        _super.prototype.validateMandatoryFields.call(this);
    };
    return TransferBuilder;
}(transactionBuilder_1.TransactionBuilder));
exports.TransferBuilder = TransferBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vaGJhci90cmFuc2ZlckJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLHlDQUE2QjtBQUM3QixzQ0FBMkM7QUFDM0Msa0VBQWdFO0FBQ2hFLDZDQUFxRztBQUVyRywyREFBcUU7QUFFckUsaUNBQTRFO0FBQzVFLHdDQUE4QztBQUU5QztJQUFxQyxtQ0FBa0I7SUFLckQseUJBQVksV0FBaUM7UUFBN0MsWUFDRSxrQkFBTSxXQUFXLENBQUMsU0FHbkI7UUFGQyxLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksY0FBSyxDQUFDLDZCQUE2QixFQUFFLENBQUM7UUFDN0QsS0FBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQzs7SUFDakQsQ0FBQztJQUVELGtCQUFrQjtJQUNGLDZDQUFtQixHQUFuQzs7Ozs7d0JBQ0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7d0JBQ3RELElBQUksQ0FBQyxXQUFXLENBQUMsa0JBQWtCLENBQUMsMEJBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDbkQscUJBQU0saUJBQU0sbUJBQW1CLFdBQUUsRUFBQTs0QkFBeEMsc0JBQU8sU0FBaUMsRUFBQzs7OztLQUMxQztJQUVPLDJDQUFpQixHQUF6QjtRQUNFLE9BQU87WUFDTCxjQUFjLEVBQUU7Z0JBQ2QsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxD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LENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUNqQyxNQUFNLElBQUksOEJBQXFCLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRTtRQUNELElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUU7WUFDOUIsTUFBTSxJQUFJLDhCQUFxQixDQUFDLHFDQUFxQyxDQUFDLENBQUM7U0FDeEU7UUFDRCxpQkFBTSx1QkFBdUIsV0FBRSxDQUFDO0lBQ2xDLENBQUM7SUFFSCxzQkFBQztBQUFELENBQUMsQUFsSEQsQ0FBcUMsdUNBQWtCLEdBa0h0RDtBQWxIWSwwQ0FBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgKiBhcyBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IHsgQWNjb3VudElkIH0gZnJvbSAnQGhhc2hncmFwaC9zZGsnO1xuaW1wb3J0IHsgcHJvdG8gfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZXMvaGJhci9wcm90b2J1Zi9oZWRlcmEnO1xuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBJbnZhbGlkUGFyYW1ldGVyVmFsdWVFcnJvciwgU2lnbmluZ0Vycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IEJhc2VLZXkgfSBmcm9tICcuLi9iYXNlQ29pbi9pZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbkJ1aWxkZXIsIERFRkFVTFRfTSB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBpc1ZhbGlkQWRkcmVzcywgaXNWYWxpZEFtb3VudCwgc3RyaW5naWZ5QWNjb3VudElkIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2ZlckJ1aWxkZXIgZXh0ZW5kcyBUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcml2YXRlIF90eEJvZHlEYXRhOiBwcm90by5DcnlwdG9UcmFuc2ZlclRyYW5zYWN0aW9uQm9keTtcbiAgcHJpdmF0ZSBfdG9BZGRyZXNzOiBzdHJpbmc7XG4gIHByaXZhdGUgX2Ftb3VudDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl90eEJvZHlEYXRhID0gbmV3IHByb3RvLkNyeXB0b1RyYW5zZmVyVHJhbnNhY3Rpb25Cb2R5KCk7XG4gICAgdGhpcy5fdHhCb2R5LmNyeXB0b1RyYW5zZmVyID0gdGhpcy5fdHhCb2R5RGF0YTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgdGhpcy5fdHhCb2R5RGF0YS50cmFuc2ZlcnMgPSB0aGlzLmJ1aWxkVHJhbnNmZXJEYXRhKCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvblR5cGUoVHJhbnNhY3Rpb25UeXBlLlNlbmQpO1xuICAgIHJldHVybiBhd2FpdCBzdXBlci5idWlsZEltcGxlbWVudGF0aW9uKCk7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkVHJhbnNmZXJEYXRhKCk6IHByb3RvLklUcmFuc2Zlckxpc3Qge1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50QW1vdW50czogW1xuICAgICAgICB7IGFjY291bnRJRDogdGhpcy5idWlsZEFjY291bnREYXRhKHRoaXMuX3NvdXJjZS5hZGRyZXNzKSwgYW1vdW50OiBMb25nLmZyb21TdHJpbmcodGhpcy5fYW1vdW50KS5uZWdhdGUoKSB9LCAvLyBzZW5kZXJcbiAgICAgICAgeyBhY2NvdW50SUQ6IHRoaXMuYnVpbGRBY2NvdW50RGF0YSh0aGlzLl90b0FkZHJlc3MpLCBhbW91bnQ6IExvbmcuZnJvbVN0cmluZyh0aGlzLl9hbW91bnQpIH0sIC8vIHJlY2lwaWVudFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEFjY291bnREYXRhKGFkZHJlc3M6IHN0cmluZyk6IHByb3RvLkFjY291bnRJRCB7XG4gICAgY29uc3QgYWNjb3VudERhdGEgPSBBY2NvdW50SWQuZnJvbVN0cmluZyhhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IHByb3RvLkFjY291bnRJRCh7XG4gICAgICBhY2NvdW50TnVtOiBhY2NvdW50RGF0YS5udW0sXG4gICAgICByZWFsbU51bTogYWNjb3VudERhdGEucmVhbG0sXG4gICAgICBzaGFyZE51bTogYWNjb3VudERhdGEuc2hhcmQsXG4gICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb25UeXBlKFRyYW5zYWN0aW9uVHlwZS5TZW5kKTtcbiAgICBjb25zdCB0cmFuc2ZlckRhdGEgPSB0eC50eEJvZHkuY3J5cHRvVHJhbnNmZXI7XG4gICAgaWYgKHRyYW5zZmVyRGF0YSAmJiB0cmFuc2ZlckRhdGEudHJhbnNmZXJzICYmIHRyYW5zZmVyRGF0YS50cmFuc2ZlcnMuYWNjb3VudEFtb3VudHMpIHtcbiAgICAgIHRoaXMuaW5pdFRyYW5zZmVycyh0cmFuc2ZlckRhdGEudHJhbnNmZXJzLmFjY291bnRBbW91bnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNmZXIgc3BlY2lmaWMgZGF0YSwgZ2V0dGluZyB0aGUgcmVjaXBpZW50IGFjY291bnRcbiAgICogcmVwcmVzZW50ZWQgYnkgdGhlIGVsZW1lbnQgd2l0aCBhIHBvc2l0aXZlIGFtb3VudCBvbiB0aGUgdHJhbnNmZXIgZWxlbWVudC5cbiAgICogVGhlIG5lZ2F0aXZlIGFtb3VudCByZXByZXNlbnRzIHRoZSBzb3VyY2UgYWNjb3VudCBzbyBpdCdzIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7cHJvdG8uSUFjY291bnRBbW91bnRbXX0gdHJhbnNmZXJzIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggY29udGFpbnMgYWNjb3VudElEIGFuZCB0cmFuc2ZlcnJlZCBhbW91bnRcbiAgICovXG4gIHByb3RlY3RlZCBpbml0VHJhbnNmZXJzKHRyYW5zZmVyczogcHJvdG8uSUFjY291bnRBbW91bnRbXSk6IHZvaWQge1xuICAgIHRyYW5zZmVycy5mb3JFYWNoKCh0cmFuc2ZlckRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGFtb3VudCA9IExvbmcuZnJvbVZhbHVlKHRyYW5zZmVyRGF0YS5hbW91bnQhKTtcbiAgICAgIGlmIChhbW91bnQuaXNQb3NpdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMudG8oc3RyaW5naWZ5QWNjb3VudElkKHRyYW5zZmVyRGF0YS5hY2NvdW50SUQhKSk7XG4gICAgICAgIHRoaXMuYW1vdW50KGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgc2lnbkltcGxlbWVudGF0aW9uKGtleTogQmFzZUtleSk6IFRyYW5zYWN0aW9uIHtcbiAgICBpZiAodGhpcy5fbXVsdGlTaWduZXJLZXlQYWlycy5sZW5ndGggPj0gREVGQVVMVF9NKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdBIG1heGltdW0gb2YgJyArIERFRkFVTFRfTSArICcgY2FuIHNpZ24gdGhlIHRyYW5zYWN0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2lnbkltcGxlbWVudGF0aW9uKGtleSk7XG4gIH1cblxuICAvLyByZWdpb24gVHJhbnNmZXIgZmllbGRzXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3Mgd2hlcmUgdGhlIGZ1bmRzIHdpbGwgYmUgc2VudCxcbiAgICogaXQgbWF5IHRha2UgdGhlIGZvcm1hdCBgJzxzaGFyZD4uPHJlYWxtPi48YWNjb3VudD4nYCBvciBgJzxhY2NvdW50PidgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZ1bmRzIHRvXG4gICAqIEByZXR1cm5zIHtUcmFuc2ZlckJ1aWxkZXJ9IHRoZSBidWlsZGVyIHdpdGggdGhlIG5ldyBwYXJhbWV0ZXIgc2V0XG4gICAqL1xuICB0byhhZGRyZXNzOiBzdHJpbmcpOiB0aGlzIHtcbiAgICBpZiAoIWlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgIH1cbiAgICB0aGlzLl90b0FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYW1vdW50IHRvIGJlIHRyYW5zZmVycmVkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgYW1vdW50IHRvIHRyYW5zZmVyIGluIHRpbnlCYXJzICh0aGVyZSBhcmUgMTAwLDAwMCwwMDAgdGlueUJhcnMgaW4gb25lIEhiYXIpXG4gICAqIEByZXR1cm5zIHtUcmFuc2ZlckJ1aWxkZXJ9IHRoZSBidWlsZGVyIHdpdGggdGhlIG5ldyBwYXJhbWV0ZXIgc2V0XG4gICAqL1xuICBhbW91bnQoYW1vdW50OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBpZiAoIWlzVmFsaWRBbW91bnQoYW1vdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yKCdJbnZhbGlkIGFtb3VudCcpO1xuICAgIH1cbiAgICB0aGlzLl9hbW91bnQgPSBhbW91bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbmRyZWdpb25cblxuICAvLyByZWdpb24gVmFsaWRhdG9yc1xuICB2YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fdG9BZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3NpbmcgdG8nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Ftb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGFtb3VudCcpO1xuICAgIH1cbiAgICBzdXBlci52YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcygpO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxufVxuIl19