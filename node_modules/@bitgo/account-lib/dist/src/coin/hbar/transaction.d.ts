import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { proto } from '../../../resources/hbar/protobuf/hedera';
import { BaseTransaction, TransactionType } from '../baseCoin';
import { BaseKey } from '../baseCoin/iface';
import { TxData } from './ifaces';
import { KeyPair } from './';
export declare class Transaction extends BaseTransaction {
    private _hederaTx;
    private _txBody;
    protected _type: TransactionType;
    constructor(_coinConfig: Readonly<CoinConfig>);
    /** @inheritdoc */
    canSign(key: BaseKey): boolean;
    sign(keyPair: KeyPair): Promise<void>;
    /**
     * Add a signature to this transaction
     *
     * @param {string} signature The signature to add, in string hex format
     * @param {KeyPair} key The key of the key that created the signature
     */
    addSignature(signature: string, key: KeyPair): void;
    /** @inheritdoc */
    toBroadcastFormat(): string;
    /** @inheritdoc */
    toJson(): TxData;
    /**
     * Get the recipient account and the amount
     * transferred on this transaction
     *
     * @returns {[string, string]} first element is the recipient, second element is the amount
     */
    private getTransferData;
    get txBody(): proto.TransactionBody;
    get hederaTx(): proto.Transaction;
    /**
     * Sets this transaction body components
     *
     * @param {proto.Transaction} tx body transaction
     */
    body(tx: proto.Transaction): void;
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType: TransactionType): void;
    /**
     * Decode previous signatures from the inner hedera transaction
     * and save them into the base transaction signature list.
     */
    loadPreviousSignatures(): void;
    /**
     * Load the input and output data on this transaction using the transaction json
     * if there are outputs. For transactions without outputs (e.g. wallet initializations),
     * this function will not do anything
     */
    loadInputsAndOutputs(): void;
    /**
     * Sets this transaction body components
     *
     * @param {Uint8Array} bytes encoded body transaction
     */
    bodyBytes(bytes: Uint8Array): void;
    /**
     * Returns this hedera transaction id components in a readable format
     *
     * @returns {[string, string]} - transaction id parts [<account id>, <startTime in seconds>]
     */
    getTxIdParts(): [string, string];
    /**
     * Returns this transaction hash
     *
     * @returns {string} - The transaction hash
     */
    getTxHash(): string;
    /**
     * Encode an object using the given encoder class
     *
     * @param {proto} obj - the object to be encoded, it must be an proto namespace object
     * @param encoder - Object encoder
     * @returns {Uint8Array} - encoded object byte array
     */
    private encode;
    /**
     * Returns an sha-384 hash
     *
     * @param {Uint8Array} bytes - bytes to be hashed
     * @returns {string} - the resulting hash string
     */
    sha(bytes: Uint8Array): string;
    /**
     * Returns a hash of the given proto object.
     *
     * @param {proto} obj - The object to be hashed, it must be an proto namespace object
     * @returns {string} - the resulting hash string
     */
    private getHashOf;
}
//# sourceMappingURL=transaction.d.ts.map