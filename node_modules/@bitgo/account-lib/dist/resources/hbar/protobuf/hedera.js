/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.proto = (function() {

    /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
    var proto = {};

    proto.Timestamp = (function() {

        /**
         * Properties of a Timestamp.
         * @memberof proto
         * @interface ITimestamp
         * @property {number|Long|null} [seconds] Timestamp seconds
         * @property {number|null} [nanos] Timestamp nanos
         */

        /**
         * Constructs a new Timestamp.
         * @memberof proto
         * @classdesc Represents a Timestamp.
         * @implements ITimestamp
         * @constructor
         * @param {proto.ITimestamp=} [properties] Properties to set
         */
        function Timestamp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timestamp seconds.
         * @member {number|Long} seconds
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Timestamp nanos.
         * @member {number} nanos
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @function create
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp=} [properties] Properties to set
         * @returns {proto.Timestamp} Timestamp instance
         */
        Timestamp.create = function create(properties) {
            return new Timestamp(properties);
        };

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
            return writer;
        };

        /**
         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Timestamp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timestamp message.
         * @function verify
         * @memberof proto.Timestamp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timestamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                    return "seconds: integer|Long expected";
            if (message.nanos != null && message.hasOwnProperty("nanos"))
                if (!$util.isInteger(message.nanos))
                    return "nanos: integer expected";
            return null;
        };

        /**
         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Timestamp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Timestamp} Timestamp
         */
        Timestamp.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Timestamp)
                return object;
            var message = new $root.proto.Timestamp();
            if (object.seconds != null)
                if ($util.Long)
                    (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                else if (typeof object.seconds === "string")
                    message.seconds = parseInt(object.seconds, 10);
                else if (typeof object.seconds === "number")
                    message.seconds = object.seconds;
                else if (typeof object.seconds === "object")
                    message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
            if (object.nanos != null)
                message.nanos = object.nanos | 0;
            return message;
        };

        /**
         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Timestamp
         * @static
         * @param {proto.Timestamp} message Timestamp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timestamp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds = options.longs === String ? "0" : 0;
                object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (typeof message.seconds === "number")
                    object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else
                    object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
                object.nanos = message.nanos;
            return object;
        };

        /**
         * Converts this Timestamp to JSON.
         * @function toJSON
         * @memberof proto.Timestamp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timestamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Timestamp;
    })();

    proto.TimestampSeconds = (function() {

        /**
         * Properties of a TimestampSeconds.
         * @memberof proto
         * @interface ITimestampSeconds
         * @property {number|Long|null} [seconds] TimestampSeconds seconds
         */

        /**
         * Constructs a new TimestampSeconds.
         * @memberof proto
         * @classdesc Represents a TimestampSeconds.
         * @implements ITimestampSeconds
         * @constructor
         * @param {proto.ITimestampSeconds=} [properties] Properties to set
         */
        function TimestampSeconds(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimestampSeconds seconds.
         * @member {number|Long} seconds
         * @memberof proto.TimestampSeconds
         * @instance
         */
        TimestampSeconds.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TimestampSeconds instance using the specified properties.
         * @function create
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds=} [properties] Properties to set
         * @returns {proto.TimestampSeconds} TimestampSeconds instance
         */
        TimestampSeconds.create = function create(properties) {
            return new TimestampSeconds(properties);
        };

        /**
         * Encodes the specified TimestampSeconds message. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @function encode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds} message TimestampSeconds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampSeconds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
            return writer;
        };

        /**
         * Encodes the specified TimestampSeconds message, length delimited. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds} message TimestampSeconds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampSeconds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TimestampSeconds} TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampSeconds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TimestampSeconds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TimestampSeconds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TimestampSeconds} TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampSeconds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimestampSeconds message.
         * @function verify
         * @memberof proto.TimestampSeconds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimestampSeconds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                    return "seconds: integer|Long expected";
            return null;
        };

        /**
         * Creates a TimestampSeconds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TimestampSeconds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TimestampSeconds} TimestampSeconds
         */
        TimestampSeconds.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TimestampSeconds)
                return object;
            var message = new $root.proto.TimestampSeconds();
            if (object.seconds != null)
                if ($util.Long)
                    (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                else if (typeof object.seconds === "string")
                    message.seconds = parseInt(object.seconds, 10);
                else if (typeof object.seconds === "number")
                    message.seconds = object.seconds;
                else if (typeof object.seconds === "object")
                    message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TimestampSeconds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.TimestampSeconds} message TimestampSeconds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimestampSeconds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds = options.longs === String ? "0" : 0;
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (typeof message.seconds === "number")
                    object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else
                    object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            return object;
        };

        /**
         * Converts this TimestampSeconds to JSON.
         * @function toJSON
         * @memberof proto.TimestampSeconds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimestampSeconds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimestampSeconds;
    })();

    proto.ShardID = (function() {

        /**
         * Properties of a ShardID.
         * @memberof proto
         * @interface IShardID
         * @property {number|Long|null} [shardNum] ShardID shardNum
         */

        /**
         * Constructs a new ShardID.
         * @memberof proto
         * @classdesc Represents a ShardID.
         * @implements IShardID
         * @constructor
         * @param {proto.IShardID=} [properties] Properties to set
         */
        function ShardID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.ShardID
         * @instance
         */
        ShardID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ShardID instance using the specified properties.
         * @function create
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID=} [properties] Properties to set
         * @returns {proto.ShardID} ShardID instance
         */
        ShardID.create = function create(properties) {
            return new ShardID(properties);
        };

        /**
         * Encodes the specified ShardID message. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @function encode
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID} message ShardID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            return writer;
        };

        /**
         * Encodes the specified ShardID message, length delimited. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID} message ShardID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ShardID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ShardID} ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ShardID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ShardID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ShardID} ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardID message.
         * @function verify
         * @memberof proto.ShardID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a ShardID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ShardID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ShardID} ShardID
         */
        ShardID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ShardID)
                return object;
            var message = new $root.proto.ShardID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ShardID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ShardID
         * @static
         * @param {proto.ShardID} message ShardID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            return object;
        };

        /**
         * Converts this ShardID to JSON.
         * @function toJSON
         * @memberof proto.ShardID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShardID;
    })();

    proto.RealmID = (function() {

        /**
         * Properties of a RealmID.
         * @memberof proto
         * @interface IRealmID
         * @property {number|Long|null} [shardNum] RealmID shardNum
         * @property {number|Long|null} [realmNum] RealmID realmNum
         */

        /**
         * Constructs a new RealmID.
         * @memberof proto
         * @classdesc Represents a RealmID.
         * @implements IRealmID
         * @constructor
         * @param {proto.IRealmID=} [properties] Properties to set
         */
        function RealmID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RealmID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RealmID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RealmID instance using the specified properties.
         * @function create
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID=} [properties] Properties to set
         * @returns {proto.RealmID} RealmID instance
         */
        RealmID.create = function create(properties) {
            return new RealmID(properties);
        };

        /**
         * Encodes the specified RealmID message. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @function encode
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID} message RealmID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealmID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            return writer;
        };

        /**
         * Encodes the specified RealmID message, length delimited. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID} message RealmID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealmID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RealmID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RealmID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RealmID} RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealmID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RealmID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RealmID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RealmID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RealmID} RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealmID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RealmID message.
         * @function verify
         * @memberof proto.RealmID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RealmID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a RealmID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RealmID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RealmID} RealmID
         */
        RealmID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RealmID)
                return object;
            var message = new $root.proto.RealmID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RealmID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RealmID
         * @static
         * @param {proto.RealmID} message RealmID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RealmID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            return object;
        };

        /**
         * Converts this RealmID to JSON.
         * @function toJSON
         * @memberof proto.RealmID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RealmID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RealmID;
    })();

    proto.AccountID = (function() {

        /**
         * Properties of an AccountID.
         * @memberof proto
         * @interface IAccountID
         * @property {number|Long|null} [shardNum] AccountID shardNum
         * @property {number|Long|null} [realmNum] AccountID realmNum
         * @property {number|Long|null} [accountNum] AccountID accountNum
         */

        /**
         * Constructs a new AccountID.
         * @memberof proto
         * @classdesc Represents an AccountID.
         * @implements IAccountID
         * @constructor
         * @param {proto.IAccountID=} [properties] Properties to set
         */
        function AccountID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountID accountNum.
         * @member {number|Long} accountNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.accountNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountID instance using the specified properties.
         * @function create
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID=} [properties] Properties to set
         * @returns {proto.AccountID} AccountID instance
         */
        AccountID.create = function create(properties) {
            return new AccountID(properties);
        };

        /**
         * Encodes the specified AccountID message. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID} message AccountID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            if (message.accountNum != null && Object.hasOwnProperty.call(message, "accountNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.accountNum);
            return writer;
        };

        /**
         * Encodes the specified AccountID message, length delimited. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID} message AccountID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AccountID} AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AccountID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                case 3:
                    message.accountNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AccountID} AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountID message.
         * @function verify
         * @memberof proto.AccountID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            if (message.accountNum != null && message.hasOwnProperty("accountNum"))
                if (!$util.isInteger(message.accountNum) && !(message.accountNum && $util.isInteger(message.accountNum.low) && $util.isInteger(message.accountNum.high)))
                    return "accountNum: integer|Long expected";
            return null;
        };

        /**
         * Creates an AccountID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AccountID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AccountID} AccountID
         */
        AccountID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AccountID)
                return object;
            var message = new $root.proto.AccountID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            if (object.accountNum != null)
                if ($util.Long)
                    (message.accountNum = $util.Long.fromValue(object.accountNum)).unsigned = false;
                else if (typeof object.accountNum === "string")
                    message.accountNum = parseInt(object.accountNum, 10);
                else if (typeof object.accountNum === "number")
                    message.accountNum = object.accountNum;
                else if (typeof object.accountNum === "object")
                    message.accountNum = new $util.LongBits(object.accountNum.low >>> 0, object.accountNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AccountID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AccountID
         * @static
         * @param {proto.AccountID} message AccountID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.accountNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accountNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            if (message.accountNum != null && message.hasOwnProperty("accountNum"))
                if (typeof message.accountNum === "number")
                    object.accountNum = options.longs === String ? String(message.accountNum) : message.accountNum;
                else
                    object.accountNum = options.longs === String ? $util.Long.prototype.toString.call(message.accountNum) : options.longs === Number ? new $util.LongBits(message.accountNum.low >>> 0, message.accountNum.high >>> 0).toNumber() : message.accountNum;
            return object;
        };

        /**
         * Converts this AccountID to JSON.
         * @function toJSON
         * @memberof proto.AccountID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountID;
    })();

    proto.FileID = (function() {

        /**
         * Properties of a FileID.
         * @memberof proto
         * @interface IFileID
         * @property {number|Long|null} [shardNum] FileID shardNum
         * @property {number|Long|null} [realmNum] FileID realmNum
         * @property {number|Long|null} [fileNum] FileID fileNum
         */

        /**
         * Constructs a new FileID.
         * @memberof proto
         * @classdesc Represents a FileID.
         * @implements IFileID
         * @constructor
         * @param {proto.IFileID=} [properties] Properties to set
         */
        function FileID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FileID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FileID fileNum.
         * @member {number|Long} fileNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.fileNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FileID instance using the specified properties.
         * @function create
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID=} [properties] Properties to set
         * @returns {proto.FileID} FileID instance
         */
        FileID.create = function create(properties) {
            return new FileID(properties);
        };

        /**
         * Encodes the specified FileID message. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @function encode
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID} message FileID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            if (message.fileNum != null && Object.hasOwnProperty.call(message, "fileNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fileNum);
            return writer;
        };

        /**
         * Encodes the specified FileID message, length delimited. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID} message FileID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FileID} FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FileID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                case 3:
                    message.fileNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FileID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.FileID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.FileID} FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileID message.
         * @function verify
         * @memberof proto.FileID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            if (message.fileNum != null && message.hasOwnProperty("fileNum"))
                if (!$util.isInteger(message.fileNum) && !(message.fileNum && $util.isInteger(message.fileNum.low) && $util.isInteger(message.fileNum.high)))
                    return "fileNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a FileID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.FileID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.FileID} FileID
         */
        FileID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.FileID)
                return object;
            var message = new $root.proto.FileID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            if (object.fileNum != null)
                if ($util.Long)
                    (message.fileNum = $util.Long.fromValue(object.fileNum)).unsigned = false;
                else if (typeof object.fileNum === "string")
                    message.fileNum = parseInt(object.fileNum, 10);
                else if (typeof object.fileNum === "number")
                    message.fileNum = object.fileNum;
                else if (typeof object.fileNum === "object")
                    message.fileNum = new $util.LongBits(object.fileNum.low >>> 0, object.fileNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FileID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.FileID
         * @static
         * @param {proto.FileID} message FileID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fileNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            if (message.fileNum != null && message.hasOwnProperty("fileNum"))
                if (typeof message.fileNum === "number")
                    object.fileNum = options.longs === String ? String(message.fileNum) : message.fileNum;
                else
                    object.fileNum = options.longs === String ? $util.Long.prototype.toString.call(message.fileNum) : options.longs === Number ? new $util.LongBits(message.fileNum.low >>> 0, message.fileNum.high >>> 0).toNumber() : message.fileNum;
            return object;
        };

        /**
         * Converts this FileID to JSON.
         * @function toJSON
         * @memberof proto.FileID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileID;
    })();

    proto.ContractID = (function() {

        /**
         * Properties of a ContractID.
         * @memberof proto
         * @interface IContractID
         * @property {number|Long|null} [shardNum] ContractID shardNum
         * @property {number|Long|null} [realmNum] ContractID realmNum
         * @property {number|Long|null} [contractNum] ContractID contractNum
         */

        /**
         * Constructs a new ContractID.
         * @memberof proto
         * @classdesc Represents a ContractID.
         * @implements IContractID
         * @constructor
         * @param {proto.IContractID=} [properties] Properties to set
         */
        function ContractID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractID contractNum.
         * @member {number|Long} contractNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.contractNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ContractID instance using the specified properties.
         * @function create
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID=} [properties] Properties to set
         * @returns {proto.ContractID} ContractID instance
         */
        ContractID.create = function create(properties) {
            return new ContractID(properties);
        };

        /**
         * Encodes the specified ContractID message. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID} message ContractID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            if (message.contractNum != null && Object.hasOwnProperty.call(message, "contractNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.contractNum);
            return writer;
        };

        /**
         * Encodes the specified ContractID message, length delimited. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID} message ContractID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ContractID} ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ContractID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                case 3:
                    message.contractNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ContractID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ContractID} ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractID message.
         * @function verify
         * @memberof proto.ContractID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            if (message.contractNum != null && message.hasOwnProperty("contractNum"))
                if (!$util.isInteger(message.contractNum) && !(message.contractNum && $util.isInteger(message.contractNum.low) && $util.isInteger(message.contractNum.high)))
                    return "contractNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a ContractID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ContractID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ContractID} ContractID
         */
        ContractID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ContractID)
                return object;
            var message = new $root.proto.ContractID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            if (object.contractNum != null)
                if ($util.Long)
                    (message.contractNum = $util.Long.fromValue(object.contractNum)).unsigned = false;
                else if (typeof object.contractNum === "string")
                    message.contractNum = parseInt(object.contractNum, 10);
                else if (typeof object.contractNum === "number")
                    message.contractNum = object.contractNum;
                else if (typeof object.contractNum === "object")
                    message.contractNum = new $util.LongBits(object.contractNum.low >>> 0, object.contractNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ContractID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ContractID
         * @static
         * @param {proto.ContractID} message ContractID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.contractNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.contractNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            if (message.contractNum != null && message.hasOwnProperty("contractNum"))
                if (typeof message.contractNum === "number")
                    object.contractNum = options.longs === String ? String(message.contractNum) : message.contractNum;
                else
                    object.contractNum = options.longs === String ? $util.Long.prototype.toString.call(message.contractNum) : options.longs === Number ? new $util.LongBits(message.contractNum.low >>> 0, message.contractNum.high >>> 0).toNumber() : message.contractNum;
            return object;
        };

        /**
         * Converts this ContractID to JSON.
         * @function toJSON
         * @memberof proto.ContractID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContractID;
    })();

    proto.TransactionID = (function() {

        /**
         * Properties of a TransactionID.
         * @memberof proto
         * @interface ITransactionID
         * @property {proto.ITimestamp|null} [transactionValidStart] TransactionID transactionValidStart
         * @property {proto.IAccountID|null} [accountID] TransactionID accountID
         * @property {boolean|null} [scheduled] TransactionID scheduled
         */

        /**
         * Constructs a new TransactionID.
         * @memberof proto
         * @classdesc Represents a TransactionID.
         * @implements ITransactionID
         * @constructor
         * @param {proto.ITransactionID=} [properties] Properties to set
         */
        function TransactionID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionID transactionValidStart.
         * @member {proto.ITimestamp|null|undefined} transactionValidStart
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.transactionValidStart = null;

        /**
         * TransactionID accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.accountID = null;

        /**
         * TransactionID scheduled.
         * @member {boolean} scheduled
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.scheduled = false;

        /**
         * Creates a new TransactionID instance using the specified properties.
         * @function create
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID=} [properties] Properties to set
         * @returns {proto.TransactionID} TransactionID instance
         */
        TransactionID.create = function create(properties) {
            return new TransactionID(properties);
        };

        /**
         * Encodes the specified TransactionID message. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID} message TransactionID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactionValidStart != null && Object.hasOwnProperty.call(message, "transactionValidStart"))
                $root.proto.Timestamp.encode(message.transactionValidStart, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
                $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.scheduled != null && Object.hasOwnProperty.call(message, "scheduled"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.scheduled);
            return writer;
        };

        /**
         * Encodes the specified TransactionID message, length delimited. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID} message TransactionID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TransactionID} TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transactionValidStart = $root.proto.Timestamp.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.scheduled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TransactionID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TransactionID} TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionID message.
         * @function verify
         * @memberof proto.TransactionID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactionValidStart != null && message.hasOwnProperty("transactionValidStart")) {
                var error = $root.proto.Timestamp.verify(message.transactionValidStart);
                if (error)
                    return "transactionValidStart." + error;
            }
            if (message.accountID != null && message.hasOwnProperty("accountID")) {
                var error = $root.proto.AccountID.verify(message.accountID);
                if (error)
                    return "accountID." + error;
            }
            if (message.scheduled != null && message.hasOwnProperty("scheduled"))
                if (typeof message.scheduled !== "boolean")
                    return "scheduled: boolean expected";
            return null;
        };

        /**
         * Creates a TransactionID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TransactionID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TransactionID} TransactionID
         */
        TransactionID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TransactionID)
                return object;
            var message = new $root.proto.TransactionID();
            if (object.transactionValidStart != null) {
                if (typeof object.transactionValidStart !== "object")
                    throw TypeError(".proto.TransactionID.transactionValidStart: object expected");
                message.transactionValidStart = $root.proto.Timestamp.fromObject(object.transactionValidStart);
            }
            if (object.accountID != null) {
                if (typeof object.accountID !== "object")
                    throw TypeError(".proto.TransactionID.accountID: object expected");
                message.accountID = $root.proto.AccountID.fromObject(object.accountID);
            }
            if (object.scheduled != null)
                message.scheduled = Boolean(object.scheduled);
            return message;
        };

        /**
         * Creates a plain object from a TransactionID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TransactionID
         * @static
         * @param {proto.TransactionID} message TransactionID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transactionValidStart = null;
                object.accountID = null;
                object.scheduled = false;
            }
            if (message.transactionValidStart != null && message.hasOwnProperty("transactionValidStart"))
                object.transactionValidStart = $root.proto.Timestamp.toObject(message.transactionValidStart, options);
            if (message.accountID != null && message.hasOwnProperty("accountID"))
                object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
            if (message.scheduled != null && message.hasOwnProperty("scheduled"))
                object.scheduled = message.scheduled;
            return object;
        };

        /**
         * Converts this TransactionID to JSON.
         * @function toJSON
         * @memberof proto.TransactionID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionID;
    })();

    proto.AccountAmount = (function() {

        /**
         * Properties of an AccountAmount.
         * @memberof proto
         * @interface IAccountAmount
         * @property {proto.IAccountID|null} [accountID] AccountAmount accountID
         * @property {number|Long|null} [amount] AccountAmount amount
         */

        /**
         * Constructs a new AccountAmount.
         * @memberof proto
         * @classdesc Represents an AccountAmount.
         * @implements IAccountAmount
         * @constructor
         * @param {proto.IAccountAmount=} [properties] Properties to set
         */
        function AccountAmount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountAmount accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.accountID = null;

        /**
         * AccountAmount amount.
         * @member {number|Long} amount
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountAmount instance using the specified properties.
         * @function create
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount=} [properties] Properties to set
         * @returns {proto.AccountAmount} AccountAmount instance
         */
        AccountAmount.create = function create(properties) {
            return new AccountAmount(properties);
        };

        /**
         * Encodes the specified AccountAmount message. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount} message AccountAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID"))
                $root.proto.AccountID.encode(message.accountID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified AccountAmount message, length delimited. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount} message AccountAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountAmount message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AccountAmount} AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AccountAmount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accountID = $root.proto.AccountID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.amount = reader.sint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AccountAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AccountAmount} AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountAmount message.
         * @function verify
         * @memberof proto.AccountAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountID != null && message.hasOwnProperty("accountID")) {
                var error = $root.proto.AccountID.verify(message.accountID);
                if (error)
                    return "accountID." + error;
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates an AccountAmount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AccountAmount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AccountAmount} AccountAmount
         */
        AccountAmount.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AccountAmount)
                return object;
            var message = new $root.proto.AccountAmount();
            if (object.accountID != null) {
                if (typeof object.accountID !== "object")
                    throw TypeError(".proto.AccountAmount.accountID: object expected");
                message.accountID = $root.proto.AccountID.fromObject(object.accountID);
            }
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AccountAmount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.AccountAmount} message AccountAmount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountAmount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.accountID = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.accountID != null && message.hasOwnProperty("accountID"))
                object.accountID = $root.proto.AccountID.toObject(message.accountID, options);
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this AccountAmount to JSON.
         * @function toJSON
         * @memberof proto.AccountAmount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountAmount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountAmount;
    })();

    proto.TransferList = (function() {

        /**
         * Properties of a TransferList.
         * @memberof proto
         * @interface ITransferList
         * @property {Array.<proto.IAccountAmount>|null} [accountAmounts] TransferList accountAmounts
         */

        /**
         * Constructs a new TransferList.
         * @memberof proto
         * @classdesc Represents a TransferList.
         * @implements ITransferList
         * @constructor
         * @param {proto.ITransferList=} [properties] Properties to set
         */
        function TransferList(properties) {
            this.accountAmounts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferList accountAmounts.
         * @member {Array.<proto.IAccountAmount>} accountAmounts
         * @memberof proto.TransferList
         * @instance
         */
        TransferList.prototype.accountAmounts = $util.emptyArray;

        /**
         * Creates a new TransferList instance using the specified properties.
         * @function create
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList=} [properties] Properties to set
         * @returns {proto.TransferList} TransferList instance
         */
        TransferList.create = function create(properties) {
            return new TransferList(properties);
        };

        /**
         * Encodes the specified TransferList message. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList} message TransferList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountAmounts != null && message.accountAmounts.length)
                for (var i = 0; i < message.accountAmounts.length; ++i)
                    $root.proto.AccountAmount.encode(message.accountAmounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransferList message, length delimited. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList} message TransferList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TransferList} TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransferList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accountAmounts && message.accountAmounts.length))
                        message.accountAmounts = [];
                    message.accountAmounts.push($root.proto.AccountAmount.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TransferList} TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferList message.
         * @function verify
         * @memberof proto.TransferList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountAmounts != null && message.hasOwnProperty("accountAmounts")) {
                if (!Array.isArray(message.accountAmounts))
                    return "accountAmounts: array expected";
                for (var i = 0; i < message.accountAmounts.length; ++i) {
                    var error = $root.proto.AccountAmount.verify(message.accountAmounts[i]);
                    if (error)
                        return "accountAmounts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransferList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TransferList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TransferList} TransferList
         */
        TransferList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TransferList)
                return object;
            var message = new $root.proto.TransferList();
            if (object.accountAmounts) {
                if (!Array.isArray(object.accountAmounts))
                    throw TypeError(".proto.TransferList.accountAmounts: array expected");
                message.accountAmounts = [];
                for (var i = 0; i < object.accountAmounts.length; ++i) {
                    if (typeof object.accountAmounts[i] !== "object")
                        throw TypeError(".proto.TransferList.accountAmounts: object expected");
                    message.accountAmounts[i] = $root.proto.AccountAmount.fromObject(object.accountAmounts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransferList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TransferList
         * @static
         * @param {proto.TransferList} message TransferList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accountAmounts = [];
            if (message.accountAmounts && message.accountAmounts.length) {
                object.accountAmounts = [];
                for (var j = 0; j < message.accountAmounts.length; ++j)
                    object.accountAmounts[j] = $root.proto.AccountAmount.toObject(message.accountAmounts[j], options);
            }
            return object;
        };

        /**
         * Converts this TransferList to JSON.
         * @function toJSON
         * @memberof proto.TransferList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferList;
    })();

    proto.TokenTransferList = (function() {

        /**
         * Properties of a TokenTransferList.
         * @memberof proto
         * @interface ITokenTransferList
         * @property {proto.ITokenID|null} [token] TokenTransferList token
         * @property {Array.<proto.IAccountAmount>|null} [transfers] TokenTransferList transfers
         */

        /**
         * Constructs a new TokenTransferList.
         * @memberof proto
         * @classdesc Represents a TokenTransferList.
         * @implements ITokenTransferList
         * @constructor
         * @param {proto.ITokenTransferList=} [properties] Properties to set
         */
        function TokenTransferList(properties) {
            this.transfers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenTransferList token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.token = null;

        /**
         * TokenTransferList transfers.
         * @member {Array.<proto.IAccountAmount>} transfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.transfers = $util.emptyArray;

        /**
         * Creates a new TokenTransferList instance using the specified properties.
         * @function create
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList=} [properties] Properties to set
         * @returns {proto.TokenTransferList} TokenTransferList instance
         */
        TokenTransferList.create = function create(properties) {
            return new TokenTransferList(properties);
        };

        /**
         * Encodes the specified TokenTransferList message. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList} message TokenTransferList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenTransferList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                $root.proto.TokenID.encode(message.token, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.transfers != null && message.transfers.length)
                for (var i = 0; i < message.transfers.length; ++i)
                    $root.proto.AccountAmount.encode(message.transfers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TokenTransferList message, length delimited. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList} message TokenTransferList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenTransferList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenTransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TokenTransferList} TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenTransferList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TokenTransferList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = $root.proto.TokenID.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.transfers && message.transfers.length))
                        message.transfers = [];
                    message.transfers.push($root.proto.AccountAmount.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TokenTransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TokenTransferList} TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenTransferList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenTransferList message.
         * @function verify
         * @memberof proto.TokenTransferList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenTransferList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token")) {
                var error = $root.proto.TokenID.verify(message.token);
                if (error)
                    return "token." + error;
            }
            if (message.transfers != null && message.hasOwnProperty("transfers")) {
                if (!Array.isArray(message.transfers))
                    return "transfers: array expected";
                for (var i = 0; i < message.transfers.length; ++i) {
                    var error = $root.proto.AccountAmount.verify(message.transfers[i]);
                    if (error)
                        return "transfers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TokenTransferList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TokenTransferList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TokenTransferList} TokenTransferList
         */
        TokenTransferList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TokenTransferList)
                return object;
            var message = new $root.proto.TokenTransferList();
            if (object.token != null) {
                if (typeof object.token !== "object")
                    throw TypeError(".proto.TokenTransferList.token: object expected");
                message.token = $root.proto.TokenID.fromObject(object.token);
            }
            if (object.transfers) {
                if (!Array.isArray(object.transfers))
                    throw TypeError(".proto.TokenTransferList.transfers: array expected");
                message.transfers = [];
                for (var i = 0; i < object.transfers.length; ++i) {
                    if (typeof object.transfers[i] !== "object")
                        throw TypeError(".proto.TokenTransferList.transfers: object expected");
                    message.transfers[i] = $root.proto.AccountAmount.fromObject(object.transfers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TokenTransferList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.TokenTransferList} message TokenTransferList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenTransferList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transfers = [];
            if (options.defaults)
                object.token = null;
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = $root.proto.TokenID.toObject(message.token, options);
            if (message.transfers && message.transfers.length) {
                object.transfers = [];
                for (var j = 0; j < message.transfers.length; ++j)
                    object.transfers[j] = $root.proto.AccountAmount.toObject(message.transfers[j], options);
            }
            return object;
        };

        /**
         * Converts this TokenTransferList to JSON.
         * @function toJSON
         * @memberof proto.TokenTransferList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenTransferList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenTransferList;
    })();

    proto.TopicID = (function() {

        /**
         * Properties of a TopicID.
         * @memberof proto
         * @interface ITopicID
         * @property {number|Long|null} [shardNum] TopicID shardNum
         * @property {number|Long|null} [realmNum] TopicID realmNum
         * @property {number|Long|null} [topicNum] TopicID topicNum
         */

        /**
         * Constructs a new TopicID.
         * @memberof proto
         * @classdesc Represents a TopicID.
         * @implements ITopicID
         * @constructor
         * @param {proto.ITopicID=} [properties] Properties to set
         */
        function TopicID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopicID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TopicID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TopicID topicNum.
         * @member {number|Long} topicNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.topicNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TopicID instance using the specified properties.
         * @function create
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID=} [properties] Properties to set
         * @returns {proto.TopicID} TopicID instance
         */
        TopicID.create = function create(properties) {
            return new TopicID(properties);
        };

        /**
         * Encodes the specified TopicID message. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @function encode
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID} message TopicID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopicID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            if (message.topicNum != null && Object.hasOwnProperty.call(message, "topicNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.topicNum);
            return writer;
        };

        /**
         * Encodes the specified TopicID message, length delimited. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID} message TopicID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopicID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TopicID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TopicID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TopicID} TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TopicID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                case 3:
                    message.topicNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TopicID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TopicID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TopicID} TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TopicID message.
         * @function verify
         * @memberof proto.TopicID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TopicID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            if (message.topicNum != null && message.hasOwnProperty("topicNum"))
                if (!$util.isInteger(message.topicNum) && !(message.topicNum && $util.isInteger(message.topicNum.low) && $util.isInteger(message.topicNum.high)))
                    return "topicNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a TopicID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TopicID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TopicID} TopicID
         */
        TopicID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TopicID)
                return object;
            var message = new $root.proto.TopicID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            if (object.topicNum != null)
                if ($util.Long)
                    (message.topicNum = $util.Long.fromValue(object.topicNum)).unsigned = false;
                else if (typeof object.topicNum === "string")
                    message.topicNum = parseInt(object.topicNum, 10);
                else if (typeof object.topicNum === "number")
                    message.topicNum = object.topicNum;
                else if (typeof object.topicNum === "object")
                    message.topicNum = new $util.LongBits(object.topicNum.low >>> 0, object.topicNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TopicID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TopicID
         * @static
         * @param {proto.TopicID} message TopicID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TopicID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.topicNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.topicNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            if (message.topicNum != null && message.hasOwnProperty("topicNum"))
                if (typeof message.topicNum === "number")
                    object.topicNum = options.longs === String ? String(message.topicNum) : message.topicNum;
                else
                    object.topicNum = options.longs === String ? $util.Long.prototype.toString.call(message.topicNum) : options.longs === Number ? new $util.LongBits(message.topicNum.low >>> 0, message.topicNum.high >>> 0).toNumber() : message.topicNum;
            return object;
        };

        /**
         * Converts this TopicID to JSON.
         * @function toJSON
         * @memberof proto.TopicID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TopicID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TopicID;
    })();

    proto.TokenID = (function() {

        /**
         * Properties of a TokenID.
         * @memberof proto
         * @interface ITokenID
         * @property {number|Long|null} [shardNum] TokenID shardNum
         * @property {number|Long|null} [realmNum] TokenID realmNum
         * @property {number|Long|null} [tokenNum] TokenID tokenNum
         */

        /**
         * Constructs a new TokenID.
         * @memberof proto
         * @classdesc Represents a TokenID.
         * @implements ITokenID
         * @constructor
         * @param {proto.ITokenID=} [properties] Properties to set
         */
        function TokenID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenID tokenNum.
         * @member {number|Long} tokenNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenID instance using the specified properties.
         * @function create
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID=} [properties] Properties to set
         * @returns {proto.TokenID} TokenID instance
         */
        TokenID.create = function create(properties) {
            return new TokenID(properties);
        };

        /**
         * Encodes the specified TokenID message. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID} message TokenID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            if (message.tokenNum != null && Object.hasOwnProperty.call(message, "tokenNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.tokenNum);
            return writer;
        };

        /**
         * Encodes the specified TokenID message, length delimited. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID} message TokenID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TokenID} TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TokenID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                case 3:
                    message.tokenNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TokenID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TokenID} TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenID message.
         * @function verify
         * @memberof proto.TokenID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            if (message.tokenNum != null && message.hasOwnProperty("tokenNum"))
                if (!$util.isInteger(message.tokenNum) && !(message.tokenNum && $util.isInteger(message.tokenNum.low) && $util.isInteger(message.tokenNum.high)))
                    return "tokenNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a TokenID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TokenID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TokenID} TokenID
         */
        TokenID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TokenID)
                return object;
            var message = new $root.proto.TokenID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            if (object.tokenNum != null)
                if ($util.Long)
                    (message.tokenNum = $util.Long.fromValue(object.tokenNum)).unsigned = false;
                else if (typeof object.tokenNum === "string")
                    message.tokenNum = parseInt(object.tokenNum, 10);
                else if (typeof object.tokenNum === "number")
                    message.tokenNum = object.tokenNum;
                else if (typeof object.tokenNum === "object")
                    message.tokenNum = new $util.LongBits(object.tokenNum.low >>> 0, object.tokenNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TokenID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TokenID
         * @static
         * @param {proto.TokenID} message TokenID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tokenNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tokenNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            if (message.tokenNum != null && message.hasOwnProperty("tokenNum"))
                if (typeof message.tokenNum === "number")
                    object.tokenNum = options.longs === String ? String(message.tokenNum) : message.tokenNum;
                else
                    object.tokenNum = options.longs === String ? $util.Long.prototype.toString.call(message.tokenNum) : options.longs === Number ? new $util.LongBits(message.tokenNum.low >>> 0, message.tokenNum.high >>> 0).toNumber() : message.tokenNum;
            return object;
        };

        /**
         * Converts this TokenID to JSON.
         * @function toJSON
         * @memberof proto.TokenID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenID;
    })();

    proto.ScheduleID = (function() {

        /**
         * Properties of a ScheduleID.
         * @memberof proto
         * @interface IScheduleID
         * @property {number|Long|null} [shardNum] ScheduleID shardNum
         * @property {number|Long|null} [realmNum] ScheduleID realmNum
         * @property {number|Long|null} [scheduleNum] ScheduleID scheduleNum
         */

        /**
         * Constructs a new ScheduleID.
         * @memberof proto
         * @classdesc Represents a ScheduleID.
         * @implements IScheduleID
         * @constructor
         * @param {proto.IScheduleID=} [properties] Properties to set
         */
        function ScheduleID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScheduleID shardNum.
         * @member {number|Long} shardNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ScheduleID realmNum.
         * @member {number|Long} realmNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ScheduleID scheduleNum.
         * @member {number|Long} scheduleNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ScheduleID instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID=} [properties] Properties to set
         * @returns {proto.ScheduleID} ScheduleID instance
         */
        ScheduleID.create = function create(properties) {
            return new ScheduleID(properties);
        };

        /**
         * Encodes the specified ScheduleID message. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID} message ScheduleID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shardNum != null && Object.hasOwnProperty.call(message, "shardNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.shardNum);
            if (message.realmNum != null && Object.hasOwnProperty.call(message, "realmNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.realmNum);
            if (message.scheduleNum != null && Object.hasOwnProperty.call(message, "scheduleNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.scheduleNum);
            return writer;
        };

        /**
         * Encodes the specified ScheduleID message, length delimited. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID} message ScheduleID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScheduleID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ScheduleID} ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ScheduleID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shardNum = reader.int64();
                    break;
                case 2:
                    message.realmNum = reader.int64();
                    break;
                case 3:
                    message.scheduleNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScheduleID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ScheduleID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ScheduleID} ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScheduleID message.
         * @function verify
         * @memberof proto.ScheduleID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScheduleID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (!$util.isInteger(message.shardNum) && !(message.shardNum && $util.isInteger(message.shardNum.low) && $util.isInteger(message.shardNum.high)))
                    return "shardNum: integer|Long expected";
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (!$util.isInteger(message.realmNum) && !(message.realmNum && $util.isInteger(message.realmNum.low) && $util.isInteger(message.realmNum.high)))
                    return "realmNum: integer|Long expected";
            if (message.scheduleNum != null && message.hasOwnProperty("scheduleNum"))
                if (!$util.isInteger(message.scheduleNum) && !(message.scheduleNum && $util.isInteger(message.scheduleNum.low) && $util.isInteger(message.scheduleNum.high)))
                    return "scheduleNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a ScheduleID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ScheduleID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ScheduleID} ScheduleID
         */
        ScheduleID.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ScheduleID)
                return object;
            var message = new $root.proto.ScheduleID();
            if (object.shardNum != null)
                if ($util.Long)
                    (message.shardNum = $util.Long.fromValue(object.shardNum)).unsigned = false;
                else if (typeof object.shardNum === "string")
                    message.shardNum = parseInt(object.shardNum, 10);
                else if (typeof object.shardNum === "number")
                    message.shardNum = object.shardNum;
                else if (typeof object.shardNum === "object")
                    message.shardNum = new $util.LongBits(object.shardNum.low >>> 0, object.shardNum.high >>> 0).toNumber();
            if (object.realmNum != null)
                if ($util.Long)
                    (message.realmNum = $util.Long.fromValue(object.realmNum)).unsigned = false;
                else if (typeof object.realmNum === "string")
                    message.realmNum = parseInt(object.realmNum, 10);
                else if (typeof object.realmNum === "number")
                    message.realmNum = object.realmNum;
                else if (typeof object.realmNum === "object")
                    message.realmNum = new $util.LongBits(object.realmNum.low >>> 0, object.realmNum.high >>> 0).toNumber();
            if (object.scheduleNum != null)
                if ($util.Long)
                    (message.scheduleNum = $util.Long.fromValue(object.scheduleNum)).unsigned = false;
                else if (typeof object.scheduleNum === "string")
                    message.scheduleNum = parseInt(object.scheduleNum, 10);
                else if (typeof object.scheduleNum === "number")
                    message.scheduleNum = object.scheduleNum;
                else if (typeof object.scheduleNum === "object")
                    message.scheduleNum = new $util.LongBits(object.scheduleNum.low >>> 0, object.scheduleNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ScheduleID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.ScheduleID} message ScheduleID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScheduleID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shardNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shardNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.realmNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.realmNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.scheduleNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.scheduleNum = options.longs === String ? "0" : 0;
            }
            if (message.shardNum != null && message.hasOwnProperty("shardNum"))
                if (typeof message.shardNum === "number")
                    object.shardNum = options.longs === String ? String(message.shardNum) : message.shardNum;
                else
                    object.shardNum = options.longs === String ? $util.Long.prototype.toString.call(message.shardNum) : options.longs === Number ? new $util.LongBits(message.shardNum.low >>> 0, message.shardNum.high >>> 0).toNumber() : message.shardNum;
            if (message.realmNum != null && message.hasOwnProperty("realmNum"))
                if (typeof message.realmNum === "number")
                    object.realmNum = options.longs === String ? String(message.realmNum) : message.realmNum;
                else
                    object.realmNum = options.longs === String ? $util.Long.prototype.toString.call(message.realmNum) : options.longs === Number ? new $util.LongBits(message.realmNum.low >>> 0, message.realmNum.high >>> 0).toNumber() : message.realmNum;
            if (message.scheduleNum != null && message.hasOwnProperty("scheduleNum"))
                if (typeof message.scheduleNum === "number")
                    object.scheduleNum = options.longs === String ? String(message.scheduleNum) : message.scheduleNum;
                else
                    object.scheduleNum = options.longs === String ? $util.Long.prototype.toString.call(message.scheduleNum) : options.longs === Number ? new $util.LongBits(message.scheduleNum.low >>> 0, message.scheduleNum.high >>> 0).toNumber() : message.scheduleNum;
            return object;
        };

        /**
         * Converts this ScheduleID to JSON.
         * @function toJSON
         * @memberof proto.ScheduleID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScheduleID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ScheduleID;
    })();

    /**
     * TokenFreezeStatus enum.
     * @name proto.TokenFreezeStatus
     * @enum {number}
     * @property {number} FreezeNotApplicable=0 FreezeNotApplicable value
     * @property {number} Frozen=1 Frozen value
     * @property {number} Unfrozen=2 Unfrozen value
     */
    proto.TokenFreezeStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FreezeNotApplicable"] = 0;
        values[valuesById[1] = "Frozen"] = 1;
        values[valuesById[2] = "Unfrozen"] = 2;
        return values;
    })();

    /**
     * TokenKycStatus enum.
     * @name proto.TokenKycStatus
     * @enum {number}
     * @property {number} KycNotApplicable=0 KycNotApplicable value
     * @property {number} Granted=1 Granted value
     * @property {number} Revoked=2 Revoked value
     */
    proto.TokenKycStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KycNotApplicable"] = 0;
        values[valuesById[1] = "Granted"] = 1;
        values[valuesById[2] = "Revoked"] = 2;
        return values;
    })();

    proto.Key = (function() {

        /**
         * Properties of a Key.
         * @memberof proto
         * @interface IKey
         * @property {proto.IContractID|null} [contractID] Key contractID
         * @property {Uint8Array|null} [ed25519] Key ed25519
         * @property {Uint8Array|null} [RSA_3072] Key RSA_3072
         * @property {Uint8Array|null} [ECDSA_384] Key ECDSA_384
         * @property {proto.IThresholdKey|null} [thresholdKey] Key thresholdKey
         * @property {proto.IKeyList|null} [keyList] Key keyList
         */

        /**
         * Constructs a new Key.
         * @memberof proto
         * @classdesc Represents a Key.
         * @implements IKey
         * @constructor
         * @param {proto.IKey=} [properties] Properties to set
         */
        function Key(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Key contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.contractID = null;

        /**
         * Key ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ed25519 = null;

        /**
         * Key RSA_3072.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.RSA_3072 = null;

        /**
         * Key ECDSA_384.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ECDSA_384 = null;

        /**
         * Key thresholdKey.
         * @member {proto.IThresholdKey|null|undefined} thresholdKey
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.thresholdKey = null;

        /**
         * Key keyList.
         * @member {proto.IKeyList|null|undefined} keyList
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.keyList = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Key key.
         * @member {"contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|undefined} key
         * @memberof proto.Key
         * @instance
         */
        Object.defineProperty(Key.prototype, "key", {
            get: $util.oneOfGetter($oneOfFields = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Key instance using the specified properties.
         * @function create
         * @memberof proto.Key
         * @static
         * @param {proto.IKey=} [properties] Properties to set
         * @returns {proto.Key} Key instance
         */
        Key.create = function create(properties) {
            return new Key(properties);
        };

        /**
         * Encodes the specified Key message. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @function encode
         * @memberof proto.Key
         * @static
         * @param {proto.IKey} message Key message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contractID != null && Object.hasOwnProperty.call(message, "contractID"))
                $root.proto.ContractID.encode(message.contractID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ed25519);
            if (message.RSA_3072 != null && Object.hasOwnProperty.call(message, "RSA_3072"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.RSA_3072);
            if (message.ECDSA_384 != null && Object.hasOwnProperty.call(message, "ECDSA_384"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ECDSA_384);
            if (message.thresholdKey != null && Object.hasOwnProperty.call(message, "thresholdKey"))
                $root.proto.ThresholdKey.encode(message.thresholdKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.keyList != null && Object.hasOwnProperty.call(message, "keyList"))
                $root.proto.KeyList.encode(message.keyList, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Key message, length delimited. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Key
         * @static
         * @param {proto.IKey} message Key message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Key();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contractID = $root.proto.ContractID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ed25519 = reader.bytes();
                    break;
                case 3:
                    message.RSA_3072 = reader.bytes();
                    break;
                case 4:
                    message.ECDSA_384 = reader.bytes();
                    break;
                case 5:
                    message.thresholdKey = $root.proto.ThresholdKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.keyList = $root.proto.KeyList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Key message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Key message.
         * @function verify
         * @memberof proto.Key
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Key.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.contractID != null && message.hasOwnProperty("contractID")) {
                properties.key = 1;
                {
                    var error = $root.proto.ContractID.verify(message.contractID);
                    if (error)
                        return "contractID." + error;
                }
            }
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                if (properties.key === 1)
                    return "key: multiple values";
                properties.key = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
                if (properties.key === 1)
                    return "key: multiple values";
                properties.key = 1;
                if (!(message.RSA_3072 && typeof message.RSA_3072.length === "number" || $util.isString(message.RSA_3072)))
                    return "RSA_3072: buffer expected";
            }
            if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
                if (properties.key === 1)
                    return "key: multiple values";
                properties.key = 1;
                if (!(message.ECDSA_384 && typeof message.ECDSA_384.length === "number" || $util.isString(message.ECDSA_384)))
                    return "ECDSA_384: buffer expected";
            }
            if (message.thresholdKey != null && message.hasOwnProperty("thresholdKey")) {
                if (properties.key === 1)
                    return "key: multiple values";
                properties.key = 1;
                {
                    var error = $root.proto.ThresholdKey.verify(message.thresholdKey);
                    if (error)
                        return "thresholdKey." + error;
                }
            }
            if (message.keyList != null && message.hasOwnProperty("keyList")) {
                if (properties.key === 1)
                    return "key: multiple values";
                properties.key = 1;
                {
                    var error = $root.proto.KeyList.verify(message.keyList);
                    if (error)
                        return "keyList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Key message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Key
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Key} Key
         */
        Key.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Key)
                return object;
            var message = new $root.proto.Key();
            if (object.contractID != null) {
                if (typeof object.contractID !== "object")
                    throw TypeError(".proto.Key.contractID: object expected");
                message.contractID = $root.proto.ContractID.fromObject(object.contractID);
            }
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            if (object.RSA_3072 != null)
                if (typeof object.RSA_3072 === "string")
                    $util.base64.decode(object.RSA_3072, message.RSA_3072 = $util.newBuffer($util.base64.length(object.RSA_3072)), 0);
                else if (object.RSA_3072.length)
                    message.RSA_3072 = object.RSA_3072;
            if (object.ECDSA_384 != null)
                if (typeof object.ECDSA_384 === "string")
                    $util.base64.decode(object.ECDSA_384, message.ECDSA_384 = $util.newBuffer($util.base64.length(object.ECDSA_384)), 0);
                else if (object.ECDSA_384.length)
                    message.ECDSA_384 = object.ECDSA_384;
            if (object.thresholdKey != null) {
                if (typeof object.thresholdKey !== "object")
                    throw TypeError(".proto.Key.thresholdKey: object expected");
                message.thresholdKey = $root.proto.ThresholdKey.fromObject(object.thresholdKey);
            }
            if (object.keyList != null) {
                if (typeof object.keyList !== "object")
                    throw TypeError(".proto.Key.keyList: object expected");
                message.keyList = $root.proto.KeyList.fromObject(object.keyList);
            }
            return message;
        };

        /**
         * Creates a plain object from a Key message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Key
         * @static
         * @param {proto.Key} message Key
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Key.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.contractID != null && message.hasOwnProperty("contractID")) {
                object.contractID = $root.proto.ContractID.toObject(message.contractID, options);
                if (options.oneofs)
                    object.key = "contractID";
            }
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.key = "ed25519";
            }
            if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
                object.RSA_3072 = options.bytes === String ? $util.base64.encode(message.RSA_3072, 0, message.RSA_3072.length) : options.bytes === Array ? Array.prototype.slice.call(message.RSA_3072) : message.RSA_3072;
                if (options.oneofs)
                    object.key = "RSA_3072";
            }
            if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
                object.ECDSA_384 = options.bytes === String ? $util.base64.encode(message.ECDSA_384, 0, message.ECDSA_384.length) : options.bytes === Array ? Array.prototype.slice.call(message.ECDSA_384) : message.ECDSA_384;
                if (options.oneofs)
                    object.key = "ECDSA_384";
            }
            if (message.thresholdKey != null && message.hasOwnProperty("thresholdKey")) {
                object.thresholdKey = $root.proto.ThresholdKey.toObject(message.thresholdKey, options);
                if (options.oneofs)
                    object.key = "thresholdKey";
            }
            if (message.keyList != null && message.hasOwnProperty("keyList")) {
                object.keyList = $root.proto.KeyList.toObject(message.keyList, options);
                if (options.oneofs)
                    object.key = "keyList";
            }
            return object;
        };

        /**
         * Converts this Key to JSON.
         * @function toJSON
         * @memberof proto.Key
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Key.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Key;
    })();

    proto.ThresholdKey = (function() {

        /**
         * Properties of a ThresholdKey.
         * @memberof proto
         * @interface IThresholdKey
         * @property {number|null} [threshold] ThresholdKey threshold
         * @property {proto.IKeyList|null} [keys] ThresholdKey keys
         */

        /**
         * Constructs a new ThresholdKey.
         * @memberof proto
         * @classdesc Represents a ThresholdKey.
         * @implements IThresholdKey
         * @constructor
         * @param {proto.IThresholdKey=} [properties] Properties to set
         */
        function ThresholdKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ThresholdKey threshold.
         * @member {number} threshold
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.threshold = 0;

        /**
         * ThresholdKey keys.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.keys = null;

        /**
         * Creates a new ThresholdKey instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey=} [properties] Properties to set
         * @returns {proto.ThresholdKey} ThresholdKey instance
         */
        ThresholdKey.create = function create(properties) {
            return new ThresholdKey(properties);
        };

        /**
         * Encodes the specified ThresholdKey message. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey} message ThresholdKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.threshold);
            if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
                $root.proto.KeyList.encode(message.keys, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ThresholdKey message, length delimited. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey} message ThresholdKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ThresholdKey} ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ThresholdKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.threshold = reader.uint32();
                    break;
                case 2:
                    message.keys = $root.proto.KeyList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ThresholdKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ThresholdKey} ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ThresholdKey message.
         * @function verify
         * @memberof proto.ThresholdKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ThresholdKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (!$util.isInteger(message.threshold))
                    return "threshold: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                var error = $root.proto.KeyList.verify(message.keys);
                if (error)
                    return "keys." + error;
            }
            return null;
        };

        /**
         * Creates a ThresholdKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ThresholdKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ThresholdKey} ThresholdKey
         */
        ThresholdKey.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ThresholdKey)
                return object;
            var message = new $root.proto.ThresholdKey();
            if (object.threshold != null)
                message.threshold = object.threshold >>> 0;
            if (object.keys != null) {
                if (typeof object.keys !== "object")
                    throw TypeError(".proto.ThresholdKey.keys: object expected");
                message.keys = $root.proto.KeyList.fromObject(object.keys);
            }
            return message;
        };

        /**
         * Creates a plain object from a ThresholdKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.ThresholdKey} message ThresholdKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ThresholdKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.threshold = 0;
                object.keys = null;
            }
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = message.threshold;
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = $root.proto.KeyList.toObject(message.keys, options);
            return object;
        };

        /**
         * Converts this ThresholdKey to JSON.
         * @function toJSON
         * @memberof proto.ThresholdKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ThresholdKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ThresholdKey;
    })();

    proto.KeyList = (function() {

        /**
         * Properties of a KeyList.
         * @memberof proto
         * @interface IKeyList
         * @property {Array.<proto.IKey>|null} [keys] KeyList keys
         */

        /**
         * Constructs a new KeyList.
         * @memberof proto
         * @classdesc Represents a KeyList.
         * @implements IKeyList
         * @constructor
         * @param {proto.IKeyList=} [properties] Properties to set
         */
        function KeyList(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyList keys.
         * @member {Array.<proto.IKey>} keys
         * @memberof proto.KeyList
         * @instance
         */
        KeyList.prototype.keys = $util.emptyArray;

        /**
         * Creates a new KeyList instance using the specified properties.
         * @function create
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList=} [properties] Properties to set
         * @returns {proto.KeyList} KeyList instance
         */
        KeyList.create = function create(properties) {
            return new KeyList(properties);
        };

        /**
         * Encodes the specified KeyList message. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @function encode
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList} message KeyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.proto.Key.encode(message.keys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified KeyList message, length delimited. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList} message KeyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.KeyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.KeyList} KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.KeyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.proto.Key.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.KeyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.KeyList} KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyList message.
         * @function verify
         * @memberof proto.KeyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.proto.Key.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a KeyList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.KeyList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.KeyList} KeyList
         */
        KeyList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.KeyList)
                return object;
            var message = new $root.proto.KeyList();
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".proto.KeyList.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".proto.KeyList.keys: object expected");
                    message.keys[i] = $root.proto.Key.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a KeyList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.KeyList
         * @static
         * @param {proto.KeyList} message KeyList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.proto.Key.toObject(message.keys[j], options);
            }
            return object;
        };

        /**
         * Converts this KeyList to JSON.
         * @function toJSON
         * @memberof proto.KeyList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyList;
    })();

    proto.Signature = (function() {

        /**
         * Properties of a Signature.
         * @memberof proto
         * @interface ISignature
         * @property {Uint8Array|null} [contract] Signature contract
         * @property {Uint8Array|null} [ed25519] Signature ed25519
         * @property {Uint8Array|null} [RSA_3072] Signature RSA_3072
         * @property {Uint8Array|null} [ECDSA_384] Signature ECDSA_384
         * @property {proto.IThresholdSignature|null} [thresholdSignature] Signature thresholdSignature
         * @property {proto.ISignatureList|null} [signatureList] Signature signatureList
         */

        /**
         * Constructs a new Signature.
         * @memberof proto
         * @classdesc Represents a Signature.
         * @implements ISignature
         * @constructor
         * @param {proto.ISignature=} [properties] Properties to set
         */
        function Signature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Signature contract.
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.contract = null;

        /**
         * Signature ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ed25519 = null;

        /**
         * Signature RSA_3072.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.RSA_3072 = null;

        /**
         * Signature ECDSA_384.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ECDSA_384 = null;

        /**
         * Signature thresholdSignature.
         * @member {proto.IThresholdSignature|null|undefined} thresholdSignature
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.thresholdSignature = null;

        /**
         * Signature signatureList.
         * @member {proto.ISignatureList|null|undefined} signatureList
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.signatureList = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Signature signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList"|undefined} signature
         * @memberof proto.Signature
         * @instance
         */
        Object.defineProperty(Signature.prototype, "signature", {
            get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature=} [properties] Properties to set
         * @returns {proto.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @function encode
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract);
            if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ed25519);
            if (message.RSA_3072 != null && Object.hasOwnProperty.call(message, "RSA_3072"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.RSA_3072);
            if (message.ECDSA_384 != null && Object.hasOwnProperty.call(message, "ECDSA_384"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ECDSA_384);
            if (message.thresholdSignature != null && Object.hasOwnProperty.call(message, "thresholdSignature"))
                $root.proto.ThresholdSignature.encode(message.thresholdSignature, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.signatureList != null && Object.hasOwnProperty.call(message, "signatureList"))
                $root.proto.SignatureList.encode(message.signatureList, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Signature message, length delimited. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Signature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.contract = reader.bytes();
                    break;
                case 2:
                    message.ed25519 = reader.bytes();
                    break;
                case 3:
                    message.RSA_3072 = reader.bytes();
                    break;
                case 4:
                    message.ECDSA_384 = reader.bytes();
                    break;
                case 5:
                    message.thresholdSignature = $root.proto.ThresholdSignature.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.signatureList = $root.proto.SignatureList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Signature message.
         * @function verify
         * @memberof proto.Signature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Signature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.contract != null && message.hasOwnProperty("contract")) {
                properties.signature = 1;
                if (!(message.contract && typeof message.contract.length === "number" || $util.isString(message.contract)))
                    return "contract: buffer expected";
            }
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                if (!(message.RSA_3072 && typeof message.RSA_3072.length === "number" || $util.isString(message.RSA_3072)))
                    return "RSA_3072: buffer expected";
            }
            if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                if (!(message.ECDSA_384 && typeof message.ECDSA_384.length === "number" || $util.isString(message.ECDSA_384)))
                    return "ECDSA_384: buffer expected";
            }
            if (message.thresholdSignature != null && message.hasOwnProperty("thresholdSignature")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                {
                    var error = $root.proto.ThresholdSignature.verify(message.thresholdSignature);
                    if (error)
                        return "thresholdSignature." + error;
                }
            }
            if (message.signatureList != null && message.hasOwnProperty("signatureList")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                {
                    var error = $root.proto.SignatureList.verify(message.signatureList);
                    if (error)
                        return "signatureList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Signature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Signature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Signature} Signature
         */
        Signature.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Signature)
                return object;
            var message = new $root.proto.Signature();
            if (object.contract != null)
                if (typeof object.contract === "string")
                    $util.base64.decode(object.contract, message.contract = $util.newBuffer($util.base64.length(object.contract)), 0);
                else if (object.contract.length)
                    message.contract = object.contract;
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            if (object.RSA_3072 != null)
                if (typeof object.RSA_3072 === "string")
                    $util.base64.decode(object.RSA_3072, message.RSA_3072 = $util.newBuffer($util.base64.length(object.RSA_3072)), 0);
                else if (object.RSA_3072.length)
                    message.RSA_3072 = object.RSA_3072;
            if (object.ECDSA_384 != null)
                if (typeof object.ECDSA_384 === "string")
                    $util.base64.decode(object.ECDSA_384, message.ECDSA_384 = $util.newBuffer($util.base64.length(object.ECDSA_384)), 0);
                else if (object.ECDSA_384.length)
                    message.ECDSA_384 = object.ECDSA_384;
            if (object.thresholdSignature != null) {
                if (typeof object.thresholdSignature !== "object")
                    throw TypeError(".proto.Signature.thresholdSignature: object expected");
                message.thresholdSignature = $root.proto.ThresholdSignature.fromObject(object.thresholdSignature);
            }
            if (object.signatureList != null) {
                if (typeof object.signatureList !== "object")
                    throw TypeError(".proto.Signature.signatureList: object expected");
                message.signatureList = $root.proto.SignatureList.fromObject(object.signatureList);
            }
            return message;
        };

        /**
         * Creates a plain object from a Signature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Signature
         * @static
         * @param {proto.Signature} message Signature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Signature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.contract != null && message.hasOwnProperty("contract")) {
                object.contract = options.bytes === String ? $util.base64.encode(message.contract, 0, message.contract.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract) : message.contract;
                if (options.oneofs)
                    object.signature = "contract";
            }
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.signature = "ed25519";
            }
            if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
                object.RSA_3072 = options.bytes === String ? $util.base64.encode(message.RSA_3072, 0, message.RSA_3072.length) : options.bytes === Array ? Array.prototype.slice.call(message.RSA_3072) : message.RSA_3072;
                if (options.oneofs)
                    object.signature = "RSA_3072";
            }
            if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
                object.ECDSA_384 = options.bytes === String ? $util.base64.encode(message.ECDSA_384, 0, message.ECDSA_384.length) : options.bytes === Array ? Array.prototype.slice.call(message.ECDSA_384) : message.ECDSA_384;
                if (options.oneofs)
                    object.signature = "ECDSA_384";
            }
            if (message.thresholdSignature != null && message.hasOwnProperty("thresholdSignature")) {
                object.thresholdSignature = $root.proto.ThresholdSignature.toObject(message.thresholdSignature, options);
                if (options.oneofs)
                    object.signature = "thresholdSignature";
            }
            if (message.signatureList != null && message.hasOwnProperty("signatureList")) {
                object.signatureList = $root.proto.SignatureList.toObject(message.signatureList, options);
                if (options.oneofs)
                    object.signature = "signatureList";
            }
            return object;
        };

        /**
         * Converts this Signature to JSON.
         * @function toJSON
         * @memberof proto.Signature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Signature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Signature;
    })();

    proto.ThresholdSignature = (function() {

        /**
         * Properties of a ThresholdSignature.
         * @memberof proto
         * @interface IThresholdSignature
         * @property {proto.ISignatureList|null} [sigs] ThresholdSignature sigs
         */

        /**
         * Constructs a new ThresholdSignature.
         * @memberof proto
         * @classdesc Represents a ThresholdSignature.
         * @implements IThresholdSignature
         * @constructor
         * @param {proto.IThresholdSignature=} [properties] Properties to set
         */
        function ThresholdSignature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ThresholdSignature sigs.
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.ThresholdSignature
         * @instance
         */
        ThresholdSignature.prototype.sigs = null;

        /**
         * Creates a new ThresholdSignature instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature=} [properties] Properties to set
         * @returns {proto.ThresholdSignature} ThresholdSignature instance
         */
        ThresholdSignature.create = function create(properties) {
            return new ThresholdSignature(properties);
        };

        /**
         * Encodes the specified ThresholdSignature message. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature} message ThresholdSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdSignature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sigs != null && Object.hasOwnProperty.call(message, "sigs"))
                $root.proto.SignatureList.encode(message.sigs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ThresholdSignature message, length delimited. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature} message ThresholdSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdSignature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ThresholdSignature} ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdSignature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ThresholdSignature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.sigs = $root.proto.SignatureList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ThresholdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ThresholdSignature} ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdSignature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ThresholdSignature message.
         * @function verify
         * @memberof proto.ThresholdSignature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ThresholdSignature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sigs != null && message.hasOwnProperty("sigs")) {
                var error = $root.proto.SignatureList.verify(message.sigs);
                if (error)
                    return "sigs." + error;
            }
            return null;
        };

        /**
         * Creates a ThresholdSignature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ThresholdSignature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ThresholdSignature} ThresholdSignature
         */
        ThresholdSignature.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ThresholdSignature)
                return object;
            var message = new $root.proto.ThresholdSignature();
            if (object.sigs != null) {
                if (typeof object.sigs !== "object")
                    throw TypeError(".proto.ThresholdSignature.sigs: object expected");
                message.sigs = $root.proto.SignatureList.fromObject(object.sigs);
            }
            return message;
        };

        /**
         * Creates a plain object from a ThresholdSignature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.ThresholdSignature} message ThresholdSignature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ThresholdSignature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sigs = null;
            if (message.sigs != null && message.hasOwnProperty("sigs"))
                object.sigs = $root.proto.SignatureList.toObject(message.sigs, options);
            return object;
        };

        /**
         * Converts this ThresholdSignature to JSON.
         * @function toJSON
         * @memberof proto.ThresholdSignature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ThresholdSignature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ThresholdSignature;
    })();

    proto.SignatureList = (function() {

        /**
         * Properties of a SignatureList.
         * @memberof proto
         * @interface ISignatureList
         * @property {Array.<proto.ISignature>|null} [sigs] SignatureList sigs
         */

        /**
         * Constructs a new SignatureList.
         * @memberof proto
         * @classdesc Represents a SignatureList.
         * @implements ISignatureList
         * @constructor
         * @param {proto.ISignatureList=} [properties] Properties to set
         */
        function SignatureList(properties) {
            this.sigs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignatureList sigs.
         * @member {Array.<proto.ISignature>} sigs
         * @memberof proto.SignatureList
         * @instance
         */
        SignatureList.prototype.sigs = $util.emptyArray;

        /**
         * Creates a new SignatureList instance using the specified properties.
         * @function create
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList=} [properties] Properties to set
         * @returns {proto.SignatureList} SignatureList instance
         */
        SignatureList.create = function create(properties) {
            return new SignatureList(properties);
        };

        /**
         * Encodes the specified SignatureList message. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList} message SignatureList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sigs != null && message.sigs.length)
                for (var i = 0; i < message.sigs.length; ++i)
                    $root.proto.Signature.encode(message.sigs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SignatureList message, length delimited. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList} message SignatureList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignatureList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignatureList} SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignatureList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.sigs && message.sigs.length))
                        message.sigs = [];
                    message.sigs.push($root.proto.Signature.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignatureList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SignatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SignatureList} SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignatureList message.
         * @function verify
         * @memberof proto.SignatureList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignatureList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sigs != null && message.hasOwnProperty("sigs")) {
                if (!Array.isArray(message.sigs))
                    return "sigs: array expected";
                for (var i = 0; i < message.sigs.length; ++i) {
                    var error = $root.proto.Signature.verify(message.sigs[i]);
                    if (error)
                        return "sigs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SignatureList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SignatureList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SignatureList} SignatureList
         */
        SignatureList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SignatureList)
                return object;
            var message = new $root.proto.SignatureList();
            if (object.sigs) {
                if (!Array.isArray(object.sigs))
                    throw TypeError(".proto.SignatureList.sigs: array expected");
                message.sigs = [];
                for (var i = 0; i < object.sigs.length; ++i) {
                    if (typeof object.sigs[i] !== "object")
                        throw TypeError(".proto.SignatureList.sigs: object expected");
                    message.sigs[i] = $root.proto.Signature.fromObject(object.sigs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SignatureList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SignatureList
         * @static
         * @param {proto.SignatureList} message SignatureList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignatureList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sigs = [];
            if (message.sigs && message.sigs.length) {
                object.sigs = [];
                for (var j = 0; j < message.sigs.length; ++j)
                    object.sigs[j] = $root.proto.Signature.toObject(message.sigs[j], options);
            }
            return object;
        };

        /**
         * Converts this SignatureList to JSON.
         * @function toJSON
         * @memberof proto.SignatureList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignatureList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignatureList;
    })();

    proto.SignaturePair = (function() {

        /**
         * Properties of a SignaturePair.
         * @memberof proto
         * @interface ISignaturePair
         * @property {Uint8Array|null} [pubKeyPrefix] SignaturePair pubKeyPrefix
         * @property {Uint8Array|null} [contract] SignaturePair contract
         * @property {Uint8Array|null} [ed25519] SignaturePair ed25519
         * @property {Uint8Array|null} [RSA_3072] SignaturePair RSA_3072
         * @property {Uint8Array|null} [ECDSA_384] SignaturePair ECDSA_384
         */

        /**
         * Constructs a new SignaturePair.
         * @memberof proto
         * @classdesc Represents a SignaturePair.
         * @implements ISignaturePair
         * @constructor
         * @param {proto.ISignaturePair=} [properties] Properties to set
         */
        function SignaturePair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignaturePair pubKeyPrefix.
         * @member {Uint8Array} pubKeyPrefix
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.pubKeyPrefix = $util.newBuffer([]);

        /**
         * SignaturePair contract.
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.contract = null;

        /**
         * SignaturePair ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ed25519 = null;

        /**
         * SignaturePair RSA_3072.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.RSA_3072 = null;

        /**
         * SignaturePair ECDSA_384.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ECDSA_384 = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SignaturePair signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|undefined} signature
         * @memberof proto.SignaturePair
         * @instance
         */
        Object.defineProperty(SignaturePair.prototype, "signature", {
            get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SignaturePair instance using the specified properties.
         * @function create
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair=} [properties] Properties to set
         * @returns {proto.SignaturePair} SignaturePair instance
         */
        SignaturePair.create = function create(properties) {
            return new SignaturePair(properties);
        };

        /**
         * Encodes the specified SignaturePair message. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @function encode
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair} message SignaturePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignaturePair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKeyPrefix != null && Object.hasOwnProperty.call(message, "pubKeyPrefix"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubKeyPrefix);
            if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract);
            if (message.ed25519 != null && Object.hasOwnProperty.call(message, "ed25519"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ed25519);
            if (message.RSA_3072 != null && Object.hasOwnProperty.call(message, "RSA_3072"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.RSA_3072);
            if (message.ECDSA_384 != null && Object.hasOwnProperty.call(message, "ECDSA_384"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.ECDSA_384);
            return writer;
        };

        /**
         * Encodes the specified SignaturePair message, length delimited. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair} message SignaturePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignaturePair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignaturePair message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignaturePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignaturePair} SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignaturePair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignaturePair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKeyPrefix = reader.bytes();
                    break;
                case 2:
                    message.contract = reader.bytes();
                    break;
                case 3:
                    message.ed25519 = reader.bytes();
                    break;
                case 4:
                    message.RSA_3072 = reader.bytes();
                    break;
                case 5:
                    message.ECDSA_384 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignaturePair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SignaturePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SignaturePair} SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignaturePair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignaturePair message.
         * @function verify
         * @memberof proto.SignaturePair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignaturePair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.pubKeyPrefix != null && message.hasOwnProperty("pubKeyPrefix"))
                if (!(message.pubKeyPrefix && typeof message.pubKeyPrefix.length === "number" || $util.isString(message.pubKeyPrefix)))
                    return "pubKeyPrefix: buffer expected";
            if (message.contract != null && message.hasOwnProperty("contract")) {
                properties.signature = 1;
                if (!(message.contract && typeof message.contract.length === "number" || $util.isString(message.contract)))
                    return "contract: buffer expected";
            }
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                if (!(message.RSA_3072 && typeof message.RSA_3072.length === "number" || $util.isString(message.RSA_3072)))
                    return "RSA_3072: buffer expected";
            }
            if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
                if (properties.signature === 1)
                    return "signature: multiple values";
                properties.signature = 1;
                if (!(message.ECDSA_384 && typeof message.ECDSA_384.length === "number" || $util.isString(message.ECDSA_384)))
                    return "ECDSA_384: buffer expected";
            }
            return null;
        };

        /**
         * Creates a SignaturePair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SignaturePair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SignaturePair} SignaturePair
         */
        SignaturePair.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SignaturePair)
                return object;
            var message = new $root.proto.SignaturePair();
            if (object.pubKeyPrefix != null)
                if (typeof object.pubKeyPrefix === "string")
                    $util.base64.decode(object.pubKeyPrefix, message.pubKeyPrefix = $util.newBuffer($util.base64.length(object.pubKeyPrefix)), 0);
                else if (object.pubKeyPrefix.length)
                    message.pubKeyPrefix = object.pubKeyPrefix;
            if (object.contract != null)
                if (typeof object.contract === "string")
                    $util.base64.decode(object.contract, message.contract = $util.newBuffer($util.base64.length(object.contract)), 0);
                else if (object.contract.length)
                    message.contract = object.contract;
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            if (object.RSA_3072 != null)
                if (typeof object.RSA_3072 === "string")
                    $util.base64.decode(object.RSA_3072, message.RSA_3072 = $util.newBuffer($util.base64.length(object.RSA_3072)), 0);
                else if (object.RSA_3072.length)
                    message.RSA_3072 = object.RSA_3072;
            if (object.ECDSA_384 != null)
                if (typeof object.ECDSA_384 === "string")
                    $util.base64.decode(object.ECDSA_384, message.ECDSA_384 = $util.newBuffer($util.base64.length(object.ECDSA_384)), 0);
                else if (object.ECDSA_384.length)
                    message.ECDSA_384 = object.ECDSA_384;
            return message;
        };

        /**
         * Creates a plain object from a SignaturePair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.SignaturePair} message SignaturePair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignaturePair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.pubKeyPrefix = "";
                else {
                    object.pubKeyPrefix = [];
                    if (options.bytes !== Array)
                        object.pubKeyPrefix = $util.newBuffer(object.pubKeyPrefix);
                }
            if (message.pubKeyPrefix != null && message.hasOwnProperty("pubKeyPrefix"))
                object.pubKeyPrefix = options.bytes === String ? $util.base64.encode(message.pubKeyPrefix, 0, message.pubKeyPrefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKeyPrefix) : message.pubKeyPrefix;
            if (message.contract != null && message.hasOwnProperty("contract")) {
                object.contract = options.bytes === String ? $util.base64.encode(message.contract, 0, message.contract.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract) : message.contract;
                if (options.oneofs)
                    object.signature = "contract";
            }
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.signature = "ed25519";
            }
            if (message.RSA_3072 != null && message.hasOwnProperty("RSA_3072")) {
                object.RSA_3072 = options.bytes === String ? $util.base64.encode(message.RSA_3072, 0, message.RSA_3072.length) : options.bytes === Array ? Array.prototype.slice.call(message.RSA_3072) : message.RSA_3072;
                if (options.oneofs)
                    object.signature = "RSA_3072";
            }
            if (message.ECDSA_384 != null && message.hasOwnProperty("ECDSA_384")) {
                object.ECDSA_384 = options.bytes === String ? $util.base64.encode(message.ECDSA_384, 0, message.ECDSA_384.length) : options.bytes === Array ? Array.prototype.slice.call(message.ECDSA_384) : message.ECDSA_384;
                if (options.oneofs)
                    object.signature = "ECDSA_384";
            }
            return object;
        };

        /**
         * Converts this SignaturePair to JSON.
         * @function toJSON
         * @memberof proto.SignaturePair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignaturePair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignaturePair;
    })();

    proto.SignatureMap = (function() {

        /**
         * Properties of a SignatureMap.
         * @memberof proto
         * @interface ISignatureMap
         * @property {Array.<proto.ISignaturePair>|null} [sigPair] SignatureMap sigPair
         */

        /**
         * Constructs a new SignatureMap.
         * @memberof proto
         * @classdesc Represents a SignatureMap.
         * @implements ISignatureMap
         * @constructor
         * @param {proto.ISignatureMap=} [properties] Properties to set
         */
        function SignatureMap(properties) {
            this.sigPair = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignatureMap sigPair.
         * @member {Array.<proto.ISignaturePair>} sigPair
         * @memberof proto.SignatureMap
         * @instance
         */
        SignatureMap.prototype.sigPair = $util.emptyArray;

        /**
         * Creates a new SignatureMap instance using the specified properties.
         * @function create
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap=} [properties] Properties to set
         * @returns {proto.SignatureMap} SignatureMap instance
         */
        SignatureMap.create = function create(properties) {
            return new SignatureMap(properties);
        };

        /**
         * Encodes the specified SignatureMap message. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap} message SignatureMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureMap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sigPair != null && message.sigPair.length)
                for (var i = 0; i < message.sigPair.length; ++i)
                    $root.proto.SignaturePair.encode(message.sigPair[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SignatureMap message, length delimited. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap} message SignatureMap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureMap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignatureMap message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignatureMap} SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureMap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignatureMap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sigPair && message.sigPair.length))
                        message.sigPair = [];
                    message.sigPair.push($root.proto.SignaturePair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignatureMap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SignatureMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SignatureMap} SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureMap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignatureMap message.
         * @function verify
         * @memberof proto.SignatureMap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignatureMap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sigPair != null && message.hasOwnProperty("sigPair")) {
                if (!Array.isArray(message.sigPair))
                    return "sigPair: array expected";
                for (var i = 0; i < message.sigPair.length; ++i) {
                    var error = $root.proto.SignaturePair.verify(message.sigPair[i]);
                    if (error)
                        return "sigPair." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SignatureMap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SignatureMap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SignatureMap} SignatureMap
         */
        SignatureMap.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SignatureMap)
                return object;
            var message = new $root.proto.SignatureMap();
            if (object.sigPair) {
                if (!Array.isArray(object.sigPair))
                    throw TypeError(".proto.SignatureMap.sigPair: array expected");
                message.sigPair = [];
                for (var i = 0; i < object.sigPair.length; ++i) {
                    if (typeof object.sigPair[i] !== "object")
                        throw TypeError(".proto.SignatureMap.sigPair: object expected");
                    message.sigPair[i] = $root.proto.SignaturePair.fromObject(object.sigPair[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SignatureMap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.SignatureMap} message SignatureMap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignatureMap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sigPair = [];
            if (message.sigPair && message.sigPair.length) {
                object.sigPair = [];
                for (var j = 0; j < message.sigPair.length; ++j)
                    object.sigPair[j] = $root.proto.SignaturePair.toObject(message.sigPair[j], options);
            }
            return object;
        };

        /**
         * Converts this SignatureMap to JSON.
         * @function toJSON
         * @memberof proto.SignatureMap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignatureMap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignatureMap;
    })();

    /**
     * HederaFunctionality enum.
     * @name proto.HederaFunctionality
     * @enum {number}
     * @property {number} NONE=0 NONE value
     * @property {number} CryptoTransfer=1 CryptoTransfer value
     * @property {number} CryptoUpdate=2 CryptoUpdate value
     * @property {number} CryptoDelete=3 CryptoDelete value
     * @property {number} CryptoAddLiveHash=4 CryptoAddLiveHash value
     * @property {number} CryptoDeleteLiveHash=5 CryptoDeleteLiveHash value
     * @property {number} ContractCall=6 ContractCall value
     * @property {number} ContractCreate=7 ContractCreate value
     * @property {number} ContractUpdate=8 ContractUpdate value
     * @property {number} FileCreate=9 FileCreate value
     * @property {number} FileAppend=10 FileAppend value
     * @property {number} FileUpdate=11 FileUpdate value
     * @property {number} FileDelete=12 FileDelete value
     * @property {number} CryptoGetAccountBalance=13 CryptoGetAccountBalance value
     * @property {number} CryptoGetAccountRecords=14 CryptoGetAccountRecords value
     * @property {number} CryptoGetInfo=15 CryptoGetInfo value
     * @property {number} ContractCallLocal=16 ContractCallLocal value
     * @property {number} ContractGetInfo=17 ContractGetInfo value
     * @property {number} ContractGetBytecode=18 ContractGetBytecode value
     * @property {number} GetBySolidityID=19 GetBySolidityID value
     * @property {number} GetByKey=20 GetByKey value
     * @property {number} CryptoGetLiveHash=21 CryptoGetLiveHash value
     * @property {number} CryptoGetStakers=22 CryptoGetStakers value
     * @property {number} FileGetContents=23 FileGetContents value
     * @property {number} FileGetInfo=24 FileGetInfo value
     * @property {number} TransactionGetRecord=25 TransactionGetRecord value
     * @property {number} ContractGetRecords=26 ContractGetRecords value
     * @property {number} CryptoCreate=27 CryptoCreate value
     * @property {number} SystemDelete=28 SystemDelete value
     * @property {number} SystemUndelete=29 SystemUndelete value
     * @property {number} ContractDelete=30 ContractDelete value
     * @property {number} Freeze=31 Freeze value
     * @property {number} CreateTransactionRecord=32 CreateTransactionRecord value
     * @property {number} CryptoAccountAutoRenew=33 CryptoAccountAutoRenew value
     * @property {number} ContractAutoRenew=34 ContractAutoRenew value
     * @property {number} GetVersionInfo=35 GetVersionInfo value
     * @property {number} TransactionGetReceipt=36 TransactionGetReceipt value
     * @property {number} ConsensusCreateTopic=50 ConsensusCreateTopic value
     * @property {number} ConsensusUpdateTopic=51 ConsensusUpdateTopic value
     * @property {number} ConsensusDeleteTopic=52 ConsensusDeleteTopic value
     * @property {number} ConsensusGetTopicInfo=53 ConsensusGetTopicInfo value
     * @property {number} ConsensusSubmitMessage=54 ConsensusSubmitMessage value
     * @property {number} UncheckedSubmit=55 UncheckedSubmit value
     * @property {number} TokenCreate=56 TokenCreate value
     * @property {number} TokenGetInfo=58 TokenGetInfo value
     * @property {number} TokenFreezeAccount=59 TokenFreezeAccount value
     * @property {number} TokenUnfreezeAccount=60 TokenUnfreezeAccount value
     * @property {number} TokenGrantKycToAccount=61 TokenGrantKycToAccount value
     * @property {number} TokenRevokeKycFromAccount=62 TokenRevokeKycFromAccount value
     * @property {number} TokenDelete=63 TokenDelete value
     * @property {number} TokenUpdate=64 TokenUpdate value
     * @property {number} TokenMint=65 TokenMint value
     * @property {number} TokenBurn=66 TokenBurn value
     * @property {number} TokenAccountWipe=67 TokenAccountWipe value
     * @property {number} TokenAssociateToAccount=68 TokenAssociateToAccount value
     * @property {number} TokenDissociateFromAccount=69 TokenDissociateFromAccount value
     * @property {number} ScheduleCreate=70 ScheduleCreate value
     * @property {number} ScheduleDelete=71 ScheduleDelete value
     * @property {number} ScheduleSign=72 ScheduleSign value
     * @property {number} ScheduleGetInfo=73 ScheduleGetInfo value
     */
    proto.HederaFunctionality = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "CryptoTransfer"] = 1;
        values[valuesById[2] = "CryptoUpdate"] = 2;
        values[valuesById[3] = "CryptoDelete"] = 3;
        values[valuesById[4] = "CryptoAddLiveHash"] = 4;
        values[valuesById[5] = "CryptoDeleteLiveHash"] = 5;
        values[valuesById[6] = "ContractCall"] = 6;
        values[valuesById[7] = "ContractCreate"] = 7;
        values[valuesById[8] = "ContractUpdate"] = 8;
        values[valuesById[9] = "FileCreate"] = 9;
        values[valuesById[10] = "FileAppend"] = 10;
        values[valuesById[11] = "FileUpdate"] = 11;
        values[valuesById[12] = "FileDelete"] = 12;
        values[valuesById[13] = "CryptoGetAccountBalance"] = 13;
        values[valuesById[14] = "CryptoGetAccountRecords"] = 14;
        values[valuesById[15] = "CryptoGetInfo"] = 15;
        values[valuesById[16] = "ContractCallLocal"] = 16;
        values[valuesById[17] = "ContractGetInfo"] = 17;
        values[valuesById[18] = "ContractGetBytecode"] = 18;
        values[valuesById[19] = "GetBySolidityID"] = 19;
        values[valuesById[20] = "GetByKey"] = 20;
        values[valuesById[21] = "CryptoGetLiveHash"] = 21;
        values[valuesById[22] = "CryptoGetStakers"] = 22;
        values[valuesById[23] = "FileGetContents"] = 23;
        values[valuesById[24] = "FileGetInfo"] = 24;
        values[valuesById[25] = "TransactionGetRecord"] = 25;
        values[valuesById[26] = "ContractGetRecords"] = 26;
        values[valuesById[27] = "CryptoCreate"] = 27;
        values[valuesById[28] = "SystemDelete"] = 28;
        values[valuesById[29] = "SystemUndelete"] = 29;
        values[valuesById[30] = "ContractDelete"] = 30;
        values[valuesById[31] = "Freeze"] = 31;
        values[valuesById[32] = "CreateTransactionRecord"] = 32;
        values[valuesById[33] = "CryptoAccountAutoRenew"] = 33;
        values[valuesById[34] = "ContractAutoRenew"] = 34;
        values[valuesById[35] = "GetVersionInfo"] = 35;
        values[valuesById[36] = "TransactionGetReceipt"] = 36;
        values[valuesById[50] = "ConsensusCreateTopic"] = 50;
        values[valuesById[51] = "ConsensusUpdateTopic"] = 51;
        values[valuesById[52] = "ConsensusDeleteTopic"] = 52;
        values[valuesById[53] = "ConsensusGetTopicInfo"] = 53;
        values[valuesById[54] = "ConsensusSubmitMessage"] = 54;
        values[valuesById[55] = "UncheckedSubmit"] = 55;
        values[valuesById[56] = "TokenCreate"] = 56;
        values[valuesById[58] = "TokenGetInfo"] = 58;
        values[valuesById[59] = "TokenFreezeAccount"] = 59;
        values[valuesById[60] = "TokenUnfreezeAccount"] = 60;
        values[valuesById[61] = "TokenGrantKycToAccount"] = 61;
        values[valuesById[62] = "TokenRevokeKycFromAccount"] = 62;
        values[valuesById[63] = "TokenDelete"] = 63;
        values[valuesById[64] = "TokenUpdate"] = 64;
        values[valuesById[65] = "TokenMint"] = 65;
        values[valuesById[66] = "TokenBurn"] = 66;
        values[valuesById[67] = "TokenAccountWipe"] = 67;
        values[valuesById[68] = "TokenAssociateToAccount"] = 68;
        values[valuesById[69] = "TokenDissociateFromAccount"] = 69;
        values[valuesById[70] = "ScheduleCreate"] = 70;
        values[valuesById[71] = "ScheduleDelete"] = 71;
        values[valuesById[72] = "ScheduleSign"] = 72;
        values[valuesById[73] = "ScheduleGetInfo"] = 73;
        return values;
    })();

    proto.FeeComponents = (function() {

        /**
         * Properties of a FeeComponents.
         * @memberof proto
         * @interface IFeeComponents
         * @property {number|Long|null} [min] FeeComponents min
         * @property {number|Long|null} [max] FeeComponents max
         * @property {number|Long|null} [constant] FeeComponents constant
         * @property {number|Long|null} [bpt] FeeComponents bpt
         * @property {number|Long|null} [vpt] FeeComponents vpt
         * @property {number|Long|null} [rbh] FeeComponents rbh
         * @property {number|Long|null} [sbh] FeeComponents sbh
         * @property {number|Long|null} [gas] FeeComponents gas
         * @property {number|Long|null} [tv] FeeComponents tv
         * @property {number|Long|null} [bpr] FeeComponents bpr
         * @property {number|Long|null} [sbpr] FeeComponents sbpr
         */

        /**
         * Constructs a new FeeComponents.
         * @memberof proto
         * @classdesc Represents a FeeComponents.
         * @implements IFeeComponents
         * @constructor
         * @param {proto.IFeeComponents=} [properties] Properties to set
         */
        function FeeComponents(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeComponents min.
         * @member {number|Long} min
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.min = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents max.
         * @member {number|Long} max
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.max = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents constant.
         * @member {number|Long} constant
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.constant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents bpt.
         * @member {number|Long} bpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents vpt.
         * @member {number|Long} vpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.vpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents rbh.
         * @member {number|Long} rbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.rbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents sbh.
         * @member {number|Long} sbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents gas.
         * @member {number|Long} gas
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents tv.
         * @member {number|Long} tv
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.tv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents bpr.
         * @member {number|Long} bpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents sbpr.
         * @member {number|Long} sbpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FeeComponents instance using the specified properties.
         * @function create
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents=} [properties] Properties to set
         * @returns {proto.FeeComponents} FeeComponents instance
         */
        FeeComponents.create = function create(properties) {
            return new FeeComponents(properties);
        };

        /**
         * Encodes the specified FeeComponents message. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents} message FeeComponents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeComponents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.min);
            if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.max);
            if (message.constant != null && Object.hasOwnProperty.call(message, "constant"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.constant);
            if (message.bpt != null && Object.hasOwnProperty.call(message, "bpt"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.bpt);
            if (message.vpt != null && Object.hasOwnProperty.call(message, "vpt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.vpt);
            if (message.rbh != null && Object.hasOwnProperty.call(message, "rbh"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.rbh);
            if (message.sbh != null && Object.hasOwnProperty.call(message, "sbh"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sbh);
            if (message.gas != null && Object.hasOwnProperty.call(message, "gas"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.gas);
            if (message.tv != null && Object.hasOwnProperty.call(message, "tv"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.tv);
            if (message.bpr != null && Object.hasOwnProperty.call(message, "bpr"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.bpr);
            if (message.sbpr != null && Object.hasOwnProperty.call(message, "sbpr"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.sbpr);
            return writer;
        };

        /**
         * Encodes the specified FeeComponents message, length delimited. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents} message FeeComponents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeComponents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeComponents message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeComponents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FeeComponents} FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeComponents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeeComponents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.min = reader.int64();
                    break;
                case 2:
                    message.max = reader.int64();
                    break;
                case 3:
                    message.constant = reader.int64();
                    break;
                case 4:
                    message.bpt = reader.int64();
                    break;
                case 5:
                    message.vpt = reader.int64();
                    break;
                case 6:
                    message.rbh = reader.int64();
                    break;
                case 7:
                    message.sbh = reader.int64();
                    break;
                case 8:
                    message.gas = reader.int64();
                    break;
                case 9:
                    message.tv = reader.int64();
                    break;
                case 10:
                    message.bpr = reader.int64();
                    break;
                case 11:
                    message.sbpr = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeComponents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.FeeComponents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.FeeComponents} FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeComponents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeComponents message.
         * @function verify
         * @memberof proto.FeeComponents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeComponents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.min != null && message.hasOwnProperty("min"))
                if (!$util.isInteger(message.min) && !(message.min && $util.isInteger(message.min.low) && $util.isInteger(message.min.high)))
                    return "min: integer|Long expected";
            if (message.max != null && message.hasOwnProperty("max"))
                if (!$util.isInteger(message.max) && !(message.max && $util.isInteger(message.max.low) && $util.isInteger(message.max.high)))
                    return "max: integer|Long expected";
            if (message.constant != null && message.hasOwnProperty("constant"))
                if (!$util.isInteger(message.constant) && !(message.constant && $util.isInteger(message.constant.low) && $util.isInteger(message.constant.high)))
                    return "constant: integer|Long expected";
            if (message.bpt != null && message.hasOwnProperty("bpt"))
                if (!$util.isInteger(message.bpt) && !(message.bpt && $util.isInteger(message.bpt.low) && $util.isInteger(message.bpt.high)))
                    return "bpt: integer|Long expected";
            if (message.vpt != null && message.hasOwnProperty("vpt"))
                if (!$util.isInteger(message.vpt) && !(message.vpt && $util.isInteger(message.vpt.low) && $util.isInteger(message.vpt.high)))
                    return "vpt: integer|Long expected";
            if (message.rbh != null && message.hasOwnProperty("rbh"))
                if (!$util.isInteger(message.rbh) && !(message.rbh && $util.isInteger(message.rbh.low) && $util.isInteger(message.rbh.high)))
                    return "rbh: integer|Long expected";
            if (message.sbh != null && message.hasOwnProperty("sbh"))
                if (!$util.isInteger(message.sbh) && !(message.sbh && $util.isInteger(message.sbh.low) && $util.isInteger(message.sbh.high)))
                    return "sbh: integer|Long expected";
            if (message.gas != null && message.hasOwnProperty("gas"))
                if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                    return "gas: integer|Long expected";
            if (message.tv != null && message.hasOwnProperty("tv"))
                if (!$util.isInteger(message.tv) && !(message.tv && $util.isInteger(message.tv.low) && $util.isInteger(message.tv.high)))
                    return "tv: integer|Long expected";
            if (message.bpr != null && message.hasOwnProperty("bpr"))
                if (!$util.isInteger(message.bpr) && !(message.bpr && $util.isInteger(message.bpr.low) && $util.isInteger(message.bpr.high)))
                    return "bpr: integer|Long expected";
            if (message.sbpr != null && message.hasOwnProperty("sbpr"))
                if (!$util.isInteger(message.sbpr) && !(message.sbpr && $util.isInteger(message.sbpr.low) && $util.isInteger(message.sbpr.high)))
                    return "sbpr: integer|Long expected";
            return null;
        };

        /**
         * Creates a FeeComponents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.FeeComponents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.FeeComponents} FeeComponents
         */
        FeeComponents.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.FeeComponents)
                return object;
            var message = new $root.proto.FeeComponents();
            if (object.min != null)
                if ($util.Long)
                    (message.min = $util.Long.fromValue(object.min)).unsigned = false;
                else if (typeof object.min === "string")
                    message.min = parseInt(object.min, 10);
                else if (typeof object.min === "number")
                    message.min = object.min;
                else if (typeof object.min === "object")
                    message.min = new $util.LongBits(object.min.low >>> 0, object.min.high >>> 0).toNumber();
            if (object.max != null)
                if ($util.Long)
                    (message.max = $util.Long.fromValue(object.max)).unsigned = false;
                else if (typeof object.max === "string")
                    message.max = parseInt(object.max, 10);
                else if (typeof object.max === "number")
                    message.max = object.max;
                else if (typeof object.max === "object")
                    message.max = new $util.LongBits(object.max.low >>> 0, object.max.high >>> 0).toNumber();
            if (object.constant != null)
                if ($util.Long)
                    (message.constant = $util.Long.fromValue(object.constant)).unsigned = false;
                else if (typeof object.constant === "string")
                    message.constant = parseInt(object.constant, 10);
                else if (typeof object.constant === "number")
                    message.constant = object.constant;
                else if (typeof object.constant === "object")
                    message.constant = new $util.LongBits(object.constant.low >>> 0, object.constant.high >>> 0).toNumber();
            if (object.bpt != null)
                if ($util.Long)
                    (message.bpt = $util.Long.fromValue(object.bpt)).unsigned = false;
                else if (typeof object.bpt === "string")
                    message.bpt = parseInt(object.bpt, 10);
                else if (typeof object.bpt === "number")
                    message.bpt = object.bpt;
                else if (typeof object.bpt === "object")
                    message.bpt = new $util.LongBits(object.bpt.low >>> 0, object.bpt.high >>> 0).toNumber();
            if (object.vpt != null)
                if ($util.Long)
                    (message.vpt = $util.Long.fromValue(object.vpt)).unsigned = false;
                else if (typeof object.vpt === "string")
                    message.vpt = parseInt(object.vpt, 10);
                else if (typeof object.vpt === "number")
                    message.vpt = object.vpt;
                else if (typeof object.vpt === "object")
                    message.vpt = new $util.LongBits(object.vpt.low >>> 0, object.vpt.high >>> 0).toNumber();
            if (object.rbh != null)
                if ($util.Long)
                    (message.rbh = $util.Long.fromValue(object.rbh)).unsigned = false;
                else if (typeof object.rbh === "string")
                    message.rbh = parseInt(object.rbh, 10);
                else if (typeof object.rbh === "number")
                    message.rbh = object.rbh;
                else if (typeof object.rbh === "object")
                    message.rbh = new $util.LongBits(object.rbh.low >>> 0, object.rbh.high >>> 0).toNumber();
            if (object.sbh != null)
                if ($util.Long)
                    (message.sbh = $util.Long.fromValue(object.sbh)).unsigned = false;
                else if (typeof object.sbh === "string")
                    message.sbh = parseInt(object.sbh, 10);
                else if (typeof object.sbh === "number")
                    message.sbh = object.sbh;
                else if (typeof object.sbh === "object")
                    message.sbh = new $util.LongBits(object.sbh.low >>> 0, object.sbh.high >>> 0).toNumber();
            if (object.gas != null)
                if ($util.Long)
                    (message.gas = $util.Long.fromValue(object.gas)).unsigned = false;
                else if (typeof object.gas === "string")
                    message.gas = parseInt(object.gas, 10);
                else if (typeof object.gas === "number")
                    message.gas = object.gas;
                else if (typeof object.gas === "object")
                    message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber();
            if (object.tv != null)
                if ($util.Long)
                    (message.tv = $util.Long.fromValue(object.tv)).unsigned = false;
                else if (typeof object.tv === "string")
                    message.tv = parseInt(object.tv, 10);
                else if (typeof object.tv === "number")
                    message.tv = object.tv;
                else if (typeof object.tv === "object")
                    message.tv = new $util.LongBits(object.tv.low >>> 0, object.tv.high >>> 0).toNumber();
            if (object.bpr != null)
                if ($util.Long)
                    (message.bpr = $util.Long.fromValue(object.bpr)).unsigned = false;
                else if (typeof object.bpr === "string")
                    message.bpr = parseInt(object.bpr, 10);
                else if (typeof object.bpr === "number")
                    message.bpr = object.bpr;
                else if (typeof object.bpr === "object")
                    message.bpr = new $util.LongBits(object.bpr.low >>> 0, object.bpr.high >>> 0).toNumber();
            if (object.sbpr != null)
                if ($util.Long)
                    (message.sbpr = $util.Long.fromValue(object.sbpr)).unsigned = false;
                else if (typeof object.sbpr === "string")
                    message.sbpr = parseInt(object.sbpr, 10);
                else if (typeof object.sbpr === "number")
                    message.sbpr = object.sbpr;
                else if (typeof object.sbpr === "object")
                    message.sbpr = new $util.LongBits(object.sbpr.low >>> 0, object.sbpr.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FeeComponents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.FeeComponents} message FeeComponents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeComponents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.min = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.min = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.max = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.max = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.constant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.constant = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bpt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bpt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vpt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vpt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rbh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rbh = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sbh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sbh = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gas = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tv = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bpr = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bpr = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sbpr = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sbpr = options.longs === String ? "0" : 0;
            }
            if (message.min != null && message.hasOwnProperty("min"))
                if (typeof message.min === "number")
                    object.min = options.longs === String ? String(message.min) : message.min;
                else
                    object.min = options.longs === String ? $util.Long.prototype.toString.call(message.min) : options.longs === Number ? new $util.LongBits(message.min.low >>> 0, message.min.high >>> 0).toNumber() : message.min;
            if (message.max != null && message.hasOwnProperty("max"))
                if (typeof message.max === "number")
                    object.max = options.longs === String ? String(message.max) : message.max;
                else
                    object.max = options.longs === String ? $util.Long.prototype.toString.call(message.max) : options.longs === Number ? new $util.LongBits(message.max.low >>> 0, message.max.high >>> 0).toNumber() : message.max;
            if (message.constant != null && message.hasOwnProperty("constant"))
                if (typeof message.constant === "number")
                    object.constant = options.longs === String ? String(message.constant) : message.constant;
                else
                    object.constant = options.longs === String ? $util.Long.prototype.toString.call(message.constant) : options.longs === Number ? new $util.LongBits(message.constant.low >>> 0, message.constant.high >>> 0).toNumber() : message.constant;
            if (message.bpt != null && message.hasOwnProperty("bpt"))
                if (typeof message.bpt === "number")
                    object.bpt = options.longs === String ? String(message.bpt) : message.bpt;
                else
                    object.bpt = options.longs === String ? $util.Long.prototype.toString.call(message.bpt) : options.longs === Number ? new $util.LongBits(message.bpt.low >>> 0, message.bpt.high >>> 0).toNumber() : message.bpt;
            if (message.vpt != null && message.hasOwnProperty("vpt"))
                if (typeof message.vpt === "number")
                    object.vpt = options.longs === String ? String(message.vpt) : message.vpt;
                else
                    object.vpt = options.longs === String ? $util.Long.prototype.toString.call(message.vpt) : options.longs === Number ? new $util.LongBits(message.vpt.low >>> 0, message.vpt.high >>> 0).toNumber() : message.vpt;
            if (message.rbh != null && message.hasOwnProperty("rbh"))
                if (typeof message.rbh === "number")
                    object.rbh = options.longs === String ? String(message.rbh) : message.rbh;
                else
                    object.rbh = options.longs === String ? $util.Long.prototype.toString.call(message.rbh) : options.longs === Number ? new $util.LongBits(message.rbh.low >>> 0, message.rbh.high >>> 0).toNumber() : message.rbh;
            if (message.sbh != null && message.hasOwnProperty("sbh"))
                if (typeof message.sbh === "number")
                    object.sbh = options.longs === String ? String(message.sbh) : message.sbh;
                else
                    object.sbh = options.longs === String ? $util.Long.prototype.toString.call(message.sbh) : options.longs === Number ? new $util.LongBits(message.sbh.low >>> 0, message.sbh.high >>> 0).toNumber() : message.sbh;
            if (message.gas != null && message.hasOwnProperty("gas"))
                if (typeof message.gas === "number")
                    object.gas = options.longs === String ? String(message.gas) : message.gas;
                else
                    object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber() : message.gas;
            if (message.tv != null && message.hasOwnProperty("tv"))
                if (typeof message.tv === "number")
                    object.tv = options.longs === String ? String(message.tv) : message.tv;
                else
                    object.tv = options.longs === String ? $util.Long.prototype.toString.call(message.tv) : options.longs === Number ? new $util.LongBits(message.tv.low >>> 0, message.tv.high >>> 0).toNumber() : message.tv;
            if (message.bpr != null && message.hasOwnProperty("bpr"))
                if (typeof message.bpr === "number")
                    object.bpr = options.longs === String ? String(message.bpr) : message.bpr;
                else
                    object.bpr = options.longs === String ? $util.Long.prototype.toString.call(message.bpr) : options.longs === Number ? new $util.LongBits(message.bpr.low >>> 0, message.bpr.high >>> 0).toNumber() : message.bpr;
            if (message.sbpr != null && message.hasOwnProperty("sbpr"))
                if (typeof message.sbpr === "number")
                    object.sbpr = options.longs === String ? String(message.sbpr) : message.sbpr;
                else
                    object.sbpr = options.longs === String ? $util.Long.prototype.toString.call(message.sbpr) : options.longs === Number ? new $util.LongBits(message.sbpr.low >>> 0, message.sbpr.high >>> 0).toNumber() : message.sbpr;
            return object;
        };

        /**
         * Converts this FeeComponents to JSON.
         * @function toJSON
         * @memberof proto.FeeComponents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeComponents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeComponents;
    })();

    proto.TransactionFeeSchedule = (function() {

        /**
         * Properties of a TransactionFeeSchedule.
         * @memberof proto
         * @interface ITransactionFeeSchedule
         * @property {proto.HederaFunctionality|null} [hederaFunctionality] TransactionFeeSchedule hederaFunctionality
         * @property {proto.IFeeData|null} [feeData] TransactionFeeSchedule feeData
         */

        /**
         * Constructs a new TransactionFeeSchedule.
         * @memberof proto
         * @classdesc Represents a TransactionFeeSchedule.
         * @implements ITransactionFeeSchedule
         * @constructor
         * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
         */
        function TransactionFeeSchedule(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionFeeSchedule hederaFunctionality.
         * @member {proto.HederaFunctionality} hederaFunctionality
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.hederaFunctionality = 0;

        /**
         * TransactionFeeSchedule feeData.
         * @member {proto.IFeeData|null|undefined} feeData
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.feeData = null;

        /**
         * Creates a new TransactionFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule instance
         */
        TransactionFeeSchedule.create = function create(properties) {
            return new TransactionFeeSchedule(properties);
        };

        /**
         * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule} message TransactionFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionFeeSchedule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hederaFunctionality != null && Object.hasOwnProperty.call(message, "hederaFunctionality"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hederaFunctionality);
            if (message.feeData != null && Object.hasOwnProperty.call(message, "feeData"))
                $root.proto.FeeData.encode(message.feeData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionFeeSchedule message, length delimited. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule} message TransactionFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionFeeSchedule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionFeeSchedule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionFeeSchedule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hederaFunctionality = reader.int32();
                    break;
                case 2:
                    message.feeData = $root.proto.FeeData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionFeeSchedule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionFeeSchedule message.
         * @function verify
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionFeeSchedule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hederaFunctionality != null && message.hasOwnProperty("hederaFunctionality"))
                switch (message.hederaFunctionality) {
                default:
                    return "hederaFunctionality: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                    break;
                }
            if (message.feeData != null && message.hasOwnProperty("feeData")) {
                var error = $root.proto.FeeData.verify(message.feeData);
                if (error)
                    return "feeData." + error;
            }
            return null;
        };

        /**
         * Creates a TransactionFeeSchedule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
         */
        TransactionFeeSchedule.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TransactionFeeSchedule)
                return object;
            var message = new $root.proto.TransactionFeeSchedule();
            switch (object.hederaFunctionality) {
            case "NONE":
            case 0:
                message.hederaFunctionality = 0;
                break;
            case "CryptoTransfer":
            case 1:
                message.hederaFunctionality = 1;
                break;
            case "CryptoUpdate":
            case 2:
                message.hederaFunctionality = 2;
                break;
            case "CryptoDelete":
            case 3:
                message.hederaFunctionality = 3;
                break;
            case "CryptoAddLiveHash":
            case 4:
                message.hederaFunctionality = 4;
                break;
            case "CryptoDeleteLiveHash":
            case 5:
                message.hederaFunctionality = 5;
                break;
            case "ContractCall":
            case 6:
                message.hederaFunctionality = 6;
                break;
            case "ContractCreate":
            case 7:
                message.hederaFunctionality = 7;
                break;
            case "ContractUpdate":
            case 8:
                message.hederaFunctionality = 8;
                break;
            case "FileCreate":
            case 9:
                message.hederaFunctionality = 9;
                break;
            case "FileAppend":
            case 10:
                message.hederaFunctionality = 10;
                break;
            case "FileUpdate":
            case 11:
                message.hederaFunctionality = 11;
                break;
            case "FileDelete":
            case 12:
                message.hederaFunctionality = 12;
                break;
            case "CryptoGetAccountBalance":
            case 13:
                message.hederaFunctionality = 13;
                break;
            case "CryptoGetAccountRecords":
            case 14:
                message.hederaFunctionality = 14;
                break;
            case "CryptoGetInfo":
            case 15:
                message.hederaFunctionality = 15;
                break;
            case "ContractCallLocal":
            case 16:
                message.hederaFunctionality = 16;
                break;
            case "ContractGetInfo":
            case 17:
                message.hederaFunctionality = 17;
                break;
            case "ContractGetBytecode":
            case 18:
                message.hederaFunctionality = 18;
                break;
            case "GetBySolidityID":
            case 19:
                message.hederaFunctionality = 19;
                break;
            case "GetByKey":
            case 20:
                message.hederaFunctionality = 20;
                break;
            case "CryptoGetLiveHash":
            case 21:
                message.hederaFunctionality = 21;
                break;
            case "CryptoGetStakers":
            case 22:
                message.hederaFunctionality = 22;
                break;
            case "FileGetContents":
            case 23:
                message.hederaFunctionality = 23;
                break;
            case "FileGetInfo":
            case 24:
                message.hederaFunctionality = 24;
                break;
            case "TransactionGetRecord":
            case 25:
                message.hederaFunctionality = 25;
                break;
            case "ContractGetRecords":
            case 26:
                message.hederaFunctionality = 26;
                break;
            case "CryptoCreate":
            case 27:
                message.hederaFunctionality = 27;
                break;
            case "SystemDelete":
            case 28:
                message.hederaFunctionality = 28;
                break;
            case "SystemUndelete":
            case 29:
                message.hederaFunctionality = 29;
                break;
            case "ContractDelete":
            case 30:
                message.hederaFunctionality = 30;
                break;
            case "Freeze":
            case 31:
                message.hederaFunctionality = 31;
                break;
            case "CreateTransactionRecord":
            case 32:
                message.hederaFunctionality = 32;
                break;
            case "CryptoAccountAutoRenew":
            case 33:
                message.hederaFunctionality = 33;
                break;
            case "ContractAutoRenew":
            case 34:
                message.hederaFunctionality = 34;
                break;
            case "GetVersionInfo":
            case 35:
                message.hederaFunctionality = 35;
                break;
            case "TransactionGetReceipt":
            case 36:
                message.hederaFunctionality = 36;
                break;
            case "ConsensusCreateTopic":
            case 50:
                message.hederaFunctionality = 50;
                break;
            case "ConsensusUpdateTopic":
            case 51:
                message.hederaFunctionality = 51;
                break;
            case "ConsensusDeleteTopic":
            case 52:
                message.hederaFunctionality = 52;
                break;
            case "ConsensusGetTopicInfo":
            case 53:
                message.hederaFunctionality = 53;
                break;
            case "ConsensusSubmitMessage":
            case 54:
                message.hederaFunctionality = 54;
                break;
            case "UncheckedSubmit":
            case 55:
                message.hederaFunctionality = 55;
                break;
            case "TokenCreate":
            case 56:
                message.hederaFunctionality = 56;
                break;
            case "TokenGetInfo":
            case 58:
                message.hederaFunctionality = 58;
                break;
            case "TokenFreezeAccount":
            case 59:
                message.hederaFunctionality = 59;
                break;
            case "TokenUnfreezeAccount":
            case 60:
                message.hederaFunctionality = 60;
                break;
            case "TokenGrantKycToAccount":
            case 61:
                message.hederaFunctionality = 61;
                break;
            case "TokenRevokeKycFromAccount":
            case 62:
                message.hederaFunctionality = 62;
                break;
            case "TokenDelete":
            case 63:
                message.hederaFunctionality = 63;
                break;
            case "TokenUpdate":
            case 64:
                message.hederaFunctionality = 64;
                break;
            case "TokenMint":
            case 65:
                message.hederaFunctionality = 65;
                break;
            case "TokenBurn":
            case 66:
                message.hederaFunctionality = 66;
                break;
            case "TokenAccountWipe":
            case 67:
                message.hederaFunctionality = 67;
                break;
            case "TokenAssociateToAccount":
            case 68:
                message.hederaFunctionality = 68;
                break;
            case "TokenDissociateFromAccount":
            case 69:
                message.hederaFunctionality = 69;
                break;
            case "ScheduleCreate":
            case 70:
                message.hederaFunctionality = 70;
                break;
            case "ScheduleDelete":
            case 71:
                message.hederaFunctionality = 71;
                break;
            case "ScheduleSign":
            case 72:
                message.hederaFunctionality = 72;
                break;
            case "ScheduleGetInfo":
            case 73:
                message.hederaFunctionality = 73;
                break;
            }
            if (object.feeData != null) {
                if (typeof object.feeData !== "object")
                    throw TypeError(".proto.TransactionFeeSchedule.feeData: object expected");
                message.feeData = $root.proto.FeeData.fromObject(object.feeData);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionFeeSchedule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.TransactionFeeSchedule} message TransactionFeeSchedule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionFeeSchedule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hederaFunctionality = options.enums === String ? "NONE" : 0;
                object.feeData = null;
            }
            if (message.hederaFunctionality != null && message.hasOwnProperty("hederaFunctionality"))
                object.hederaFunctionality = options.enums === String ? $root.proto.HederaFunctionality[message.hederaFunctionality] : message.hederaFunctionality;
            if (message.feeData != null && message.hasOwnProperty("feeData"))
                object.feeData = $root.proto.FeeData.toObject(message.feeData, options);
            return object;
        };

        /**
         * Converts this TransactionFeeSchedule to JSON.
         * @function toJSON
         * @memberof proto.TransactionFeeSchedule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionFeeSchedule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionFeeSchedule;
    })();

    proto.FeeData = (function() {

        /**
         * Properties of a FeeData.
         * @memberof proto
         * @interface IFeeData
         * @property {proto.IFeeComponents|null} [nodedata] FeeData nodedata
         * @property {proto.IFeeComponents|null} [networkdata] FeeData networkdata
         * @property {proto.IFeeComponents|null} [servicedata] FeeData servicedata
         */

        /**
         * Constructs a new FeeData.
         * @memberof proto
         * @classdesc Represents a FeeData.
         * @implements IFeeData
         * @constructor
         * @param {proto.IFeeData=} [properties] Properties to set
         */
        function FeeData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeData nodedata.
         * @member {proto.IFeeComponents|null|undefined} nodedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.nodedata = null;

        /**
         * FeeData networkdata.
         * @member {proto.IFeeComponents|null|undefined} networkdata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.networkdata = null;

        /**
         * FeeData servicedata.
         * @member {proto.IFeeComponents|null|undefined} servicedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.servicedata = null;

        /**
         * Creates a new FeeData instance using the specified properties.
         * @function create
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData=} [properties] Properties to set
         * @returns {proto.FeeData} FeeData instance
         */
        FeeData.create = function create(properties) {
            return new FeeData(properties);
        };

        /**
         * Encodes the specified FeeData message. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData} message FeeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodedata != null && Object.hasOwnProperty.call(message, "nodedata"))
                $root.proto.FeeComponents.encode(message.nodedata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.networkdata != null && Object.hasOwnProperty.call(message, "networkdata"))
                $root.proto.FeeComponents.encode(message.networkdata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.servicedata != null && Object.hasOwnProperty.call(message, "servicedata"))
                $root.proto.FeeComponents.encode(message.servicedata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeeData message, length delimited. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData} message FeeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FeeData} FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeeData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodedata = $root.proto.FeeComponents.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.networkdata = $root.proto.FeeComponents.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.servicedata = $root.proto.FeeComponents.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.FeeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.FeeData} FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeData message.
         * @function verify
         * @memberof proto.FeeData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodedata != null && message.hasOwnProperty("nodedata")) {
                var error = $root.proto.FeeComponents.verify(message.nodedata);
                if (error)
                    return "nodedata." + error;
            }
            if (message.networkdata != null && message.hasOwnProperty("networkdata")) {
                var error = $root.proto.FeeComponents.verify(message.networkdata);
                if (error)
                    return "networkdata." + error;
            }
            if (message.servicedata != null && message.hasOwnProperty("servicedata")) {
                var error = $root.proto.FeeComponents.verify(message.servicedata);
                if (error)
                    return "servicedata." + error;
            }
            return null;
        };

        /**
         * Creates a FeeData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.FeeData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.FeeData} FeeData
         */
        FeeData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.FeeData)
                return object;
            var message = new $root.proto.FeeData();
            if (object.nodedata != null) {
                if (typeof object.nodedata !== "object")
                    throw TypeError(".proto.FeeData.nodedata: object expected");
                message.nodedata = $root.proto.FeeComponents.fromObject(object.nodedata);
            }
            if (object.networkdata != null) {
                if (typeof object.networkdata !== "object")
                    throw TypeError(".proto.FeeData.networkdata: object expected");
                message.networkdata = $root.proto.FeeComponents.fromObject(object.networkdata);
            }
            if (object.servicedata != null) {
                if (typeof object.servicedata !== "object")
                    throw TypeError(".proto.FeeData.servicedata: object expected");
                message.servicedata = $root.proto.FeeComponents.fromObject(object.servicedata);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeeData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.FeeData
         * @static
         * @param {proto.FeeData} message FeeData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nodedata = null;
                object.networkdata = null;
                object.servicedata = null;
            }
            if (message.nodedata != null && message.hasOwnProperty("nodedata"))
                object.nodedata = $root.proto.FeeComponents.toObject(message.nodedata, options);
            if (message.networkdata != null && message.hasOwnProperty("networkdata"))
                object.networkdata = $root.proto.FeeComponents.toObject(message.networkdata, options);
            if (message.servicedata != null && message.hasOwnProperty("servicedata"))
                object.servicedata = $root.proto.FeeComponents.toObject(message.servicedata, options);
            return object;
        };

        /**
         * Converts this FeeData to JSON.
         * @function toJSON
         * @memberof proto.FeeData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeData;
    })();

    proto.FeeSchedule = (function() {

        /**
         * Properties of a FeeSchedule.
         * @memberof proto
         * @interface IFeeSchedule
         * @property {Array.<proto.ITransactionFeeSchedule>|null} [transactionFeeSchedule] FeeSchedule transactionFeeSchedule
         * @property {proto.ITimestampSeconds|null} [expiryTime] FeeSchedule expiryTime
         */

        /**
         * Constructs a new FeeSchedule.
         * @memberof proto
         * @classdesc Represents a FeeSchedule.
         * @implements IFeeSchedule
         * @constructor
         * @param {proto.IFeeSchedule=} [properties] Properties to set
         */
        function FeeSchedule(properties) {
            this.transactionFeeSchedule = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeSchedule transactionFeeSchedule.
         * @member {Array.<proto.ITransactionFeeSchedule>} transactionFeeSchedule
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.transactionFeeSchedule = $util.emptyArray;

        /**
         * FeeSchedule expiryTime.
         * @member {proto.ITimestampSeconds|null|undefined} expiryTime
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.expiryTime = null;

        /**
         * Creates a new FeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule=} [properties] Properties to set
         * @returns {proto.FeeSchedule} FeeSchedule instance
         */
        FeeSchedule.create = function create(properties) {
            return new FeeSchedule(properties);
        };

        /**
         * Encodes the specified FeeSchedule message. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule} message FeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeSchedule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactionFeeSchedule != null && message.transactionFeeSchedule.length)
                for (var i = 0; i < message.transactionFeeSchedule.length; ++i)
                    $root.proto.TransactionFeeSchedule.encode(message.transactionFeeSchedule[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.expiryTime != null && Object.hasOwnProperty.call(message, "expiryTime"))
                $root.proto.TimestampSeconds.encode(message.expiryTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeeSchedule message, length delimited. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule} message FeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeSchedule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FeeSchedule} FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeSchedule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeeSchedule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactionFeeSchedule && message.transactionFeeSchedule.length))
                        message.transactionFeeSchedule = [];
                    message.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.expiryTime = $root.proto.TimestampSeconds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.FeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.FeeSchedule} FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeSchedule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeSchedule message.
         * @function verify
         * @memberof proto.FeeSchedule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeSchedule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactionFeeSchedule != null && message.hasOwnProperty("transactionFeeSchedule")) {
                if (!Array.isArray(message.transactionFeeSchedule))
                    return "transactionFeeSchedule: array expected";
                for (var i = 0; i < message.transactionFeeSchedule.length; ++i) {
                    var error = $root.proto.TransactionFeeSchedule.verify(message.transactionFeeSchedule[i]);
                    if (error)
                        return "transactionFeeSchedule." + error;
                }
            }
            if (message.expiryTime != null && message.hasOwnProperty("expiryTime")) {
                var error = $root.proto.TimestampSeconds.verify(message.expiryTime);
                if (error)
                    return "expiryTime." + error;
            }
            return null;
        };

        /**
         * Creates a FeeSchedule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.FeeSchedule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.FeeSchedule} FeeSchedule
         */
        FeeSchedule.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.FeeSchedule)
                return object;
            var message = new $root.proto.FeeSchedule();
            if (object.transactionFeeSchedule) {
                if (!Array.isArray(object.transactionFeeSchedule))
                    throw TypeError(".proto.FeeSchedule.transactionFeeSchedule: array expected");
                message.transactionFeeSchedule = [];
                for (var i = 0; i < object.transactionFeeSchedule.length; ++i) {
                    if (typeof object.transactionFeeSchedule[i] !== "object")
                        throw TypeError(".proto.FeeSchedule.transactionFeeSchedule: object expected");
                    message.transactionFeeSchedule[i] = $root.proto.TransactionFeeSchedule.fromObject(object.transactionFeeSchedule[i]);
                }
            }
            if (object.expiryTime != null) {
                if (typeof object.expiryTime !== "object")
                    throw TypeError(".proto.FeeSchedule.expiryTime: object expected");
                message.expiryTime = $root.proto.TimestampSeconds.fromObject(object.expiryTime);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeeSchedule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.FeeSchedule} message FeeSchedule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeSchedule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactionFeeSchedule = [];
            if (options.defaults)
                object.expiryTime = null;
            if (message.transactionFeeSchedule && message.transactionFeeSchedule.length) {
                object.transactionFeeSchedule = [];
                for (var j = 0; j < message.transactionFeeSchedule.length; ++j)
                    object.transactionFeeSchedule[j] = $root.proto.TransactionFeeSchedule.toObject(message.transactionFeeSchedule[j], options);
            }
            if (message.expiryTime != null && message.hasOwnProperty("expiryTime"))
                object.expiryTime = $root.proto.TimestampSeconds.toObject(message.expiryTime, options);
            return object;
        };

        /**
         * Converts this FeeSchedule to JSON.
         * @function toJSON
         * @memberof proto.FeeSchedule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeSchedule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeSchedule;
    })();

    proto.CurrentAndNextFeeSchedule = (function() {

        /**
         * Properties of a CurrentAndNextFeeSchedule.
         * @memberof proto
         * @interface ICurrentAndNextFeeSchedule
         * @property {proto.IFeeSchedule|null} [currentFeeSchedule] CurrentAndNextFeeSchedule currentFeeSchedule
         * @property {proto.IFeeSchedule|null} [nextFeeSchedule] CurrentAndNextFeeSchedule nextFeeSchedule
         */

        /**
         * Constructs a new CurrentAndNextFeeSchedule.
         * @memberof proto
         * @classdesc Represents a CurrentAndNextFeeSchedule.
         * @implements ICurrentAndNextFeeSchedule
         * @constructor
         * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
         */
        function CurrentAndNextFeeSchedule(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CurrentAndNextFeeSchedule currentFeeSchedule.
         * @member {proto.IFeeSchedule|null|undefined} currentFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.currentFeeSchedule = null;

        /**
         * CurrentAndNextFeeSchedule nextFeeSchedule.
         * @member {proto.IFeeSchedule|null|undefined} nextFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.nextFeeSchedule = null;

        /**
         * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule instance
         */
        CurrentAndNextFeeSchedule.create = function create(properties) {
            return new CurrentAndNextFeeSchedule(properties);
        };

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule} message CurrentAndNextFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentAndNextFeeSchedule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentFeeSchedule != null && Object.hasOwnProperty.call(message, "currentFeeSchedule"))
                $root.proto.FeeSchedule.encode(message.currentFeeSchedule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextFeeSchedule != null && Object.hasOwnProperty.call(message, "nextFeeSchedule"))
                $root.proto.FeeSchedule.encode(message.nextFeeSchedule, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message, length delimited. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule} message CurrentAndNextFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentAndNextFeeSchedule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentAndNextFeeSchedule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CurrentAndNextFeeSchedule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentFeeSchedule = $root.proto.FeeSchedule.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nextFeeSchedule = $root.proto.FeeSchedule.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentAndNextFeeSchedule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CurrentAndNextFeeSchedule message.
         * @function verify
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CurrentAndNextFeeSchedule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentFeeSchedule != null && message.hasOwnProperty("currentFeeSchedule")) {
                var error = $root.proto.FeeSchedule.verify(message.currentFeeSchedule);
                if (error)
                    return "currentFeeSchedule." + error;
            }
            if (message.nextFeeSchedule != null && message.hasOwnProperty("nextFeeSchedule")) {
                var error = $root.proto.FeeSchedule.verify(message.nextFeeSchedule);
                if (error)
                    return "nextFeeSchedule." + error;
            }
            return null;
        };

        /**
         * Creates a CurrentAndNextFeeSchedule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
         */
        CurrentAndNextFeeSchedule.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.CurrentAndNextFeeSchedule)
                return object;
            var message = new $root.proto.CurrentAndNextFeeSchedule();
            if (object.currentFeeSchedule != null) {
                if (typeof object.currentFeeSchedule !== "object")
                    throw TypeError(".proto.CurrentAndNextFeeSchedule.currentFeeSchedule: object expected");
                message.currentFeeSchedule = $root.proto.FeeSchedule.fromObject(object.currentFeeSchedule);
            }
            if (object.nextFeeSchedule != null) {
                if (typeof object.nextFeeSchedule !== "object")
                    throw TypeError(".proto.CurrentAndNextFeeSchedule.nextFeeSchedule: object expected");
                message.nextFeeSchedule = $root.proto.FeeSchedule.fromObject(object.nextFeeSchedule);
            }
            return message;
        };

        /**
         * Creates a plain object from a CurrentAndNextFeeSchedule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.CurrentAndNextFeeSchedule} message CurrentAndNextFeeSchedule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CurrentAndNextFeeSchedule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currentFeeSchedule = null;
                object.nextFeeSchedule = null;
            }
            if (message.currentFeeSchedule != null && message.hasOwnProperty("currentFeeSchedule"))
                object.currentFeeSchedule = $root.proto.FeeSchedule.toObject(message.currentFeeSchedule, options);
            if (message.nextFeeSchedule != null && message.hasOwnProperty("nextFeeSchedule"))
                object.nextFeeSchedule = $root.proto.FeeSchedule.toObject(message.nextFeeSchedule, options);
            return object;
        };

        /**
         * Converts this CurrentAndNextFeeSchedule to JSON.
         * @function toJSON
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CurrentAndNextFeeSchedule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CurrentAndNextFeeSchedule;
    })();

    proto.NodeEndpoint = (function() {

        /**
         * Properties of a NodeEndpoint.
         * @memberof proto
         * @interface INodeEndpoint
         * @property {string|null} [ipAddress] NodeEndpoint ipAddress
         * @property {string|null} [port] NodeEndpoint port
         */

        /**
         * Constructs a new NodeEndpoint.
         * @memberof proto
         * @classdesc Represents a NodeEndpoint.
         * @implements INodeEndpoint
         * @constructor
         * @param {proto.INodeEndpoint=} [properties] Properties to set
         */
        function NodeEndpoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeEndpoint ipAddress.
         * @member {string} ipAddress
         * @memberof proto.NodeEndpoint
         * @instance
         */
        NodeEndpoint.prototype.ipAddress = "";

        /**
         * NodeEndpoint port.
         * @member {string} port
         * @memberof proto.NodeEndpoint
         * @instance
         */
        NodeEndpoint.prototype.port = "";

        /**
         * Creates a new NodeEndpoint instance using the specified properties.
         * @function create
         * @memberof proto.NodeEndpoint
         * @static
         * @param {proto.INodeEndpoint=} [properties] Properties to set
         * @returns {proto.NodeEndpoint} NodeEndpoint instance
         */
        NodeEndpoint.create = function create(properties) {
            return new NodeEndpoint(properties);
        };

        /**
         * Encodes the specified NodeEndpoint message. Does not implicitly {@link proto.NodeEndpoint.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeEndpoint
         * @static
         * @param {proto.INodeEndpoint} message NodeEndpoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeEndpoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ipAddress != null && Object.hasOwnProperty.call(message, "ipAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ipAddress);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.port);
            return writer;
        };

        /**
         * Encodes the specified NodeEndpoint message, length delimited. Does not implicitly {@link proto.NodeEndpoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.NodeEndpoint
         * @static
         * @param {proto.INodeEndpoint} message NodeEndpoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeEndpoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeEndpoint message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeEndpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.NodeEndpoint} NodeEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeEndpoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NodeEndpoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ipAddress = reader.string();
                    break;
                case 2:
                    message.port = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeEndpoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.NodeEndpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.NodeEndpoint} NodeEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeEndpoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeEndpoint message.
         * @function verify
         * @memberof proto.NodeEndpoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeEndpoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isString(message.port))
                    return "port: string expected";
            return null;
        };

        /**
         * Creates a NodeEndpoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.NodeEndpoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.NodeEndpoint} NodeEndpoint
         */
        NodeEndpoint.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.NodeEndpoint)
                return object;
            var message = new $root.proto.NodeEndpoint();
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            if (object.port != null)
                message.port = String(object.port);
            return message;
        };

        /**
         * Creates a plain object from a NodeEndpoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.NodeEndpoint
         * @static
         * @param {proto.NodeEndpoint} message NodeEndpoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeEndpoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ipAddress = "";
                object.port = "";
            }
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this NodeEndpoint to JSON.
         * @function toJSON
         * @memberof proto.NodeEndpoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeEndpoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeEndpoint;
    })();

    proto.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof proto
         * @interface INodeAddress
         * @property {Uint8Array|null} [ipAddress] NodeAddress ipAddress
         * @property {number|null} [portno] NodeAddress portno
         * @property {Uint8Array|null} [memo] NodeAddress memo
         * @property {string|null} [RSA_PubKey] NodeAddress RSA_PubKey
         * @property {number|Long|null} [nodeId] NodeAddress nodeId
         * @property {proto.IAccountID|null} [nodeAccountId] NodeAddress nodeAccountId
         * @property {Uint8Array|null} [nodeCertHash] NodeAddress nodeCertHash
         * @property {Array.<proto.INodeEndpoint>|null} [nodeEndpoint] NodeAddress nodeEndpoint
         * @property {string|null} [description] NodeAddress description
         * @property {number|Long|null} [stake] NodeAddress stake
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof proto
         * @classdesc Represents a NodeAddress.
         * @implements INodeAddress
         * @constructor
         * @param {proto.INodeAddress=} [properties] Properties to set
         */
        function NodeAddress(properties) {
            this.nodeEndpoint = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeAddress ipAddress.
         * @member {Uint8Array} ipAddress
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.ipAddress = $util.newBuffer([]);

        /**
         * NodeAddress portno.
         * @member {number} portno
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.portno = 0;

        /**
         * NodeAddress memo.
         * @member {Uint8Array} memo
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.memo = $util.newBuffer([]);

        /**
         * NodeAddress RSA_PubKey.
         * @member {string} RSA_PubKey
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.RSA_PubKey = "";

        /**
         * NodeAddress nodeId.
         * @member {number|Long} nodeId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeAddress nodeAccountId.
         * @member {proto.IAccountID|null|undefined} nodeAccountId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeAccountId = null;

        /**
         * NodeAddress nodeCertHash.
         * @member {Uint8Array} nodeCertHash
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeCertHash = $util.newBuffer([]);

        /**
         * NodeAddress nodeEndpoint.
         * @member {Array.<proto.INodeEndpoint>} nodeEndpoint
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeEndpoint = $util.emptyArray;

        /**
         * NodeAddress description.
         * @member {string} description
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.description = "";

        /**
         * NodeAddress stake.
         * @member {number|Long} stake
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress=} [properties] Properties to set
         * @returns {proto.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ipAddress != null && Object.hasOwnProperty.call(message, "ipAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ipAddress);
            if (message.portno != null && Object.hasOwnProperty.call(message, "portno"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.portno);
            if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.memo);
            if (message.RSA_PubKey != null && Object.hasOwnProperty.call(message, "RSA_PubKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.RSA_PubKey);
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.nodeId);
            if (message.nodeAccountId != null && Object.hasOwnProperty.call(message, "nodeAccountId"))
                $root.proto.AccountID.encode(message.nodeAccountId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.nodeCertHash != null && Object.hasOwnProperty.call(message, "nodeCertHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.nodeCertHash);
            if (message.nodeEndpoint != null && message.nodeEndpoint.length)
                for (var i = 0; i < message.nodeEndpoint.length; ++i)
                    $root.proto.NodeEndpoint.encode(message.nodeEndpoint[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.description);
            if (message.stake != null && Object.hasOwnProperty.call(message, "stake"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.stake);
            return writer;
        };

        /**
         * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NodeAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ipAddress = reader.bytes();
                    break;
                case 2:
                    message.portno = reader.int32();
                    break;
                case 3:
                    message.memo = reader.bytes();
                    break;
                case 4:
                    message.RSA_PubKey = reader.string();
                    break;
                case 5:
                    message.nodeId = reader.int64();
                    break;
                case 6:
                    message.nodeAccountId = $root.proto.AccountID.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.nodeCertHash = reader.bytes();
                    break;
                case 8:
                    if (!(message.nodeEndpoint && message.nodeEndpoint.length))
                        message.nodeEndpoint = [];
                    message.nodeEndpoint.push($root.proto.NodeEndpoint.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.description = reader.string();
                    break;
                case 10:
                    message.stake = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeAddress message.
         * @function verify
         * @memberof proto.NodeAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!(message.ipAddress && typeof message.ipAddress.length === "number" || $util.isString(message.ipAddress)))
                    return "ipAddress: buffer expected";
            if (message.portno != null && message.hasOwnProperty("portno"))
                if (!$util.isInteger(message.portno))
                    return "portno: integer expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!(message.memo && typeof message.memo.length === "number" || $util.isString(message.memo)))
                    return "memo: buffer expected";
            if (message.RSA_PubKey != null && message.hasOwnProperty("RSA_PubKey"))
                if (!$util.isString(message.RSA_PubKey))
                    return "RSA_PubKey: string expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
                    return "nodeId: integer|Long expected";
            if (message.nodeAccountId != null && message.hasOwnProperty("nodeAccountId")) {
                var error = $root.proto.AccountID.verify(message.nodeAccountId);
                if (error)
                    return "nodeAccountId." + error;
            }
            if (message.nodeCertHash != null && message.hasOwnProperty("nodeCertHash"))
                if (!(message.nodeCertHash && typeof message.nodeCertHash.length === "number" || $util.isString(message.nodeCertHash)))
                    return "nodeCertHash: buffer expected";
            if (message.nodeEndpoint != null && message.hasOwnProperty("nodeEndpoint")) {
                if (!Array.isArray(message.nodeEndpoint))
                    return "nodeEndpoint: array expected";
                for (var i = 0; i < message.nodeEndpoint.length; ++i) {
                    var error = $root.proto.NodeEndpoint.verify(message.nodeEndpoint[i]);
                    if (error)
                        return "nodeEndpoint." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.stake != null && message.hasOwnProperty("stake"))
                if (!$util.isInteger(message.stake) && !(message.stake && $util.isInteger(message.stake.low) && $util.isInteger(message.stake.high)))
                    return "stake: integer|Long expected";
            return null;
        };

        /**
         * Creates a NodeAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.NodeAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.NodeAddress} NodeAddress
         */
        NodeAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.NodeAddress)
                return object;
            var message = new $root.proto.NodeAddress();
            if (object.ipAddress != null)
                if (typeof object.ipAddress === "string")
                    $util.base64.decode(object.ipAddress, message.ipAddress = $util.newBuffer($util.base64.length(object.ipAddress)), 0);
                else if (object.ipAddress.length)
                    message.ipAddress = object.ipAddress;
            if (object.portno != null)
                message.portno = object.portno | 0;
            if (object.memo != null)
                if (typeof object.memo === "string")
                    $util.base64.decode(object.memo, message.memo = $util.newBuffer($util.base64.length(object.memo)), 0);
                else if (object.memo.length)
                    message.memo = object.memo;
            if (object.RSA_PubKey != null)
                message.RSA_PubKey = String(object.RSA_PubKey);
            if (object.nodeId != null)
                if ($util.Long)
                    (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
                else if (typeof object.nodeId === "string")
                    message.nodeId = parseInt(object.nodeId, 10);
                else if (typeof object.nodeId === "number")
                    message.nodeId = object.nodeId;
                else if (typeof object.nodeId === "object")
                    message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber();
            if (object.nodeAccountId != null) {
                if (typeof object.nodeAccountId !== "object")
                    throw TypeError(".proto.NodeAddress.nodeAccountId: object expected");
                message.nodeAccountId = $root.proto.AccountID.fromObject(object.nodeAccountId);
            }
            if (object.nodeCertHash != null)
                if (typeof object.nodeCertHash === "string")
                    $util.base64.decode(object.nodeCertHash, message.nodeCertHash = $util.newBuffer($util.base64.length(object.nodeCertHash)), 0);
                else if (object.nodeCertHash.length)
                    message.nodeCertHash = object.nodeCertHash;
            if (object.nodeEndpoint) {
                if (!Array.isArray(object.nodeEndpoint))
                    throw TypeError(".proto.NodeAddress.nodeEndpoint: array expected");
                message.nodeEndpoint = [];
                for (var i = 0; i < object.nodeEndpoint.length; ++i) {
                    if (typeof object.nodeEndpoint[i] !== "object")
                        throw TypeError(".proto.NodeAddress.nodeEndpoint: object expected");
                    message.nodeEndpoint[i] = $root.proto.NodeEndpoint.fromObject(object.nodeEndpoint[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.stake != null)
                if ($util.Long)
                    (message.stake = $util.Long.fromValue(object.stake)).unsigned = false;
                else if (typeof object.stake === "string")
                    message.stake = parseInt(object.stake, 10);
                else if (typeof object.stake === "number")
                    message.stake = object.stake;
                else if (typeof object.stake === "object")
                    message.stake = new $util.LongBits(object.stake.low >>> 0, object.stake.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a NodeAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.NodeAddress} message NodeAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nodeEndpoint = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ipAddress = "";
                else {
                    object.ipAddress = [];
                    if (options.bytes !== Array)
                        object.ipAddress = $util.newBuffer(object.ipAddress);
                }
                object.portno = 0;
                if (options.bytes === String)
                    object.memo = "";
                else {
                    object.memo = [];
                    if (options.bytes !== Array)
                        object.memo = $util.newBuffer(object.memo);
                }
                object.RSA_PubKey = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nodeId = options.longs === String ? "0" : 0;
                object.nodeAccountId = null;
                if (options.bytes === String)
                    object.nodeCertHash = "";
                else {
                    object.nodeCertHash = [];
                    if (options.bytes !== Array)
                        object.nodeCertHash = $util.newBuffer(object.nodeCertHash);
                }
                object.description = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.stake = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.stake = options.longs === String ? "0" : 0;
            }
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = options.bytes === String ? $util.base64.encode(message.ipAddress, 0, message.ipAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ipAddress) : message.ipAddress;
            if (message.portno != null && message.hasOwnProperty("portno"))
                object.portno = message.portno;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = options.bytes === String ? $util.base64.encode(message.memo, 0, message.memo.length) : options.bytes === Array ? Array.prototype.slice.call(message.memo) : message.memo;
            if (message.RSA_PubKey != null && message.hasOwnProperty("RSA_PubKey"))
                object.RSA_PubKey = message.RSA_PubKey;
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (typeof message.nodeId === "number")
                    object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
                else
                    object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber() : message.nodeId;
            if (message.nodeAccountId != null && message.hasOwnProperty("nodeAccountId"))
                object.nodeAccountId = $root.proto.AccountID.toObject(message.nodeAccountId, options);
            if (message.nodeCertHash != null && message.hasOwnProperty("nodeCertHash"))
                object.nodeCertHash = options.bytes === String ? $util.base64.encode(message.nodeCertHash, 0, message.nodeCertHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodeCertHash) : message.nodeCertHash;
            if (message.nodeEndpoint && message.nodeEndpoint.length) {
                object.nodeEndpoint = [];
                for (var j = 0; j < message.nodeEndpoint.length; ++j)
                    object.nodeEndpoint[j] = $root.proto.NodeEndpoint.toObject(message.nodeEndpoint[j], options);
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.stake != null && message.hasOwnProperty("stake"))
                if (typeof message.stake === "number")
                    object.stake = options.longs === String ? String(message.stake) : message.stake;
                else
                    object.stake = options.longs === String ? $util.Long.prototype.toString.call(message.stake) : options.longs === Number ? new $util.LongBits(message.stake.low >>> 0, message.stake.high >>> 0).toNumber() : message.stake;
            return object;
        };

        /**
         * Converts this NodeAddress to JSON.
         * @function toJSON
         * @memberof proto.NodeAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeAddress;
    })();

    proto.AddressBook = (function() {

        /**
         * Properties of an AddressBook.
         * @memberof proto
         * @interface IAddressBook
         * @property {Array.<proto.INodeAddress>|null} [nodeAddress] AddressBook nodeAddress
         */

        /**
         * Constructs a new AddressBook.
         * @memberof proto
         * @classdesc Represents an AddressBook.
         * @implements IAddressBook
         * @constructor
         * @param {proto.IAddressBook=} [properties] Properties to set
         */
        function AddressBook(properties) {
            this.nodeAddress = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddressBook nodeAddress.
         * @member {Array.<proto.INodeAddress>} nodeAddress
         * @memberof proto.AddressBook
         * @instance
         */
        AddressBook.prototype.nodeAddress = $util.emptyArray;

        /**
         * Creates a new AddressBook instance using the specified properties.
         * @function create
         * @memberof proto.AddressBook
         * @static
         * @param {proto.IAddressBook=} [properties] Properties to set
         * @returns {proto.AddressBook} AddressBook instance
         */
        AddressBook.create = function create(properties) {
            return new AddressBook(properties);
        };

        /**
         * Encodes the specified AddressBook message. Does not implicitly {@link proto.AddressBook.verify|verify} messages.
         * @function encode
         * @memberof proto.AddressBook
         * @static
         * @param {proto.IAddressBook} message AddressBook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddressBook.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeAddress != null && message.nodeAddress.length)
                for (var i = 0; i < message.nodeAddress.length; ++i)
                    $root.proto.NodeAddress.encode(message.nodeAddress[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddressBook message, length delimited. Does not implicitly {@link proto.AddressBook.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AddressBook
         * @static
         * @param {proto.IAddressBook} message AddressBook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddressBook.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddressBook message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AddressBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AddressBook} AddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddressBook.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AddressBook();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodeAddress && message.nodeAddress.length))
                        message.nodeAddress = [];
                    message.nodeAddress.push($root.proto.NodeAddress.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddressBook message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AddressBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AddressBook} AddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddressBook.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddressBook message.
         * @function verify
         * @memberof proto.AddressBook
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddressBook.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeAddress != null && message.hasOwnProperty("nodeAddress")) {
                if (!Array.isArray(message.nodeAddress))
                    return "nodeAddress: array expected";
                for (var i = 0; i < message.nodeAddress.length; ++i) {
                    var error = $root.proto.NodeAddress.verify(message.nodeAddress[i]);
                    if (error)
                        return "nodeAddress." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AddressBook message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AddressBook
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AddressBook} AddressBook
         */
        AddressBook.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AddressBook)
                return object;
            var message = new $root.proto.AddressBook();
            if (object.nodeAddress) {
                if (!Array.isArray(object.nodeAddress))
                    throw TypeError(".proto.AddressBook.nodeAddress: array expected");
                message.nodeAddress = [];
                for (var i = 0; i < object.nodeAddress.length; ++i) {
                    if (typeof object.nodeAddress[i] !== "object")
                        throw TypeError(".proto.AddressBook.nodeAddress: object expected");
                    message.nodeAddress[i] = $root.proto.NodeAddress.fromObject(object.nodeAddress[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AddressBook message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AddressBook
         * @static
         * @param {proto.AddressBook} message AddressBook
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddressBook.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nodeAddress = [];
            if (message.nodeAddress && message.nodeAddress.length) {
                object.nodeAddress = [];
                for (var j = 0; j < message.nodeAddress.length; ++j)
                    object.nodeAddress[j] = $root.proto.NodeAddress.toObject(message.nodeAddress[j], options);
            }
            return object;
        };

        /**
         * Converts this AddressBook to JSON.
         * @function toJSON
         * @memberof proto.AddressBook
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddressBook.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddressBook;
    })();

    proto.NodeAddressForClients = (function() {

        /**
         * Properties of a NodeAddressForClients.
         * @memberof proto
         * @interface INodeAddressForClients
         * @property {number|Long|null} [nodeId] NodeAddressForClients nodeId
         * @property {proto.IAccountID|null} [nodeAccountId] NodeAddressForClients nodeAccountId
         * @property {Uint8Array|null} [nodeCertHash] NodeAddressForClients nodeCertHash
         * @property {Array.<proto.INodeEndpoint>|null} [nodeEndpoint] NodeAddressForClients nodeEndpoint
         */

        /**
         * Constructs a new NodeAddressForClients.
         * @memberof proto
         * @classdesc Represents a NodeAddressForClients.
         * @implements INodeAddressForClients
         * @constructor
         * @param {proto.INodeAddressForClients=} [properties] Properties to set
         */
        function NodeAddressForClients(properties) {
            this.nodeEndpoint = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeAddressForClients nodeId.
         * @member {number|Long} nodeId
         * @memberof proto.NodeAddressForClients
         * @instance
         */
        NodeAddressForClients.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeAddressForClients nodeAccountId.
         * @member {proto.IAccountID|null|undefined} nodeAccountId
         * @memberof proto.NodeAddressForClients
         * @instance
         */
        NodeAddressForClients.prototype.nodeAccountId = null;

        /**
         * NodeAddressForClients nodeCertHash.
         * @member {Uint8Array} nodeCertHash
         * @memberof proto.NodeAddressForClients
         * @instance
         */
        NodeAddressForClients.prototype.nodeCertHash = $util.newBuffer([]);

        /**
         * NodeAddressForClients nodeEndpoint.
         * @member {Array.<proto.INodeEndpoint>} nodeEndpoint
         * @memberof proto.NodeAddressForClients
         * @instance
         */
        NodeAddressForClients.prototype.nodeEndpoint = $util.emptyArray;

        /**
         * Creates a new NodeAddressForClients instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {proto.INodeAddressForClients=} [properties] Properties to set
         * @returns {proto.NodeAddressForClients} NodeAddressForClients instance
         */
        NodeAddressForClients.create = function create(properties) {
            return new NodeAddressForClients(properties);
        };

        /**
         * Encodes the specified NodeAddressForClients message. Does not implicitly {@link proto.NodeAddressForClients.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {proto.INodeAddressForClients} message NodeAddressForClients message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddressForClients.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.nodeId);
            if (message.nodeAccountId != null && Object.hasOwnProperty.call(message, "nodeAccountId"))
                $root.proto.AccountID.encode(message.nodeAccountId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.nodeCertHash != null && Object.hasOwnProperty.call(message, "nodeCertHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.nodeCertHash);
            if (message.nodeEndpoint != null && message.nodeEndpoint.length)
                for (var i = 0; i < message.nodeEndpoint.length; ++i)
                    $root.proto.NodeEndpoint.encode(message.nodeEndpoint[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeAddressForClients message, length delimited. Does not implicitly {@link proto.NodeAddressForClients.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {proto.INodeAddressForClients} message NodeAddressForClients message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddressForClients.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeAddressForClients message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.NodeAddressForClients} NodeAddressForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddressForClients.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.NodeAddressForClients();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.nodeId = reader.int64();
                    break;
                case 6:
                    message.nodeAccountId = $root.proto.AccountID.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.nodeCertHash = reader.bytes();
                    break;
                case 8:
                    if (!(message.nodeEndpoint && message.nodeEndpoint.length))
                        message.nodeEndpoint = [];
                    message.nodeEndpoint.push($root.proto.NodeEndpoint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeAddressForClients message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.NodeAddressForClients} NodeAddressForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddressForClients.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeAddressForClients message.
         * @function verify
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeAddressForClients.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
                    return "nodeId: integer|Long expected";
            if (message.nodeAccountId != null && message.hasOwnProperty("nodeAccountId")) {
                var error = $root.proto.AccountID.verify(message.nodeAccountId);
                if (error)
                    return "nodeAccountId." + error;
            }
            if (message.nodeCertHash != null && message.hasOwnProperty("nodeCertHash"))
                if (!(message.nodeCertHash && typeof message.nodeCertHash.length === "number" || $util.isString(message.nodeCertHash)))
                    return "nodeCertHash: buffer expected";
            if (message.nodeEndpoint != null && message.hasOwnProperty("nodeEndpoint")) {
                if (!Array.isArray(message.nodeEndpoint))
                    return "nodeEndpoint: array expected";
                for (var i = 0; i < message.nodeEndpoint.length; ++i) {
                    var error = $root.proto.NodeEndpoint.verify(message.nodeEndpoint[i]);
                    if (error)
                        return "nodeEndpoint." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeAddressForClients message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.NodeAddressForClients} NodeAddressForClients
         */
        NodeAddressForClients.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.NodeAddressForClients)
                return object;
            var message = new $root.proto.NodeAddressForClients();
            if (object.nodeId != null)
                if ($util.Long)
                    (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
                else if (typeof object.nodeId === "string")
                    message.nodeId = parseInt(object.nodeId, 10);
                else if (typeof object.nodeId === "number")
                    message.nodeId = object.nodeId;
                else if (typeof object.nodeId === "object")
                    message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber();
            if (object.nodeAccountId != null) {
                if (typeof object.nodeAccountId !== "object")
                    throw TypeError(".proto.NodeAddressForClients.nodeAccountId: object expected");
                message.nodeAccountId = $root.proto.AccountID.fromObject(object.nodeAccountId);
            }
            if (object.nodeCertHash != null)
                if (typeof object.nodeCertHash === "string")
                    $util.base64.decode(object.nodeCertHash, message.nodeCertHash = $util.newBuffer($util.base64.length(object.nodeCertHash)), 0);
                else if (object.nodeCertHash.length)
                    message.nodeCertHash = object.nodeCertHash;
            if (object.nodeEndpoint) {
                if (!Array.isArray(object.nodeEndpoint))
                    throw TypeError(".proto.NodeAddressForClients.nodeEndpoint: array expected");
                message.nodeEndpoint = [];
                for (var i = 0; i < object.nodeEndpoint.length; ++i) {
                    if (typeof object.nodeEndpoint[i] !== "object")
                        throw TypeError(".proto.NodeAddressForClients.nodeEndpoint: object expected");
                    message.nodeEndpoint[i] = $root.proto.NodeEndpoint.fromObject(object.nodeEndpoint[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeAddressForClients message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.NodeAddressForClients
         * @static
         * @param {proto.NodeAddressForClients} message NodeAddressForClients
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeAddressForClients.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nodeEndpoint = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nodeId = options.longs === String ? "0" : 0;
                object.nodeAccountId = null;
                if (options.bytes === String)
                    object.nodeCertHash = "";
                else {
                    object.nodeCertHash = [];
                    if (options.bytes !== Array)
                        object.nodeCertHash = $util.newBuffer(object.nodeCertHash);
                }
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (typeof message.nodeId === "number")
                    object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
                else
                    object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber() : message.nodeId;
            if (message.nodeAccountId != null && message.hasOwnProperty("nodeAccountId"))
                object.nodeAccountId = $root.proto.AccountID.toObject(message.nodeAccountId, options);
            if (message.nodeCertHash != null && message.hasOwnProperty("nodeCertHash"))
                object.nodeCertHash = options.bytes === String ? $util.base64.encode(message.nodeCertHash, 0, message.nodeCertHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodeCertHash) : message.nodeCertHash;
            if (message.nodeEndpoint && message.nodeEndpoint.length) {
                object.nodeEndpoint = [];
                for (var j = 0; j < message.nodeEndpoint.length; ++j)
                    object.nodeEndpoint[j] = $root.proto.NodeEndpoint.toObject(message.nodeEndpoint[j], options);
            }
            return object;
        };

        /**
         * Converts this NodeAddressForClients to JSON.
         * @function toJSON
         * @memberof proto.NodeAddressForClients
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeAddressForClients.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeAddressForClients;
    })();

    proto.AddressBookForClients = (function() {

        /**
         * Properties of an AddressBookForClients.
         * @memberof proto
         * @interface IAddressBookForClients
         * @property {Array.<proto.INodeAddressForClients>|null} [nodeAddressForClients] AddressBookForClients nodeAddressForClients
         */

        /**
         * Constructs a new AddressBookForClients.
         * @memberof proto
         * @classdesc Represents an AddressBookForClients.
         * @implements IAddressBookForClients
         * @constructor
         * @param {proto.IAddressBookForClients=} [properties] Properties to set
         */
        function AddressBookForClients(properties) {
            this.nodeAddressForClients = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddressBookForClients nodeAddressForClients.
         * @member {Array.<proto.INodeAddressForClients>} nodeAddressForClients
         * @memberof proto.AddressBookForClients
         * @instance
         */
        AddressBookForClients.prototype.nodeAddressForClients = $util.emptyArray;

        /**
         * Creates a new AddressBookForClients instance using the specified properties.
         * @function create
         * @memberof proto.AddressBookForClients
         * @static
         * @param {proto.IAddressBookForClients=} [properties] Properties to set
         * @returns {proto.AddressBookForClients} AddressBookForClients instance
         */
        AddressBookForClients.create = function create(properties) {
            return new AddressBookForClients(properties);
        };

        /**
         * Encodes the specified AddressBookForClients message. Does not implicitly {@link proto.AddressBookForClients.verify|verify} messages.
         * @function encode
         * @memberof proto.AddressBookForClients
         * @static
         * @param {proto.IAddressBookForClients} message AddressBookForClients message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddressBookForClients.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeAddressForClients != null && message.nodeAddressForClients.length)
                for (var i = 0; i < message.nodeAddressForClients.length; ++i)
                    $root.proto.NodeAddressForClients.encode(message.nodeAddressForClients[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddressBookForClients message, length delimited. Does not implicitly {@link proto.AddressBookForClients.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AddressBookForClients
         * @static
         * @param {proto.IAddressBookForClients} message AddressBookForClients message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddressBookForClients.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddressBookForClients message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AddressBookForClients
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AddressBookForClients} AddressBookForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddressBookForClients.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AddressBookForClients();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodeAddressForClients && message.nodeAddressForClients.length))
                        message.nodeAddressForClients = [];
                    message.nodeAddressForClients.push($root.proto.NodeAddressForClients.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddressBookForClients message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AddressBookForClients
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AddressBookForClients} AddressBookForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddressBookForClients.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddressBookForClients message.
         * @function verify
         * @memberof proto.AddressBookForClients
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddressBookForClients.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeAddressForClients != null && message.hasOwnProperty("nodeAddressForClients")) {
                if (!Array.isArray(message.nodeAddressForClients))
                    return "nodeAddressForClients: array expected";
                for (var i = 0; i < message.nodeAddressForClients.length; ++i) {
                    var error = $root.proto.NodeAddressForClients.verify(message.nodeAddressForClients[i]);
                    if (error)
                        return "nodeAddressForClients." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AddressBookForClients message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AddressBookForClients
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AddressBookForClients} AddressBookForClients
         */
        AddressBookForClients.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AddressBookForClients)
                return object;
            var message = new $root.proto.AddressBookForClients();
            if (object.nodeAddressForClients) {
                if (!Array.isArray(object.nodeAddressForClients))
                    throw TypeError(".proto.AddressBookForClients.nodeAddressForClients: array expected");
                message.nodeAddressForClients = [];
                for (var i = 0; i < object.nodeAddressForClients.length; ++i) {
                    if (typeof object.nodeAddressForClients[i] !== "object")
                        throw TypeError(".proto.AddressBookForClients.nodeAddressForClients: object expected");
                    message.nodeAddressForClients[i] = $root.proto.NodeAddressForClients.fromObject(object.nodeAddressForClients[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AddressBookForClients message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AddressBookForClients
         * @static
         * @param {proto.AddressBookForClients} message AddressBookForClients
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddressBookForClients.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nodeAddressForClients = [];
            if (message.nodeAddressForClients && message.nodeAddressForClients.length) {
                object.nodeAddressForClients = [];
                for (var j = 0; j < message.nodeAddressForClients.length; ++j)
                    object.nodeAddressForClients[j] = $root.proto.NodeAddressForClients.toObject(message.nodeAddressForClients[j], options);
            }
            return object;
        };

        /**
         * Converts this AddressBookForClients to JSON.
         * @function toJSON
         * @memberof proto.AddressBookForClients
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddressBookForClients.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddressBookForClients;
    })();

    proto.SemanticVersion = (function() {

        /**
         * Properties of a SemanticVersion.
         * @memberof proto
         * @interface ISemanticVersion
         * @property {number|null} [major] SemanticVersion major
         * @property {number|null} [minor] SemanticVersion minor
         * @property {number|null} [patch] SemanticVersion patch
         */

        /**
         * Constructs a new SemanticVersion.
         * @memberof proto
         * @classdesc Represents a SemanticVersion.
         * @implements ISemanticVersion
         * @constructor
         * @param {proto.ISemanticVersion=} [properties] Properties to set
         */
        function SemanticVersion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SemanticVersion major.
         * @member {number} major
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.major = 0;

        /**
         * SemanticVersion minor.
         * @member {number} minor
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.minor = 0;

        /**
         * SemanticVersion patch.
         * @member {number} patch
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.patch = 0;

        /**
         * Creates a new SemanticVersion instance using the specified properties.
         * @function create
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion=} [properties] Properties to set
         * @returns {proto.SemanticVersion} SemanticVersion instance
         */
        SemanticVersion.create = function create(properties) {
            return new SemanticVersion(properties);
        };

        /**
         * Encodes the specified SemanticVersion message. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @function encode
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion} message SemanticVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SemanticVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.major != null && Object.hasOwnProperty.call(message, "major"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.major);
            if (message.minor != null && Object.hasOwnProperty.call(message, "minor"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minor);
            if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.patch);
            return writer;
        };

        /**
         * Encodes the specified SemanticVersion message, length delimited. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion} message SemanticVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SemanticVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SemanticVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SemanticVersion} SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SemanticVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SemanticVersion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.major = reader.int32();
                    break;
                case 2:
                    message.minor = reader.int32();
                    break;
                case 3:
                    message.patch = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SemanticVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SemanticVersion} SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SemanticVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SemanticVersion message.
         * @function verify
         * @memberof proto.SemanticVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SemanticVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.major != null && message.hasOwnProperty("major"))
                if (!$util.isInteger(message.major))
                    return "major: integer expected";
            if (message.minor != null && message.hasOwnProperty("minor"))
                if (!$util.isInteger(message.minor))
                    return "minor: integer expected";
            if (message.patch != null && message.hasOwnProperty("patch"))
                if (!$util.isInteger(message.patch))
                    return "patch: integer expected";
            return null;
        };

        /**
         * Creates a SemanticVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SemanticVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SemanticVersion} SemanticVersion
         */
        SemanticVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SemanticVersion)
                return object;
            var message = new $root.proto.SemanticVersion();
            if (object.major != null)
                message.major = object.major | 0;
            if (object.minor != null)
                message.minor = object.minor | 0;
            if (object.patch != null)
                message.patch = object.patch | 0;
            return message;
        };

        /**
         * Creates a plain object from a SemanticVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.SemanticVersion} message SemanticVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SemanticVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.major = 0;
                object.minor = 0;
                object.patch = 0;
            }
            if (message.major != null && message.hasOwnProperty("major"))
                object.major = message.major;
            if (message.minor != null && message.hasOwnProperty("minor"))
                object.minor = message.minor;
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = message.patch;
            return object;
        };

        /**
         * Converts this SemanticVersion to JSON.
         * @function toJSON
         * @memberof proto.SemanticVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SemanticVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SemanticVersion;
    })();

    proto.Setting = (function() {

        /**
         * Properties of a Setting.
         * @memberof proto
         * @interface ISetting
         * @property {string|null} [name] Setting name
         * @property {string|null} [value] Setting value
         * @property {Uint8Array|null} [data] Setting data
         */

        /**
         * Constructs a new Setting.
         * @memberof proto
         * @classdesc Represents a Setting.
         * @implements ISetting
         * @constructor
         * @param {proto.ISetting=} [properties] Properties to set
         */
        function Setting(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Setting name.
         * @member {string} name
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.name = "";

        /**
         * Setting value.
         * @member {string} value
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.value = "";

        /**
         * Setting data.
         * @member {Uint8Array} data
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Setting instance using the specified properties.
         * @function create
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting=} [properties] Properties to set
         * @returns {proto.Setting} Setting instance
         */
        Setting.create = function create(properties) {
            return new Setting(properties);
        };

        /**
         * Encodes the specified Setting message. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @function encode
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting} message Setting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Setting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Setting message, length delimited. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting} message Setting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Setting.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Setting();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Setting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Setting message.
         * @function verify
         * @memberof proto.Setting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Setting.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a Setting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Setting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Setting} Setting
         */
        Setting.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Setting)
                return object;
            var message = new $root.proto.Setting();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a Setting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Setting
         * @static
         * @param {proto.Setting} message Setting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Setting.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Setting to JSON.
         * @function toJSON
         * @memberof proto.Setting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Setting.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Setting;
    })();

    proto.ServicesConfigurationList = (function() {

        /**
         * Properties of a ServicesConfigurationList.
         * @memberof proto
         * @interface IServicesConfigurationList
         * @property {Array.<proto.ISetting>|null} [nameValue] ServicesConfigurationList nameValue
         */

        /**
         * Constructs a new ServicesConfigurationList.
         * @memberof proto
         * @classdesc Represents a ServicesConfigurationList.
         * @implements IServicesConfigurationList
         * @constructor
         * @param {proto.IServicesConfigurationList=} [properties] Properties to set
         */
        function ServicesConfigurationList(properties) {
            this.nameValue = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServicesConfigurationList nameValue.
         * @member {Array.<proto.ISetting>} nameValue
         * @memberof proto.ServicesConfigurationList
         * @instance
         */
        ServicesConfigurationList.prototype.nameValue = $util.emptyArray;

        /**
         * Creates a new ServicesConfigurationList instance using the specified properties.
         * @function create
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList=} [properties] Properties to set
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList instance
         */
        ServicesConfigurationList.create = function create(properties) {
            return new ServicesConfigurationList(properties);
        };

        /**
         * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @function encode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList} message ServicesConfigurationList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServicesConfigurationList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nameValue != null && message.nameValue.length)
                for (var i = 0; i < message.nameValue.length; ++i)
                    $root.proto.Setting.encode(message.nameValue[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServicesConfigurationList message, length delimited. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList} message ServicesConfigurationList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServicesConfigurationList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServicesConfigurationList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ServicesConfigurationList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nameValue && message.nameValue.length))
                        message.nameValue = [];
                    message.nameValue.push($root.proto.Setting.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServicesConfigurationList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServicesConfigurationList message.
         * @function verify
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServicesConfigurationList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nameValue != null && message.hasOwnProperty("nameValue")) {
                if (!Array.isArray(message.nameValue))
                    return "nameValue: array expected";
                for (var i = 0; i < message.nameValue.length; ++i) {
                    var error = $root.proto.Setting.verify(message.nameValue[i]);
                    if (error)
                        return "nameValue." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServicesConfigurationList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
         */
        ServicesConfigurationList.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ServicesConfigurationList)
                return object;
            var message = new $root.proto.ServicesConfigurationList();
            if (object.nameValue) {
                if (!Array.isArray(object.nameValue))
                    throw TypeError(".proto.ServicesConfigurationList.nameValue: array expected");
                message.nameValue = [];
                for (var i = 0; i < object.nameValue.length; ++i) {
                    if (typeof object.nameValue[i] !== "object")
                        throw TypeError(".proto.ServicesConfigurationList.nameValue: object expected");
                    message.nameValue[i] = $root.proto.Setting.fromObject(object.nameValue[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServicesConfigurationList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.ServicesConfigurationList} message ServicesConfigurationList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServicesConfigurationList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nameValue = [];
            if (message.nameValue && message.nameValue.length) {
                object.nameValue = [];
                for (var j = 0; j < message.nameValue.length; ++j)
                    object.nameValue[j] = $root.proto.Setting.toObject(message.nameValue[j], options);
            }
            return object;
        };

        /**
         * Converts this ServicesConfigurationList to JSON.
         * @function toJSON
         * @memberof proto.ServicesConfigurationList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServicesConfigurationList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServicesConfigurationList;
    })();

    proto.TokenRelationship = (function() {

        /**
         * Properties of a TokenRelationship.
         * @memberof proto
         * @interface ITokenRelationship
         * @property {proto.ITokenID|null} [tokenId] TokenRelationship tokenId
         * @property {string|null} [symbol] TokenRelationship symbol
         * @property {number|Long|null} [balance] TokenRelationship balance
         * @property {proto.TokenKycStatus|null} [kycStatus] TokenRelationship kycStatus
         * @property {proto.TokenFreezeStatus|null} [freezeStatus] TokenRelationship freezeStatus
         * @property {number|null} [decimals] TokenRelationship decimals
         */

        /**
         * Constructs a new TokenRelationship.
         * @memberof proto
         * @classdesc Represents a TokenRelationship.
         * @implements ITokenRelationship
         * @constructor
         * @param {proto.ITokenRelationship=} [properties] Properties to set
         */
        function TokenRelationship(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenRelationship tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.tokenId = null;

        /**
         * TokenRelationship symbol.
         * @member {string} symbol
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.symbol = "";

        /**
         * TokenRelationship balance.
         * @member {number|Long} balance
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenRelationship kycStatus.
         * @member {proto.TokenKycStatus} kycStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.kycStatus = 0;

        /**
         * TokenRelationship freezeStatus.
         * @member {proto.TokenFreezeStatus} freezeStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.freezeStatus = 0;

        /**
         * TokenRelationship decimals.
         * @member {number} decimals
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.decimals = 0;

        /**
         * Creates a new TokenRelationship instance using the specified properties.
         * @function create
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship=} [properties] Properties to set
         * @returns {proto.TokenRelationship} TokenRelationship instance
         */
        TokenRelationship.create = function create(properties) {
            return new TokenRelationship(properties);
        };

        /**
         * Encodes the specified TokenRelationship message. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship} message TokenRelationship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRelationship.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                $root.proto.TokenID.encode(message.tokenId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
            if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.balance);
            if (message.kycStatus != null && Object.hasOwnProperty.call(message, "kycStatus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.kycStatus);
            if (message.freezeStatus != null && Object.hasOwnProperty.call(message, "freezeStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.freezeStatus);
            if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.decimals);
            return writer;
        };

        /**
         * Encodes the specified TokenRelationship message, length delimited. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship} message TokenRelationship message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRelationship.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRelationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TokenRelationship} TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRelationship.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TokenRelationship();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tokenId = $root.proto.TokenID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.symbol = reader.string();
                    break;
                case 3:
                    message.balance = reader.uint64();
                    break;
                case 4:
                    message.kycStatus = reader.int32();
                    break;
                case 5:
                    message.freezeStatus = reader.int32();
                    break;
                case 6:
                    message.decimals = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TokenRelationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TokenRelationship} TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRelationship.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenRelationship message.
         * @function verify
         * @memberof proto.TokenRelationship
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenRelationship.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId")) {
                var error = $root.proto.TokenID.verify(message.tokenId);
                if (error)
                    return "tokenId." + error;
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.kycStatus != null && message.hasOwnProperty("kycStatus"))
                switch (message.kycStatus) {
                default:
                    return "kycStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.freezeStatus != null && message.hasOwnProperty("freezeStatus"))
                switch (message.freezeStatus) {
                default:
                    return "freezeStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                if (!$util.isInteger(message.decimals))
                    return "decimals: integer expected";
            return null;
        };

        /**
         * Creates a TokenRelationship message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TokenRelationship
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TokenRelationship} TokenRelationship
         */
        TokenRelationship.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TokenRelationship)
                return object;
            var message = new $root.proto.TokenRelationship();
            if (object.tokenId != null) {
                if (typeof object.tokenId !== "object")
                    throw TypeError(".proto.TokenRelationship.tokenId: object expected");
                message.tokenId = $root.proto.TokenID.fromObject(object.tokenId);
            }
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
            switch (object.kycStatus) {
            case "KycNotApplicable":
            case 0:
                message.kycStatus = 0;
                break;
            case "Granted":
            case 1:
                message.kycStatus = 1;
                break;
            case "Revoked":
            case 2:
                message.kycStatus = 2;
                break;
            }
            switch (object.freezeStatus) {
            case "FreezeNotApplicable":
            case 0:
                message.freezeStatus = 0;
                break;
            case "Frozen":
            case 1:
                message.freezeStatus = 1;
                break;
            case "Unfrozen":
            case 2:
                message.freezeStatus = 2;
                break;
            }
            if (object.decimals != null)
                message.decimals = object.decimals >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TokenRelationship message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.TokenRelationship} message TokenRelationship
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenRelationship.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tokenId = null;
                object.symbol = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                object.kycStatus = options.enums === String ? "KycNotApplicable" : 0;
                object.freezeStatus = options.enums === String ? "FreezeNotApplicable" : 0;
                object.decimals = 0;
            }
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = $root.proto.TokenID.toObject(message.tokenId, options);
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
            if (message.kycStatus != null && message.hasOwnProperty("kycStatus"))
                object.kycStatus = options.enums === String ? $root.proto.TokenKycStatus[message.kycStatus] : message.kycStatus;
            if (message.freezeStatus != null && message.hasOwnProperty("freezeStatus"))
                object.freezeStatus = options.enums === String ? $root.proto.TokenFreezeStatus[message.freezeStatus] : message.freezeStatus;
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                object.decimals = message.decimals;
            return object;
        };

        /**
         * Converts this TokenRelationship to JSON.
         * @function toJSON
         * @memberof proto.TokenRelationship
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenRelationship.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenRelationship;
    })();

    proto.TokenBalance = (function() {

        /**
         * Properties of a TokenBalance.
         * @memberof proto
         * @interface ITokenBalance
         * @property {proto.ITokenID|null} [tokenId] TokenBalance tokenId
         * @property {number|Long|null} [balance] TokenBalance balance
         * @property {number|null} [decimals] TokenBalance decimals
         */

        /**
         * Constructs a new TokenBalance.
         * @memberof proto
         * @classdesc Represents a TokenBalance.
         * @implements ITokenBalance
         * @constructor
         * @param {proto.ITokenBalance=} [properties] Properties to set
         */
        function TokenBalance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenBalance tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.tokenId = null;

        /**
         * TokenBalance balance.
         * @member {number|Long} balance
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenBalance decimals.
         * @member {number} decimals
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.decimals = 0;

        /**
         * Creates a new TokenBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance=} [properties] Properties to set
         * @returns {proto.TokenBalance} TokenBalance instance
         */
        TokenBalance.create = function create(properties) {
            return new TokenBalance(properties);
        };

        /**
         * Encodes the specified TokenBalance message. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance} message TokenBalance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                $root.proto.TokenID.encode(message.tokenId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.balance);
            if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.decimals);
            return writer;
        };

        /**
         * Encodes the specified TokenBalance message, length delimited. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance} message TokenBalance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TokenBalance} TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TokenBalance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tokenId = $root.proto.TokenID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.balance = reader.uint64();
                    break;
                case 3:
                    message.decimals = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenBalance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TokenBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TokenBalance} TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenBalance message.
         * @function verify
         * @memberof proto.TokenBalance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenBalance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId")) {
                var error = $root.proto.TokenID.verify(message.tokenId);
                if (error)
                    return "tokenId." + error;
            }
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                if (!$util.isInteger(message.decimals))
                    return "decimals: integer expected";
            return null;
        };

        /**
         * Creates a TokenBalance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TokenBalance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TokenBalance} TokenBalance
         */
        TokenBalance.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TokenBalance)
                return object;
            var message = new $root.proto.TokenBalance();
            if (object.tokenId != null) {
                if (typeof object.tokenId !== "object")
                    throw TypeError(".proto.TokenBalance.tokenId: object expected");
                message.tokenId = $root.proto.TokenID.fromObject(object.tokenId);
            }
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
            if (object.decimals != null)
                message.decimals = object.decimals >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TokenBalance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.TokenBalance} message TokenBalance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenBalance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tokenId = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                object.decimals = 0;
            }
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = $root.proto.TokenID.toObject(message.tokenId, options);
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                object.decimals = message.decimals;
            return object;
        };

        /**
         * Converts this TokenBalance to JSON.
         * @function toJSON
         * @memberof proto.TokenBalance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenBalance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenBalance;
    })();

    proto.TokenBalances = (function() {

        /**
         * Properties of a TokenBalances.
         * @memberof proto
         * @interface ITokenBalances
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] TokenBalances tokenBalances
         */

        /**
         * Constructs a new TokenBalances.
         * @memberof proto
         * @classdesc Represents a TokenBalances.
         * @implements ITokenBalances
         * @constructor
         * @param {proto.ITokenBalances=} [properties] Properties to set
         */
        function TokenBalances(properties) {
            this.tokenBalances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenBalances tokenBalances.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.TokenBalances
         * @instance
         */
        TokenBalances.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new TokenBalances instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances=} [properties] Properties to set
         * @returns {proto.TokenBalances} TokenBalances instance
         */
        TokenBalances.create = function create(properties) {
            return new TokenBalances(properties);
        };

        /**
         * Encodes the specified TokenBalances message. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances} message TokenBalances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalances.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tokenBalances != null && message.tokenBalances.length)
                for (var i = 0; i < message.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(message.tokenBalances[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TokenBalances message, length delimited. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances} message TokenBalances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalances.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TokenBalances} TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalances.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TokenBalances();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tokenBalances && message.tokenBalances.length))
                        message.tokenBalances = [];
                    message.tokenBalances.push($root.proto.TokenBalance.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenBalances message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TokenBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TokenBalances} TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalances.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenBalances message.
         * @function verify
         * @memberof proto.TokenBalances
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenBalances.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tokenBalances != null && message.hasOwnProperty("tokenBalances")) {
                if (!Array.isArray(message.tokenBalances))
                    return "tokenBalances: array expected";
                for (var i = 0; i < message.tokenBalances.length; ++i) {
                    var error = $root.proto.TokenBalance.verify(message.tokenBalances[i]);
                    if (error)
                        return "tokenBalances." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TokenBalances message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TokenBalances
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TokenBalances} TokenBalances
         */
        TokenBalances.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TokenBalances)
                return object;
            var message = new $root.proto.TokenBalances();
            if (object.tokenBalances) {
                if (!Array.isArray(object.tokenBalances))
                    throw TypeError(".proto.TokenBalances.tokenBalances: array expected");
                message.tokenBalances = [];
                for (var i = 0; i < object.tokenBalances.length; ++i) {
                    if (typeof object.tokenBalances[i] !== "object")
                        throw TypeError(".proto.TokenBalances.tokenBalances: object expected");
                    message.tokenBalances[i] = $root.proto.TokenBalance.fromObject(object.tokenBalances[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TokenBalances message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.TokenBalances} message TokenBalances
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenBalances.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tokenBalances = [];
            if (message.tokenBalances && message.tokenBalances.length) {
                object.tokenBalances = [];
                for (var j = 0; j < message.tokenBalances.length; ++j)
                    object.tokenBalances[j] = $root.proto.TokenBalance.toObject(message.tokenBalances[j], options);
            }
            return object;
        };

        /**
         * Converts this TokenBalances to JSON.
         * @function toJSON
         * @memberof proto.TokenBalances
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenBalances.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenBalances;
    })();

    proto.Duration = (function() {

        /**
         * Properties of a Duration.
         * @memberof proto
         * @interface IDuration
         * @property {number|Long|null} [seconds] Duration seconds
         */

        /**
         * Constructs a new Duration.
         * @memberof proto
         * @classdesc Represents a Duration.
         * @implements IDuration
         * @constructor
         * @param {proto.IDuration=} [properties] Properties to set
         */
        function Duration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Duration seconds.
         * @member {number|Long} seconds
         * @memberof proto.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Duration instance using the specified properties.
         * @function create
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration=} [properties] Properties to set
         * @returns {proto.Duration} Duration instance
         */
        Duration.create = function create(properties) {
            return new Duration(properties);
        };

        /**
         * Encodes the specified Duration message. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @function encode
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
            return writer;
        };

        /**
         * Encodes the specified Duration message, length delimited. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Duration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Duration message.
         * @function verify
         * @memberof proto.Duration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Duration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                    return "seconds: integer|Long expected";
            return null;
        };

        /**
         * Creates a Duration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Duration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Duration} Duration
         */
        Duration.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Duration)
                return object;
            var message = new $root.proto.Duration();
            if (object.seconds != null)
                if ($util.Long)
                    (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                else if (typeof object.seconds === "string")
                    message.seconds = parseInt(object.seconds, 10);
                else if (typeof object.seconds === "number")
                    message.seconds = object.seconds;
                else if (typeof object.seconds === "object")
                    message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Duration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Duration
         * @static
         * @param {proto.Duration} message Duration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Duration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds = options.longs === String ? "0" : 0;
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (typeof message.seconds === "number")
                    object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else
                    object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            return object;
        };

        /**
         * Converts this Duration to JSON.
         * @function toJSON
         * @memberof proto.Duration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Duration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Duration;
    })();

    proto.CryptoCreateTransactionBody = (function() {

        /**
         * Properties of a CryptoCreateTransactionBody.
         * @memberof proto
         * @interface ICryptoCreateTransactionBody
         * @property {proto.IKey|null} [key] CryptoCreateTransactionBody key
         * @property {number|Long|null} [initialBalance] CryptoCreateTransactionBody initialBalance
         * @property {proto.IAccountID|null} [proxyAccountID] CryptoCreateTransactionBody proxyAccountID
         * @property {number|Long|null} [sendRecordThreshold] CryptoCreateTransactionBody sendRecordThreshold
         * @property {number|Long|null} [receiveRecordThreshold] CryptoCreateTransactionBody receiveRecordThreshold
         * @property {boolean|null} [receiverSigRequired] CryptoCreateTransactionBody receiverSigRequired
         * @property {proto.IDuration|null} [autoRenewPeriod] CryptoCreateTransactionBody autoRenewPeriod
         * @property {proto.IShardID|null} [shardID] CryptoCreateTransactionBody shardID
         * @property {proto.IRealmID|null} [realmID] CryptoCreateTransactionBody realmID
         * @property {proto.IKey|null} [newRealmAdminKey] CryptoCreateTransactionBody newRealmAdminKey
         * @property {string|null} [memo] CryptoCreateTransactionBody memo
         */

        /**
         * Constructs a new CryptoCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoCreateTransactionBody.
         * @implements ICryptoCreateTransactionBody
         * @constructor
         * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
         */
        function CryptoCreateTransactionBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CryptoCreateTransactionBody key.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.key = null;

        /**
         * CryptoCreateTransactionBody initialBalance.
         * @member {number|Long} initialBalance
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoCreateTransactionBody proxyAccountID.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * CryptoCreateTransactionBody sendRecordThreshold.
         * @member {number|Long} sendRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoCreateTransactionBody receiveRecordThreshold.
         * @member {number|Long} receiveRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoCreateTransactionBody receiverSigRequired.
         * @member {boolean} receiverSigRequired
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiverSigRequired = false;

        /**
         * CryptoCreateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * CryptoCreateTransactionBody shardID.
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.shardID = null;

        /**
         * CryptoCreateTransactionBody realmID.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.realmID = null;

        /**
         * CryptoCreateTransactionBody newRealmAdminKey.
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * CryptoCreateTransactionBody memo.
         * @member {string} memo
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.memo = "";

        /**
         * Creates a new CryptoCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody instance
         */
        CryptoCreateTransactionBody.create = function create(properties) {
            return new CryptoCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody} message CryptoCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoCreateTransactionBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.proto.Key.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.initialBalance != null && Object.hasOwnProperty.call(message, "initialBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.initialBalance);
            if (message.proxyAccountID != null && Object.hasOwnProperty.call(message, "proxyAccountID"))
                $root.proto.AccountID.encode(message.proxyAccountID, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sendRecordThreshold != null && Object.hasOwnProperty.call(message, "sendRecordThreshold"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.sendRecordThreshold);
            if (message.receiveRecordThreshold != null && Object.hasOwnProperty.call(message, "receiveRecordThreshold"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.receiveRecordThreshold);
            if (message.receiverSigRequired != null && Object.hasOwnProperty.call(message, "receiverSigRequired"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.receiverSigRequired);
            if (message.autoRenewPeriod != null && Object.hasOwnProperty.call(message, "autoRenewPeriod"))
                $root.proto.Duration.encode(message.autoRenewPeriod, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.shardID != null && Object.hasOwnProperty.call(message, "shardID"))
                $root.proto.ShardID.encode(message.shardID, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.realmID != null && Object.hasOwnProperty.call(message, "realmID"))
                $root.proto.RealmID.encode(message.realmID, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.newRealmAdminKey != null && Object.hasOwnProperty.call(message, "newRealmAdminKey"))
                $root.proto.Key.encode(message.newRealmAdminKey, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CryptoCreateTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody} message CryptoCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoCreateTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoCreateTransactionBody.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoCreateTransactionBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.proto.Key.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.initialBalance = reader.uint64();
                    break;
                case 3:
                    message.proxyAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.sendRecordThreshold = reader.uint64();
                    break;
                case 7:
                    message.receiveRecordThreshold = reader.uint64();
                    break;
                case 8:
                    message.receiverSigRequired = reader.bool();
                    break;
                case 9:
                    message.autoRenewPeriod = $root.proto.Duration.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.shardID = $root.proto.ShardID.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.realmID = $root.proto.RealmID.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.newRealmAdminKey = $root.proto.Key.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoCreateTransactionBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CryptoCreateTransactionBody message.
         * @function verify
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CryptoCreateTransactionBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.proto.Key.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.initialBalance != null && message.hasOwnProperty("initialBalance"))
                if (!$util.isInteger(message.initialBalance) && !(message.initialBalance && $util.isInteger(message.initialBalance.low) && $util.isInteger(message.initialBalance.high)))
                    return "initialBalance: integer|Long expected";
            if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID")) {
                var error = $root.proto.AccountID.verify(message.proxyAccountID);
                if (error)
                    return "proxyAccountID." + error;
            }
            if (message.sendRecordThreshold != null && message.hasOwnProperty("sendRecordThreshold"))
                if (!$util.isInteger(message.sendRecordThreshold) && !(message.sendRecordThreshold && $util.isInteger(message.sendRecordThreshold.low) && $util.isInteger(message.sendRecordThreshold.high)))
                    return "sendRecordThreshold: integer|Long expected";
            if (message.receiveRecordThreshold != null && message.hasOwnProperty("receiveRecordThreshold"))
                if (!$util.isInteger(message.receiveRecordThreshold) && !(message.receiveRecordThreshold && $util.isInteger(message.receiveRecordThreshold.low) && $util.isInteger(message.receiveRecordThreshold.high)))
                    return "receiveRecordThreshold: integer|Long expected";
            if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired"))
                if (typeof message.receiverSigRequired !== "boolean")
                    return "receiverSigRequired: boolean expected";
            if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod")) {
                var error = $root.proto.Duration.verify(message.autoRenewPeriod);
                if (error)
                    return "autoRenewPeriod." + error;
            }
            if (message.shardID != null && message.hasOwnProperty("shardID")) {
                var error = $root.proto.ShardID.verify(message.shardID);
                if (error)
                    return "shardID." + error;
            }
            if (message.realmID != null && message.hasOwnProperty("realmID")) {
                var error = $root.proto.RealmID.verify(message.realmID);
                if (error)
                    return "realmID." + error;
            }
            if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey")) {
                var error = $root.proto.Key.verify(message.newRealmAdminKey);
                if (error)
                    return "newRealmAdminKey." + error;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CryptoCreateTransactionBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
         */
        CryptoCreateTransactionBody.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.CryptoCreateTransactionBody)
                return object;
            var message = new $root.proto.CryptoCreateTransactionBody();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".proto.CryptoCreateTransactionBody.key: object expected");
                message.key = $root.proto.Key.fromObject(object.key);
            }
            if (object.initialBalance != null)
                if ($util.Long)
                    (message.initialBalance = $util.Long.fromValue(object.initialBalance)).unsigned = true;
                else if (typeof object.initialBalance === "string")
                    message.initialBalance = parseInt(object.initialBalance, 10);
                else if (typeof object.initialBalance === "number")
                    message.initialBalance = object.initialBalance;
                else if (typeof object.initialBalance === "object")
                    message.initialBalance = new $util.LongBits(object.initialBalance.low >>> 0, object.initialBalance.high >>> 0).toNumber(true);
            if (object.proxyAccountID != null) {
                if (typeof object.proxyAccountID !== "object")
                    throw TypeError(".proto.CryptoCreateTransactionBody.proxyAccountID: object expected");
                message.proxyAccountID = $root.proto.AccountID.fromObject(object.proxyAccountID);
            }
            if (object.sendRecordThreshold != null)
                if ($util.Long)
                    (message.sendRecordThreshold = $util.Long.fromValue(object.sendRecordThreshold)).unsigned = true;
                else if (typeof object.sendRecordThreshold === "string")
                    message.sendRecordThreshold = parseInt(object.sendRecordThreshold, 10);
                else if (typeof object.sendRecordThreshold === "number")
                    message.sendRecordThreshold = object.sendRecordThreshold;
                else if (typeof object.sendRecordThreshold === "object")
                    message.sendRecordThreshold = new $util.LongBits(object.sendRecordThreshold.low >>> 0, object.sendRecordThreshold.high >>> 0).toNumber(true);
            if (object.receiveRecordThreshold != null)
                if ($util.Long)
                    (message.receiveRecordThreshold = $util.Long.fromValue(object.receiveRecordThreshold)).unsigned = true;
                else if (typeof object.receiveRecordThreshold === "string")
                    message.receiveRecordThreshold = parseInt(object.receiveRecordThreshold, 10);
                else if (typeof object.receiveRecordThreshold === "number")
                    message.receiveRecordThreshold = object.receiveRecordThreshold;
                else if (typeof object.receiveRecordThreshold === "object")
                    message.receiveRecordThreshold = new $util.LongBits(object.receiveRecordThreshold.low >>> 0, object.receiveRecordThreshold.high >>> 0).toNumber(true);
            if (object.receiverSigRequired != null)
                message.receiverSigRequired = Boolean(object.receiverSigRequired);
            if (object.autoRenewPeriod != null) {
                if (typeof object.autoRenewPeriod !== "object")
                    throw TypeError(".proto.CryptoCreateTransactionBody.autoRenewPeriod: object expected");
                message.autoRenewPeriod = $root.proto.Duration.fromObject(object.autoRenewPeriod);
            }
            if (object.shardID != null) {
                if (typeof object.shardID !== "object")
                    throw TypeError(".proto.CryptoCreateTransactionBody.shardID: object expected");
                message.shardID = $root.proto.ShardID.fromObject(object.shardID);
            }
            if (object.realmID != null) {
                if (typeof object.realmID !== "object")
                    throw TypeError(".proto.CryptoCreateTransactionBody.realmID: object expected");
                message.realmID = $root.proto.RealmID.fromObject(object.realmID);
            }
            if (object.newRealmAdminKey != null) {
                if (typeof object.newRealmAdminKey !== "object")
                    throw TypeError(".proto.CryptoCreateTransactionBody.newRealmAdminKey: object expected");
                message.newRealmAdminKey = $root.proto.Key.fromObject(object.newRealmAdminKey);
            }
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CryptoCreateTransactionBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.CryptoCreateTransactionBody} message CryptoCreateTransactionBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CryptoCreateTransactionBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.initialBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.initialBalance = options.longs === String ? "0" : 0;
                object.proxyAccountID = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.sendRecordThreshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sendRecordThreshold = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.receiveRecordThreshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.receiveRecordThreshold = options.longs === String ? "0" : 0;
                object.receiverSigRequired = false;
                object.autoRenewPeriod = null;
                object.shardID = null;
                object.realmID = null;
                object.newRealmAdminKey = null;
                object.memo = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.proto.Key.toObject(message.key, options);
            if (message.initialBalance != null && message.hasOwnProperty("initialBalance"))
                if (typeof message.initialBalance === "number")
                    object.initialBalance = options.longs === String ? String(message.initialBalance) : message.initialBalance;
                else
                    object.initialBalance = options.longs === String ? $util.Long.prototype.toString.call(message.initialBalance) : options.longs === Number ? new $util.LongBits(message.initialBalance.low >>> 0, message.initialBalance.high >>> 0).toNumber(true) : message.initialBalance;
            if (message.proxyAccountID != null && message.hasOwnProperty("proxyAccountID"))
                object.proxyAccountID = $root.proto.AccountID.toObject(message.proxyAccountID, options);
            if (message.sendRecordThreshold != null && message.hasOwnProperty("sendRecordThreshold"))
                if (typeof message.sendRecordThreshold === "number")
                    object.sendRecordThreshold = options.longs === String ? String(message.sendRecordThreshold) : message.sendRecordThreshold;
                else
                    object.sendRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.sendRecordThreshold) : options.longs === Number ? new $util.LongBits(message.sendRecordThreshold.low >>> 0, message.sendRecordThreshold.high >>> 0).toNumber(true) : message.sendRecordThreshold;
            if (message.receiveRecordThreshold != null && message.hasOwnProperty("receiveRecordThreshold"))
                if (typeof message.receiveRecordThreshold === "number")
                    object.receiveRecordThreshold = options.longs === String ? String(message.receiveRecordThreshold) : message.receiveRecordThreshold;
                else
                    object.receiveRecordThreshold = options.longs === String ? $util.Long.prototype.toString.call(message.receiveRecordThreshold) : options.longs === Number ? new $util.LongBits(message.receiveRecordThreshold.low >>> 0, message.receiveRecordThreshold.high >>> 0).toNumber(true) : message.receiveRecordThreshold;
            if (message.receiverSigRequired != null && message.hasOwnProperty("receiverSigRequired"))
                object.receiverSigRequired = message.receiverSigRequired;
            if (message.autoRenewPeriod != null && message.hasOwnProperty("autoRenewPeriod"))
                object.autoRenewPeriod = $root.proto.Duration.toObject(message.autoRenewPeriod, options);
            if (message.shardID != null && message.hasOwnProperty("shardID"))
                object.shardID = $root.proto.ShardID.toObject(message.shardID, options);
            if (message.realmID != null && message.hasOwnProperty("realmID"))
                object.realmID = $root.proto.RealmID.toObject(message.realmID, options);
            if (message.newRealmAdminKey != null && message.hasOwnProperty("newRealmAdminKey"))
                object.newRealmAdminKey = $root.proto.Key.toObject(message.newRealmAdminKey, options);
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CryptoCreateTransactionBody to JSON.
         * @function toJSON
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CryptoCreateTransactionBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CryptoCreateTransactionBody;
    })();

    proto.CryptoTransferTransactionBody = (function() {

        /**
         * Properties of a CryptoTransferTransactionBody.
         * @memberof proto
         * @interface ICryptoTransferTransactionBody
         * @property {proto.ITransferList|null} [transfers] CryptoTransferTransactionBody transfers
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransfers] CryptoTransferTransactionBody tokenTransfers
         */

        /**
         * Constructs a new CryptoTransferTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoTransferTransactionBody.
         * @implements ICryptoTransferTransactionBody
         * @constructor
         * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
         */
        function CryptoTransferTransactionBody(properties) {
            this.tokenTransfers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CryptoTransferTransactionBody transfers.
         * @member {proto.ITransferList|null|undefined} transfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.transfers = null;

        /**
         * CryptoTransferTransactionBody tokenTransfers.
         * @member {Array.<proto.ITokenTransferList>} tokenTransfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.tokenTransfers = $util.emptyArray;

        /**
         * Creates a new CryptoTransferTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody instance
         */
        CryptoTransferTransactionBody.create = function create(properties) {
            return new CryptoTransferTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody} message CryptoTransferTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoTransferTransactionBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transfers != null && Object.hasOwnProperty.call(message, "transfers"))
                $root.proto.TransferList.encode(message.transfers, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tokenTransfers != null && message.tokenTransfers.length)
                for (var i = 0; i < message.tokenTransfers.length; ++i)
                    $root.proto.TokenTransferList.encode(message.tokenTransfers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CryptoTransferTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody} message CryptoTransferTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoTransferTransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoTransferTransactionBody.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.CryptoTransferTransactionBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transfers = $root.proto.TransferList.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.tokenTransfers && message.tokenTransfers.length))
                        message.tokenTransfers = [];
                    message.tokenTransfers.push($root.proto.TokenTransferList.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoTransferTransactionBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CryptoTransferTransactionBody message.
         * @function verify
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CryptoTransferTransactionBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transfers != null && message.hasOwnProperty("transfers")) {
                var error = $root.proto.TransferList.verify(message.transfers);
                if (error)
                    return "transfers." + error;
            }
            if (message.tokenTransfers != null && message.hasOwnProperty("tokenTransfers")) {
                if (!Array.isArray(message.tokenTransfers))
                    return "tokenTransfers: array expected";
                for (var i = 0; i < message.tokenTransfers.length; ++i) {
                    var error = $root.proto.TokenTransferList.verify(message.tokenTransfers[i]);
                    if (error)
                        return "tokenTransfers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CryptoTransferTransactionBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
         */
        CryptoTransferTransactionBody.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.CryptoTransferTransactionBody)
                return object;
            var message = new $root.proto.CryptoTransferTransactionBody();
            if (object.transfers != null) {
                if (typeof object.transfers !== "object")
                    throw TypeError(".proto.CryptoTransferTransactionBody.transfers: object expected");
                message.transfers = $root.proto.TransferList.fromObject(object.transfers);
            }
            if (object.tokenTransfers) {
                if (!Array.isArray(object.tokenTransfers))
                    throw TypeError(".proto.CryptoTransferTransactionBody.tokenTransfers: array expected");
                message.tokenTransfers = [];
                for (var i = 0; i < object.tokenTransfers.length; ++i) {
                    if (typeof object.tokenTransfers[i] !== "object")
                        throw TypeError(".proto.CryptoTransferTransactionBody.tokenTransfers: object expected");
                    message.tokenTransfers[i] = $root.proto.TokenTransferList.fromObject(object.tokenTransfers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CryptoTransferTransactionBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.CryptoTransferTransactionBody} message CryptoTransferTransactionBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CryptoTransferTransactionBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tokenTransfers = [];
            if (options.defaults)
                object.transfers = null;
            if (message.transfers != null && message.hasOwnProperty("transfers"))
                object.transfers = $root.proto.TransferList.toObject(message.transfers, options);
            if (message.tokenTransfers && message.tokenTransfers.length) {
                object.tokenTransfers = [];
                for (var j = 0; j < message.tokenTransfers.length; ++j)
                    object.tokenTransfers[j] = $root.proto.TokenTransferList.toObject(message.tokenTransfers[j], options);
            }
            return object;
        };

        /**
         * Converts this CryptoTransferTransactionBody to JSON.
         * @function toJSON
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CryptoTransferTransactionBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CryptoTransferTransactionBody;
    })();

    proto.TransactionBody = (function() {

        /**
         * Properties of a TransactionBody.
         * @memberof proto
         * @interface ITransactionBody
         * @property {proto.ITransactionID|null} [transactionID] TransactionBody transactionID
         * @property {proto.IAccountID|null} [nodeAccountID] TransactionBody nodeAccountID
         * @property {number|Long|null} [transactionFee] TransactionBody transactionFee
         * @property {proto.IDuration|null} [transactionValidDuration] TransactionBody transactionValidDuration
         * @property {boolean|null} [generateRecord] TransactionBody generateRecord
         * @property {string|null} [memo] TransactionBody memo
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] TransactionBody cryptoCreateAccount
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] TransactionBody cryptoTransfer
         */

        /**
         * Constructs a new TransactionBody.
         * @memberof proto
         * @classdesc Represents a TransactionBody.
         * @implements ITransactionBody
         * @constructor
         * @param {proto.ITransactionBody=} [properties] Properties to set
         */
        function TransactionBody(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionBody transactionID.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionID = null;

        /**
         * TransactionBody nodeAccountID.
         * @member {proto.IAccountID|null|undefined} nodeAccountID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeAccountID = null;

        /**
         * TransactionBody transactionFee.
         * @member {number|Long} transactionFee
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionBody transactionValidDuration.
         * @member {proto.IDuration|null|undefined} transactionValidDuration
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionValidDuration = null;

        /**
         * TransactionBody generateRecord.
         * @member {boolean} generateRecord
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.generateRecord = false;

        /**
         * TransactionBody memo.
         * @member {string} memo
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.memo = "";

        /**
         * TransactionBody cryptoCreateAccount.
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * TransactionBody cryptoTransfer.
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoTransfer = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TransactionBody data.
         * @member {"cryptoCreateAccount"|"cryptoTransfer"|undefined} data
         * @memberof proto.TransactionBody
         * @instance
         */
        Object.defineProperty(TransactionBody.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["cryptoCreateAccount", "cryptoTransfer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody=} [properties] Properties to set
         * @returns {proto.TransactionBody} TransactionBody instance
         */
        TransactionBody.create = function create(properties) {
            return new TransactionBody(properties);
        };

        /**
         * Encodes the specified TransactionBody message. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody} message TransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionBody.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactionID != null && Object.hasOwnProperty.call(message, "transactionID"))
                $root.proto.TransactionID.encode(message.transactionID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nodeAccountID != null && Object.hasOwnProperty.call(message, "nodeAccountID"))
                $root.proto.AccountID.encode(message.nodeAccountID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.transactionFee != null && Object.hasOwnProperty.call(message, "transactionFee"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.transactionFee);
            if (message.transactionValidDuration != null && Object.hasOwnProperty.call(message, "transactionValidDuration"))
                $root.proto.Duration.encode(message.transactionValidDuration, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.generateRecord != null && Object.hasOwnProperty.call(message, "generateRecord"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.generateRecord);
            if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.memo);
            if (message.cryptoCreateAccount != null && Object.hasOwnProperty.call(message, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(message.cryptoCreateAccount, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.cryptoTransfer != null && Object.hasOwnProperty.call(message, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(message.cryptoTransfer, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionBody message, length delimited. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody} message TransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionBody.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TransactionBody} TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionBody.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TransactionBody();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transactionID = $root.proto.TransactionID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nodeAccountID = $root.proto.AccountID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.transactionFee = reader.uint64();
                    break;
                case 4:
                    message.transactionValidDuration = $root.proto.Duration.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.generateRecord = reader.bool();
                    break;
                case 6:
                    message.memo = reader.string();
                    break;
                case 11:
                    message.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TransactionBody} TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionBody.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionBody message.
         * @function verify
         * @memberof proto.TransactionBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionBody.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.transactionID != null && message.hasOwnProperty("transactionID")) {
                var error = $root.proto.TransactionID.verify(message.transactionID);
                if (error)
                    return "transactionID." + error;
            }
            if (message.nodeAccountID != null && message.hasOwnProperty("nodeAccountID")) {
                var error = $root.proto.AccountID.verify(message.nodeAccountID);
                if (error)
                    return "nodeAccountID." + error;
            }
            if (message.transactionFee != null && message.hasOwnProperty("transactionFee"))
                if (!$util.isInteger(message.transactionFee) && !(message.transactionFee && $util.isInteger(message.transactionFee.low) && $util.isInteger(message.transactionFee.high)))
                    return "transactionFee: integer|Long expected";
            if (message.transactionValidDuration != null && message.hasOwnProperty("transactionValidDuration")) {
                var error = $root.proto.Duration.verify(message.transactionValidDuration);
                if (error)
                    return "transactionValidDuration." + error;
            }
            if (message.generateRecord != null && message.hasOwnProperty("generateRecord"))
                if (typeof message.generateRecord !== "boolean")
                    return "generateRecord: boolean expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.cryptoCreateAccount != null && message.hasOwnProperty("cryptoCreateAccount")) {
                properties.data = 1;
                {
                    var error = $root.proto.CryptoCreateTransactionBody.verify(message.cryptoCreateAccount);
                    if (error)
                        return "cryptoCreateAccount." + error;
                }
            }
            if (message.cryptoTransfer != null && message.hasOwnProperty("cryptoTransfer")) {
                if (properties.data === 1)
                    return "data: multiple values";
                properties.data = 1;
                {
                    var error = $root.proto.CryptoTransferTransactionBody.verify(message.cryptoTransfer);
                    if (error)
                        return "cryptoTransfer." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TransactionBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TransactionBody} TransactionBody
         */
        TransactionBody.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TransactionBody)
                return object;
            var message = new $root.proto.TransactionBody();
            if (object.transactionID != null) {
                if (typeof object.transactionID !== "object")
                    throw TypeError(".proto.TransactionBody.transactionID: object expected");
                message.transactionID = $root.proto.TransactionID.fromObject(object.transactionID);
            }
            if (object.nodeAccountID != null) {
                if (typeof object.nodeAccountID !== "object")
                    throw TypeError(".proto.TransactionBody.nodeAccountID: object expected");
                message.nodeAccountID = $root.proto.AccountID.fromObject(object.nodeAccountID);
            }
            if (object.transactionFee != null)
                if ($util.Long)
                    (message.transactionFee = $util.Long.fromValue(object.transactionFee)).unsigned = true;
                else if (typeof object.transactionFee === "string")
                    message.transactionFee = parseInt(object.transactionFee, 10);
                else if (typeof object.transactionFee === "number")
                    message.transactionFee = object.transactionFee;
                else if (typeof object.transactionFee === "object")
                    message.transactionFee = new $util.LongBits(object.transactionFee.low >>> 0, object.transactionFee.high >>> 0).toNumber(true);
            if (object.transactionValidDuration != null) {
                if (typeof object.transactionValidDuration !== "object")
                    throw TypeError(".proto.TransactionBody.transactionValidDuration: object expected");
                message.transactionValidDuration = $root.proto.Duration.fromObject(object.transactionValidDuration);
            }
            if (object.generateRecord != null)
                message.generateRecord = Boolean(object.generateRecord);
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.cryptoCreateAccount != null) {
                if (typeof object.cryptoCreateAccount !== "object")
                    throw TypeError(".proto.TransactionBody.cryptoCreateAccount: object expected");
                message.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.fromObject(object.cryptoCreateAccount);
            }
            if (object.cryptoTransfer != null) {
                if (typeof object.cryptoTransfer !== "object")
                    throw TypeError(".proto.TransactionBody.cryptoTransfer: object expected");
                message.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.fromObject(object.cryptoTransfer);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.TransactionBody} message TransactionBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionBody.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transactionID = null;
                object.nodeAccountID = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.transactionFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transactionFee = options.longs === String ? "0" : 0;
                object.transactionValidDuration = null;
                object.generateRecord = false;
                object.memo = "";
            }
            if (message.transactionID != null && message.hasOwnProperty("transactionID"))
                object.transactionID = $root.proto.TransactionID.toObject(message.transactionID, options);
            if (message.nodeAccountID != null && message.hasOwnProperty("nodeAccountID"))
                object.nodeAccountID = $root.proto.AccountID.toObject(message.nodeAccountID, options);
            if (message.transactionFee != null && message.hasOwnProperty("transactionFee"))
                if (typeof message.transactionFee === "number")
                    object.transactionFee = options.longs === String ? String(message.transactionFee) : message.transactionFee;
                else
                    object.transactionFee = options.longs === String ? $util.Long.prototype.toString.call(message.transactionFee) : options.longs === Number ? new $util.LongBits(message.transactionFee.low >>> 0, message.transactionFee.high >>> 0).toNumber(true) : message.transactionFee;
            if (message.transactionValidDuration != null && message.hasOwnProperty("transactionValidDuration"))
                object.transactionValidDuration = $root.proto.Duration.toObject(message.transactionValidDuration, options);
            if (message.generateRecord != null && message.hasOwnProperty("generateRecord"))
                object.generateRecord = message.generateRecord;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.cryptoCreateAccount != null && message.hasOwnProperty("cryptoCreateAccount")) {
                object.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.toObject(message.cryptoCreateAccount, options);
                if (options.oneofs)
                    object.data = "cryptoCreateAccount";
            }
            if (message.cryptoTransfer != null && message.hasOwnProperty("cryptoTransfer")) {
                object.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.toObject(message.cryptoTransfer, options);
                if (options.oneofs)
                    object.data = "cryptoTransfer";
            }
            return object;
        };

        /**
         * Converts this TransactionBody to JSON.
         * @function toJSON
         * @memberof proto.TransactionBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionBody.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionBody;
    })();

    proto.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof proto
         * @interface ITransaction
         * @property {Uint8Array|null} [signedTransactionBytes] Transaction signedTransactionBytes
         * @property {Uint8Array|null} [bodyBytes] Transaction bodyBytes
         * @property {proto.ISignatureMap|null} [sigMap] Transaction sigMap
         */

        /**
         * Constructs a new Transaction.
         * @memberof proto
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {proto.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transaction signedTransactionBytes.
         * @member {Uint8Array} signedTransactionBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.signedTransactionBytes = $util.newBuffer([]);

        /**
         * Transaction bodyBytes.
         * @member {Uint8Array} bodyBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * Transaction sigMap.
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigMap = null;

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction=} [properties] Properties to set
         * @returns {proto.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @function encode
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sigMap != null && Object.hasOwnProperty.call(message, "sigMap"))
                $root.proto.SignatureMap.encode(message.sigMap, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.bodyBytes != null && Object.hasOwnProperty.call(message, "bodyBytes"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bodyBytes);
            if (message.signedTransactionBytes != null && Object.hasOwnProperty.call(message, "signedTransactionBytes"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signedTransactionBytes);
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    message.signedTransactionBytes = reader.bytes();
                    break;
                case 4:
                    message.bodyBytes = reader.bytes();
                    break;
                case 3:
                    message.sigMap = $root.proto.SignatureMap.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof proto.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signedTransactionBytes != null && message.hasOwnProperty("signedTransactionBytes"))
                if (!(message.signedTransactionBytes && typeof message.signedTransactionBytes.length === "number" || $util.isString(message.signedTransactionBytes)))
                    return "signedTransactionBytes: buffer expected";
            if (message.bodyBytes != null && message.hasOwnProperty("bodyBytes"))
                if (!(message.bodyBytes && typeof message.bodyBytes.length === "number" || $util.isString(message.bodyBytes)))
                    return "bodyBytes: buffer expected";
            if (message.sigMap != null && message.hasOwnProperty("sigMap")) {
                var error = $root.proto.SignatureMap.verify(message.sigMap);
                if (error)
                    return "sigMap." + error;
            }
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Transaction)
                return object;
            var message = new $root.proto.Transaction();
            if (object.signedTransactionBytes != null)
                if (typeof object.signedTransactionBytes === "string")
                    $util.base64.decode(object.signedTransactionBytes, message.signedTransactionBytes = $util.newBuffer($util.base64.length(object.signedTransactionBytes)), 0);
                else if (object.signedTransactionBytes.length)
                    message.signedTransactionBytes = object.signedTransactionBytes;
            if (object.bodyBytes != null)
                if (typeof object.bodyBytes === "string")
                    $util.base64.decode(object.bodyBytes, message.bodyBytes = $util.newBuffer($util.base64.length(object.bodyBytes)), 0);
                else if (object.bodyBytes.length)
                    message.bodyBytes = object.bodyBytes;
            if (object.sigMap != null) {
                if (typeof object.sigMap !== "object")
                    throw TypeError(".proto.Transaction.sigMap: object expected");
                message.sigMap = $root.proto.SignatureMap.fromObject(object.sigMap);
            }
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Transaction
         * @static
         * @param {proto.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sigMap = null;
                if (options.bytes === String)
                    object.bodyBytes = "";
                else {
                    object.bodyBytes = [];
                    if (options.bytes !== Array)
                        object.bodyBytes = $util.newBuffer(object.bodyBytes);
                }
                if (options.bytes === String)
                    object.signedTransactionBytes = "";
                else {
                    object.signedTransactionBytes = [];
                    if (options.bytes !== Array)
                        object.signedTransactionBytes = $util.newBuffer(object.signedTransactionBytes);
                }
            }
            if (message.sigMap != null && message.hasOwnProperty("sigMap"))
                object.sigMap = $root.proto.SignatureMap.toObject(message.sigMap, options);
            if (message.bodyBytes != null && message.hasOwnProperty("bodyBytes"))
                object.bodyBytes = options.bytes === String ? $util.base64.encode(message.bodyBytes, 0, message.bodyBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bodyBytes) : message.bodyBytes;
            if (message.signedTransactionBytes != null && message.hasOwnProperty("signedTransactionBytes"))
                object.signedTransactionBytes = options.bytes === String ? $util.base64.encode(message.signedTransactionBytes, 0, message.signedTransactionBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedTransactionBytes) : message.signedTransactionBytes;
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof proto.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transaction;
    })();

    proto.SignedTransaction = (function() {

        /**
         * Properties of a SignedTransaction.
         * @memberof proto
         * @interface ISignedTransaction
         * @property {Uint8Array|null} [bodyBytes] SignedTransaction bodyBytes
         * @property {proto.ISignatureMap|null} [sigMap] SignedTransaction sigMap
         */

        /**
         * Constructs a new SignedTransaction.
         * @memberof proto
         * @classdesc Represents a SignedTransaction.
         * @implements ISignedTransaction
         * @constructor
         * @param {proto.ISignedTransaction=} [properties] Properties to set
         */
        function SignedTransaction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignedTransaction bodyBytes.
         * @member {Uint8Array} bodyBytes
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * SignedTransaction sigMap.
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.sigMap = null;

        /**
         * Creates a new SignedTransaction instance using the specified properties.
         * @function create
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction=} [properties] Properties to set
         * @returns {proto.SignedTransaction} SignedTransaction instance
         */
        SignedTransaction.create = function create(properties) {
            return new SignedTransaction(properties);
        };

        /**
         * Encodes the specified SignedTransaction message. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @function encode
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction} message SignedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bodyBytes != null && Object.hasOwnProperty.call(message, "bodyBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.bodyBytes);
            if (message.sigMap != null && Object.hasOwnProperty.call(message, "sigMap"))
                $root.proto.SignatureMap.encode(message.sigMap, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SignedTransaction message, length delimited. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction} message SignedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SignedTransaction} SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SignedTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case 2:
                    message.sigMap = $root.proto.SignatureMap.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SignedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SignedTransaction} SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignedTransaction message.
         * @function verify
         * @memberof proto.SignedTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignedTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bodyBytes != null && message.hasOwnProperty("bodyBytes"))
                if (!(message.bodyBytes && typeof message.bodyBytes.length === "number" || $util.isString(message.bodyBytes)))
                    return "bodyBytes: buffer expected";
            if (message.sigMap != null && message.hasOwnProperty("sigMap")) {
                var error = $root.proto.SignatureMap.verify(message.sigMap);
                if (error)
                    return "sigMap." + error;
            }
            return null;
        };

        /**
         * Creates a SignedTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SignedTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SignedTransaction} SignedTransaction
         */
        SignedTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SignedTransaction)
                return object;
            var message = new $root.proto.SignedTransaction();
            if (object.bodyBytes != null)
                if (typeof object.bodyBytes === "string")
                    $util.base64.decode(object.bodyBytes, message.bodyBytes = $util.newBuffer($util.base64.length(object.bodyBytes)), 0);
                else if (object.bodyBytes.length)
                    message.bodyBytes = object.bodyBytes;
            if (object.sigMap != null) {
                if (typeof object.sigMap !== "object")
                    throw TypeError(".proto.SignedTransaction.sigMap: object expected");
                message.sigMap = $root.proto.SignatureMap.fromObject(object.sigMap);
            }
            return message;
        };

        /**
         * Creates a plain object from a SignedTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.SignedTransaction} message SignedTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignedTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.bodyBytes = "";
                else {
                    object.bodyBytes = [];
                    if (options.bytes !== Array)
                        object.bodyBytes = $util.newBuffer(object.bodyBytes);
                }
                object.sigMap = null;
            }
            if (message.bodyBytes != null && message.hasOwnProperty("bodyBytes"))
                object.bodyBytes = options.bytes === String ? $util.base64.encode(message.bodyBytes, 0, message.bodyBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bodyBytes) : message.bodyBytes;
            if (message.sigMap != null && message.hasOwnProperty("sigMap"))
                object.sigMap = $root.proto.SignatureMap.toObject(message.sigMap, options);
            return object;
        };

        /**
         * Converts this SignedTransaction to JSON.
         * @function toJSON
         * @memberof proto.SignedTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignedTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignedTransaction;
    })();

    return proto;
})();

module.exports = $root;
