import * as $protobuf from "protobufjs";
/** Namespace proto. */
export namespace proto {

    /** Properties of a Timestamp. */
    interface ITimestamp {

        /** Timestamp seconds */
        seconds?: (number|Long|null);

        /** Timestamp nanos */
        nanos?: (number|null);
    }

    /** Represents a Timestamp. */
    class Timestamp implements ITimestamp {

        /**
         * Constructs a new Timestamp.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITimestamp);

        /** Timestamp seconds. */
        public seconds: (number|Long);

        /** Timestamp nanos. */
        public nanos: number;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Timestamp instance
         */
        public static create(properties?: proto.ITimestamp): proto.Timestamp;

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @param message Timestamp message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @param message Timestamp message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Timestamp;

        /**
         * Decodes a Timestamp message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Timestamp;

        /**
         * Verifies a Timestamp message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns Timestamp
         */
        public static fromObject(object: { [k: string]: any }): proto.Timestamp;

        /**
         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
         * @param message Timestamp
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.Timestamp, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Timestamp to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TimestampSeconds. */
    interface ITimestampSeconds {

        /** TimestampSeconds seconds */
        seconds?: (number|Long|null);
    }

    /** Represents a TimestampSeconds. */
    class TimestampSeconds implements ITimestampSeconds {

        /**
         * Constructs a new TimestampSeconds.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITimestampSeconds);

        /** TimestampSeconds seconds. */
        public seconds: (number|Long);

        /**
         * Creates a new TimestampSeconds instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TimestampSeconds instance
         */
        public static create(properties?: proto.ITimestampSeconds): proto.TimestampSeconds;

        /**
         * Encodes the specified TimestampSeconds message. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @param message TimestampSeconds message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITimestampSeconds, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TimestampSeconds message, length delimited. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @param message TimestampSeconds message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITimestampSeconds, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TimestampSeconds;

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TimestampSeconds;

        /**
         * Verifies a TimestampSeconds message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TimestampSeconds message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TimestampSeconds
         */
        public static fromObject(object: { [k: string]: any }): proto.TimestampSeconds;

        /**
         * Creates a plain object from a TimestampSeconds message. Also converts values to other types if specified.
         * @param message TimestampSeconds
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TimestampSeconds, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TimestampSeconds to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a ShardID. */
    interface IShardID {

        /** ShardID shardNum */
        shardNum?: (number|Long|null);
    }

    /** Represents a ShardID. */
    class ShardID implements IShardID {

        /**
         * Constructs a new ShardID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IShardID);

        /** ShardID shardNum. */
        public shardNum: (number|Long);

        /**
         * Creates a new ShardID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns ShardID instance
         */
        public static create(properties?: proto.IShardID): proto.ShardID;

        /**
         * Encodes the specified ShardID message. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @param message ShardID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IShardID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified ShardID message, length delimited. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @param message ShardID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IShardID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ShardID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ShardID;

        /**
         * Decodes a ShardID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ShardID;

        /**
         * Verifies a ShardID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ShardID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns ShardID
         */
        public static fromObject(object: { [k: string]: any }): proto.ShardID;

        /**
         * Creates a plain object from a ShardID message. Also converts values to other types if specified.
         * @param message ShardID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.ShardID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this ShardID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a RealmID. */
    interface IRealmID {

        /** RealmID shardNum */
        shardNum?: (number|Long|null);

        /** RealmID realmNum */
        realmNum?: (number|Long|null);
    }

    /** Represents a RealmID. */
    class RealmID implements IRealmID {

        /**
         * Constructs a new RealmID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IRealmID);

        /** RealmID shardNum. */
        public shardNum: (number|Long);

        /** RealmID realmNum. */
        public realmNum: (number|Long);

        /**
         * Creates a new RealmID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns RealmID instance
         */
        public static create(properties?: proto.IRealmID): proto.RealmID;

        /**
         * Encodes the specified RealmID message. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @param message RealmID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IRealmID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified RealmID message, length delimited. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @param message RealmID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IRealmID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a RealmID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.RealmID;

        /**
         * Decodes a RealmID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.RealmID;

        /**
         * Verifies a RealmID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a RealmID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns RealmID
         */
        public static fromObject(object: { [k: string]: any }): proto.RealmID;

        /**
         * Creates a plain object from a RealmID message. Also converts values to other types if specified.
         * @param message RealmID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.RealmID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this RealmID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of an AccountID. */
    interface IAccountID {

        /** AccountID shardNum */
        shardNum?: (number|Long|null);

        /** AccountID realmNum */
        realmNum?: (number|Long|null);

        /** AccountID accountNum */
        accountNum?: (number|Long|null);
    }

    /** Represents an AccountID. */
    class AccountID implements IAccountID {

        /**
         * Constructs a new AccountID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IAccountID);

        /** AccountID shardNum. */
        public shardNum: (number|Long);

        /** AccountID realmNum. */
        public realmNum: (number|Long);

        /** AccountID accountNum. */
        public accountNum: (number|Long);

        /**
         * Creates a new AccountID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns AccountID instance
         */
        public static create(properties?: proto.IAccountID): proto.AccountID;

        /**
         * Encodes the specified AccountID message. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @param message AccountID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IAccountID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified AccountID message, length delimited. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @param message AccountID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IAccountID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an AccountID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.AccountID;

        /**
         * Decodes an AccountID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.AccountID;

        /**
         * Verifies an AccountID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an AccountID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns AccountID
         */
        public static fromObject(object: { [k: string]: any }): proto.AccountID;

        /**
         * Creates a plain object from an AccountID message. Also converts values to other types if specified.
         * @param message AccountID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.AccountID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this AccountID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a FileID. */
    interface IFileID {

        /** FileID shardNum */
        shardNum?: (number|Long|null);

        /** FileID realmNum */
        realmNum?: (number|Long|null);

        /** FileID fileNum */
        fileNum?: (number|Long|null);
    }

    /** Represents a FileID. */
    class FileID implements IFileID {

        /**
         * Constructs a new FileID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IFileID);

        /** FileID shardNum. */
        public shardNum: (number|Long);

        /** FileID realmNum. */
        public realmNum: (number|Long);

        /** FileID fileNum. */
        public fileNum: (number|Long);

        /**
         * Creates a new FileID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns FileID instance
         */
        public static create(properties?: proto.IFileID): proto.FileID;

        /**
         * Encodes the specified FileID message. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @param message FileID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IFileID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified FileID message, length delimited. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @param message FileID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IFileID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a FileID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.FileID;

        /**
         * Decodes a FileID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.FileID;

        /**
         * Verifies a FileID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a FileID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns FileID
         */
        public static fromObject(object: { [k: string]: any }): proto.FileID;

        /**
         * Creates a plain object from a FileID message. Also converts values to other types if specified.
         * @param message FileID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.FileID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this FileID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a ContractID. */
    interface IContractID {

        /** ContractID shardNum */
        shardNum?: (number|Long|null);

        /** ContractID realmNum */
        realmNum?: (number|Long|null);

        /** ContractID contractNum */
        contractNum?: (number|Long|null);
    }

    /** Represents a ContractID. */
    class ContractID implements IContractID {

        /**
         * Constructs a new ContractID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IContractID);

        /** ContractID shardNum. */
        public shardNum: (number|Long);

        /** ContractID realmNum. */
        public realmNum: (number|Long);

        /** ContractID contractNum. */
        public contractNum: (number|Long);

        /**
         * Creates a new ContractID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns ContractID instance
         */
        public static create(properties?: proto.IContractID): proto.ContractID;

        /**
         * Encodes the specified ContractID message. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @param message ContractID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IContractID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified ContractID message, length delimited. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @param message ContractID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IContractID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ContractID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ContractID;

        /**
         * Decodes a ContractID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ContractID;

        /**
         * Verifies a ContractID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ContractID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns ContractID
         */
        public static fromObject(object: { [k: string]: any }): proto.ContractID;

        /**
         * Creates a plain object from a ContractID message. Also converts values to other types if specified.
         * @param message ContractID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.ContractID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this ContractID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TransactionID. */
    interface ITransactionID {

        /** TransactionID transactionValidStart */
        transactionValidStart?: (proto.ITimestamp|null);

        /** TransactionID accountID */
        accountID?: (proto.IAccountID|null);

        /** TransactionID scheduled */
        scheduled?: (boolean|null);
    }

    /** Represents a TransactionID. */
    class TransactionID implements ITransactionID {

        /**
         * Constructs a new TransactionID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITransactionID);

        /** TransactionID transactionValidStart. */
        public transactionValidStart?: (proto.ITimestamp|null);

        /** TransactionID accountID. */
        public accountID?: (proto.IAccountID|null);

        /** TransactionID scheduled. */
        public scheduled: boolean;

        /**
         * Creates a new TransactionID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TransactionID instance
         */
        public static create(properties?: proto.ITransactionID): proto.TransactionID;

        /**
         * Encodes the specified TransactionID message. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @param message TransactionID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITransactionID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TransactionID message, length delimited. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @param message TransactionID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITransactionID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TransactionID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TransactionID;

        /**
         * Decodes a TransactionID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TransactionID;

        /**
         * Verifies a TransactionID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TransactionID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TransactionID
         */
        public static fromObject(object: { [k: string]: any }): proto.TransactionID;

        /**
         * Creates a plain object from a TransactionID message. Also converts values to other types if specified.
         * @param message TransactionID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TransactionID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TransactionID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of an AccountAmount. */
    interface IAccountAmount {

        /** AccountAmount accountID */
        accountID?: (proto.IAccountID|null);

        /** AccountAmount amount */
        amount?: (number|Long|null);
    }

    /** Represents an AccountAmount. */
    class AccountAmount implements IAccountAmount {

        /**
         * Constructs a new AccountAmount.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IAccountAmount);

        /** AccountAmount accountID. */
        public accountID?: (proto.IAccountID|null);

        /** AccountAmount amount. */
        public amount: (number|Long);

        /**
         * Creates a new AccountAmount instance using the specified properties.
         * @param [properties] Properties to set
         * @returns AccountAmount instance
         */
        public static create(properties?: proto.IAccountAmount): proto.AccountAmount;

        /**
         * Encodes the specified AccountAmount message. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @param message AccountAmount message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IAccountAmount, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified AccountAmount message, length delimited. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @param message AccountAmount message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IAccountAmount, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an AccountAmount message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.AccountAmount;

        /**
         * Decodes an AccountAmount message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.AccountAmount;

        /**
         * Verifies an AccountAmount message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an AccountAmount message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns AccountAmount
         */
        public static fromObject(object: { [k: string]: any }): proto.AccountAmount;

        /**
         * Creates a plain object from an AccountAmount message. Also converts values to other types if specified.
         * @param message AccountAmount
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.AccountAmount, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this AccountAmount to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TransferList. */
    interface ITransferList {

        /** TransferList accountAmounts */
        accountAmounts?: (proto.IAccountAmount[]|null);
    }

    /** Represents a TransferList. */
    class TransferList implements ITransferList {

        /**
         * Constructs a new TransferList.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITransferList);

        /** TransferList accountAmounts. */
        public accountAmounts: proto.IAccountAmount[];

        /**
         * Creates a new TransferList instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TransferList instance
         */
        public static create(properties?: proto.ITransferList): proto.TransferList;

        /**
         * Encodes the specified TransferList message. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @param message TransferList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITransferList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TransferList message, length delimited. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @param message TransferList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITransferList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TransferList message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TransferList;

        /**
         * Decodes a TransferList message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TransferList;

        /**
         * Verifies a TransferList message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TransferList message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TransferList
         */
        public static fromObject(object: { [k: string]: any }): proto.TransferList;

        /**
         * Creates a plain object from a TransferList message. Also converts values to other types if specified.
         * @param message TransferList
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TransferList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TransferList to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TokenTransferList. */
    interface ITokenTransferList {

        /** TokenTransferList token */
        token?: (proto.ITokenID|null);

        /** TokenTransferList transfers */
        transfers?: (proto.IAccountAmount[]|null);
    }

    /** Represents a TokenTransferList. */
    class TokenTransferList implements ITokenTransferList {

        /**
         * Constructs a new TokenTransferList.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITokenTransferList);

        /** TokenTransferList token. */
        public token?: (proto.ITokenID|null);

        /** TokenTransferList transfers. */
        public transfers: proto.IAccountAmount[];

        /**
         * Creates a new TokenTransferList instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TokenTransferList instance
         */
        public static create(properties?: proto.ITokenTransferList): proto.TokenTransferList;

        /**
         * Encodes the specified TokenTransferList message. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @param message TokenTransferList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITokenTransferList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TokenTransferList message, length delimited. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @param message TokenTransferList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITokenTransferList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TokenTransferList;

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TokenTransferList;

        /**
         * Verifies a TokenTransferList message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TokenTransferList message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TokenTransferList
         */
        public static fromObject(object: { [k: string]: any }): proto.TokenTransferList;

        /**
         * Creates a plain object from a TokenTransferList message. Also converts values to other types if specified.
         * @param message TokenTransferList
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TokenTransferList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TokenTransferList to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TopicID. */
    interface ITopicID {

        /** TopicID shardNum */
        shardNum?: (number|Long|null);

        /** TopicID realmNum */
        realmNum?: (number|Long|null);

        /** TopicID topicNum */
        topicNum?: (number|Long|null);
    }

    /** Represents a TopicID. */
    class TopicID implements ITopicID {

        /**
         * Constructs a new TopicID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITopicID);

        /** TopicID shardNum. */
        public shardNum: (number|Long);

        /** TopicID realmNum. */
        public realmNum: (number|Long);

        /** TopicID topicNum. */
        public topicNum: (number|Long);

        /**
         * Creates a new TopicID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TopicID instance
         */
        public static create(properties?: proto.ITopicID): proto.TopicID;

        /**
         * Encodes the specified TopicID message. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @param message TopicID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITopicID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TopicID message, length delimited. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @param message TopicID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITopicID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TopicID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TopicID;

        /**
         * Decodes a TopicID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TopicID;

        /**
         * Verifies a TopicID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TopicID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TopicID
         */
        public static fromObject(object: { [k: string]: any }): proto.TopicID;

        /**
         * Creates a plain object from a TopicID message. Also converts values to other types if specified.
         * @param message TopicID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TopicID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TopicID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TokenID. */
    interface ITokenID {

        /** TokenID shardNum */
        shardNum?: (number|Long|null);

        /** TokenID realmNum */
        realmNum?: (number|Long|null);

        /** TokenID tokenNum */
        tokenNum?: (number|Long|null);
    }

    /** Represents a TokenID. */
    class TokenID implements ITokenID {

        /**
         * Constructs a new TokenID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITokenID);

        /** TokenID shardNum. */
        public shardNum: (number|Long);

        /** TokenID realmNum. */
        public realmNum: (number|Long);

        /** TokenID tokenNum. */
        public tokenNum: (number|Long);

        /**
         * Creates a new TokenID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TokenID instance
         */
        public static create(properties?: proto.ITokenID): proto.TokenID;

        /**
         * Encodes the specified TokenID message. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @param message TokenID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITokenID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TokenID message, length delimited. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @param message TokenID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITokenID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TokenID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TokenID;

        /**
         * Decodes a TokenID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TokenID;

        /**
         * Verifies a TokenID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TokenID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TokenID
         */
        public static fromObject(object: { [k: string]: any }): proto.TokenID;

        /**
         * Creates a plain object from a TokenID message. Also converts values to other types if specified.
         * @param message TokenID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TokenID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TokenID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a ScheduleID. */
    interface IScheduleID {

        /** ScheduleID shardNum */
        shardNum?: (number|Long|null);

        /** ScheduleID realmNum */
        realmNum?: (number|Long|null);

        /** ScheduleID scheduleNum */
        scheduleNum?: (number|Long|null);
    }

    /** Represents a ScheduleID. */
    class ScheduleID implements IScheduleID {

        /**
         * Constructs a new ScheduleID.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IScheduleID);

        /** ScheduleID shardNum. */
        public shardNum: (number|Long);

        /** ScheduleID realmNum. */
        public realmNum: (number|Long);

        /** ScheduleID scheduleNum. */
        public scheduleNum: (number|Long);

        /**
         * Creates a new ScheduleID instance using the specified properties.
         * @param [properties] Properties to set
         * @returns ScheduleID instance
         */
        public static create(properties?: proto.IScheduleID): proto.ScheduleID;

        /**
         * Encodes the specified ScheduleID message. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @param message ScheduleID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IScheduleID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified ScheduleID message, length delimited. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @param message ScheduleID message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IScheduleID, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ScheduleID message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ScheduleID;

        /**
         * Decodes a ScheduleID message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ScheduleID;

        /**
         * Verifies a ScheduleID message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ScheduleID message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns ScheduleID
         */
        public static fromObject(object: { [k: string]: any }): proto.ScheduleID;

        /**
         * Creates a plain object from a ScheduleID message. Also converts values to other types if specified.
         * @param message ScheduleID
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.ScheduleID, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this ScheduleID to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** TokenFreezeStatus enum. */
    enum TokenFreezeStatus {
        FreezeNotApplicable = 0,
        Frozen = 1,
        Unfrozen = 2
    }

    /** TokenKycStatus enum. */
    enum TokenKycStatus {
        KycNotApplicable = 0,
        Granted = 1,
        Revoked = 2
    }

    /** Properties of a Key. */
    interface IKey {

        /** Key contractID */
        contractID?: (proto.IContractID|null);

        /** Key ed25519 */
        ed25519?: (Uint8Array|null);

        /** Key RSA_3072 */
        RSA_3072?: (Uint8Array|null);

        /** Key ECDSA_384 */
        ECDSA_384?: (Uint8Array|null);

        /** Key thresholdKey */
        thresholdKey?: (proto.IThresholdKey|null);

        /** Key keyList */
        keyList?: (proto.IKeyList|null);
    }

    /** Represents a Key. */
    class Key implements IKey {

        /**
         * Constructs a new Key.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IKey);

        /** Key contractID. */
        public contractID?: (proto.IContractID|null);

        /** Key ed25519. */
        public ed25519?: (Uint8Array|null);

        /** Key RSA_3072. */
        public RSA_3072?: (Uint8Array|null);

        /** Key ECDSA_384. */
        public ECDSA_384?: (Uint8Array|null);

        /** Key thresholdKey. */
        public thresholdKey?: (proto.IThresholdKey|null);

        /** Key keyList. */
        public keyList?: (proto.IKeyList|null);

        /** Key key. */
        public key?: ("contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList");

        /**
         * Creates a new Key instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Key instance
         */
        public static create(properties?: proto.IKey): proto.Key;

        /**
         * Encodes the specified Key message. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @param message Key message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IKey, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Key message, length delimited. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @param message Key message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IKey, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Key;

        /**
         * Decodes a Key message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Key;

        /**
         * Verifies a Key message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Key message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns Key
         */
        public static fromObject(object: { [k: string]: any }): proto.Key;

        /**
         * Creates a plain object from a Key message. Also converts values to other types if specified.
         * @param message Key
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.Key, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Key to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a ThresholdKey. */
    interface IThresholdKey {

        /** ThresholdKey threshold */
        threshold?: (number|null);

        /** ThresholdKey keys */
        keys?: (proto.IKeyList|null);
    }

    /** Represents a ThresholdKey. */
    class ThresholdKey implements IThresholdKey {

        /**
         * Constructs a new ThresholdKey.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IThresholdKey);

        /** ThresholdKey threshold. */
        public threshold: number;

        /** ThresholdKey keys. */
        public keys?: (proto.IKeyList|null);

        /**
         * Creates a new ThresholdKey instance using the specified properties.
         * @param [properties] Properties to set
         * @returns ThresholdKey instance
         */
        public static create(properties?: proto.IThresholdKey): proto.ThresholdKey;

        /**
         * Encodes the specified ThresholdKey message. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @param message ThresholdKey message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IThresholdKey, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified ThresholdKey message, length delimited. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @param message ThresholdKey message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IThresholdKey, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ThresholdKey;

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ThresholdKey;

        /**
         * Verifies a ThresholdKey message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ThresholdKey message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns ThresholdKey
         */
        public static fromObject(object: { [k: string]: any }): proto.ThresholdKey;

        /**
         * Creates a plain object from a ThresholdKey message. Also converts values to other types if specified.
         * @param message ThresholdKey
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.ThresholdKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this ThresholdKey to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a KeyList. */
    interface IKeyList {

        /** KeyList keys */
        keys?: (proto.IKey[]|null);
    }

    /** Represents a KeyList. */
    class KeyList implements IKeyList {

        /**
         * Constructs a new KeyList.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IKeyList);

        /** KeyList keys. */
        public keys: proto.IKey[];

        /**
         * Creates a new KeyList instance using the specified properties.
         * @param [properties] Properties to set
         * @returns KeyList instance
         */
        public static create(properties?: proto.IKeyList): proto.KeyList;

        /**
         * Encodes the specified KeyList message. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @param message KeyList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IKeyList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified KeyList message, length delimited. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @param message KeyList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IKeyList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a KeyList message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.KeyList;

        /**
         * Decodes a KeyList message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.KeyList;

        /**
         * Verifies a KeyList message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a KeyList message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns KeyList
         */
        public static fromObject(object: { [k: string]: any }): proto.KeyList;

        /**
         * Creates a plain object from a KeyList message. Also converts values to other types if specified.
         * @param message KeyList
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.KeyList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this KeyList to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a Signature. */
    interface ISignature {

        /** Signature contract */
        contract?: (Uint8Array|null);

        /** Signature ed25519 */
        ed25519?: (Uint8Array|null);

        /** Signature RSA_3072 */
        RSA_3072?: (Uint8Array|null);

        /** Signature ECDSA_384 */
        ECDSA_384?: (Uint8Array|null);

        /** Signature thresholdSignature */
        thresholdSignature?: (proto.IThresholdSignature|null);

        /** Signature signatureList */
        signatureList?: (proto.ISignatureList|null);
    }

    /** Represents a Signature. */
    class Signature implements ISignature {

        /**
         * Constructs a new Signature.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISignature);

        /** Signature contract. */
        public contract?: (Uint8Array|null);

        /** Signature ed25519. */
        public ed25519?: (Uint8Array|null);

        /** Signature RSA_3072. */
        public RSA_3072?: (Uint8Array|null);

        /** Signature ECDSA_384. */
        public ECDSA_384?: (Uint8Array|null);

        /** Signature thresholdSignature. */
        public thresholdSignature?: (proto.IThresholdSignature|null);

        /** Signature signatureList. */
        public signatureList?: (proto.ISignatureList|null);

        /** Signature signature. */
        public signature?: ("contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList");

        /**
         * Creates a new Signature instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Signature instance
         */
        public static create(properties?: proto.ISignature): proto.Signature;

        /**
         * Encodes the specified Signature message. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @param message Signature message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISignature, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Signature message, length delimited. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @param message Signature message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISignature, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Signature;

        /**
         * Decodes a Signature message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Signature;

        /**
         * Verifies a Signature message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Signature message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns Signature
         */
        public static fromObject(object: { [k: string]: any }): proto.Signature;

        /**
         * Creates a plain object from a Signature message. Also converts values to other types if specified.
         * @param message Signature
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.Signature, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Signature to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a ThresholdSignature. */
    interface IThresholdSignature {

        /** ThresholdSignature sigs */
        sigs?: (proto.ISignatureList|null);
    }

    /** Represents a ThresholdSignature. */
    class ThresholdSignature implements IThresholdSignature {

        /**
         * Constructs a new ThresholdSignature.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IThresholdSignature);

        /** ThresholdSignature sigs. */
        public sigs?: (proto.ISignatureList|null);

        /**
         * Creates a new ThresholdSignature instance using the specified properties.
         * @param [properties] Properties to set
         * @returns ThresholdSignature instance
         */
        public static create(properties?: proto.IThresholdSignature): proto.ThresholdSignature;

        /**
         * Encodes the specified ThresholdSignature message. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @param message ThresholdSignature message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IThresholdSignature, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified ThresholdSignature message, length delimited. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @param message ThresholdSignature message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IThresholdSignature, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ThresholdSignature;

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ThresholdSignature;

        /**
         * Verifies a ThresholdSignature message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ThresholdSignature message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns ThresholdSignature
         */
        public static fromObject(object: { [k: string]: any }): proto.ThresholdSignature;

        /**
         * Creates a plain object from a ThresholdSignature message. Also converts values to other types if specified.
         * @param message ThresholdSignature
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.ThresholdSignature, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this ThresholdSignature to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a SignatureList. */
    interface ISignatureList {

        /** SignatureList sigs */
        sigs?: (proto.ISignature[]|null);
    }

    /** Represents a SignatureList. */
    class SignatureList implements ISignatureList {

        /**
         * Constructs a new SignatureList.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISignatureList);

        /** SignatureList sigs. */
        public sigs: proto.ISignature[];

        /**
         * Creates a new SignatureList instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SignatureList instance
         */
        public static create(properties?: proto.ISignatureList): proto.SignatureList;

        /**
         * Encodes the specified SignatureList message. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @param message SignatureList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISignatureList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SignatureList message, length delimited. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @param message SignatureList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISignatureList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SignatureList message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SignatureList;

        /**
         * Decodes a SignatureList message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SignatureList;

        /**
         * Verifies a SignatureList message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SignatureList message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SignatureList
         */
        public static fromObject(object: { [k: string]: any }): proto.SignatureList;

        /**
         * Creates a plain object from a SignatureList message. Also converts values to other types if specified.
         * @param message SignatureList
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.SignatureList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SignatureList to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a SignaturePair. */
    interface ISignaturePair {

        /** SignaturePair pubKeyPrefix */
        pubKeyPrefix?: (Uint8Array|null);

        /** SignaturePair contract */
        contract?: (Uint8Array|null);

        /** SignaturePair ed25519 */
        ed25519?: (Uint8Array|null);

        /** SignaturePair RSA_3072 */
        RSA_3072?: (Uint8Array|null);

        /** SignaturePair ECDSA_384 */
        ECDSA_384?: (Uint8Array|null);
    }

    /** Represents a SignaturePair. */
    class SignaturePair implements ISignaturePair {

        /**
         * Constructs a new SignaturePair.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISignaturePair);

        /** SignaturePair pubKeyPrefix. */
        public pubKeyPrefix: Uint8Array;

        /** SignaturePair contract. */
        public contract?: (Uint8Array|null);

        /** SignaturePair ed25519. */
        public ed25519?: (Uint8Array|null);

        /** SignaturePair RSA_3072. */
        public RSA_3072?: (Uint8Array|null);

        /** SignaturePair ECDSA_384. */
        public ECDSA_384?: (Uint8Array|null);

        /** SignaturePair signature. */
        public signature?: ("contract"|"ed25519"|"RSA_3072"|"ECDSA_384");

        /**
         * Creates a new SignaturePair instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SignaturePair instance
         */
        public static create(properties?: proto.ISignaturePair): proto.SignaturePair;

        /**
         * Encodes the specified SignaturePair message. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @param message SignaturePair message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISignaturePair, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SignaturePair message, length delimited. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @param message SignaturePair message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISignaturePair, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SignaturePair message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SignaturePair;

        /**
         * Decodes a SignaturePair message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SignaturePair;

        /**
         * Verifies a SignaturePair message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SignaturePair message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SignaturePair
         */
        public static fromObject(object: { [k: string]: any }): proto.SignaturePair;

        /**
         * Creates a plain object from a SignaturePair message. Also converts values to other types if specified.
         * @param message SignaturePair
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.SignaturePair, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SignaturePair to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a SignatureMap. */
    interface ISignatureMap {

        /** SignatureMap sigPair */
        sigPair?: (proto.ISignaturePair[]|null);
    }

    /** Represents a SignatureMap. */
    class SignatureMap implements ISignatureMap {

        /**
         * Constructs a new SignatureMap.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISignatureMap);

        /** SignatureMap sigPair. */
        public sigPair: proto.ISignaturePair[];

        /**
         * Creates a new SignatureMap instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SignatureMap instance
         */
        public static create(properties?: proto.ISignatureMap): proto.SignatureMap;

        /**
         * Encodes the specified SignatureMap message. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @param message SignatureMap message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISignatureMap, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SignatureMap message, length delimited. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @param message SignatureMap message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISignatureMap, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SignatureMap message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SignatureMap;

        /**
         * Decodes a SignatureMap message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SignatureMap;

        /**
         * Verifies a SignatureMap message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SignatureMap message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SignatureMap
         */
        public static fromObject(object: { [k: string]: any }): proto.SignatureMap;

        /**
         * Creates a plain object from a SignatureMap message. Also converts values to other types if specified.
         * @param message SignatureMap
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.SignatureMap, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SignatureMap to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** HederaFunctionality enum. */
    enum HederaFunctionality {
        NONE = 0,
        CryptoTransfer = 1,
        CryptoUpdate = 2,
        CryptoDelete = 3,
        CryptoAddLiveHash = 4,
        CryptoDeleteLiveHash = 5,
        ContractCall = 6,
        ContractCreate = 7,
        ContractUpdate = 8,
        FileCreate = 9,
        FileAppend = 10,
        FileUpdate = 11,
        FileDelete = 12,
        CryptoGetAccountBalance = 13,
        CryptoGetAccountRecords = 14,
        CryptoGetInfo = 15,
        ContractCallLocal = 16,
        ContractGetInfo = 17,
        ContractGetBytecode = 18,
        GetBySolidityID = 19,
        GetByKey = 20,
        CryptoGetLiveHash = 21,
        CryptoGetStakers = 22,
        FileGetContents = 23,
        FileGetInfo = 24,
        TransactionGetRecord = 25,
        ContractGetRecords = 26,
        CryptoCreate = 27,
        SystemDelete = 28,
        SystemUndelete = 29,
        ContractDelete = 30,
        Freeze = 31,
        CreateTransactionRecord = 32,
        CryptoAccountAutoRenew = 33,
        ContractAutoRenew = 34,
        GetVersionInfo = 35,
        TransactionGetReceipt = 36,
        ConsensusCreateTopic = 50,
        ConsensusUpdateTopic = 51,
        ConsensusDeleteTopic = 52,
        ConsensusGetTopicInfo = 53,
        ConsensusSubmitMessage = 54,
        UncheckedSubmit = 55,
        TokenCreate = 56,
        TokenGetInfo = 58,
        TokenFreezeAccount = 59,
        TokenUnfreezeAccount = 60,
        TokenGrantKycToAccount = 61,
        TokenRevokeKycFromAccount = 62,
        TokenDelete = 63,
        TokenUpdate = 64,
        TokenMint = 65,
        TokenBurn = 66,
        TokenAccountWipe = 67,
        TokenAssociateToAccount = 68,
        TokenDissociateFromAccount = 69,
        ScheduleCreate = 70,
        ScheduleDelete = 71,
        ScheduleSign = 72,
        ScheduleGetInfo = 73
    }

    /** Properties of a FeeComponents. */
    interface IFeeComponents {

        /** FeeComponents min */
        min?: (number|Long|null);

        /** FeeComponents max */
        max?: (number|Long|null);

        /** FeeComponents constant */
        constant?: (number|Long|null);

        /** FeeComponents bpt */
        bpt?: (number|Long|null);

        /** FeeComponents vpt */
        vpt?: (number|Long|null);

        /** FeeComponents rbh */
        rbh?: (number|Long|null);

        /** FeeComponents sbh */
        sbh?: (number|Long|null);

        /** FeeComponents gas */
        gas?: (number|Long|null);

        /** FeeComponents tv */
        tv?: (number|Long|null);

        /** FeeComponents bpr */
        bpr?: (number|Long|null);

        /** FeeComponents sbpr */
        sbpr?: (number|Long|null);
    }

    /** Represents a FeeComponents. */
    class FeeComponents implements IFeeComponents {

        /**
         * Constructs a new FeeComponents.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IFeeComponents);

        /** FeeComponents min. */
        public min: (number|Long);

        /** FeeComponents max. */
        public max: (number|Long);

        /** FeeComponents constant. */
        public constant: (number|Long);

        /** FeeComponents bpt. */
        public bpt: (number|Long);

        /** FeeComponents vpt. */
        public vpt: (number|Long);

        /** FeeComponents rbh. */
        public rbh: (number|Long);

        /** FeeComponents sbh. */
        public sbh: (number|Long);

        /** FeeComponents gas. */
        public gas: (number|Long);

        /** FeeComponents tv. */
        public tv: (number|Long);

        /** FeeComponents bpr. */
        public bpr: (number|Long);

        /** FeeComponents sbpr. */
        public sbpr: (number|Long);

        /**
         * Creates a new FeeComponents instance using the specified properties.
         * @param [properties] Properties to set
         * @returns FeeComponents instance
         */
        public static create(properties?: proto.IFeeComponents): proto.FeeComponents;

        /**
         * Encodes the specified FeeComponents message. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @param message FeeComponents message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IFeeComponents, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified FeeComponents message, length delimited. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @param message FeeComponents message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IFeeComponents, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a FeeComponents message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.FeeComponents;

        /**
         * Decodes a FeeComponents message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.FeeComponents;

        /**
         * Verifies a FeeComponents message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a FeeComponents message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns FeeComponents
         */
        public static fromObject(object: { [k: string]: any }): proto.FeeComponents;

        /**
         * Creates a plain object from a FeeComponents message. Also converts values to other types if specified.
         * @param message FeeComponents
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.FeeComponents, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this FeeComponents to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TransactionFeeSchedule. */
    interface ITransactionFeeSchedule {

        /** TransactionFeeSchedule hederaFunctionality */
        hederaFunctionality?: (proto.HederaFunctionality|null);

        /** TransactionFeeSchedule feeData */
        feeData?: (proto.IFeeData|null);
    }

    /** Represents a TransactionFeeSchedule. */
    class TransactionFeeSchedule implements ITransactionFeeSchedule {

        /**
         * Constructs a new TransactionFeeSchedule.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITransactionFeeSchedule);

        /** TransactionFeeSchedule hederaFunctionality. */
        public hederaFunctionality: proto.HederaFunctionality;

        /** TransactionFeeSchedule feeData. */
        public feeData?: (proto.IFeeData|null);

        /**
         * Creates a new TransactionFeeSchedule instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TransactionFeeSchedule instance
         */
        public static create(properties?: proto.ITransactionFeeSchedule): proto.TransactionFeeSchedule;

        /**
         * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @param message TransactionFeeSchedule message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITransactionFeeSchedule, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TransactionFeeSchedule message, length delimited. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @param message TransactionFeeSchedule message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITransactionFeeSchedule, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TransactionFeeSchedule;

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TransactionFeeSchedule;

        /**
         * Verifies a TransactionFeeSchedule message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TransactionFeeSchedule message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TransactionFeeSchedule
         */
        public static fromObject(object: { [k: string]: any }): proto.TransactionFeeSchedule;

        /**
         * Creates a plain object from a TransactionFeeSchedule message. Also converts values to other types if specified.
         * @param message TransactionFeeSchedule
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TransactionFeeSchedule, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TransactionFeeSchedule to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a FeeData. */
    interface IFeeData {

        /** FeeData nodedata */
        nodedata?: (proto.IFeeComponents|null);

        /** FeeData networkdata */
        networkdata?: (proto.IFeeComponents|null);

        /** FeeData servicedata */
        servicedata?: (proto.IFeeComponents|null);
    }

    /** Represents a FeeData. */
    class FeeData implements IFeeData {

        /**
         * Constructs a new FeeData.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IFeeData);

        /** FeeData nodedata. */
        public nodedata?: (proto.IFeeComponents|null);

        /** FeeData networkdata. */
        public networkdata?: (proto.IFeeComponents|null);

        /** FeeData servicedata. */
        public servicedata?: (proto.IFeeComponents|null);

        /**
         * Creates a new FeeData instance using the specified properties.
         * @param [properties] Properties to set
         * @returns FeeData instance
         */
        public static create(properties?: proto.IFeeData): proto.FeeData;

        /**
         * Encodes the specified FeeData message. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @param message FeeData message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IFeeData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified FeeData message, length delimited. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @param message FeeData message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IFeeData, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a FeeData message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.FeeData;

        /**
         * Decodes a FeeData message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.FeeData;

        /**
         * Verifies a FeeData message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a FeeData message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns FeeData
         */
        public static fromObject(object: { [k: string]: any }): proto.FeeData;

        /**
         * Creates a plain object from a FeeData message. Also converts values to other types if specified.
         * @param message FeeData
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.FeeData, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this FeeData to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a FeeSchedule. */
    interface IFeeSchedule {

        /** FeeSchedule transactionFeeSchedule */
        transactionFeeSchedule?: (proto.ITransactionFeeSchedule[]|null);

        /** FeeSchedule expiryTime */
        expiryTime?: (proto.ITimestampSeconds|null);
    }

    /** Represents a FeeSchedule. */
    class FeeSchedule implements IFeeSchedule {

        /**
         * Constructs a new FeeSchedule.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IFeeSchedule);

        /** FeeSchedule transactionFeeSchedule. */
        public transactionFeeSchedule: proto.ITransactionFeeSchedule[];

        /** FeeSchedule expiryTime. */
        public expiryTime?: (proto.ITimestampSeconds|null);

        /**
         * Creates a new FeeSchedule instance using the specified properties.
         * @param [properties] Properties to set
         * @returns FeeSchedule instance
         */
        public static create(properties?: proto.IFeeSchedule): proto.FeeSchedule;

        /**
         * Encodes the specified FeeSchedule message. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @param message FeeSchedule message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IFeeSchedule, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified FeeSchedule message, length delimited. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @param message FeeSchedule message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IFeeSchedule, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.FeeSchedule;

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.FeeSchedule;

        /**
         * Verifies a FeeSchedule message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a FeeSchedule message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns FeeSchedule
         */
        public static fromObject(object: { [k: string]: any }): proto.FeeSchedule;

        /**
         * Creates a plain object from a FeeSchedule message. Also converts values to other types if specified.
         * @param message FeeSchedule
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.FeeSchedule, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this FeeSchedule to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a CurrentAndNextFeeSchedule. */
    interface ICurrentAndNextFeeSchedule {

        /** CurrentAndNextFeeSchedule currentFeeSchedule */
        currentFeeSchedule?: (proto.IFeeSchedule|null);

        /** CurrentAndNextFeeSchedule nextFeeSchedule */
        nextFeeSchedule?: (proto.IFeeSchedule|null);
    }

    /** Represents a CurrentAndNextFeeSchedule. */
    class CurrentAndNextFeeSchedule implements ICurrentAndNextFeeSchedule {

        /**
         * Constructs a new CurrentAndNextFeeSchedule.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ICurrentAndNextFeeSchedule);

        /** CurrentAndNextFeeSchedule currentFeeSchedule. */
        public currentFeeSchedule?: (proto.IFeeSchedule|null);

        /** CurrentAndNextFeeSchedule nextFeeSchedule. */
        public nextFeeSchedule?: (proto.IFeeSchedule|null);

        /**
         * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
         * @param [properties] Properties to set
         * @returns CurrentAndNextFeeSchedule instance
         */
        public static create(properties?: proto.ICurrentAndNextFeeSchedule): proto.CurrentAndNextFeeSchedule;

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @param message CurrentAndNextFeeSchedule message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ICurrentAndNextFeeSchedule, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message, length delimited. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @param message CurrentAndNextFeeSchedule message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ICurrentAndNextFeeSchedule, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.CurrentAndNextFeeSchedule;

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.CurrentAndNextFeeSchedule;

        /**
         * Verifies a CurrentAndNextFeeSchedule message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a CurrentAndNextFeeSchedule message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns CurrentAndNextFeeSchedule
         */
        public static fromObject(object: { [k: string]: any }): proto.CurrentAndNextFeeSchedule;

        /**
         * Creates a plain object from a CurrentAndNextFeeSchedule message. Also converts values to other types if specified.
         * @param message CurrentAndNextFeeSchedule
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.CurrentAndNextFeeSchedule, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this CurrentAndNextFeeSchedule to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a NodeEndpoint. */
    interface INodeEndpoint {

        /** NodeEndpoint ipAddress */
        ipAddress?: (string|null);

        /** NodeEndpoint port */
        port?: (string|null);
    }

    /** Represents a NodeEndpoint. */
    class NodeEndpoint implements INodeEndpoint {

        /**
         * Constructs a new NodeEndpoint.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.INodeEndpoint);

        /** NodeEndpoint ipAddress. */
        public ipAddress: string;

        /** NodeEndpoint port. */
        public port: string;

        /**
         * Creates a new NodeEndpoint instance using the specified properties.
         * @param [properties] Properties to set
         * @returns NodeEndpoint instance
         */
        public static create(properties?: proto.INodeEndpoint): proto.NodeEndpoint;

        /**
         * Encodes the specified NodeEndpoint message. Does not implicitly {@link proto.NodeEndpoint.verify|verify} messages.
         * @param message NodeEndpoint message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.INodeEndpoint, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified NodeEndpoint message, length delimited. Does not implicitly {@link proto.NodeEndpoint.verify|verify} messages.
         * @param message NodeEndpoint message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.INodeEndpoint, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a NodeEndpoint message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns NodeEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.NodeEndpoint;

        /**
         * Decodes a NodeEndpoint message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns NodeEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.NodeEndpoint;

        /**
         * Verifies a NodeEndpoint message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a NodeEndpoint message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns NodeEndpoint
         */
        public static fromObject(object: { [k: string]: any }): proto.NodeEndpoint;

        /**
         * Creates a plain object from a NodeEndpoint message. Also converts values to other types if specified.
         * @param message NodeEndpoint
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.NodeEndpoint, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this NodeEndpoint to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a NodeAddress. */
    interface INodeAddress {

        /** NodeAddress ipAddress */
        ipAddress?: (Uint8Array|null);

        /** NodeAddress portno */
        portno?: (number|null);

        /** NodeAddress memo */
        memo?: (Uint8Array|null);

        /** NodeAddress RSA_PubKey */
        RSA_PubKey?: (string|null);

        /** NodeAddress nodeId */
        nodeId?: (number|Long|null);

        /** NodeAddress nodeAccountId */
        nodeAccountId?: (proto.IAccountID|null);

        /** NodeAddress nodeCertHash */
        nodeCertHash?: (Uint8Array|null);

        /** NodeAddress nodeEndpoint */
        nodeEndpoint?: (proto.INodeEndpoint[]|null);

        /** NodeAddress description */
        description?: (string|null);

        /** NodeAddress stake */
        stake?: (number|Long|null);
    }

    /** Represents a NodeAddress. */
    class NodeAddress implements INodeAddress {

        /**
         * Constructs a new NodeAddress.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.INodeAddress);

        /** NodeAddress ipAddress. */
        public ipAddress: Uint8Array;

        /** NodeAddress portno. */
        public portno: number;

        /** NodeAddress memo. */
        public memo: Uint8Array;

        /** NodeAddress RSA_PubKey. */
        public RSA_PubKey: string;

        /** NodeAddress nodeId. */
        public nodeId: (number|Long);

        /** NodeAddress nodeAccountId. */
        public nodeAccountId?: (proto.IAccountID|null);

        /** NodeAddress nodeCertHash. */
        public nodeCertHash: Uint8Array;

        /** NodeAddress nodeEndpoint. */
        public nodeEndpoint: proto.INodeEndpoint[];

        /** NodeAddress description. */
        public description: string;

        /** NodeAddress stake. */
        public stake: (number|Long);

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @param [properties] Properties to set
         * @returns NodeAddress instance
         */
        public static create(properties?: proto.INodeAddress): proto.NodeAddress;

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @param message NodeAddress message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.INodeAddress, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @param message NodeAddress message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.INodeAddress, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.NodeAddress;

        /**
         * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.NodeAddress;

        /**
         * Verifies a NodeAddress message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a NodeAddress message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns NodeAddress
         */
        public static fromObject(object: { [k: string]: any }): proto.NodeAddress;

        /**
         * Creates a plain object from a NodeAddress message. Also converts values to other types if specified.
         * @param message NodeAddress
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.NodeAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this NodeAddress to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of an AddressBook. */
    interface IAddressBook {

        /** AddressBook nodeAddress */
        nodeAddress?: (proto.INodeAddress[]|null);
    }

    /** Represents an AddressBook. */
    class AddressBook implements IAddressBook {

        /**
         * Constructs a new AddressBook.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IAddressBook);

        /** AddressBook nodeAddress. */
        public nodeAddress: proto.INodeAddress[];

        /**
         * Creates a new AddressBook instance using the specified properties.
         * @param [properties] Properties to set
         * @returns AddressBook instance
         */
        public static create(properties?: proto.IAddressBook): proto.AddressBook;

        /**
         * Encodes the specified AddressBook message. Does not implicitly {@link proto.AddressBook.verify|verify} messages.
         * @param message AddressBook message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IAddressBook, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified AddressBook message, length delimited. Does not implicitly {@link proto.AddressBook.verify|verify} messages.
         * @param message AddressBook message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IAddressBook, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an AddressBook message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns AddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.AddressBook;

        /**
         * Decodes an AddressBook message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns AddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.AddressBook;

        /**
         * Verifies an AddressBook message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an AddressBook message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns AddressBook
         */
        public static fromObject(object: { [k: string]: any }): proto.AddressBook;

        /**
         * Creates a plain object from an AddressBook message. Also converts values to other types if specified.
         * @param message AddressBook
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.AddressBook, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this AddressBook to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a NodeAddressForClients. */
    interface INodeAddressForClients {

        /** NodeAddressForClients nodeId */
        nodeId?: (number|Long|null);

        /** NodeAddressForClients nodeAccountId */
        nodeAccountId?: (proto.IAccountID|null);

        /** NodeAddressForClients nodeCertHash */
        nodeCertHash?: (Uint8Array|null);

        /** NodeAddressForClients nodeEndpoint */
        nodeEndpoint?: (proto.INodeEndpoint[]|null);
    }

    /** Represents a NodeAddressForClients. */
    class NodeAddressForClients implements INodeAddressForClients {

        /**
         * Constructs a new NodeAddressForClients.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.INodeAddressForClients);

        /** NodeAddressForClients nodeId. */
        public nodeId: (number|Long);

        /** NodeAddressForClients nodeAccountId. */
        public nodeAccountId?: (proto.IAccountID|null);

        /** NodeAddressForClients nodeCertHash. */
        public nodeCertHash: Uint8Array;

        /** NodeAddressForClients nodeEndpoint. */
        public nodeEndpoint: proto.INodeEndpoint[];

        /**
         * Creates a new NodeAddressForClients instance using the specified properties.
         * @param [properties] Properties to set
         * @returns NodeAddressForClients instance
         */
        public static create(properties?: proto.INodeAddressForClients): proto.NodeAddressForClients;

        /**
         * Encodes the specified NodeAddressForClients message. Does not implicitly {@link proto.NodeAddressForClients.verify|verify} messages.
         * @param message NodeAddressForClients message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.INodeAddressForClients, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified NodeAddressForClients message, length delimited. Does not implicitly {@link proto.NodeAddressForClients.verify|verify} messages.
         * @param message NodeAddressForClients message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.INodeAddressForClients, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a NodeAddressForClients message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns NodeAddressForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.NodeAddressForClients;

        /**
         * Decodes a NodeAddressForClients message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns NodeAddressForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.NodeAddressForClients;

        /**
         * Verifies a NodeAddressForClients message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a NodeAddressForClients message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns NodeAddressForClients
         */
        public static fromObject(object: { [k: string]: any }): proto.NodeAddressForClients;

        /**
         * Creates a plain object from a NodeAddressForClients message. Also converts values to other types if specified.
         * @param message NodeAddressForClients
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.NodeAddressForClients, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this NodeAddressForClients to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of an AddressBookForClients. */
    interface IAddressBookForClients {

        /** AddressBookForClients nodeAddressForClients */
        nodeAddressForClients?: (proto.INodeAddressForClients[]|null);
    }

    /** Represents an AddressBookForClients. */
    class AddressBookForClients implements IAddressBookForClients {

        /**
         * Constructs a new AddressBookForClients.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IAddressBookForClients);

        /** AddressBookForClients nodeAddressForClients. */
        public nodeAddressForClients: proto.INodeAddressForClients[];

        /**
         * Creates a new AddressBookForClients instance using the specified properties.
         * @param [properties] Properties to set
         * @returns AddressBookForClients instance
         */
        public static create(properties?: proto.IAddressBookForClients): proto.AddressBookForClients;

        /**
         * Encodes the specified AddressBookForClients message. Does not implicitly {@link proto.AddressBookForClients.verify|verify} messages.
         * @param message AddressBookForClients message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IAddressBookForClients, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified AddressBookForClients message, length delimited. Does not implicitly {@link proto.AddressBookForClients.verify|verify} messages.
         * @param message AddressBookForClients message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IAddressBookForClients, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an AddressBookForClients message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns AddressBookForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.AddressBookForClients;

        /**
         * Decodes an AddressBookForClients message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns AddressBookForClients
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.AddressBookForClients;

        /**
         * Verifies an AddressBookForClients message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates an AddressBookForClients message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns AddressBookForClients
         */
        public static fromObject(object: { [k: string]: any }): proto.AddressBookForClients;

        /**
         * Creates a plain object from an AddressBookForClients message. Also converts values to other types if specified.
         * @param message AddressBookForClients
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.AddressBookForClients, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this AddressBookForClients to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a SemanticVersion. */
    interface ISemanticVersion {

        /** SemanticVersion major */
        major?: (number|null);

        /** SemanticVersion minor */
        minor?: (number|null);

        /** SemanticVersion patch */
        patch?: (number|null);
    }

    /** Represents a SemanticVersion. */
    class SemanticVersion implements ISemanticVersion {

        /**
         * Constructs a new SemanticVersion.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISemanticVersion);

        /** SemanticVersion major. */
        public major: number;

        /** SemanticVersion minor. */
        public minor: number;

        /** SemanticVersion patch. */
        public patch: number;

        /**
         * Creates a new SemanticVersion instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SemanticVersion instance
         */
        public static create(properties?: proto.ISemanticVersion): proto.SemanticVersion;

        /**
         * Encodes the specified SemanticVersion message. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @param message SemanticVersion message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISemanticVersion, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SemanticVersion message, length delimited. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @param message SemanticVersion message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISemanticVersion, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SemanticVersion;

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SemanticVersion;

        /**
         * Verifies a SemanticVersion message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SemanticVersion message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SemanticVersion
         */
        public static fromObject(object: { [k: string]: any }): proto.SemanticVersion;

        /**
         * Creates a plain object from a SemanticVersion message. Also converts values to other types if specified.
         * @param message SemanticVersion
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.SemanticVersion, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SemanticVersion to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a Setting. */
    interface ISetting {

        /** Setting name */
        name?: (string|null);

        /** Setting value */
        value?: (string|null);

        /** Setting data */
        data?: (Uint8Array|null);
    }

    /** Represents a Setting. */
    class Setting implements ISetting {

        /**
         * Constructs a new Setting.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISetting);

        /** Setting name. */
        public name: string;

        /** Setting value. */
        public value: string;

        /** Setting data. */
        public data: Uint8Array;

        /**
         * Creates a new Setting instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Setting instance
         */
        public static create(properties?: proto.ISetting): proto.Setting;

        /**
         * Encodes the specified Setting message. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @param message Setting message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISetting, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Setting message, length delimited. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @param message Setting message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISetting, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Setting;

        /**
         * Decodes a Setting message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Setting;

        /**
         * Verifies a Setting message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Setting message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns Setting
         */
        public static fromObject(object: { [k: string]: any }): proto.Setting;

        /**
         * Creates a plain object from a Setting message. Also converts values to other types if specified.
         * @param message Setting
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.Setting, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Setting to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a ServicesConfigurationList. */
    interface IServicesConfigurationList {

        /** ServicesConfigurationList nameValue */
        nameValue?: (proto.ISetting[]|null);
    }

    /** Represents a ServicesConfigurationList. */
    class ServicesConfigurationList implements IServicesConfigurationList {

        /**
         * Constructs a new ServicesConfigurationList.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IServicesConfigurationList);

        /** ServicesConfigurationList nameValue. */
        public nameValue: proto.ISetting[];

        /**
         * Creates a new ServicesConfigurationList instance using the specified properties.
         * @param [properties] Properties to set
         * @returns ServicesConfigurationList instance
         */
        public static create(properties?: proto.IServicesConfigurationList): proto.ServicesConfigurationList;

        /**
         * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @param message ServicesConfigurationList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IServicesConfigurationList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified ServicesConfigurationList message, length delimited. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @param message ServicesConfigurationList message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IServicesConfigurationList, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.ServicesConfigurationList;

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.ServicesConfigurationList;

        /**
         * Verifies a ServicesConfigurationList message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a ServicesConfigurationList message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns ServicesConfigurationList
         */
        public static fromObject(object: { [k: string]: any }): proto.ServicesConfigurationList;

        /**
         * Creates a plain object from a ServicesConfigurationList message. Also converts values to other types if specified.
         * @param message ServicesConfigurationList
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.ServicesConfigurationList, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this ServicesConfigurationList to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TokenRelationship. */
    interface ITokenRelationship {

        /** TokenRelationship tokenId */
        tokenId?: (proto.ITokenID|null);

        /** TokenRelationship symbol */
        symbol?: (string|null);

        /** TokenRelationship balance */
        balance?: (number|Long|null);

        /** TokenRelationship kycStatus */
        kycStatus?: (proto.TokenKycStatus|null);

        /** TokenRelationship freezeStatus */
        freezeStatus?: (proto.TokenFreezeStatus|null);

        /** TokenRelationship decimals */
        decimals?: (number|null);
    }

    /** Represents a TokenRelationship. */
    class TokenRelationship implements ITokenRelationship {

        /**
         * Constructs a new TokenRelationship.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITokenRelationship);

        /** TokenRelationship tokenId. */
        public tokenId?: (proto.ITokenID|null);

        /** TokenRelationship symbol. */
        public symbol: string;

        /** TokenRelationship balance. */
        public balance: (number|Long);

        /** TokenRelationship kycStatus. */
        public kycStatus: proto.TokenKycStatus;

        /** TokenRelationship freezeStatus. */
        public freezeStatus: proto.TokenFreezeStatus;

        /** TokenRelationship decimals. */
        public decimals: number;

        /**
         * Creates a new TokenRelationship instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TokenRelationship instance
         */
        public static create(properties?: proto.ITokenRelationship): proto.TokenRelationship;

        /**
         * Encodes the specified TokenRelationship message. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @param message TokenRelationship message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITokenRelationship, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TokenRelationship message, length delimited. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @param message TokenRelationship message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITokenRelationship, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TokenRelationship;

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TokenRelationship;

        /**
         * Verifies a TokenRelationship message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TokenRelationship message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TokenRelationship
         */
        public static fromObject(object: { [k: string]: any }): proto.TokenRelationship;

        /**
         * Creates a plain object from a TokenRelationship message. Also converts values to other types if specified.
         * @param message TokenRelationship
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TokenRelationship, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TokenRelationship to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TokenBalance. */
    interface ITokenBalance {

        /** TokenBalance tokenId */
        tokenId?: (proto.ITokenID|null);

        /** TokenBalance balance */
        balance?: (number|Long|null);

        /** TokenBalance decimals */
        decimals?: (number|null);
    }

    /** Represents a TokenBalance. */
    class TokenBalance implements ITokenBalance {

        /**
         * Constructs a new TokenBalance.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITokenBalance);

        /** TokenBalance tokenId. */
        public tokenId?: (proto.ITokenID|null);

        /** TokenBalance balance. */
        public balance: (number|Long);

        /** TokenBalance decimals. */
        public decimals: number;

        /**
         * Creates a new TokenBalance instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TokenBalance instance
         */
        public static create(properties?: proto.ITokenBalance): proto.TokenBalance;

        /**
         * Encodes the specified TokenBalance message. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @param message TokenBalance message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITokenBalance, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TokenBalance message, length delimited. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @param message TokenBalance message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITokenBalance, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TokenBalance message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TokenBalance;

        /**
         * Decodes a TokenBalance message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TokenBalance;

        /**
         * Verifies a TokenBalance message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TokenBalance message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TokenBalance
         */
        public static fromObject(object: { [k: string]: any }): proto.TokenBalance;

        /**
         * Creates a plain object from a TokenBalance message. Also converts values to other types if specified.
         * @param message TokenBalance
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TokenBalance, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TokenBalance to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TokenBalances. */
    interface ITokenBalances {

        /** TokenBalances tokenBalances */
        tokenBalances?: (proto.ITokenBalance[]|null);
    }

    /** Represents a TokenBalances. */
    class TokenBalances implements ITokenBalances {

        /**
         * Constructs a new TokenBalances.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITokenBalances);

        /** TokenBalances tokenBalances. */
        public tokenBalances: proto.ITokenBalance[];

        /**
         * Creates a new TokenBalances instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TokenBalances instance
         */
        public static create(properties?: proto.ITokenBalances): proto.TokenBalances;

        /**
         * Encodes the specified TokenBalances message. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @param message TokenBalances message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITokenBalances, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TokenBalances message, length delimited. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @param message TokenBalances message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITokenBalances, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TokenBalances message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TokenBalances;

        /**
         * Decodes a TokenBalances message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TokenBalances;

        /**
         * Verifies a TokenBalances message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TokenBalances message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TokenBalances
         */
        public static fromObject(object: { [k: string]: any }): proto.TokenBalances;

        /**
         * Creates a plain object from a TokenBalances message. Also converts values to other types if specified.
         * @param message TokenBalances
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TokenBalances, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TokenBalances to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a Duration. */
    interface IDuration {

        /** Duration seconds */
        seconds?: (number|Long|null);
    }

    /** Represents a Duration. */
    class Duration implements IDuration {

        /**
         * Constructs a new Duration.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.IDuration);

        /** Duration seconds. */
        public seconds: (number|Long);

        /**
         * Creates a new Duration instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Duration instance
         */
        public static create(properties?: proto.IDuration): proto.Duration;

        /**
         * Encodes the specified Duration message. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @param message Duration message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.IDuration, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Duration message, length delimited. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @param message Duration message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.IDuration, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Duration;

        /**
         * Decodes a Duration message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Duration;

        /**
         * Verifies a Duration message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Duration message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns Duration
         */
        public static fromObject(object: { [k: string]: any }): proto.Duration;

        /**
         * Creates a plain object from a Duration message. Also converts values to other types if specified.
         * @param message Duration
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.Duration, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Duration to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a CryptoCreateTransactionBody. */
    interface ICryptoCreateTransactionBody {

        /** CryptoCreateTransactionBody key */
        key?: (proto.IKey|null);

        /** CryptoCreateTransactionBody initialBalance */
        initialBalance?: (number|Long|null);

        /** CryptoCreateTransactionBody proxyAccountID */
        proxyAccountID?: (proto.IAccountID|null);

        /** CryptoCreateTransactionBody sendRecordThreshold */
        sendRecordThreshold?: (number|Long|null);

        /** CryptoCreateTransactionBody receiveRecordThreshold */
        receiveRecordThreshold?: (number|Long|null);

        /** CryptoCreateTransactionBody receiverSigRequired */
        receiverSigRequired?: (boolean|null);

        /** CryptoCreateTransactionBody autoRenewPeriod */
        autoRenewPeriod?: (proto.IDuration|null);

        /** CryptoCreateTransactionBody shardID */
        shardID?: (proto.IShardID|null);

        /** CryptoCreateTransactionBody realmID */
        realmID?: (proto.IRealmID|null);

        /** CryptoCreateTransactionBody newRealmAdminKey */
        newRealmAdminKey?: (proto.IKey|null);

        /** CryptoCreateTransactionBody memo */
        memo?: (string|null);
    }

    /** Represents a CryptoCreateTransactionBody. */
    class CryptoCreateTransactionBody implements ICryptoCreateTransactionBody {

        /**
         * Constructs a new CryptoCreateTransactionBody.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ICryptoCreateTransactionBody);

        /** CryptoCreateTransactionBody key. */
        public key?: (proto.IKey|null);

        /** CryptoCreateTransactionBody initialBalance. */
        public initialBalance: (number|Long);

        /** CryptoCreateTransactionBody proxyAccountID. */
        public proxyAccountID?: (proto.IAccountID|null);

        /** CryptoCreateTransactionBody sendRecordThreshold. */
        public sendRecordThreshold: (number|Long);

        /** CryptoCreateTransactionBody receiveRecordThreshold. */
        public receiveRecordThreshold: (number|Long);

        /** CryptoCreateTransactionBody receiverSigRequired. */
        public receiverSigRequired: boolean;

        /** CryptoCreateTransactionBody autoRenewPeriod. */
        public autoRenewPeriod?: (proto.IDuration|null);

        /** CryptoCreateTransactionBody shardID. */
        public shardID?: (proto.IShardID|null);

        /** CryptoCreateTransactionBody realmID. */
        public realmID?: (proto.IRealmID|null);

        /** CryptoCreateTransactionBody newRealmAdminKey. */
        public newRealmAdminKey?: (proto.IKey|null);

        /** CryptoCreateTransactionBody memo. */
        public memo: string;

        /**
         * Creates a new CryptoCreateTransactionBody instance using the specified properties.
         * @param [properties] Properties to set
         * @returns CryptoCreateTransactionBody instance
         */
        public static create(properties?: proto.ICryptoCreateTransactionBody): proto.CryptoCreateTransactionBody;

        /**
         * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @param message CryptoCreateTransactionBody message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ICryptoCreateTransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified CryptoCreateTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @param message CryptoCreateTransactionBody message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ICryptoCreateTransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.CryptoCreateTransactionBody;

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.CryptoCreateTransactionBody;

        /**
         * Verifies a CryptoCreateTransactionBody message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a CryptoCreateTransactionBody message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns CryptoCreateTransactionBody
         */
        public static fromObject(object: { [k: string]: any }): proto.CryptoCreateTransactionBody;

        /**
         * Creates a plain object from a CryptoCreateTransactionBody message. Also converts values to other types if specified.
         * @param message CryptoCreateTransactionBody
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.CryptoCreateTransactionBody, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this CryptoCreateTransactionBody to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a CryptoTransferTransactionBody. */
    interface ICryptoTransferTransactionBody {

        /** CryptoTransferTransactionBody transfers */
        transfers?: (proto.ITransferList|null);

        /** CryptoTransferTransactionBody tokenTransfers */
        tokenTransfers?: (proto.ITokenTransferList[]|null);
    }

    /** Represents a CryptoTransferTransactionBody. */
    class CryptoTransferTransactionBody implements ICryptoTransferTransactionBody {

        /**
         * Constructs a new CryptoTransferTransactionBody.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ICryptoTransferTransactionBody);

        /** CryptoTransferTransactionBody transfers. */
        public transfers?: (proto.ITransferList|null);

        /** CryptoTransferTransactionBody tokenTransfers. */
        public tokenTransfers: proto.ITokenTransferList[];

        /**
         * Creates a new CryptoTransferTransactionBody instance using the specified properties.
         * @param [properties] Properties to set
         * @returns CryptoTransferTransactionBody instance
         */
        public static create(properties?: proto.ICryptoTransferTransactionBody): proto.CryptoTransferTransactionBody;

        /**
         * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @param message CryptoTransferTransactionBody message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ICryptoTransferTransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified CryptoTransferTransactionBody message, length delimited. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @param message CryptoTransferTransactionBody message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ICryptoTransferTransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.CryptoTransferTransactionBody;

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.CryptoTransferTransactionBody;

        /**
         * Verifies a CryptoTransferTransactionBody message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a CryptoTransferTransactionBody message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns CryptoTransferTransactionBody
         */
        public static fromObject(object: { [k: string]: any }): proto.CryptoTransferTransactionBody;

        /**
         * Creates a plain object from a CryptoTransferTransactionBody message. Also converts values to other types if specified.
         * @param message CryptoTransferTransactionBody
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.CryptoTransferTransactionBody, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this CryptoTransferTransactionBody to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a TransactionBody. */
    interface ITransactionBody {

        /** TransactionBody transactionID */
        transactionID?: (proto.ITransactionID|null);

        /** TransactionBody nodeAccountID */
        nodeAccountID?: (proto.IAccountID|null);

        /** TransactionBody transactionFee */
        transactionFee?: (number|Long|null);

        /** TransactionBody transactionValidDuration */
        transactionValidDuration?: (proto.IDuration|null);

        /** TransactionBody generateRecord */
        generateRecord?: (boolean|null);

        /** TransactionBody memo */
        memo?: (string|null);

        /** TransactionBody cryptoCreateAccount */
        cryptoCreateAccount?: (proto.ICryptoCreateTransactionBody|null);

        /** TransactionBody cryptoTransfer */
        cryptoTransfer?: (proto.ICryptoTransferTransactionBody|null);
    }

    /** Represents a TransactionBody. */
    class TransactionBody implements ITransactionBody {

        /**
         * Constructs a new TransactionBody.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITransactionBody);

        /** TransactionBody transactionID. */
        public transactionID?: (proto.ITransactionID|null);

        /** TransactionBody nodeAccountID. */
        public nodeAccountID?: (proto.IAccountID|null);

        /** TransactionBody transactionFee. */
        public transactionFee: (number|Long);

        /** TransactionBody transactionValidDuration. */
        public transactionValidDuration?: (proto.IDuration|null);

        /** TransactionBody generateRecord. */
        public generateRecord: boolean;

        /** TransactionBody memo. */
        public memo: string;

        /** TransactionBody cryptoCreateAccount. */
        public cryptoCreateAccount?: (proto.ICryptoCreateTransactionBody|null);

        /** TransactionBody cryptoTransfer. */
        public cryptoTransfer?: (proto.ICryptoTransferTransactionBody|null);

        /** TransactionBody data. */
        public data?: ("cryptoCreateAccount"|"cryptoTransfer");

        /**
         * Creates a new TransactionBody instance using the specified properties.
         * @param [properties] Properties to set
         * @returns TransactionBody instance
         */
        public static create(properties?: proto.ITransactionBody): proto.TransactionBody;

        /**
         * Encodes the specified TransactionBody message. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @param message TransactionBody message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified TransactionBody message, length delimited. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @param message TransactionBody message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a TransactionBody message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.TransactionBody;

        /**
         * Decodes a TransactionBody message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.TransactionBody;

        /**
         * Verifies a TransactionBody message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a TransactionBody message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns TransactionBody
         */
        public static fromObject(object: { [k: string]: any }): proto.TransactionBody;

        /**
         * Creates a plain object from a TransactionBody message. Also converts values to other types if specified.
         * @param message TransactionBody
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.TransactionBody, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this TransactionBody to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a Transaction. */
    interface ITransaction {

        /** Transaction signedTransactionBytes */
        signedTransactionBytes?: (Uint8Array|null);

        /** Transaction bodyBytes */
        bodyBytes?: (Uint8Array|null);

        /** Transaction sigMap */
        sigMap?: (proto.ISignatureMap|null);
    }

    /** Represents a Transaction. */
    class Transaction implements ITransaction {

        /**
         * Constructs a new Transaction.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ITransaction);

        /** Transaction signedTransactionBytes. */
        public signedTransactionBytes: Uint8Array;

        /** Transaction bodyBytes. */
        public bodyBytes: Uint8Array;

        /** Transaction sigMap. */
        public sigMap?: (proto.ISignatureMap|null);

        /**
         * Creates a new Transaction instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Transaction instance
         */
        public static create(properties?: proto.ITransaction): proto.Transaction;

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @param message Transaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @param message Transaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.Transaction;

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.Transaction;

        /**
         * Verifies a Transaction message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns Transaction
         */
        public static fromObject(object: { [k: string]: any }): proto.Transaction;

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @param message Transaction
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Transaction to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a SignedTransaction. */
    interface ISignedTransaction {

        /** SignedTransaction bodyBytes */
        bodyBytes?: (Uint8Array|null);

        /** SignedTransaction sigMap */
        sigMap?: (proto.ISignatureMap|null);
    }

    /** Represents a SignedTransaction. */
    class SignedTransaction implements ISignedTransaction {

        /**
         * Constructs a new SignedTransaction.
         * @param [properties] Properties to set
         */
        constructor(properties?: proto.ISignedTransaction);

        /** SignedTransaction bodyBytes. */
        public bodyBytes: Uint8Array;

        /** SignedTransaction sigMap. */
        public sigMap?: (proto.ISignatureMap|null);

        /**
         * Creates a new SignedTransaction instance using the specified properties.
         * @param [properties] Properties to set
         * @returns SignedTransaction instance
         */
        public static create(properties?: proto.ISignedTransaction): proto.SignedTransaction;

        /**
         * Encodes the specified SignedTransaction message. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @param message SignedTransaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: proto.ISignedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified SignedTransaction message, length delimited. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @param message SignedTransaction message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: proto.ISignedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): proto.SignedTransaction;

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): proto.SignedTransaction;

        /**
         * Verifies a SignedTransaction message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a SignedTransaction message from a plain object. Also converts values to their respective internal types.
         * @param object Plain object
         * @returns SignedTransaction
         */
        public static fromObject(object: { [k: string]: any }): proto.SignedTransaction;

        /**
         * Creates a plain object from a SignedTransaction message. Also converts values to other types if specified.
         * @param message SignedTransaction
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: proto.SignedTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this SignedTransaction to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }
}
