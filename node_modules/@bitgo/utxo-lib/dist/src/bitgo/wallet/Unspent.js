"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignatureWithUnspent = exports.signInputWithUnspent = exports.isWalletUnspent = void 0;
const outputScripts_1 = require("../outputScripts");
const address_1 = require("../../address");
const signature_1 = require("../signature");
const Unspent_1 = require("../Unspent");
function isWalletUnspent(u) {
    return u.chain !== undefined;
}
exports.isWalletUnspent = isWalletUnspent;
function signInputWithUnspent(txBuilder, inputIndex, unspent, unspentSigner) {
    const { walletKeys, signer, cosigner } = unspentSigner.deriveForChainAndIndex(unspent.chain, unspent.index);
    const scriptType = outputScripts_1.scriptTypeForChain(unspent.chain);
    const pubScript = outputScripts_1.createOutputScript2of3(walletKeys.publicKeys, scriptType).scriptPubKey;
    const pubScriptExpected = address_1.toOutputScript(unspent.address, txBuilder.network);
    if (!pubScript.equals(pubScriptExpected)) {
        throw new Error(`pubscript mismatch: expected ${pubScriptExpected.toString('hex')} got ${pubScript.toString('hex')}`);
    }
    signature_1.signInput2Of3(txBuilder, inputIndex, scriptType, walletKeys.publicKeys, signer, cosigner.publicKey, unspent.value);
}
exports.signInputWithUnspent = signInputWithUnspent;
/**
 * @param tx
 * @param inputIndex
 * @param unspents
 * @param walletKeys
 * @return triple of booleans indicating a valid signature for each pubkey
 */
function verifySignatureWithUnspent(tx, inputIndex, unspents, walletKeys) {
    if (tx.ins.length !== unspents.length) {
        throw new Error(`input length must match unspents length`);
    }
    const unspent = unspents[inputIndex];
    if (!isWalletUnspent(unspent)) {
        return [false, false, false];
    }
    return signature_1.verifySignatureWithPublicKeys(tx, inputIndex, unspents.map((u) => Unspent_1.toOutput(u, tx.network)), walletKeys.deriveForChainAndIndex(unspent.chain, unspent.index).publicKeys);
}
exports.verifySignatureWithUnspent = verifySignatureWithUnspent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVW5zcGVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby93YWxsZXQvVW5zcGVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxvREFBOEU7QUFDOUUsMkNBQStDO0FBQy9DLDRDQUE0RTtBQUs1RSx3Q0FBK0M7QUFRL0MsU0FBZ0IsZUFBZSxDQUFDLENBQVU7SUFDeEMsT0FBUSxDQUFtQixDQUFDLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDbEQsQ0FBQztBQUZELDBDQUVDO0FBRUQsU0FBZ0Isb0JBQW9CLENBQ2xDLFNBQWlDLEVBQ2pDLFVBQWtCLEVBQ2xCLE9BQXNCLEVBQ3RCLGFBQWtEO0lBRWxELE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1RyxNQUFNLFVBQVUsR0FBRyxrQ0FBa0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckQsTUFBTSxTQUFTLEdBQUcsc0NBQXNCLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFDekYsTUFBTSxpQkFBaUIsR0FBRyx3QkFBYyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLE9BQWtCLENBQUMsQ0FBQztJQUN4RixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1FBQ3hDLE1BQU0sSUFBSSxLQUFLLENBQ2IsZ0NBQWdDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQ3JHLENBQUM7S0FDSDtJQUNELHlCQUFhLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckgsQ0FBQztBQWhCRCxvREFnQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQiwwQkFBMEIsQ0FDeEMsRUFBbUIsRUFDbkIsVUFBa0IsRUFDbEIsUUFBbUIsRUFDbkIsVUFBMEI7SUFFMUIsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTSxFQUFFO1FBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztLQUM1RDtJQUNELE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyQyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzdCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQzlCO0lBQ0QsT0FBTyx5Q0FBNkIsQ0FDbEMsRUFBRSxFQUNGLFVBQVUsRUFDVixRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxrQkFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsRUFDNUMsVUFBVSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLFVBQVUsQ0FDeEQsQ0FBQztBQUN2QixDQUFDO0FBbkJELGdFQW1CQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5ldHdvcmsgfSBmcm9tICcuLi8uLic7XG5pbXBvcnQgeyBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi4vVXR4b1RyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQgeyBjcmVhdGVPdXRwdXRTY3JpcHQyb2YzLCBzY3JpcHRUeXBlRm9yQ2hhaW4gfSBmcm9tICcuLi9vdXRwdXRTY3JpcHRzJztcbmltcG9ydCB7IHRvT3V0cHV0U2NyaXB0IH0gZnJvbSAnLi4vLi4vYWRkcmVzcyc7XG5pbXBvcnQgeyBzaWduSW5wdXQyT2YzLCB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5cyB9IGZyb20gJy4uL3NpZ25hdHVyZSc7XG5pbXBvcnQgeyBXYWxsZXRVbnNwZW50U2lnbmVyIH0gZnJvbSAnLi9XYWxsZXRVbnNwZW50U2lnbmVyJztcbmltcG9ydCB7IFJvb3RXYWxsZXRLZXlzIH0gZnJvbSAnLi9XYWxsZXRLZXlzJztcbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbiB9IGZyb20gJy4uL1V0eG9UcmFuc2FjdGlvbic7XG5pbXBvcnQgeyBUcmlwbGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB0b091dHB1dCwgVW5zcGVudCB9IGZyb20gJy4uL1Vuc3BlbnQnO1xuaW1wb3J0IHsgQ2hhaW5Db2RlIH0gZnJvbSAnLi9jaGFpbnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldFVuc3BlbnQgZXh0ZW5kcyBVbnNwZW50IHtcbiAgY2hhaW46IENoYWluQ29kZTtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2FsbGV0VW5zcGVudCh1OiBVbnNwZW50KTogdSBpcyBXYWxsZXRVbnNwZW50IHtcbiAgcmV0dXJuICh1IGFzIFdhbGxldFVuc3BlbnQpLmNoYWluICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaWduSW5wdXRXaXRoVW5zcGVudChcbiAgdHhCdWlsZGVyOiBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyLFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHVuc3BlbnQ6IFdhbGxldFVuc3BlbnQsXG4gIHVuc3BlbnRTaWduZXI6IFdhbGxldFVuc3BlbnRTaWduZXI8Um9vdFdhbGxldEtleXM+XG4pOiB2b2lkIHtcbiAgY29uc3QgeyB3YWxsZXRLZXlzLCBzaWduZXIsIGNvc2lnbmVyIH0gPSB1bnNwZW50U2lnbmVyLmRlcml2ZUZvckNoYWluQW5kSW5kZXgodW5zcGVudC5jaGFpbiwgdW5zcGVudC5pbmRleCk7XG4gIGNvbnN0IHNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlRm9yQ2hhaW4odW5zcGVudC5jaGFpbik7XG4gIGNvbnN0IHB1YlNjcmlwdCA9IGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMod2FsbGV0S2V5cy5wdWJsaWNLZXlzLCBzY3JpcHRUeXBlKS5zY3JpcHRQdWJLZXk7XG4gIGNvbnN0IHB1YlNjcmlwdEV4cGVjdGVkID0gdG9PdXRwdXRTY3JpcHQodW5zcGVudC5hZGRyZXNzLCB0eEJ1aWxkZXIubmV0d29yayBhcyBOZXR3b3JrKTtcbiAgaWYgKCFwdWJTY3JpcHQuZXF1YWxzKHB1YlNjcmlwdEV4cGVjdGVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBwdWJzY3JpcHQgbWlzbWF0Y2g6IGV4cGVjdGVkICR7cHViU2NyaXB0RXhwZWN0ZWQudG9TdHJpbmcoJ2hleCcpfSBnb3QgJHtwdWJTY3JpcHQudG9TdHJpbmcoJ2hleCcpfWBcbiAgICApO1xuICB9XG4gIHNpZ25JbnB1dDJPZjModHhCdWlsZGVyLCBpbnB1dEluZGV4LCBzY3JpcHRUeXBlLCB3YWxsZXRLZXlzLnB1YmxpY0tleXMsIHNpZ25lciwgY29zaWduZXIucHVibGljS2V5LCB1bnNwZW50LnZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdHhcbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gdW5zcGVudHNcbiAqIEBwYXJhbSB3YWxsZXRLZXlzXG4gKiBAcmV0dXJuIHRyaXBsZSBvZiBib29sZWFucyBpbmRpY2F0aW5nIGEgdmFsaWQgc2lnbmF0dXJlIGZvciBlYWNoIHB1YmtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlV2l0aFVuc3BlbnQoXG4gIHR4OiBVdHhvVHJhbnNhY3Rpb24sXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgdW5zcGVudHM6IFVuc3BlbnRbXSxcbiAgd2FsbGV0S2V5czogUm9vdFdhbGxldEtleXNcbik6IFRyaXBsZTxib29sZWFuPiB7XG4gIGlmICh0eC5pbnMubGVuZ3RoICE9PSB1bnNwZW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGxlbmd0aCBtdXN0IG1hdGNoIHVuc3BlbnRzIGxlbmd0aGApO1xuICB9XG4gIGNvbnN0IHVuc3BlbnQgPSB1bnNwZW50c1tpbnB1dEluZGV4XTtcbiAgaWYgKCFpc1dhbGxldFVuc3BlbnQodW5zcGVudCkpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICB9XG4gIHJldHVybiB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5cyhcbiAgICB0eCxcbiAgICBpbnB1dEluZGV4LFxuICAgIHVuc3BlbnRzLm1hcCgodSkgPT4gdG9PdXRwdXQodSwgdHgubmV0d29yaykpLFxuICAgIHdhbGxldEtleXMuZGVyaXZlRm9yQ2hhaW5BbmRJbmRleCh1bnNwZW50LmNoYWluLCB1bnNwZW50LmluZGV4KS5wdWJsaWNLZXlzXG4gICkgYXMgVHJpcGxlPGJvb2xlYW4+O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2VkIGluIGNlcnRhaW4gbGVnYWN5IHNpZ25pbmcgbWV0aG9kcyB0aGF0IGRvIG5vdCBkZXJpdmUgc2lnbmluZyBkYXRhIGZyb20gaW5kZXgvY2hhaW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRVbnNwZW50TGVnYWN5IGV4dGVuZHMgV2FsbGV0VW5zcGVudCB7XG4gIC8qKiBAZGVwcmVjYXRlZCAtIG9idmlhdGVkIGJ5IHNpZ25XaXRoVW5zcGVudCAqL1xuICByZWRlZW1TY3JpcHQ/OiBzdHJpbmc7XG4gIC8qKiBAZGVwcmVjYXRlZCAtIG9idmlhdGVkIGJ5IHZlcmlmeVdpdGhVbnNwZW50ICovXG4gIHdpdG5lc3NTY3JpcHQ/OiBzdHJpbmc7XG59XG4iXX0=