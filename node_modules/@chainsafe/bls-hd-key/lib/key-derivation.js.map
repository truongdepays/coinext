{"version":3,"sources":["../src/key-derivation.ts"],"names":["ikmToLamportSK","ikm","salt","bIKM","Buffer","from","prk","HKDF","extract","SHA256","okm","expand","alloc","Array","length","_","i","slice","parentSKToLamportPK","parentSK","index","BN","toArrayLike","lamport0","notIkm","map","value","lamport1","lamportPK","concat","digest","hkdfModR","keyInfo","okmBN","r","mod","toArray","deriveChildSK","isBuffer","Error","Number","isSafeInteger","compressedLamportPK","deriveMasterSK","deriveChildSKMultiple","indices","key","forEach"],"mappings":"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","sourcesContent":["import SHA256 from \"bcrypto/lib/sha256\";\nimport HKDF from \"bcrypto/lib/hkdf\";\nimport BN from \"bn.js\";\nimport {Buffer} from \"buffer\";\n\nfunction ikmToLamportSK(ikm: Buffer, salt: Buffer): Buffer[] {\n  const bIKM = Buffer.from(ikm);\n  const prk = HKDF.extract(SHA256, bIKM, salt);\n  const okm = HKDF.expand(SHA256, prk, Buffer.alloc(0), 8160); // 8160 = 255 * 32\n  return Array.from({length: 255}, (_, i) => okm.slice(i*32, (i+1)*32));\n}\n\nfunction parentSKToLamportPK(parentSK: Buffer, index: number): Buffer {\n  const salt = (new BN(index)).toArrayLike(Buffer, \"be\", 4);\n  const ikm = Buffer.from(parentSK);\n  const lamport0 = ikmToLamportSK(ikm, salt);\n  const notIkm = Buffer.from(ikm.map((value) => ~value));\n  const lamport1 = ikmToLamportSK(notIkm, salt);\n  const lamportPK = lamport0.concat(lamport1).map((value) => SHA256.digest(value));\n  return SHA256.digest(Buffer.concat(lamportPK));\n}\n\nfunction hkdfModR(ikm: Buffer, keyInfo: Buffer = Buffer.alloc(0)): Buffer {\n  const prk = HKDF.extract(\n    SHA256,\n    Buffer.concat([ikm, Buffer.alloc(1)]),\n    Buffer.from(\"BLS-SIG-KEYGEN-SALT-\", \"ascii\")\n  );\n  const okm = HKDF.expand(SHA256, prk, Buffer.concat([keyInfo, Buffer.from([0, 48])]), 48);\n  const okmBN = new BN(okm, \"hex\", \"be\");\n  const r = new BN(\"52435875175126190479447740508185965837690552500527637822603658699938581184513\");\n  return Buffer.from(okmBN.mod(r).toArray(\"be\", 32));\n}\n\nexport function deriveChildSK(parentSK: Buffer, index: number): Buffer {\n  if (!Buffer.isBuffer(parentSK) || parentSK.length !== 32) {\n    throw new Error(\"parentSK must be a Buffer of 32 bytes\");\n  }\n  if (!Number.isSafeInteger(index) || index < 0 || index >= 2 ** 32) {\n    throw new Error(\"index must be 0 <= i < 2**32\");\n  }\n  const compressedLamportPK = parentSKToLamportPK(parentSK, index);\n  return hkdfModR(compressedLamportPK);\n}\n\nexport function deriveMasterSK(ikm: Buffer): Buffer {\n  if (!Buffer.isBuffer(ikm)) {\n    throw new Error(\"ikm must be a Buffer\");\n  }\n  if (ikm.length < 32) {\n    throw new Error(\"ikm must be >= 32 bytes\");\n  }\n  return hkdfModR(ikm);\n}\n\nexport function deriveChildSKMultiple(parentSK: Buffer, indices: number[]): Buffer {\n  let key = parentSK;\n  indices.forEach(i => key = deriveChildSK(key, i));\n  return key;\n}\n"],"file":"key-derivation.js"}