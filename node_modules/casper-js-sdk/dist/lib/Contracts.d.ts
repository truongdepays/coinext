import { CLPublicKey } from '../index';
import * as DeployUtil from './DeployUtil';
import { RuntimeArgs } from './RuntimeArgs';
import { AsymmetricKey } from './Keys';
/**
 * Use blake2b to compute hash of ByteArray
 *
 * @param x
 */
export declare function byteHash(x: Uint8Array): Uint8Array;
export declare class Contract {
    private sessionWasm;
    private paymentWasm;
    /**
     *
     * @param sessionPath
     * @param paymentPath the path of payment contract file, set it undefined if you want use standard payment
     */
    constructor(sessionPath: string, paymentPath?: string);
    /**
     * Generate the Deploy message for this contract
     *
     * @param args Arguments
     * @param paymentAmount
     * @param accountPublicKey
     * @param signingKeyPair key pair to sign the deploy
     * @param chainName
     */
    deploy(args: RuntimeArgs, paymentAmount: bigint, accountPublicKey: CLPublicKey, signingKeyPair: AsymmetricKey, chainName: string): DeployUtil.Deploy;
}
/**
 * Always use the same account for deploying and signing.
 */
export declare class BoundContract {
    private contract;
    private contractKeyPair;
    constructor(contract: Contract, contractKeyPair: AsymmetricKey);
    deploy(args: RuntimeArgs, paymentAmount: bigint, chainName: string): DeployUtil.Deploy;
}
export declare class Faucet {
    /**
     * Arguments for Faucet smart contract
     *
     * @param accountPublicKeyHash the public key hash that want to be funded
     */
    static args(accountPublicKeyHash: Uint8Array): RuntimeArgs;
}
export declare class Transfer {
    /**
     * Arguments for Transfer smart contract
     *
     * @param accountPublicKeyHash the target account to transfer tokens
     * @param amount the amount of tokens to transfer
     */
    static args(accountPublicKeyHash: Uint8Array, amount: bigint): RuntimeArgs;
}
