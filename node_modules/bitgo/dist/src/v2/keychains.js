"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keychains = exports.KeyIndices = void 0;
const _ = require("lodash");
const util_1 = require("./internal/util");
const sdk_core_1 = require("@bitgo/sdk-core");
const tssUtils_1 = require("./internal/tssUtils");
const blsUtils_1 = require("./internal/blsUtils");
const { validateParams } = sdk_core_1.common;
var KeyIndices;
(function (KeyIndices) {
    KeyIndices[KeyIndices["USER"] = 0] = "USER";
    KeyIndices[KeyIndices["BACKUP"] = 1] = "BACKUP";
    KeyIndices[KeyIndices["BITGO"] = 2] = "BITGO";
})(KeyIndices = exports.KeyIndices || (exports.KeyIndices = {}));
class Keychains {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a keychain by ID
     * @param params
     * @param params.id
     * @param params.xpub (optional)
     * @param params.ethAddress (optional)
     * @param params.reqId (optional)
     */
    async get(params) {
        validateParams(params, [], ['xpub', 'ethAddress']);
        if (_.isUndefined(params.id)) {
            throw new Error('id must be defined');
        }
        const id = params.id;
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo.get(this.baseCoin.url('/key/' + encodeURIComponent(id))).result();
    }
    /**
     * list the users keychains
     * @param params
     * @param params.limit - Max number of results in a single call.
     * @param params.prevId - Continue iterating (provided by nextBatchPrevId in the previous list)
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (!_.isUndefined(params.limit)) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        return this.bitgo.get(this.baseCoin.url('/key')).query(queryObject).result();
    }
    /**
     * Change the decryption password for all possible keychains associated with a user.
     *
     * This function iterates through all keys associated with the user, decrypts
     * them with the old password and re-encrypts them with the new password.
     *
     * This should be called when a user changes their login password, and are expecting
     * that their wallet passwords are changed to match the new login password.
     *
     * @param params
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns changedKeys Object - e.g.:
     *  {
     *    xpub1: encryptedPrv,
     *    ...
     *  }
     */
    async updatePassword(params) {
        validateParams(params, ['oldPassword', 'newPassword'], []);
        const changedKeys = {};
        let prevId;
        let keysLeft = true;
        while (keysLeft) {
            const result = await this.list({ limit: 500, prevId });
            for (const key of result.keys) {
                const oldEncryptedPrv = key.encryptedPrv;
                if (_.isUndefined(oldEncryptedPrv)) {
                    continue;
                }
                try {
                    const updatedKeychain = this.updateSingleKeychainPassword({
                        keychain: key,
                        oldPassword: params.oldPassword,
                        newPassword: params.newPassword,
                    });
                    if (updatedKeychain.encryptedPrv) {
                        changedKeys[updatedKeychain.pub] = updatedKeychain.encryptedPrv;
                    }
                }
                catch (e) {
                    // if the password was incorrect, silence the error, throw otherwise
                    if (!e.message.includes('private key is incorrect')) {
                        throw e;
                    }
                }
            }
            if (result.nextBatchPrevId) {
                prevId = result.nextBatchPrevId;
            }
            else {
                keysLeft = false;
            }
        }
        return changedKeys;
    }
    /**
     * Update the password used to decrypt a single keychain
     * @param params
     * @param params.keychain - The keychain whose password should be updated
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns {object}
     */
    updateSingleKeychainPassword(params = {}) {
        if (!_.isString(params.oldPassword)) {
            throw new Error('expected old password to be a string');
        }
        if (!_.isString(params.newPassword)) {
            throw new Error('expected new password to be a string');
        }
        if (!_.isObject(params.keychain) || !_.isString(params.keychain.encryptedPrv)) {
            throw new Error('expected keychain to be an object with an encryptedPrv property');
        }
        const oldEncryptedPrv = params.keychain.encryptedPrv;
        try {
            const decryptedPrv = this.bitgo.decrypt({ input: oldEncryptedPrv, password: params.oldPassword });
            const newEncryptedPrv = this.bitgo.encrypt({ input: decryptedPrv, password: params.newPassword });
            return _.assign({}, params.keychain, { encryptedPrv: newEncryptedPrv });
        }
        catch (e) {
            // catching an error here means that the password was incorrect or, less likely, the input to decrypt is corrupted
            throw new Error('password used to decrypt keychain private key is incorrect');
        }
    }
    /**
     * Create a public/private key pair
     * @param params.seed
     */
    create(params = {}) {
        return this.baseCoin.generateKeyPair(params.seed);
    }
    /**
     * Add a keychain to BitGo's records
     * @param params
     */
    async add(params = {}) {
        params = params || {};
        validateParams(params, [], ['pub', 'encryptedPrv', 'type', 'source', 'originalPasscodeEncryptionCode', 'enterprise', 'derivedFromParentWithSeed']);
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo.post(this.baseCoin.url('/key'))
            .send({
            pub: params.pub,
            commonPub: params.commonPub,
            commonKeychain: params.commonKeychain,
            encryptedPrv: params.encryptedPrv,
            type: params.type,
            source: params.source,
            provider: params.provider,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            enterprise: params.enterprise,
            derivedFromParentWithSeed: params.derivedFromParentWithSeed,
            disableKRSEmail: params.disableKRSEmail,
            krsSpecific: params.krsSpecific,
            keyShares: params.keyShares,
            userGPGPublicKey: params.userGPGPublicKey,
            backupGPGPublicKey: params.backupGPGPublicKey,
        })
            .result();
    }
    /**
     * Create a BitGo key
     * @param params (empty)
     */
    async createBitGo(params = {}) {
        params.source = 'bitgo';
        this.baseCoin.preCreateBitGo(params);
        return await this.add(params);
    }
    /**
     * Create a backup key
     * @param params
     * @param params.provider (optional)
     */
    async createBackup(params = {}) {
        params.source = 'backup';
        const isTssBackupKey = params.prv && params.encryptedPrv &&
            (params.commonKeychain || params.commonPub);
        if (_.isUndefined(params.provider) && !isTssBackupKey) {
            // if the provider is undefined, we generate a local key and add the source details
            const key = this.create();
            _.extend(params, key);
        }
        const serverResponse = await this.add(params);
        return _.extend({}, serverResponse, _.pick(params, ['prv', 'encryptedPrv', 'provider', 'source']));
    }
    /**
     * Gets keys for signing from a wallet
     * @param params
     * @returns {Promise<Keychain[]>}
     */
    async getKeysForSigning(params = {}) {
        if (!_.isObject(params.wallet)) {
            throw new Error('missing required param wallet');
        }
        const wallet = params.wallet;
        const reqId = params.reqId || new util_1.RequestTracer();
        const ids = wallet.baseCoin.keyIdsForSigning();
        const keychainQueriesBluebirds = ids.map((id) => this.get({ id: wallet.keyIds()[id], reqId }));
        return Promise.all(keychainQueriesBluebirds);
    }
    /**
     * Convenience function to create and store MPC keychains with BitGo.
     * @param params passphrase used to encrypt secret materials
     * @return {Promise<KeychainsTriplet>} newly created User, Backup, and BitGo keys
     */
    async createMpc(params) {
        if (_.isUndefined(params.passphrase)) {
            throw new Error('missing required param passphrase');
        }
        let MpcUtils;
        switch (params.multisigType) {
            case 'tss':
                MpcUtils = tssUtils_1.TssUtils;
                break;
            case 'blsdkg':
                MpcUtils = blsUtils_1.BlsUtils;
                break;
            default:
                throw new Error('Unsupported multi-sig type');
        }
        const mpcUtils = new MpcUtils(this.bitgo, this.baseCoin);
        return await mpcUtils.createKeychains({
            passphrase: params.passphrase,
            enterprise: params.enterprise,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
        });
    }
}
exports.Keychains = Keychains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL2tleWNoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0QkFBNEI7QUFLNUIsMENBQWdEO0FBQ2hELDhDQUF5QztBQUN6QyxrREFBK0M7QUFDL0Msa0RBQStDO0FBRS9DLE1BQU0sRUFBRSxjQUFjLEVBQUUsR0FBRyxpQkFBTSxDQUFDO0FBdUdsQyxJQUFZLFVBSVg7QUFKRCxXQUFZLFVBQVU7SUFDcEIsMkNBQVEsQ0FBQTtJQUNSLCtDQUFVLENBQUE7SUFDViw2Q0FBUyxDQUFBO0FBQ1gsQ0FBQyxFQUpXLFVBQVUsR0FBVixrQkFBVSxLQUFWLGtCQUFVLFFBSXJCO0FBRUQsTUFBYSxTQUFTO0lBS3BCLFlBQVksS0FBWSxFQUFFLFFBQWtCO1FBQzFDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUEwQjtRQUNsQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBRW5ELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNyQixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUE4QixFQUFFO1FBQ3pDLE1BQU0sV0FBVyxHQUFRLEVBQUUsQ0FBQztRQUU1QixJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7YUFDN0Q7WUFDRCxXQUFXLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDbEM7UUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7YUFDOUQ7WUFDRCxXQUFXLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDcEM7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQy9FLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkc7SUFDSCxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQTZCO1FBQ2hELGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDM0QsTUFBTSxXQUFXLEdBQXFCLEVBQUUsQ0FBQztRQUN6QyxJQUFJLE1BQU0sQ0FBQztRQUNYLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztRQUNwQixPQUFPLFFBQVEsRUFBRTtZQUNmLE1BQU0sTUFBTSxHQUF3QixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDNUUsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO2dCQUM3QixNQUFNLGVBQWUsR0FBRyxHQUFHLENBQUMsWUFBWSxDQUFDO2dCQUN6QyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLEVBQUU7b0JBQ2xDLFNBQVM7aUJBQ1Y7Z0JBQ0QsSUFBSTtvQkFDRixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsNEJBQTRCLENBQUM7d0JBQ3hELFFBQVEsRUFBRSxHQUFHO3dCQUNiLFdBQVcsRUFBRSxNQUFNLENBQUMsV0FBVzt3QkFDL0IsV0FBVyxFQUFFLE1BQU0sQ0FBQyxXQUFXO3FCQUNoQyxDQUFDLENBQUM7b0JBQ0gsSUFBSSxlQUFlLENBQUMsWUFBWSxFQUFFO3dCQUNoQyxXQUFXLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxZQUFZLENBQUM7cUJBQ2pFO2lCQUNGO2dCQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUNWLG9FQUFvRTtvQkFDcEUsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDLEVBQUU7d0JBQ25ELE1BQU0sQ0FBQyxDQUFDO3FCQUNUO2lCQUNGO2FBQ0Y7WUFDRCxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7Z0JBQzFCLE1BQU0sR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDO2FBQ2pDO2lCQUFNO2dCQUNMLFFBQVEsR0FBRyxLQUFLLENBQUM7YUFDbEI7U0FDRjtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsNEJBQTRCLENBQUMsU0FBOEMsRUFBRTtRQUMzRSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO1NBQ3pEO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ25DLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztTQUN6RDtRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUM3RSxNQUFNLElBQUksS0FBSyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7U0FDcEY7UUFFRCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUNyRCxJQUFJO1lBQ0YsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUNsRyxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1lBQ2xHLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO1NBQ3pFO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixrSEFBa0g7WUFDbEgsTUFBTSxJQUFJLEtBQUssQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO1NBQy9FO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxTQUE0QixFQUFFO1FBQ25DLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLFNBQTZCLEVBQUU7UUFDdkMsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDdEIsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsZ0NBQWdDLEVBQUUsWUFBWSxFQUFFLDJCQUEyQixDQUFDLENBQUMsQ0FBQztRQUVuSixJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDMUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxFQUFFO2dCQUN4QyxNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7YUFDeEU7U0FDRjtRQUVELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQztRQUNELE9BQU8sTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNwRCxJQUFJLENBQUM7WUFDSixHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUc7WUFDZixTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7WUFDM0IsY0FBYyxFQUFFLE1BQU0sQ0FBQyxjQUFjO1lBQ3JDLFlBQVksRUFBRSxNQUFNLENBQUMsWUFBWTtZQUNqQyxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO1lBQ3JCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtZQUN6Qiw4QkFBOEIsRUFBRSxNQUFNLENBQUMsOEJBQThCO1lBQ3JFLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3Qix5QkFBeUIsRUFBRSxNQUFNLENBQUMseUJBQXlCO1lBQzNELGVBQWUsRUFBRSxNQUFNLENBQUMsZUFBZTtZQUN2QyxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDL0IsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO1lBQzNCLGdCQUFnQixFQUFFLE1BQU0sQ0FBQyxnQkFBZ0I7WUFDekMsa0JBQWtCLEVBQUUsTUFBTSxDQUFDLGtCQUFrQjtTQUM5QyxDQUFDO2FBQ0QsTUFBTSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUE2QixFQUFFO1FBQy9DLE1BQU0sQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDO1FBRXhCLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQWEsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLFlBQVksQ0FBQyxTQUE4QixFQUFFO1FBQ2pELE1BQU0sQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDO1FBRXpCLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLFlBQVk7WUFDdEQsQ0FBQyxNQUFNLENBQUMsY0FBYyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3JELG1GQUFtRjtZQUNuRixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDMUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDdkI7UUFFRCxNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLEVBQUUsY0FBYyxFQUFFLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckcsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsaUJBQWlCLENBQUMsU0FBbUMsRUFBRTtRQUMzRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUM3QixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJLElBQUksb0JBQWEsRUFBRSxDQUFDO1FBQ2xELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUMvQyxNQUFNLHdCQUF3QixHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQ3RDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUNyRCxDQUFDO1FBQ0YsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQXdCO1FBQ3RDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsSUFBSSxRQUFRLENBQUM7UUFDYixRQUFRLE1BQU0sQ0FBQyxZQUFZLEVBQUU7WUFDM0IsS0FBSyxLQUFLO2dCQUNSLFFBQVEsR0FBRyxtQkFBUSxDQUFDO2dCQUNwQixNQUFNO1lBQ1IsS0FBSyxRQUFRO2dCQUNYLFFBQVEsR0FBRyxtQkFBUSxDQUFDO2dCQUNwQixNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDekQsT0FBTyxNQUFNLFFBQVEsQ0FBQyxlQUFlLENBQUM7WUFDcEMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1lBQzdCLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtZQUM3Qiw4QkFBOEIsRUFBRSxNQUFNLENBQUMsOEJBQThCO1NBQ3RFLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQTlRRCw4QkE4UUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcblxuaW1wb3J0IHsgQmFzZUNvaW4sIEtleWNoYWluc1RyaXBsZXQsIEtleVBhaXIgfSBmcm9tICcuL2Jhc2VDb2luJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuL2ludGVybmFsL3V0aWwnO1xuaW1wb3J0IHsgY29tbW9uIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFRzc1V0aWxzIH0gZnJvbSAnLi9pbnRlcm5hbC90c3NVdGlscyc7XG5pbXBvcnQgeyBCbHNVdGlscyB9IGZyb20gJy4vaW50ZXJuYWwvYmxzVXRpbHMnO1xuXG5jb25zdCB7IHZhbGlkYXRlUGFyYW1zIH0gPSBjb21tb247XG5leHBvcnQgaW50ZXJmYWNlIEtleWNoYWluIHtcbiAgaWQ6IHN0cmluZztcbiAgcHViOiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbiAgcHJvdmlkZXI/OiBzdHJpbmc7XG4gIGVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgZGVyaXZhdGlvblBhdGg/OiBzdHJpbmc7XG4gIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ/OiBzdHJpbmc7XG4gIGNvbW1vblB1Yj86IHN0cmluZztcbiAgY29tbW9uS2V5Y2hhaW4/OiBzdHJpbmc7XG4gIGtleVNoYXJlcz86IEtleVNoYXJlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhbmdlZEtleWNoYWlucyB7XG4gIFtwdWJrZXk6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0S2V5Y2hhaW5zUmVzdWx0IHtcbiAga2V5czogS2V5Y2hhaW5bXTtcbiAgbmV4dEJhdGNoUHJldklkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEtleWNoYWluT3B0aW9ucyB7XG4gIGlkOiBzdHJpbmc7XG4gIHhwdWI/OiBzdHJpbmc7XG4gIGV0aEFkZHJlc3M/OiBzdHJpbmc7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0S2V5Y2hhaW5PcHRpb25zIHtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHByZXZJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVQYXNzd29yZE9wdGlvbnMge1xuICBvbGRQYXNzd29yZDogc3RyaW5nO1xuICBuZXdQYXNzd29yZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZE9wdGlvbnMge1xuICBrZXljaGFpbj86IEtleWNoYWluO1xuICBvbGRQYXNzd29yZD86IHN0cmluZztcbiAgbmV3UGFzc3dvcmQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBZGRLZXljaGFpbk9wdGlvbnMge1xuICBwdWI/OiBzdHJpbmc7XG4gIGNvbW1vblB1Yj86IHN0cmluZztcbiAgY29tbW9uS2V5Y2hhaW4/OiBzdHJpbmc7XG4gIGVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgc291cmNlPzogc3RyaW5nO1xuICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ/OiBhbnk7XG4gIGRpc2FibGVLUlNFbWFpbD86IGJvb2xlYW47XG4gIHByb3ZpZGVyPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIGtyc1NwZWNpZmljPzogYW55O1xuICBrZXlTaGFyZXM/OiBLZXlTaGFyZVtdO1xuICB1c2VyR1BHUHVibGljS2V5Pzogc3RyaW5nO1xuICBiYWNrdXBHUEdQdWJsaWNLZXk/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBLZXlTaGFyZSB7XG4gIGZyb206IHN0cmluZztcbiAgdG86IHN0cmluZztcbiAgcHVibGljU2hhcmU6IHN0cmluZztcbiAgcHJpdmF0ZVNoYXJlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQmFja3VwT3B0aW9ucyB7XG4gIHByb3ZpZGVyPzogc3RyaW5nO1xuICBzb3VyY2U/OiBzdHJpbmc7XG4gIGRpc2FibGVLUlNFbWFpbD86IGJvb2xlYW47XG4gIGtyc1NwZWNpZmljPzogYW55O1xuICB0eXBlPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIGNvbW1vblB1Yj86IHN0cmluZztcbiAgY29tbW9uS2V5Y2hhaW4/OiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbiAgZW5jcnlwdGVkUHJ2Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ3JlYXRlQml0R29PcHRpb25zIHtcbiAgc291cmNlPzogJ2JpdGdvJztcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xufVxuXG5pbnRlcmZhY2UgQ3JlYXRlTXBjT3B0aW9ucyB7XG4gIG11bHRpc2lnVHlwZTogJ29uY2hhaW4nIHwgJ3RzcycgfCAnYmxzZGtnJztcbiAgcGFzc3BocmFzZTogc3RyaW5nO1xuICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBHZXRLZXlzRm9yU2lnbmluZ09wdGlvbnMge1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIHdhbGxldD86IFdhbGxldDtcbn1cblxuZXhwb3J0IGVudW0gS2V5SW5kaWNlcyB7XG4gIFVTRVIgPSAwLFxuICBCQUNLVVAgPSAxLFxuICBCSVRHTyA9IDIsXG59XG5cbmV4cG9ydCBjbGFzcyBLZXljaGFpbnMge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEga2V5Y2hhaW4gYnkgSURcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmlkXG4gICAqIEBwYXJhbSBwYXJhbXMueHB1YiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMuZXRoQWRkcmVzcyAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMucmVxSWQgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtczogR2V0S2V5Y2hhaW5PcHRpb25zKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsneHB1YicsICdldGhBZGRyZXNzJ10pO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IHBhcmFtcy5pZDtcbiAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcva2V5LycgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogbGlzdCB0aGUgdXNlcnMga2V5Y2hhaW5zXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5saW1pdCAtIE1heCBudW1iZXIgb2YgcmVzdWx0cyBpbiBhIHNpbmdsZSBjYWxsLlxuICAgKiBAcGFyYW0gcGFyYW1zLnByZXZJZCAtIENvbnRpbnVlIGl0ZXJhdGluZyAocHJvdmlkZWQgYnkgbmV4dEJhdGNoUHJldklkIGluIHRoZSBwcmV2aW91cyBsaXN0KVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGxpc3QocGFyYW1zOiBMaXN0S2V5Y2hhaW5PcHRpb25zID0ge30pOiBQcm9taXNlPExpc3RLZXljaGFpbnNSZXN1bHQ+IHtcbiAgICBjb25zdCBxdWVyeU9iamVjdDogYW55ID0ge307XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmxpbWl0KSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy9rZXknKSkucXVlcnkocXVlcnlPYmplY3QpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZGVjcnlwdGlvbiBwYXNzd29yZCBmb3IgYWxsIHBvc3NpYmxlIGtleWNoYWlucyBhc3NvY2lhdGVkIHdpdGggYSB1c2VyLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHRocm91Z2ggYWxsIGtleXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyLCBkZWNyeXB0c1xuICAgKiB0aGVtIHdpdGggdGhlIG9sZCBwYXNzd29yZCBhbmQgcmUtZW5jcnlwdHMgdGhlbSB3aXRoIHRoZSBuZXcgcGFzc3dvcmQuXG4gICAqXG4gICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGEgdXNlciBjaGFuZ2VzIHRoZWlyIGxvZ2luIHBhc3N3b3JkLCBhbmQgYXJlIGV4cGVjdGluZ1xuICAgKiB0aGF0IHRoZWlyIHdhbGxldCBwYXNzd29yZHMgYXJlIGNoYW5nZWQgdG8gbWF0Y2ggdGhlIG5ldyBsb2dpbiBwYXNzd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLm9sZFBhc3N3b3JkIC0gVGhlIG9sZCBwYXNzd29yZCB1c2VkIGZvciBlbmNyeXB0aW5nIHRoZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQgdG8gYmUgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEByZXR1cm5zIGNoYW5nZWRLZXlzIE9iamVjdCAtIGUuZy46XG4gICAqICB7XG4gICAqICAgIHhwdWIxOiBlbmNyeXB0ZWRQcnYsXG4gICAqICAgIC4uLlxuICAgKiAgfVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUGFzc3dvcmQocGFyYW1zOiBVcGRhdGVQYXNzd29yZE9wdGlvbnMpOiBQcm9taXNlPENoYW5nZWRLZXljaGFpbnM+IHtcbiAgICB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnb2xkUGFzc3dvcmQnLCAnbmV3UGFzc3dvcmQnXSwgW10pO1xuICAgIGNvbnN0IGNoYW5nZWRLZXlzOiBDaGFuZ2VkS2V5Y2hhaW5zID0ge307XG4gICAgbGV0IHByZXZJZDtcbiAgICBsZXQga2V5c0xlZnQgPSB0cnVlO1xuICAgIHdoaWxlIChrZXlzTGVmdCkge1xuICAgICAgY29uc3QgcmVzdWx0OiBMaXN0S2V5Y2hhaW5zUmVzdWx0ID0gYXdhaXQgdGhpcy5saXN0KHsgbGltaXQ6IDUwMCwgcHJldklkIH0pO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVzdWx0LmtleXMpIHtcbiAgICAgICAgY29uc3Qgb2xkRW5jcnlwdGVkUHJ2ID0ga2V5LmVuY3J5cHRlZFBydjtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob2xkRW5jcnlwdGVkUHJ2KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZEtleWNoYWluID0gdGhpcy51cGRhdGVTaW5nbGVLZXljaGFpblBhc3N3b3JkKHtcbiAgICAgICAgICAgIGtleWNoYWluOiBrZXksXG4gICAgICAgICAgICBvbGRQYXNzd29yZDogcGFyYW1zLm9sZFBhc3N3b3JkLFxuICAgICAgICAgICAgbmV3UGFzc3dvcmQ6IHBhcmFtcy5uZXdQYXNzd29yZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodXBkYXRlZEtleWNoYWluLmVuY3J5cHRlZFBydikge1xuICAgICAgICAgICAgY2hhbmdlZEtleXNbdXBkYXRlZEtleWNoYWluLnB1Yl0gPSB1cGRhdGVkS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBwYXNzd29yZCB3YXMgaW5jb3JyZWN0LCBzaWxlbmNlIHRoZSBlcnJvciwgdGhyb3cgb3RoZXJ3aXNlXG4gICAgICAgICAgaWYgKCFlLm1lc3NhZ2UuaW5jbHVkZXMoJ3ByaXZhdGUga2V5IGlzIGluY29ycmVjdCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5uZXh0QmF0Y2hQcmV2SWQpIHtcbiAgICAgICAgcHJldklkID0gcmVzdWx0Lm5leHRCYXRjaFByZXZJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXNMZWZ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhc3N3b3JkIHVzZWQgdG8gZGVjcnlwdCBhIHNpbmdsZSBrZXljaGFpblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW4gLSBUaGUga2V5Y2hhaW4gd2hvc2UgcGFzc3dvcmQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICogQHBhcmFtIHBhcmFtcy5vbGRQYXNzd29yZCAtIFRoZSBvbGQgcGFzc3dvcmQgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkIHRvIGJlIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgdXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZChwYXJhbXM6IFVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmRPcHRpb25zID0ge30pOiBLZXljaGFpbiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5vbGRQYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgb2xkIHBhc3N3b3JkIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5uZXdQYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgbmV3IHBhc3N3b3JkIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5rZXljaGFpbikgfHwgIV8uaXNTdHJpbmcocGFyYW1zLmtleWNoYWluLmVuY3J5cHRlZFBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQga2V5Y2hhaW4gdG8gYmUgYW4gb2JqZWN0IHdpdGggYW4gZW5jcnlwdGVkUHJ2IHByb3BlcnR5Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkRW5jcnlwdGVkUHJ2ID0gcGFyYW1zLmtleWNoYWluLmVuY3J5cHRlZFBydjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IG9sZEVuY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy5vbGRQYXNzd29yZCB9KTtcbiAgICAgIGNvbnN0IG5ld0VuY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7IGlucHV0OiBkZWNyeXB0ZWRQcnYsIHBhc3N3b3JkOiBwYXJhbXMubmV3UGFzc3dvcmQgfSk7XG4gICAgICByZXR1cm4gXy5hc3NpZ24oe30sIHBhcmFtcy5rZXljaGFpbiwgeyBlbmNyeXB0ZWRQcnY6IG5ld0VuY3J5cHRlZFBydiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBjYXRjaGluZyBhbiBlcnJvciBoZXJlIG1lYW5zIHRoYXQgdGhlIHBhc3N3b3JkIHdhcyBpbmNvcnJlY3Qgb3IsIGxlc3MgbGlrZWx5LCB0aGUgaW5wdXQgdG8gZGVjcnlwdCBpcyBjb3JydXB0ZWRcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmQgdXNlZCB0byBkZWNyeXB0IGtleWNoYWluIHByaXZhdGUga2V5IGlzIGluY29ycmVjdCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwdWJsaWMvcHJpdmF0ZSBrZXkgcGFpclxuICAgKiBAcGFyYW0gcGFyYW1zLnNlZWRcbiAgICovXG4gIGNyZWF0ZShwYXJhbXM6IHsgc2VlZD86IEJ1ZmZlciB9ID0ge30pOiBLZXlQYWlyIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5nZW5lcmF0ZUtleVBhaXIocGFyYW1zLnNlZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGtleWNoYWluIHRvIEJpdEdvJ3MgcmVjb3Jkc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBhZGQocGFyYW1zOiBBZGRLZXljaGFpbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydwdWInLCAnZW5jcnlwdGVkUHJ2JywgJ3R5cGUnLCAnc291cmNlJywgJ29yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZScsICdlbnRlcnByaXNlJywgJ2Rlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQnXSk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVLUlNFbWFpbCBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL2tleScpKVxuICAgICAgLnNlbmQoe1xuICAgICAgICBwdWI6IHBhcmFtcy5wdWIsXG4gICAgICAgIGNvbW1vblB1YjogcGFyYW1zLmNvbW1vblB1YixcbiAgICAgICAgY29tbW9uS2V5Y2hhaW46IHBhcmFtcy5jb21tb25LZXljaGFpbixcbiAgICAgICAgZW5jcnlwdGVkUHJ2OiBwYXJhbXMuZW5jcnlwdGVkUHJ2LFxuICAgICAgICB0eXBlOiBwYXJhbXMudHlwZSxcbiAgICAgICAgc291cmNlOiBwYXJhbXMuc291cmNlLFxuICAgICAgICBwcm92aWRlcjogcGFyYW1zLnByb3ZpZGVyLFxuICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5vcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgICBkZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkOiBwYXJhbXMuZGVyaXZlZEZyb21QYXJlbnRXaXRoU2VlZCxcbiAgICAgICAgZGlzYWJsZUtSU0VtYWlsOiBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsLFxuICAgICAgICBrcnNTcGVjaWZpYzogcGFyYW1zLmtyc1NwZWNpZmljLFxuICAgICAgICBrZXlTaGFyZXM6IHBhcmFtcy5rZXlTaGFyZXMsXG4gICAgICAgIHVzZXJHUEdQdWJsaWNLZXk6IHBhcmFtcy51c2VyR1BHUHVibGljS2V5LFxuICAgICAgICBiYWNrdXBHUEdQdWJsaWNLZXk6IHBhcmFtcy5iYWNrdXBHUEdQdWJsaWNLZXksXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJpdEdvIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zIChlbXB0eSlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJpdEdvKHBhcmFtczogQ3JlYXRlQml0R29PcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgcGFyYW1zLnNvdXJjZSA9ICdiaXRnbyc7XG5cbiAgICB0aGlzLmJhc2VDb2luLnByZUNyZWF0ZUJpdEdvKHBhcmFtcyBhcyBhbnkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkZChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnByb3ZpZGVyIChvcHRpb25hbClcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJhY2t1cChwYXJhbXM6IENyZWF0ZUJhY2t1cE9wdGlvbnMgPSB7fSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMuc291cmNlID0gJ2JhY2t1cCc7XG5cbiAgICBjb25zdCBpc1Rzc0JhY2t1cEtleSA9IHBhcmFtcy5wcnYgJiYgcGFyYW1zLmVuY3J5cHRlZFBydiAmJlxuICAgICAgKHBhcmFtcy5jb21tb25LZXljaGFpbiB8fCBwYXJhbXMuY29tbW9uUHViKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcm92aWRlcikgJiYgIWlzVHNzQmFja3VwS2V5KSB7XG4gICAgICAvLyBpZiB0aGUgcHJvdmlkZXIgaXMgdW5kZWZpbmVkLCB3ZSBnZW5lcmF0ZSBhIGxvY2FsIGtleSBhbmQgYWRkIHRoZSBzb3VyY2UgZGV0YWlsc1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgIF8uZXh0ZW5kKHBhcmFtcywga2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuYWRkKHBhcmFtcyk7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBzZXJ2ZXJSZXNwb25zZSwgXy5waWNrKHBhcmFtcywgWydwcnYnLCAnZW5jcnlwdGVkUHJ2JywgJ3Byb3ZpZGVyJywgJ3NvdXJjZSddKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBrZXlzIGZvciBzaWduaW5nIGZyb20gYSB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXljaGFpbltdPn1cbiAgICovXG4gIGFzeW5jIGdldEtleXNGb3JTaWduaW5nKHBhcmFtczogR2V0S2V5c0ZvclNpZ25pbmdPcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluW10+IHtcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLndhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSB3YWxsZXQnKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gcGFyYW1zLndhbGxldDtcbiAgICBjb25zdCByZXFJZCA9IHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIGNvbnN0IGlkcyA9IHdhbGxldC5iYXNlQ29pbi5rZXlJZHNGb3JTaWduaW5nKCk7XG4gICAgY29uc3Qga2V5Y2hhaW5RdWVyaWVzQmx1ZWJpcmRzID0gaWRzLm1hcChcbiAgICAgIChpZCkgPT4gdGhpcy5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW2lkXSwgcmVxSWQgfSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChrZXljaGFpblF1ZXJpZXNCbHVlYmlyZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbmQgc3RvcmUgTVBDIGtleWNoYWlucyB3aXRoIEJpdEdvLlxuICAgKiBAcGFyYW0gcGFyYW1zIHBhc3NwaHJhc2UgdXNlZCB0byBlbmNyeXB0IHNlY3JldCBtYXRlcmlhbHNcbiAgICogQHJldHVybiB7UHJvbWlzZTxLZXljaGFpbnNUcmlwbGV0Pn0gbmV3bHkgY3JlYXRlZCBVc2VyLCBCYWNrdXAsIGFuZCBCaXRHbyBrZXlzXG4gICAqL1xuICBhc3luYyBjcmVhdGVNcGMocGFyYW1zOiBDcmVhdGVNcGNPcHRpb25zKTogUHJvbWlzZTxLZXljaGFpbnNUcmlwbGV0PiB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnBhc3NwaHJhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gcGFzc3BocmFzZScpO1xuICAgIH1cblxuICAgIGxldCBNcGNVdGlscztcbiAgICBzd2l0Y2ggKHBhcmFtcy5tdWx0aXNpZ1R5cGUpIHtcbiAgICAgIGNhc2UgJ3Rzcyc6XG4gICAgICAgIE1wY1V0aWxzID0gVHNzVXRpbHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmxzZGtnJzpcbiAgICAgICAgTXBjVXRpbHMgPSBCbHNVdGlscztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG11bHRpLXNpZyB0eXBlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbXBjVXRpbHMgPSBuZXcgTXBjVXRpbHModGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbik7XG4gICAgcmV0dXJuIGF3YWl0IG1wY1V0aWxzLmNyZWF0ZUtleWNoYWlucyh7XG4gICAgICBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSxcbiAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMub3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIH0pO1xuICB9XG59XG4iXX0=