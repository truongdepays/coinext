"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradingAccount = void 0;
const bignumber_js_1 = require("bignumber.js");
const tradingPartners_1 = require("./tradingPartners");
const affirmations_1 = require("./affirmations");
const settlements_1 = require("./settlements");
const TRADE_PAYLOAD_VERSION = '1.2.0';
class TradingAccount {
    constructor(enterpriseId, wallet, bitgo) {
        this.enterpriseId = enterpriseId;
        this.wallet = wallet;
        this.bitgo = bitgo;
    }
    get id() {
        return this.wallet.id();
    }
    /**
     * Builds a payload authorizing trade from this trading account.
     * @param params
     * @param params.amounts[] array of amounts that will be traded as part of the settlement
     * @param params.amounts[].accountId the accountId corresponding with the sending and receiving amounts for the settlement
     * @param params.amounts[].sendAmount amount of currency sent by trading account of given accountId
     * @param params.amounts[].sendCurrency currency of amount sent by trading account of given accountId
     * @param params.amounts[].receiveAmount amount of currency received by trading account of given accountId
     * @param params.amounts[].receiveCurrency currency of amount received by trading account of given accountId
     * @returns unsigned trade payload for the given parameters. This object should be stringified with JSON.stringify() before being submitted
     */
    async buildPayload(params) {
        const url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/account/${this.id}/payload`);
        const body = {
            version: TRADE_PAYLOAD_VERSION,
            amounts: params.amounts,
        };
        const response = (await this.bitgo.post(url).send(body).result());
        if (!this.verifyPayload(params, response.payload)) {
            throw new Error('Unable to verify trade payload. You may need to update the BitGo SDK, or the payload may have been tampered with.');
        }
        return JSON.parse(response.payload);
    }
    /**
     * Verifies that a payload received from BitGo sufficiently matches the expected parameters. This is used to prevent
     * man-in-the-middle attacks which could maliciously alter the contents of a payload.
     * @param params parameters used to build the payload
     * @param payload payload received from the BitGo API
     * @returns true if the payload's sensitive fields match, false if the payload may have been tampered with
     */
    verifyPayload(params, payload) {
        const payloadObj = JSON.parse(payload);
        const paramsCopy = JSON.parse(JSON.stringify(params)); // needs to be a deep copy
        // Verifies that for each party in the payload, we requested a matching party, only checking sensitive fields
        let validAmounts = 0;
        for (const amount of payloadObj.amounts) {
            const matchingExpectedParty = paramsCopy.amounts.findIndex((expectedAmount) => amount.accountId === expectedAmount.accountId &&
                amount.sendCurrency === expectedAmount.sendCurrency &&
                amount.sendSubtotal === expectedAmount.sendAmount &&
                amount.receiveAmount === expectedAmount.receiveAmount &&
                amount.receiveCurrency === expectedAmount.receiveCurrency);
            if (matchingExpectedParty === -1) {
                // matchingExpectedParty not found to the payloadObject
                // payload is not valid
                break;
            }
            if (amount.fees && amount.fees.length > 0) {
                let feeTotal = new bignumber_js_1.BigNumber(0);
                for (const fee of amount.fees) {
                    feeTotal = feeTotal.plus(new bignumber_js_1.BigNumber(fee.feeAmount));
                }
                const expectedTotalAmount = new bignumber_js_1.BigNumber(paramsCopy.amounts[matchingExpectedParty].sendAmount).plus(feeTotal);
                if (expectedTotalAmount.toString() !== amount.sendAmount) {
                    // expected total does not match the sendAmount of the payload
                    // payload is not valid
                    break;
                }
            }
            // matching party found, and fee found
            validAmounts = validAmounts + 1;
            // delete so we ensure no duplicates
            paramsCopy.amounts.splice(matchingExpectedParty, 1);
        }
        return (payloadObj.accountId === this.id &&
            payloadObj.amounts.length === params.amounts.length &&
            validAmounts === payloadObj.amounts.length);
    }
    /**
     * Calculates the necessary fees to complete a settlement between two parties, based on the amounts and currencies of the settlement.
     * @param params
     * @param params.counterpartyAccountId Account ID of the counterparty of the settlement
     * @param params.sendCurrency Currency to be sent as part of the settlement
     * @param params.sendAmount Amount of currency (in base units such as cents, satoshis, or wei) to be sent
     * @param params.receiveCurrency Currency to be received as part of the settlement
     * @param params.receiveAmount Amount of currency (in base units such as cents, satoshis, or wei) to be received
     * @returns Fee rate, currency, and total amount of the described settlement
     */
    async calculateSettlementFees(params) {
        const url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/account/${this.id}/calculatefees`);
        return await this.bitgo.post(url).send(params).result();
    }
    /**
     * Signs a pre-built trade payload with the user key on this trading account
     * @param params
     * @param params.payload trade payload object from TradingAccount::buildPayload()
     * @param params.walletPassphrase passphrase on this trading account, used to unlock the account user key
     * @returns hex-encoded signature of the payload
     */
    async signPayload(params) {
        const key = (await this.wallet.baseCoin.keychains().get({ id: this.wallet.keyIds()[0] }));
        const prv = this.wallet.bitgo.decrypt({
            input: key.encryptedPrv,
            password: params.walletPassphrase,
        });
        const payload = JSON.stringify(params.payload);
        return (await this.wallet.baseCoin.signMessage({ prv }, payload)).toString('hex');
    }
    affirmations() {
        return new affirmations_1.Affirmations(this.bitgo, this.enterpriseId, this);
    }
    settlements() {
        return new settlements_1.Settlements(this.bitgo, this.enterpriseId, this);
    }
    partners() {
        return new tradingPartners_1.TradingPartners(this.bitgo, this.enterpriseId, this);
    }
}
exports.TradingAccount = TradingAccount;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZGluZ0FjY291bnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvdHJhZGluZy90cmFkaW5nQWNjb3VudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7OztBQUVILCtDQUF5QztBQUt6Qyx1REFBb0Q7QUFDcEQsaURBQThDO0FBQzlDLCtDQUE0QztBQUU1QyxNQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQztBQWlDdEMsTUFBYSxjQUFjO0lBTXpCLFlBQVksWUFBb0IsRUFBRSxNQUFjLEVBQUUsS0FBWTtRQUM1RCxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQsSUFBSSxFQUFFO1FBQ0osT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUE4QjtRQUMvQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLDRCQUE0QixJQUFJLENBQUMsWUFBWSxZQUFZLElBQUksQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRXBILE1BQU0sSUFBSSxHQUFHO1lBQ1gsT0FBTyxFQUFFLHFCQUFxQjtZQUM5QixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87U0FDeEIsQ0FBQztRQUVGLE1BQU0sUUFBUSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQVEsQ0FBQztRQUV6RSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFD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QyxDQUFDO0lBQ2xFLENBQUM7Q0FDRjtBQXBKRCx3Q0FvSkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcblxuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi4vd2FsbGV0JztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuL3BheWxvYWQnO1xuaW1wb3J0IHsgVHJhZGluZ1BhcnRuZXJzIH0gZnJvbSAnLi90cmFkaW5nUGFydG5lcnMnO1xuaW1wb3J0IHsgQWZmaXJtYXRpb25zIH0gZnJvbSAnLi9hZmZpcm1hdGlvbnMnO1xuaW1wb3J0IHsgU2V0dGxlbWVudHMgfSBmcm9tICcuL3NldHRsZW1lbnRzJztcblxuY29uc3QgVFJBREVfUEFZTE9BRF9WRVJTSU9OID0gJzEuMi4wJztcblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzIHtcbiAgYW1vdW50czogQnVpbGRQYXlsb2FkQW1vdW50c1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkUGF5bG9hZEFtb3VudHMge1xuICBhY2NvdW50SWQ6IHN0cmluZztcbiAgc2VuZEFtb3VudDogc3RyaW5nO1xuICBzZW5kQ3VycmVuY3k6IHN0cmluZztcbiAgcmVjZWl2ZUFtb3VudDogc3RyaW5nO1xuICByZWNlaXZlQ3VycmVuY3k6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduUGF5bG9hZFBhcmFtZXRlcnMge1xuICBwYXlsb2FkOiBQYXlsb2FkO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGxlbWVudEZlZXMge1xuICBmZWVSYXRlOiBzdHJpbmc7XG4gIGZlZUFtb3VudDogc3RyaW5nO1xuICBmZWVDdXJyZW5jeTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbGN1bGF0ZVNldHRsZW1lbnRGZWVzUGFyYW1zIHtcbiAgY291bnRlcnBhcnR5QWNjb3VudElkOiBzdHJpbmc7XG4gIHNlbmRDdXJyZW5jeTogc3RyaW5nO1xuICBzZW5kQW1vdW50OiBzdHJpbmc7XG4gIHJlY2VpdmVDdXJyZW5jeTogc3RyaW5nO1xuICByZWNlaXZlQW1vdW50OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFkaW5nQWNjb3VudCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGVudGVycHJpc2VJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyB3YWxsZXQ6IFdhbGxldDtcblxuICBjb25zdHJ1Y3RvcihlbnRlcnByaXNlSWQ6IHN0cmluZywgd2FsbGV0OiBXYWxsZXQsIGJpdGdvOiBCaXRHbykge1xuICAgIHRoaXMuZW50ZXJwcmlzZUlkID0gZW50ZXJwcmlzZUlkO1xuICAgIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy53YWxsZXQuaWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBwYXlsb2FkIGF1dGhvcml6aW5nIHRyYWRlIGZyb20gdGhpcyB0cmFkaW5nIGFjY291bnQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10gYXJyYXkgb2YgYW1vdW50cyB0aGF0IHdpbGwgYmUgdHJhZGVkIGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10uYWNjb3VudElkIHRoZSBhY2NvdW50SWQgY29ycmVzcG9uZGluZyB3aXRoIHRoZSBzZW5kaW5nIGFuZCByZWNlaXZpbmcgYW1vdW50cyBmb3IgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10uc2VuZEFtb3VudCBhbW91bnQgb2YgY3VycmVuY3kgc2VudCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50c1tdLnNlbmRDdXJyZW5jeSBjdXJyZW5jeSBvZiBhbW91bnQgc2VudCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50c1tdLnJlY2VpdmVBbW91bnQgYW1vdW50IG9mIGN1cnJlbmN5IHJlY2VpdmVkIGJ5IHRyYWRpbmcgYWNjb3VudCBvZiBnaXZlbiBhY2NvdW50SWRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10ucmVjZWl2ZUN1cnJlbmN5IGN1cnJlbmN5IG9mIGFtb3VudCByZWNlaXZlZCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEByZXR1cm5zIHVuc2lnbmVkIHRyYWRlIHBheWxvYWQgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBUaGlzIG9iamVjdCBzaG91bGQgYmUgc3RyaW5naWZpZWQgd2l0aCBKU09OLnN0cmluZ2lmeSgpIGJlZm9yZSBiZWluZyBzdWJtaXR0ZWRcbiAgICovXG4gIGFzeW5jIGJ1aWxkUGF5bG9hZChwYXJhbXM6IEJ1aWxkUGF5bG9hZFBhcmFtZXRlcnMpOiBQcm9taXNlPFBheWxvYWQ+IHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoYC9hcGkvdHJhZGUvdjEvZW50ZXJwcmlzZS8ke3RoaXMuZW50ZXJwcmlzZUlkfS9hY2NvdW50LyR7dGhpcy5pZH0vcGF5bG9hZGApO1xuXG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIHZlcnNpb246IFRSQURFX1BBWUxPQURfVkVSU0lPTixcbiAgICAgIGFtb3VudHM6IHBhcmFtcy5hbW91bnRzLFxuICAgIH07XG5cbiAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCB0aGlzLmJpdGdvLnBvc3QodXJsKS5zZW5kKGJvZHkpLnJlc3VsdCgpKSBhcyBhbnk7XG5cbiAgICBpZiAoIXRoaXMudmVyaWZ5UGF5bG9hZChwYXJhbXMsIHJlc3BvbnNlLnBheWxvYWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmFibGUgdG8gdmVyaWZ5IHRyYWRlIHBheWxvYWQuIFlvdSBtYXkgbmVlZCB0byB1cGRhdGUgdGhlIEJpdEdvIFNESywgb3IgdGhlIHBheWxvYWQgbWF5IGhhdmUgYmVlbiB0YW1wZXJlZCB3aXRoLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UucGF5bG9hZCkgYXMgUGF5bG9hZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGF0IGEgcGF5bG9hZCByZWNlaXZlZCBmcm9tIEJpdEdvIHN1ZmZpY2llbnRseSBtYXRjaGVzIHRoZSBleHBlY3RlZCBwYXJhbWV0ZXJzLiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudFxuICAgKiBtYW4taW4tdGhlLW1pZGRsZSBhdHRhY2tzIHdoaWNoIGNvdWxkIG1hbGljaW91c2x5IGFsdGVyIHRoZSBjb250ZW50cyBvZiBhIHBheWxvYWQuXG4gICAqIEBwYXJhbSBwYXJhbXMgcGFyYW1ldGVycyB1c2VkIHRvIGJ1aWxkIHRoZSBwYXlsb2FkXG4gICAqIEBwYXJhbSBwYXlsb2FkIHBheWxvYWQgcmVjZWl2ZWQgZnJvbSB0aGUgQml0R28gQVBJXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBheWxvYWQncyBzZW5zaXRpdmUgZmllbGRzIG1hdGNoLCBmYWxzZSBpZiB0aGUgcGF5bG9hZCBtYXkgaGF2ZSBiZWVuIHRhbXBlcmVkIHdpdGhcbiAgICovXG4gIHZlcmlmeVBheWxvYWQocGFyYW1zOiBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzLCBwYXlsb2FkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwYXlsb2FkT2JqID0gSlNPTi5wYXJzZShwYXlsb2FkKTtcbiAgICBjb25zdCBwYXJhbXNDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJhbXMpKTsgLy8gbmVlZHMgdG8gYmUgYSBkZWVwIGNvcHlcblxuICAgIC8vIFZlcmlmaWVzIHRoYXQgZm9yIGVhY2ggcGFydHkgaW4gdGhlIHBheWxvYWQsIHdlIHJlcXVlc3RlZCBhIG1hdGNoaW5nIHBhcnR5LCBvbmx5IGNoZWNraW5nIHNlbnNpdGl2ZSBmaWVsZHNcbiAgICBsZXQgdmFsaWRBbW91bnRzID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtb3VudCBvZiBwYXlsb2FkT2JqLmFtb3VudHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSA9IHBhcmFtc0NvcHkuYW1vdW50cy5maW5kSW5kZXgoXG4gICAgICAgIChleHBlY3RlZEFtb3VudCkgPT5cbiAgICAgICAgICBhbW91bnQuYWNjb3VudElkID09PSBleHBlY3RlZEFtb3VudC5hY2NvdW50SWQgJiZcbiAgICAgICAgICBhbW91bnQuc2VuZEN1cnJlbmN5ID09PSBleHBlY3RlZEFtb3VudC5zZW5kQ3VycmVuY3kgJiZcbiAgICAgICAgICBhbW91bnQuc2VuZFN1YnRvdGFsID09PSBleHBlY3RlZEFtb3VudC5zZW5kQW1vdW50ICYmXG4gICAgICAgICAgYW1vdW50LnJlY2VpdmVBbW91bnQgPT09IGV4cGVjdGVkQW1vdW50LnJlY2VpdmVBbW91bnQgJiZcbiAgICAgICAgICBhbW91bnQucmVjZWl2ZUN1cnJlbmN5ID09PSBleHBlY3RlZEFtb3VudC5yZWNlaXZlQ3VycmVuY3lcbiAgICAgICk7XG5cbiAgICAgIGlmIChtYXRjaGluZ0V4cGVjdGVkUGFydHkgPT09IC0xKSB7XG4gICAgICAgIC8vIG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSBub3QgZm91bmQgdG8gdGhlIHBheWxvYWRPYmplY3RcbiAgICAgICAgLy8gcGF5bG9hZCBpcyBub3QgdmFsaWRcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbW91bnQuZmVlcyAmJiBhbW91bnQuZmVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBmZWVUb3RhbCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICAgIGZvciAoY29uc3QgZmVlIG9mIGFtb3VudC5mZWVzKSB7XG4gICAgICAgICAgZmVlVG90YWwgPSBmZWVUb3RhbC5wbHVzKG5ldyBCaWdOdW1iZXIoZmVlLmZlZUFtb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocGFyYW1zQ29weS5hbW91bnRzW21hdGNoaW5nRXhwZWN0ZWRQYXJ0eV0uc2VuZEFtb3VudCkucGx1cyhmZWVUb3RhbCk7XG4gICAgICAgIGlmIChleHBlY3RlZFRvdGFsQW1vdW50LnRvU3RyaW5nKCkgIT09IGFtb3VudC5zZW5kQW1vdW50KSB7XG4gICAgICAgICAgLy8gZXhwZWN0ZWQgdG90YWwgZG9lcyBub3QgbWF0Y2ggdGhlIHNlbmRBbW91bnQgb2YgdGhlIHBheWxvYWRcbiAgICAgICAgICAvLyBwYXlsb2FkIGlzIG5vdCB2YWxpZFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1hdGNoaW5nIHBhcnR5IGZvdW5kLCBhbmQgZmVlIGZvdW5kXG4gICAgICB2YWxpZEFtb3VudHMgPSB2YWxpZEFtb3VudHMgKyAxO1xuICAgICAgLy8gZGVsZXRlIHNvIHdlIGVuc3VyZSBubyBkdXBsaWNhdGVzXG4gICAgICBwYXJhbXNDb3B5LmFtb3VudHMuc3BsaWNlKG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHBheWxvYWRPYmouYWNjb3VudElkID09PSB0aGlzLmlkICYmXG4gICAgICBwYXlsb2FkT2JqLmFtb3VudHMubGVuZ3RoID09PSBwYXJhbXMuYW1vdW50cy5sZW5ndGggJiZcbiAgICAgIHZhbGlkQW1vdW50cyA9PT0gcGF5bG9hZE9iai5hbW91bnRzLmxlbmd0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbmVjZXNzYXJ5IGZlZXMgdG8gY29tcGxldGUgYSBzZXR0bGVtZW50IGJldHdlZW4gdHdvIHBhcnRpZXMsIGJhc2VkIG9uIHRoZSBhbW91bnRzIGFuZCBjdXJyZW5jaWVzIG9mIHRoZSBzZXR0bGVtZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuY291bnRlcnBhcnR5QWNjb3VudElkIEFjY291bnQgSUQgb2YgdGhlIGNvdW50ZXJwYXJ0eSBvZiB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlbmRDdXJyZW5jeSBDdXJyZW5jeSB0byBiZSBzZW50IGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5zZW5kQW1vdW50IEFtb3VudCBvZiBjdXJyZW5jeSAoaW4gYmFzZSB1bml0cyBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKSB0byBiZSBzZW50XG4gICAqIEBwYXJhbSBwYXJhbXMucmVjZWl2ZUN1cnJlbmN5IEN1cnJlbmN5IHRvIGJlIHJlY2VpdmVkIGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNlaXZlQW1vdW50IEFtb3VudCBvZiBjdXJyZW5jeSAoaW4gYmFzZSB1bml0cyBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKSB0byBiZSByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBGZWUgcmF0ZSwgY3VycmVuY3ksIGFuZCB0b3RhbCBhbW91bnQgb2YgdGhlIGRlc2NyaWJlZCBzZXR0bGVtZW50XG4gICAqL1xuICBhc3luYyBjYWxjdWxhdGVTZXR0bGVtZW50RmVlcyhwYXJhbXM6IENhbGN1bGF0ZVNldHRsZW1lbnRGZWVzUGFyYW1zKTogUHJvbWlzZTxTZXR0bGVtZW50RmVlcz4ge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYml0Z28ubWljcm9zZXJ2aWNlc1VybChcbiAgICAgIGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHt0aGlzLmVudGVycHJpc2VJZH0vYWNjb3VudC8ke3RoaXMuaWR9L2NhbGN1bGF0ZWZlZXNgXG4gICAgKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodXJsKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYSBwcmUtYnVpbHQgdHJhZGUgcGF5bG9hZCB3aXRoIHRoZSB1c2VyIGtleSBvbiB0aGlzIHRyYWRpbmcgYWNjb3VudFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMucGF5bG9hZCB0cmFkZSBwYXlsb2FkIG9iamVjdCBmcm9tIFRyYWRpbmdBY2NvdW50OjpidWlsZFBheWxvYWQoKVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgcGFzc3BocmFzZSBvbiB0aGlzIHRyYWRpbmcgYWNjb3VudCwgdXNlZCB0byB1bmxvY2sgdGhlIGFjY291bnQgdXNlciBrZXlcbiAgICogQHJldHVybnMgaGV4LWVuY29kZWQgc2lnbmF0dXJlIG9mIHRoZSBwYXlsb2FkXG4gICAqL1xuICBhc3luYyBzaWduUGF5bG9hZChwYXJhbXM6IFNpZ25QYXlsb2FkUGFyYW1ldGVycyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qga2V5ID0gKGF3YWl0IHRoaXMud2FsbGV0LmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiB0aGlzLndhbGxldC5rZXlJZHMoKVswXSB9KSkgYXMgYW55O1xuICAgIGNvbnN0IHBydiA9IHRoaXMud2FsbGV0LmJpdGdvLmRlY3J5cHQoe1xuICAgICAgaW5wdXQ6IGtleS5lbmNyeXB0ZWRQcnYsXG4gICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgfSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcy5wYXlsb2FkKTtcbiAgICByZXR1cm4gKChhd2FpdCB0aGlzLndhbGxldC5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBwYXlsb2FkKSkgYXMgYW55KS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICBhZmZpcm1hdGlvbnMoKTogQWZmaXJtYXRpb25zIHtcbiAgICByZXR1cm4gbmV3IEFmZmlybWF0aW9ucyh0aGlzLmJpdGdvLCB0aGlzLmVudGVycHJpc2VJZCwgdGhpcyk7XG4gIH1cblxuICBzZXR0bGVtZW50cygpOiBTZXR0bGVtZW50cyB7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVtZW50cyh0aGlzLmJpdGdvLCB0aGlzLmVudGVycHJpc2VJZCwgdGhpcyk7XG4gIH1cblxuICBwYXJ0bmVycygpOiBUcmFkaW5nUGFydG5lcnMge1xuICAgIHJldHVybiBuZXcgVHJhZGluZ1BhcnRuZXJzKHRoaXMuYml0Z28sIHRoaXMuZW50ZXJwcmlzZUlkLCB0aGlzKTtcbiAgfVxufVxuIl19