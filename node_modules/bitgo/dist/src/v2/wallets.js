"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallets = void 0;
/**
 * @prettier
 */
const bignumber_js_1 = require("bignumber.js");
const bip32 = require("bip32");
const _ = require("lodash");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_api_1 = require("@bitgo/sdk-api");
const wallet_1 = require("./wallet");
const util_1 = require("./internal/util");
const ecdh_1 = require("../ecdh");
const promise_utils_1 = require("./promise-utils");
class Wallets {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     */
    async get(params = {}) {
        return this.getWallet(params);
    }
    /**
     * List a user's wallets
     * @param params
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (params.skip && params.prevId) {
            throw new Error('cannot specify both skip and prevId');
        }
        if (params.getbalances) {
            if (!_.isBoolean(params.getbalances)) {
                throw new Error('invalid getbalances argument, expecting boolean');
            }
            queryObject.getbalances = params.getbalances;
        }
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            queryObject.allTokens = params.allTokens;
        }
        const body = (await this.bitgo.get(this.baseCoin.url('/wallet')).query(queryObject).result());
        body.wallets = body.wallets.map((w) => new wallet_1.Wallet(this.bitgo, this.baseCoin, w));
        return body;
    }
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    async add(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['label', 'enterprise', 'type']);
        // no need to pass keys for (single) custodial wallets
        if (params.type !== 'custodial') {
            if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
                throw new Error('invalid argument');
            }
            // TODO: support more types of multisig
            if (!this.baseCoin.isValidMofNSetup(params)) {
                throw new Error('unsupported multi-sig type');
            }
        }
        if (params.gasPrice && !_.isNumber(params.gasPrice)) {
            throw new Error('invalid argument for gasPrice - number expected');
        }
        if (params.walletVersion && !_.isNumber(params.walletVersion)) {
            throw new Error('invalid argument for walletVersion - number expected');
        }
        if (params.tags && Array.isArray(params.tags) === false) {
            throw new Error('invalid argument for tags - array expected');
        }
        if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
            throw new Error('invalid argument for clientFlags - array expected');
        }
        if (params.isCold && !_.isBoolean(params.isCold)) {
            throw new Error('invalid argument for isCold - boolean expected');
        }
        if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
            throw new Error('invalid argument for isCustodial - boolean expected');
        }
        if (params.address && (!_.isString(params.address) || !this.baseCoin.isValidAddress(params.address))) {
            throw new Error('invalid argument for address - valid address string expected');
        }
        const walletParams = _.pick(params, [
            'label',
            'm',
            'n',
            'keys',
            'enterprise',
            'isCold',
            'isCustodial',
            'tags',
            'clientFlags',
            'type',
            'address',
            'gasPrice',
            'walletVersion',
        ]);
        // Additional params needed for xrp
        if (params.rootPub) {
            walletParams.rootPub = params.rootPub;
        }
        // In XRP, XLM and CSPR this private key is used only for wallet creation purposes,
        // once the wallet is initialized then we update its weight to 0 making it an invalid key.
        // https://www.stellar.org/developers/guides/concepts/multi-sig.html#additional-signing-keys
        if (params.rootPrivateKey) {
            walletParams.rootPrivateKey = params.rootPrivateKey;
        }
        if (params.initializationTxs) {
            walletParams.initializationTxs = params.initializationTxs;
        }
        if (params.disableTransactionNotifications) {
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        if (params.multisigType) {
            walletParams.multisigType = params.multisigType;
        }
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(walletParams).result();
        return {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
        };
    }
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label
     * @param params.passphrase
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.enterprise
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode
     * @param params.coldDerivationSeed
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param params.walletVersion
     * @param params.multisigType optional multisig type, 'onchain' or 'tss' or 'blsdkg'; if absent, we will defer to the coin's default type
     * @returns {*}
     */
    async generateWallet(params = {}) {
        sdk_core_1.common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub']);
        if (!_.isString(params.label)) {
            throw new Error('missing required string parameter label');
        }
        const isTss = params.multisigType ? params.multisigType === 'tss' : this.baseCoin.supportsTss();
        const label = params.label;
        const passphrase = params.passphrase;
        const canEncrypt = !!passphrase && typeof passphrase === 'string';
        const isCold = !canEncrypt || !!params.userKey;
        const walletParams = {
            label: label,
            m: 2,
            n: 3,
            keys: [],
            isCold,
        };
        if (!_.isUndefined(params.passcodeEncryptionCode)) {
            if (!_.isString(params.passcodeEncryptionCode)) {
                throw new Error('passcodeEncryptionCode must be a string');
            }
        }
        if (!_.isUndefined(params.enterprise)) {
            if (!_.isString(params.enterprise)) {
                throw new Error('invalid enterprise argument, expecting string');
            }
            walletParams.enterprise = params.enterprise;
        }
        if (isTss) {
            if (!canEncrypt) {
                throw new Error('cannot generate TSS keys without passphrase');
            }
            if (isCold) {
                throw new Error('TSS cold wallets are not supported at this time');
            }
            if (!this.baseCoin.supportsTss()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support TSS at this time`);
            }
            return this.generateMpcWallet({
                multisigType: 'tss',
                label,
                passphrase: passphrase,
                originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                enterprise: params.enterprise,
            });
        }
        const isBlsDkg = params.multisigType ? params.multisigType === 'blsdkg' : this.baseCoin.supportsBlsDkg();
        if (isBlsDkg) {
            if (!canEncrypt) {
                throw new Error('cannot generate BLS-DKG keys without passphrase');
            }
            if (isCold) {
                throw new Error('BLS-DKG cold wallets are not supported at this time');
            }
            if (!this.baseCoin.supportsBlsDkg()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support BLS-DKG at this time`);
            }
            return this.generateMpcWallet({ multisigType: 'blsdkg', label, passphrase: passphrase });
        }
        const hasBackupXpub = !!params.backupXpub;
        const hasBackupXpubProvider = !!params.backupXpubProvider;
        if (hasBackupXpub && hasBackupXpubProvider) {
            throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
        }
        if (params.gasPrice && params.eip1559) {
            throw new Error('can not use both eip1559 and gasPrice values');
        }
        if (!_.isUndefined(params.disableTransactionNotifications)) {
            if (!_.isBoolean(params.disableTransactionNotifications)) {
                throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
            }
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        if (!_.isUndefined(params.gasPrice)) {
            const gasPriceBN = new bignumber_js_1.BigNumber(params.gasPrice);
            if (gasPriceBN.isNaN()) {
                throw new Error('invalid gas price argument, expecting number or number as string');
            }
            walletParams.gasPrice = gasPriceBN.toString();
        }
        if (!_.isUndefined(params.eip1559) && !_.isEmpty(params.eip1559)) {
            const maxFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxFeePerGas);
            if (maxFeePerGasBN.isNaN()) {
                throw new Error('invalid max fee argument, expecting number or number as string');
            }
            const maxPriorityFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxPriorityFeePerGas);
            if (maxPriorityFeePerGasBN.isNaN()) {
                throw new Error('invalid priority fee argument, expecting number or number as string');
            }
            walletParams.eip1559 = {
                maxFeePerGas: maxFeePerGasBN.toString(),
                maxPriorityFeePerGas: maxPriorityFeePerGasBN.toString(),
            };
        }
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
            walletParams.disableKRSEmail = params.disableKRSEmail;
        }
        if (!_.isUndefined(params.walletVersion)) {
            if (!_.isNumber(params.walletVersion)) {
                throw new Error('invalid walletVersion provided, expecting number');
            }
            walletParams.walletVersion = params.walletVersion;
        }
        // Ensure each krsSpecific param is either a string, boolean, or number
        const { krsSpecific } = params;
        if (!_.isUndefined(krsSpecific)) {
            Object.keys(krsSpecific).forEach((key) => {
                const val = krsSpecific[key];
                if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                    throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                }
            });
        }
        let derivationPath = undefined;
        const reqId = new util_1.RequestTracer();
        // Add the user keychain
        const userKeychainPromise = async () => {
            let userKeychainParams;
            let userKeychain;
            // User provided user key
            if (params.userKey) {
                userKeychain = { pub: params.userKey };
                userKeychainParams = userKeychain;
                if (params.coldDerivationSeed) {
                    // the derivation only makes sense when a key already exists
                    const derivation = this.baseCoin.deriveKeyWithSeed({
                        key: params.userKey,
                        seed: params.coldDerivationSeed,
                    });
                    derivationPath = derivation.derivationPath;
                    userKeychain.pub = derivation.key;
                    userKeychain.derivedFromParentWithSeed = params.coldDerivationSeed;
                }
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate user keypair without passphrase');
                }
                // Create the user key.
                userKeychain = this.baseCoin.keychains().create();
                userKeychain.encryptedPrv = this.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                userKeychainParams = {
                    pub: userKeychain.pub,
                    encryptedPrv: userKeychain.encryptedPrv,
                    originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                };
            }
            userKeychainParams.reqId = reqId;
            const newUserKeychain = await this.baseCoin.keychains().add(userKeychainParams);
            return _.extend({}, newUserKeychain, userKeychain);
        };
        const backupKeychainPromise = async () => {
            if (params.backupXpubProvider) {
                // If requested, use a KRS or backup key provider
                return this.baseCoin.keychains().createBackup({
                    provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                    disableKRSEmail: params.disableKRSEmail,
                    krsSpecific: params.krsSpecific,
                    type: this.baseCoin.getChain(),
                    reqId,
                });
            }
            // User provided backup xpub
            if (params.backupXpub) {
                // user provided backup ethereum address
                return this.baseCoin.keychains().add({
                    pub: params.backupXpub,
                    source: 'backup',
                    reqId,
                });
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate backup keypair without passphrase');
                }
                // No provided backup xpub or address, so default to creating one here
                return this.baseCoin.keychains().createBackup({ reqId });
            }
        };
        const { userKeychain, backupKeychain, bitgoKeychain } = await promise_utils_1.promiseProps({
            userKeychain: userKeychainPromise(),
            backupKeychain: backupKeychainPromise(),
            bitgoKeychain: this.baseCoin.keychains().createBitGo({ enterprise: params.enterprise, reqId }),
        });
        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
        walletParams.isCold = isCold;
        const { prv } = userKeychain;
        if (_.isString(prv)) {
            walletParams.keySignatures = {
                backup: (await this.baseCoin.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
                bitgo: (await this.baseCoin.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
            };
        }
        if (_.includes(['xrp', 'xlm', 'cspr'], this.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
            walletParams.rootPrivateKey = params.rootPrivateKey;
        }
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        this.bitgo.setRequestTracer(reqId);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
        };
        if (!_.isUndefined(backupKeychain.prv)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        if (!_.isUndefined(derivationPath)) {
            userKeychain.derivationPath = derivationPath;
        }
        return result;
    }
    /**
     * List the user's wallet shares
     * @param params
     */
    async listShares(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/walletshare')).result();
    }
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     */
    async getShare(params = {}) {
        sdk_core_1.common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo.get(this.baseCoin.url('/walletshare/' + params.walletShareId)).result();
    }
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     */
    async updateShare(params = {}) {
        sdk_core_1.common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .post(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send(params)
            .result();
    }
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     */
    async resendShareInvite(params = {}) {
        sdk_core_1.common.validateParams(params, ['walletShareId'], []);
        const urlParts = params.walletShareId + '/resendemail';
        return this.bitgo.post(this.baseCoin.url('/walletshare/' + urlParts)).result();
    }
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     */
    async cancelShare(params = {}) {
        sdk_core_1.common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .del(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send()
            .result();
    }
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     */
    async acceptShare(params = {}) {
        sdk_core_1.common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase']);
        let encryptedPrv = params.overrideEncryptedPrv;
        const walletShare = (await this.getShare({ walletShareId: params.walletShareId }));
        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
            return this.updateShare({
                walletShareId: params.walletShareId,
                state: 'accepted',
            });
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (_.isUndefined(params.userPassword)) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        const sharingKeychain = (await this.bitgo.getECDHSharingKeychain());
        if (_.isUndefined(sharingKeychain.encryptedXprv)) {
            throw new Error('encryptedXprv was not found on sharing keychain');
        }
        // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
        sharingKeychain.prv = this.bitgo.decrypt({
            password: params.userPassword,
            input: sharingKeychain.encryptedXprv,
        });
        const secret = ecdh_1.getSharedSecret(
        // Derive key by path (which is used between these 2 users only)
        bip32.fromBase58(sharingKeychain.prv).derivePath(sdk_api_1.sanitizeLegacyPath(walletShare.keychain.path)), Buffer.from(walletShare.keychain.fromPubKey, 'hex')).toString('hex');
        // Yes! We got the secret successfully here, now decrypt the shared wallet prv
        const decryptedSharedWalletPrv = this.bitgo.decrypt({
            password: secret,
            input: walletShare.keychain.encryptedPrv,
        });
        // We will now re-encrypt the wallet with our own password
        const newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
        encryptedPrv = this.bitgo.encrypt({
            password: newWalletPassphrase,
            input: decryptedSharedWalletPrv,
        });
        const updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted',
        };
        if (encryptedPrv) {
            updateParams.encryptedPrv = encryptedPrv;
        }
        return this.updateShare(updateParams);
    }
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @returns {*}
     */
    async getWallet(params = {}) {
        sdk_core_1.common.validateParams(params, ['id'], []);
        const query = {};
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        this.bitgo.setRequestTracer(params.reqId || new util_1.RequestTracer());
        const wallet = await this.bitgo
            .get(this.baseCoin.url('/wallet/' + params.id))
            .query(query)
            .result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @returns {*}
     */
    async getWalletByAddress(params = {}) {
        sdk_core_1.common.validateParams(params, ['address'], []);
        this.bitgo.setRequestTracer(params.reqId || new util_1.RequestTracer());
        const wallet = await this.bitgo.get(this.baseCoin.url('/wallet/address/' + params.address)).result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @returns {*}
     */
    async getTotalBalances(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/wallet/balances')).result();
    }
    /**
     * Generates a TSS or BLS-DKG Wallet.
     * @param params
     * @private
     */
    async generateMpcWallet(params) {
        const reqId = new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        const walletParams = {
            label: params.label,
            m: 2,
            n: 3,
            keys: [],
            isCold: false,
            multisigType: params.multisigType,
            enterprise: params.enterprise,
        };
        // Create MPC Keychains
        const keychains = await this.baseCoin.keychains().createMpc({
            multisigType: params.multisigType,
            passphrase: params.passphrase,
            enterprise: params.enterprise,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
        });
        const { userKeychain, backupKeychain, bitgoKeychain } = keychains;
        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
        // Create Wallet
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        if (!_.isUndefined(backupKeychain.prv)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        return result;
    }
}
exports.Wallets = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92Mi93YWxsZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztHQUVHO0FBQ0gsK0NBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFHNUIsOENBQXlDO0FBR3pDLDRDQUFvRTtBQUNwRSxxQ0FBcUQ7QUFDckQsMENBQWdEO0FBQ2hELGtDQUEwQztBQUMxQyxtREFBK0M7QUF3Ri9DLE1BQWEsT0FBTztJQUlsQixZQUFZLEtBQVksRUFBRSxRQUFrQjtRQUMxQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLEdBQUcsQ0FBQyxTQUEyQixFQUFFO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBNEIsRUFBRTtRQUN2QyxNQUFNLFdBQVcsR0FBc0IsRUFBRSxDQUFDO1FBRTFDLElBQUksTUFBTSxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQztTQUN4RDtRQUVELElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTtZQUN0QixJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQzthQUNwRTtZQUNELFdBQVcsQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztTQUM5QztRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsQ0FBQyxD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TUFBTSxDQUFDLFVBQVU7WUFDN0IsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1lBQzdCLDhCQUE4QixFQUFFLE1BQU0sQ0FBQyw4QkFBOEI7U0FDdEUsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLEdBQUcsU0FBUyxDQUFDO1FBQ2xFLFlBQVksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxFQUFFLEVBQUUsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNFLGdCQUFnQjtRQUNoQixNQUFNLGlCQUFpQixHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDaEcsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXZHLE1BQU0sTUFBTSxHQUF3QjtZQUNsQyxNQUFNLEVBQUUsSUFBSSxlQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQztZQUN4RCxZQUFZO1lBQ1osY0FBYztZQUNkLGFBQWE7U0FDZCxDQUFDO1FBRUYsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3RDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsMEVBQTBFLENBQUM7U0FDN0Y7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUEzcEJELDBCQTJwQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCB7IGNvbW1vbiB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB9IGZyb20gJy4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgS2V5Y2hhaW4gfSBmcm9tICcuL2tleWNoYWlucyc7XG5pbXBvcnQgeyBJUmVxdWVzdFRyYWNlciwgc2FuaXRpemVMZWdhY3lQYXRoIH0gZnJvbSAnQGJpdGdvL3Nkay1hcGknO1xuaW1wb3J0IHsgUGFnaW5hdGlvbk9wdGlvbnMsIFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuL2ludGVybmFsL3V0aWwnO1xuaW1wb3J0IHsgZ2V0U2hhcmVkU2VjcmV0IH0gZnJvbSAnLi4vZWNkaCc7XG5pbXBvcnQgeyBwcm9taXNlUHJvcHMgfSBmcm9tICcuL3Byb21pc2UtdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldFdpdGhLZXljaGFpbnMgZXh0ZW5kcyBLZXljaGFpbnNUcmlwbGV0IHtcbiAgd2FsbGV0OiBXYWxsZXQ7XG4gIHdhcm5pbmc/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0V2FsbGV0T3B0aW9ucyB7XG4gIGFsbFRva2Vucz86IGJvb2xlYW47XG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXI7XG4gIGlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlTXBjV2FsbGV0T3B0aW9ucyB7XG4gIG11bHRpc2lnVHlwZTogJ29uY2hhaW4nIHwgJ3RzcycgfCAnYmxzZGtnJztcbiAgbGFiZWw6IHN0cmluZztcbiAgcGFzc3BocmFzZTogc3RyaW5nO1xuICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIHBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHVzZXJLZXk/OiBzdHJpbmc7XG4gIGJhY2t1cFhwdWI/OiBzdHJpbmc7XG4gIGJhY2t1cFhwdWJQcm92aWRlcj86IHN0cmluZztcbiAgcGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZztcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucz86IHN0cmluZztcbiAgZ2FzUHJpY2U/OiBzdHJpbmc7XG4gIGVpcDE1NTk/OiB7XG4gICAgbWF4RmVlUGVyR2FzOiBzdHJpbmc7XG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHN0cmluZztcbiAgfTtcbiAgd2FsbGV0VmVyc2lvbj86IG51bWJlcjtcbiAgZGlzYWJsZUtSU0VtYWlsPzogYm9vbGVhbjtcbiAga3JzU3BlY2lmaWM/OiB7XG4gICAgW2luZGV4OiBzdHJpbmddOiBib29sZWFuIHwgc3RyaW5nIHwgbnVtYmVyO1xuICB9O1xuICBjb2xkRGVyaXZhdGlvblNlZWQ/OiBzdHJpbmc7XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xuICBtdWx0aXNpZ1R5cGU/OiAnb25jaGFpbicgfCAndHNzJyB8ICdibHNka2cnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFdhbGxldEJ5QWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlU2hhcmVPcHRpb25zIHtcbiAgd2FsbGV0U2hhcmVJZD86IHN0cmluZztcbiAgc3RhdGU/OiBzdHJpbmc7XG4gIGVuY3J5cHRlZFBydj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY2NlcHRTaGFyZU9wdGlvbnMge1xuICBvdmVycmlkZUVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgd2FsbGV0U2hhcmVJZD86IHN0cmluZztcbiAgdXNlclBhc3N3b3JkPzogc3RyaW5nO1xuICBuZXdXYWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZFdhbGxldE9wdGlvbnMge1xuICB0eXBlPzogc3RyaW5nO1xuICBrZXlzPzogc3RyaW5nW107XG4gIG0/OiBudW1iZXI7XG4gIG4/OiBudW1iZXI7XG4gIHRhZ3M/OiBzdHJpbmdbXTtcbiAgY2xpZW50RmxhZ3M/OiBzdHJpbmdbXTtcbiAgaXNDb2xkPzogYm9vbGVhbjtcbiAgaXNDdXN0b2RpYWw/OiBib29sZWFuO1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICByb290UHViPzogc3RyaW5nO1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbiAgaW5pdGlhbGl6YXRpb25UeHM/OiBhbnk7XG4gIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM/OiBib29sZWFuO1xuICBnYXNQcmljZT86IG51bWJlcjtcbiAgd2FsbGV0VmVyc2lvbj86IG51bWJlcjtcbiAgbXVsdGlzaWdUeXBlPzogJ29uY2hhaW4nIHwgJ3RzcycgfCAnYmxzZGtnJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0V2FsbGV0T3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgc2tpcD86IG51bWJlcjtcbiAgZ2V0YmFsYW5jZXM/OiBib29sZWFuO1xuICBhbGxUb2tlbnM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgV2FsbGV0cyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IElEIChwcm94eSBmb3IgZ2V0V2FsbGV0KVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBnZXQocGFyYW1zOiBHZXRXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPFdhbGxldD4ge1xuICAgIHJldHVybiB0aGlzLmdldFdhbGxldChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYSB1c2VyJ3Mgd2FsbGV0c1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgbGlzdChwYXJhbXM6IExpc3RXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPHsgd2FsbGV0czogV2FsbGV0W10gfT4ge1xuICAgIGNvbnN0IHF1ZXJ5T2JqZWN0OiBMaXN0V2FsbGV0T3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5za2lwICYmIHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgYm90aCBza2lwIGFuZCBwcmV2SWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmdldGJhbGFuY2VzKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5nZXRiYWxhbmNlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGdldGJhbGFuY2VzIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QuZ2V0YmFsYW5jZXMgPSBwYXJhbXMuZ2V0YmFsYW5jZXM7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucHJldklkKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gKGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnF1ZXJ5KHF1ZXJ5T2JqZWN0KS5yZXN1bHQoKSkgYXMgYW55O1xuICAgIGJvZHkud2FsbGV0cyA9IGJvZHkud2FsbGV0cy5tYXAoKHcpID0+IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgdykpO1xuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZFxuICAgKiBBZGQgYSBuZXcgd2FsbGV0IChhZHZhbmNlZCBtb2RlKS5cbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIG1hbnVhbGx5IHN1Ym1pdCB0aGUga2V5cywgdHlwZSwgbSBhbmQgbiBvZiB0aGUgd2FsbGV0XG4gICAqIFBhcmFtZXRlcnMgaW5jbHVkZTpcbiAgICogICAgXCJsYWJlbFwiOiBsYWJlbCBvZiB0aGUgd2FsbGV0IHRvIGJlIHNob3duIGluIFVJXG4gICAqICAgIFwibVwiOiBudW1iZXIgb2Yga2V5cyByZXF1aXJlZCB0byB1bmxvY2sgd2FsbGV0ICgyKVxuICAgKiAgICBcIm5cIjogbnVtYmVyIG9mIGtleXMgYXZhaWxhYmxlIG9uIHRoZSB3YWxsZXQgKDMpXG4gICAqICAgIFwia2V5c1wiOiBhcnJheSBvZiBrZXljaGFpbiBpZHNcbiAgICovXG4gIGFzeW5jIGFkZChwYXJhbXM6IEFkZFdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnbGFiZWwnLCAnZW50ZXJwcmlzZScsICd0eXBlJ10pO1xuXG4gICAgLy8gbm8gbmVlZCB0byBwYXNzIGtleXMgZm9yIChzaW5nbGUpIGN1c3RvZGlhbCB3YWxsZXRzXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnY3VzdG9kaWFsJykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zLmtleXMpID09PSBmYWxzZSB8fCAhXy5pc051bWJlcihwYXJhbXMubSkgfHwgIV8uaXNOdW1iZXIocGFyYW1zLm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IG1vcmUgdHlwZXMgb2YgbXVsdGlzaWdcbiAgICAgIGlmICghdGhpcy5iYXNlQ29pbi5pc1ZhbGlkTW9mTlNldHVwKHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBtdWx0aS1zaWcgdHlwZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmdhc1ByaWNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBnYXNQcmljZSAtIG51bWJlciBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMud2FsbGV0VmVyc2lvbiAmJiAhXy5pc051bWJlcihwYXJhbXMud2FsbGV0VmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3Igd2FsbGV0VmVyc2lvbiAtIG51bWJlciBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMudGFncyAmJiBBcnJheS5pc0FycmF5KHBhcmFtcy50YWdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgdGFncyAtIGFycmF5IGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5jbGllbnRGbGFncyAmJiBBcnJheS5pc0FycmF5KHBhcmFtcy5jbGllbnRGbGFncykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGNsaWVudEZsYWdzIC0gYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmlzQ29sZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmlzQ29sZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgaXNDb2xkIC0gYm9vbGVhbiBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuaXNDdXN0b2RpYWwgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5pc0N1c3RvZGlhbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgaXNDdXN0b2RpYWwgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hZGRyZXNzICYmICghXy5pc1N0cmluZyhwYXJhbXMuYWRkcmVzcykgfHwgIXRoaXMuYmFzZUNvaW4uaXNWYWxpZEFkZHJlc3MocGFyYW1zLmFkZHJlc3MpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhZGRyZXNzIC0gdmFsaWQgYWRkcmVzcyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB3YWxsZXRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAnbGFiZWwnLFxuICAgICAgJ20nLFxuICAgICAgJ24nLFxuICAgICAgJ2tleXMnLFxuICAgICAgJ2VudGVycHJpc2UnLFxuICAgICAgJ2lzQ29sZCcsXG4gICAgICAnaXNDdXN0b2RpYWwnLFxuICAgICAgJ3RhZ3MnLFxuICAgICAgJ2NsaWVudEZsYWdzJyxcbiAgICAgICd0eXBlJyxcbiAgICAgICdhZGRyZXNzJyxcbiAgICAgICdnYXNQcmljZScsXG4gICAgICAnd2FsbGV0VmVyc2lvbicsXG4gICAgXSk7XG5cbiAgICAvLyBBZGRpdGlvbmFsIHBhcmFtcyBuZWVkZWQgZm9yIHhycFxuICAgIGlmIChwYXJhbXMucm9vdFB1Yikge1xuICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQdWIgPSBwYXJhbXMucm9vdFB1YjtcbiAgICB9XG5cbiAgICAvLyBJbiBYUlAsIFhMTSBhbmQgQ1NQUiB0aGlzIHByaXZhdGUga2V5IGlzIHVzZWQgb25seSBmb3Igd2FsbGV0IGNyZWF0aW9uIHB1cnBvc2VzLFxuICAgIC8vIG9uY2UgdGhlIHdhbGxldCBpcyBpbml0aWFsaXplZCB0aGVuIHdlIHVwZGF0ZSBpdHMgd2VpZ2h0IHRvIDAgbWFraW5nIGl0IGFuIGludmFsaWQga2V5LlxuICAgIC8vIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL211bHRpLXNpZy5odG1sI2FkZGl0aW9uYWwtc2lnbmluZy1rZXlzXG4gICAgaWYgKHBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0gcGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuaW5pdGlhbGl6YXRpb25UeHMpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5pbml0aWFsaXphdGlvblR4cyA9IHBhcmFtcy5pbml0aWFsaXphdGlvblR4cztcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zID0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5tdWx0aXNpZ1R5cGUpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5tdWx0aXNpZ1R5cGUgPSBwYXJhbXMubXVsdGlzaWdUeXBlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5zZW5kKHdhbGxldFBhcmFtcykucmVzdWx0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhbGxldDogbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgd2FsbGV0XG4gICAqIDEuIENyZWF0ZXMgdGhlIHVzZXIga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAyLiBJZiBubyBwdWIgd2FzIHByb3ZpZGVkLCBjcmVhdGVzIHRoZSBiYWNrdXAga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAzLiBVcGxvYWRzIHRoZSBlbmNyeXB0ZWQgdXNlciBhbmQgYmFja3VwIGtleWNoYWlucyB0byBCaXRHb1xuICAgKiA0LiBDcmVhdGVzIHRoZSBCaXRHbyBrZXkgb24gdGhlIHNlcnZpY2VcbiAgICogNS4gQ3JlYXRlcyB0aGUgd2FsbGV0IG9uIEJpdEdvIHdpdGggdGhlIDMgcHVibGljIGtleXMgYWJvdmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmxhYmVsXG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJLZXkgVXNlciB4cHViXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwWHB1YiBCYWNrdXAgeHB1YlxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlclxuICAgKiBAcGFyYW0gcGFyYW1zLmVudGVycHJpc2VcbiAgICogQHBhcmFtIHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZFxuICAgKiBAcGFyYW0gcGFyYW1zLmdhc1ByaWNlXG4gICAqIEBwYXJhbSBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0VmVyc2lvblxuICAgKiBAcGFyYW0gcGFyYW1zLm11bHRpc2lnVHlwZSBvcHRpb25hbCBtdWx0aXNpZyB0eXBlLCAnb25jaGFpbicgb3IgJ3Rzcycgb3IgJ2Jsc2RrZyc7IGlmIGFic2VudCwgd2Ugd2lsbCBkZWZlciB0byB0aGUgY29pbidzIGRlZmF1bHQgdHlwZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlV2FsbGV0KHBhcmFtczogR2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPFdhbGxldFdpdGhLZXljaGFpbnM+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2xhYmVsJ10sIFsncGFzc3BocmFzZScsICd1c2VyS2V5JywgJ2JhY2t1cFhwdWInXSk7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5sYWJlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIGxhYmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNUc3MgPSBwYXJhbXMubXVsdGlzaWdUeXBlID8gcGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgOiB0aGlzLmJhc2VDb2luLnN1cHBvcnRzVHNzKCk7XG4gICAgY29uc3QgbGFiZWwgPSBwYXJhbXMubGFiZWw7XG4gICAgY29uc3QgcGFzc3BocmFzZSA9IHBhcmFtcy5wYXNzcGhyYXNlO1xuICAgIGNvbnN0IGNhbkVuY3J5cHQgPSAhIXBhc3NwaHJhc2UgJiYgdHlwZW9mIHBhc3NwaHJhc2UgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGlzQ29sZCA9ICFjYW5FbmNyeXB0IHx8ICEhcGFyYW1zLnVzZXJLZXk7XG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgbTogMixcbiAgICAgIG46IDMsXG4gICAgICBrZXlzOiBbXSxcbiAgICAgIGlzQ29sZCxcbiAgICB9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3Njb2RlRW5jcnlwdGlvbkNvZGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuZW50ZXJwcmlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVudGVycHJpc2UgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5lbnRlcnByaXNlID0gcGFyYW1zLmVudGVycHJpc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzVHNzKSB7XG4gICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgVFNTIGtleXMgd2l0aG91dCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NvbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUU1MgY29sZCB3YWxsZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGF0IHRoaXMgdGltZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYmFzZUNvaW4uc3VwcG9ydHNUc3MoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvaW4gJHt0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpfSBkb2VzIG5vdCBzdXBwb3J0IFRTUyBhdCB0aGlzIHRpbWVgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNcGNXYWxsZXQoe1xuICAgICAgICBtdWx0aXNpZ1R5cGU6ICd0c3MnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgcGFzc3BocmFzZTogcGFzc3BocmFzZSEsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLnBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNCbHNEa2cgPSBwYXJhbXMubXVsdGlzaWdUeXBlID8gcGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ2Jsc2RrZycgOiB0aGlzLmJhc2VDb2luLnN1cHBvcnRzQmxzRGtnKCk7XG4gICAgaWYgKGlzQmxzRGtnKSB7XG4gICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgQkxTLURLRyBrZXlzIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb2xkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQkxTLURLRyBjb2xkIHdhbGxldHMgYXJlIG5vdCBzdXBwb3J0ZWQgYXQgdGhpcyB0aW1lJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5iYXNlQ29pbi5zdXBwb3J0c0Jsc0RrZygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29pbiAke3RoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCl9IGRvZXMgbm90IHN1cHBvcnQgQkxTLURLRyBhdCB0aGlzIHRpbWVgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNcGNXYWxsZXQoeyBtdWx0aXNpZ1R5cGU6ICdibHNka2cnLCBsYWJlbCwgcGFzc3BocmFzZTogcGFzc3BocmFzZSEgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQmFja3VwWHB1YiA9ICEhcGFyYW1zLmJhY2t1cFhwdWI7XG4gICAgY29uc3QgaGFzQmFja3VwWHB1YlByb3ZpZGVyID0gISFwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyO1xuICAgIGlmIChoYXNCYWNrdXBYcHViICYmIGhhc0JhY2t1cFhwdWJQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcHJvdmlkZSBtb3JlIHRoYW4gb25lIGJhY2t1cFhwdWIgb3IgYmFja3VwWHB1YlByb3ZpZGVyIGZsYWcnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmdhc1ByaWNlICYmIHBhcmFtcy5laXAxNTU5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbiBub3QgdXNlIGJvdGggZWlwMTU1OSBhbmQgZ2FzUHJpY2UgdmFsdWVzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zKSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyA9IHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZ2FzUHJpY2UpKSB7XG4gICAgICBjb25zdCBnYXNQcmljZUJOID0gbmV3IEJpZ051bWJlcihwYXJhbXMuZ2FzUHJpY2UpO1xuICAgICAgaWYgKGdhc1ByaWNlQk4uaXNOYU4oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZ2FzIHByaWNlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyIG9yIG51bWJlciBhcyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5nYXNQcmljZSA9IGdhc1ByaWNlQk4udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVpcDE1NTkpICYmICFfLmlzRW1wdHkocGFyYW1zLmVpcDE1NTkpKSB7XG4gICAgICBjb25zdCBtYXhGZWVQZXJHYXNCTiA9IG5ldyBCaWdOdW1iZXIocGFyYW1zLmVpcDE1NTkubWF4RmVlUGVyR2FzKTtcbiAgICAgIGlmIChtYXhGZWVQZXJHYXNCTi5pc05hTigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtYXggZmVlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyIG9yIG51bWJlciBhcyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzQk4gPSBuZXcgQmlnTnVtYmVyKHBhcmFtcy5laXAxNTU5Lm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhc0JOLmlzTmFOKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaW9yaXR5IGZlZSBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlciBvciBudW1iZXIgYXMgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZWlwMTU1OSA9IHtcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXNCTi50b1N0cmluZygpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXNCTi50b1N0cmluZygpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVLUlNFbWFpbCBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlS1JTRW1haWwgPSBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0VmVyc2lvbikpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMud2FsbGV0VmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdhbGxldFZlcnNpb24gcHJvdmlkZWQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy53YWxsZXRWZXJzaW9uID0gcGFyYW1zLndhbGxldFZlcnNpb247XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGVhY2gga3JzU3BlY2lmaWMgcGFyYW0gaXMgZWl0aGVyIGEgc3RyaW5nLCBib29sZWFuLCBvciBudW1iZXJcbiAgICBjb25zdCB7IGtyc1NwZWNpZmljIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGtyc1NwZWNpZmljKSkge1xuICAgICAgT2JqZWN0LmtleXMoa3JzU3BlY2lmaWMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBrcnNTcGVjaWZpY1trZXldO1xuICAgICAgICBpZiAoIV8uaXNCb29sZWFuKHZhbCkgJiYgIV8uaXNTdHJpbmcodmFsKSAmJiAhXy5pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrcnNTcGVjaWZpYyBvYmplY3QgY29udGFpbnMgaWxsZWdhbCB2YWx1ZXMuIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MsIGJvb2xlYW5zLCBvciBudW1iZXJzJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBkZXJpdmF0aW9uUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuXG4gICAgLy8gQWRkIHRoZSB1c2VyIGtleWNoYWluXG4gICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IGFzeW5jICgpOiBQcm9taXNlPEtleWNoYWluPiA9PiB7XG4gICAgICBsZXQgdXNlcktleWNoYWluUGFyYW1zO1xuICAgICAgbGV0IHVzZXJLZXljaGFpbjtcbiAgICAgIC8vIFVzZXIgcHJvdmlkZWQgdXNlciBrZXlcbiAgICAgIGlmIChwYXJhbXMudXNlcktleSkge1xuICAgICAgICB1c2VyS2V5Y2hhaW4gPSB7IHB1YjogcGFyYW1zLnVzZXJLZXkgfTtcbiAgICAgICAgdXNlcktleWNoYWluUGFyYW1zID0gdXNlcktleWNoYWluO1xuICAgICAgICBpZiAocGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCkge1xuICAgICAgICAgIC8vIHRoZSBkZXJpdmF0aW9uIG9ubHkgbWFrZXMgc2Vuc2Ugd2hlbiBhIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgIGNvbnN0IGRlcml2YXRpb24gPSB0aGlzLmJhc2VDb2luLmRlcml2ZUtleVdpdGhTZWVkKHtcbiAgICAgICAgICAgIGtleTogcGFyYW1zLnVzZXJLZXksXG4gICAgICAgICAgICBzZWVkOiBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlcml2YXRpb25QYXRoID0gZGVyaXZhdGlvbi5kZXJpdmF0aW9uUGF0aDtcbiAgICAgICAgICB1c2VyS2V5Y2hhaW4ucHViID0gZGVyaXZhdGlvbi5rZXk7XG4gICAgICAgICAgdXNlcktleWNoYWluLmRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQgPSBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZW5lcmF0ZSB1c2VyIGtleXBhaXIgd2l0aG91dCBwYXNzcGhyYXNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB1c2VyIGtleS5cbiAgICAgICAgdXNlcktleWNoYWluID0gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGUoKTtcbiAgICAgICAgdXNlcktleWNoYWluLmVuY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7IHBhc3N3b3JkOiBwYXNzcGhyYXNlLCBpbnB1dDogdXNlcktleWNoYWluLnBydiB9KTtcbiAgICAgICAgdXNlcktleWNoYWluUGFyYW1zID0ge1xuICAgICAgICAgIHB1YjogdXNlcktleWNoYWluLnB1YixcbiAgICAgICAgICBlbmNyeXB0ZWRQcnY6IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnYsXG4gICAgICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdXNlcktleWNoYWluUGFyYW1zLnJlcUlkID0gcmVxSWQ7XG4gICAgICBjb25zdCBuZXdVc2VyS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh1c2VyS2V5Y2hhaW5QYXJhbXMpO1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBuZXdVc2VyS2V5Y2hhaW4sIHVzZXJLZXljaGFpbik7XG4gICAgfTtcblxuICAgIGNvbnN0IGJhY2t1cEtleWNoYWluUHJvbWlzZSA9IGFzeW5jICgpOiBQcm9taXNlPEtleWNoYWluPiA9PiB7XG4gICAgICBpZiAocGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlcikge1xuICAgICAgICAvLyBJZiByZXF1ZXN0ZWQsIHVzZSBhIEtSUyBvciBiYWNrdXAga2V5IHByb3ZpZGVyXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cCh7XG4gICAgICAgICAgcHJvdmlkZXI6IHBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXIgfHwgJ2RlZmF1bHRSTUdCYWNrdXBQcm92aWRlcicsXG4gICAgICAgICAgZGlzYWJsZUtSU0VtYWlsOiBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsLFxuICAgICAgICAgIGtyc1NwZWNpZmljOiBwYXJhbXMua3JzU3BlY2lmaWMsXG4gICAgICAgICAgdHlwZTogdGhpcy5iYXNlQ29pbi5nZXRDaGFpbigpLFxuICAgICAgICAgIHJlcUlkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBwcm92aWRlZCBiYWNrdXAgeHB1YlxuICAgICAgaWYgKHBhcmFtcy5iYWNrdXBYcHViKSB7XG4gICAgICAgIC8vIHVzZXIgcHJvdmlkZWQgYmFja3VwIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuYWRkKHtcbiAgICAgICAgICBwdWI6IHBhcmFtcy5iYWNrdXBYcHViLFxuICAgICAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICAgICAgcmVxSWQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjYW5FbmNyeXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgYmFja3VwIGtleXBhaXIgd2l0aG91dCBwYXNzcGhyYXNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gcHJvdmlkZWQgYmFja3VwIHhwdWIgb3IgYWRkcmVzcywgc28gZGVmYXVsdCB0byBjcmVhdGluZyBvbmUgaGVyZVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVCYWNrdXAoeyByZXFJZCB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH06IEtleWNoYWluc1RyaXBsZXQgPSBhd2FpdCBwcm9taXNlUHJvcHMoe1xuICAgICAgdXNlcktleWNoYWluOiB1c2VyS2V5Y2hhaW5Qcm9taXNlKCksXG4gICAgICBiYWNrdXBLZXljaGFpbjogYmFja3VwS2V5Y2hhaW5Qcm9taXNlKCksXG4gICAgICBiaXRnb0tleWNoYWluOiB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJpdEdvKHsgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsIHJlcUlkIH0pLFxuICAgIH0pO1xuXG4gICAgd2FsbGV0UGFyYW1zLmtleXMgPSBbdXNlcktleWNoYWluLmlkLCBiYWNrdXBLZXljaGFpbi5pZCwgYml0Z29LZXljaGFpbi5pZF07XG5cbiAgICB3YWxsZXRQYXJhbXMuaXNDb2xkID0gaXNDb2xkO1xuXG4gICAgY29uc3QgeyBwcnYgfSA9IHVzZXJLZXljaGFpbjtcbiAgICBpZiAoXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICB3YWxsZXRQYXJhbXMua2V5U2lnbmF0dXJlcyA9IHtcbiAgICAgICAgYmFja3VwOiAoYXdhaXQgdGhpcy5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBiYWNrdXBLZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIGJpdGdvOiAoYXdhaXQgdGhpcy5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBiaXRnb0tleWNoYWluLnB1YikpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKF8uaW5jbHVkZXMoWyd4cnAnLCAneGxtJywgJ2NzcHInXSwgdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLnJvb3RQcml2YXRlS2V5KSkge1xuICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0gcGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgIH1cblxuICAgIGNvbnN0IGtleWNoYWlucyA9IHtcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuICAgIGNvbnN0IGZpbmFsV2FsbGV0UGFyYW1zID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5zdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQod2FsbGV0UGFyYW1zLCBrZXljaGFpbnMpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgY29uc3QgbmV3V2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnNlbmQoZmluYWxXYWxsZXRQYXJhbXMpLnJlc3VsdCgpO1xuXG4gICAgY29uc3QgcmVzdWx0OiBXYWxsZXRXaXRoS2V5Y2hhaW5zID0ge1xuICAgICAgd2FsbGV0OiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIG5ld1dhbGxldCksXG4gICAgICB1c2VyS2V5Y2hhaW46IHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluOiBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW46IGJpdGdvS2V5Y2hhaW4sXG4gICAgfTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChiYWNrdXBLZXljaGFpbi5wcnYpKSB7XG4gICAgICByZXN1bHQud2FybmluZyA9ICdCZSBzdXJlIHRvIGJhY2t1cCB0aGUgYmFja3VwIGtleWNoYWluIC0tIGl0IGlzIG5vdCBzdG9yZWQgYW55d2hlcmUgZWxzZSEnO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChkZXJpdmF0aW9uUGF0aCkpIHtcbiAgICAgIHVzZXJLZXljaGFpbi5kZXJpdmF0aW9uUGF0aCA9IGRlcml2YXRpb25QYXRoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgdXNlcidzIHdhbGxldCBzaGFyZXNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgbGlzdFNoYXJlcyhwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB3YWxsZXQgc2hhcmUgaW5mb3JtYXRpb24sIGluY2x1ZGluZyB0aGUgZW5jcnlwdGVkIHNoYXJpbmcga2V5Y2hhaW4uIHJlcXVpcmVzIHVubG9jayBpZiBrZXljaGFpbiBpcyBwcmVzZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gZ2V0IGluZm9ybWF0aW9uIG9uXG4gICAqL1xuICBhc3luYyBnZXRTaGFyZShwYXJhbXM6IHsgd2FsbGV0U2hhcmVJZD86IHN0cmluZyB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHBhcmFtcy5zdGF0ZSAtIHRoZSBuZXcgc3RhdGUgb2YgdGhlIHdhbGxldCBzaGFyZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyB1cGRhdGVTaGFyZShwYXJhbXM6IFVwZGF0ZVNoYXJlT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNlbmQgYSB3YWxsZXQgc2hhcmUgaW52aXRhdGlvbiBlbWFpbFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgd2hvc2UgaW52aXRpYXRpb24gc2hvdWxkIGJlIHJlc2VudFxuICAgKi9cbiAgYXN5bmMgcmVzZW5kU2hhcmVJbnZpdGUocGFyYW1zOiB7IHdhbGxldFNoYXJlSWQ/OiBzdHJpbmcgfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgY29uc3QgdXJsUGFydHMgPSBwYXJhbXMud2FsbGV0U2hhcmVJZCArICcvcmVzZW5kZW1haWwnO1xuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgdXJsUGFydHMpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIHVwZGF0ZVxuICAgKi9cbiAgYXN5bmMgY2FuY2VsU2hhcmUocGFyYW1zOiB7IHdhbGxldFNoYXJlSWQ/OiBzdHJpbmcgfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5kZWwodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSB3YWxsZXQgc2hhcmUsIGFkZGluZyB0aGUgd2FsbGV0IHRvIHRoZSB1c2VyJ3MgbGlzdFxuICAgKiBOZWVkcyBhIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQga2V5XG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBhY2NlcHRcbiAgICogQHBhcmFtIHBhcmFtcy51c2VyUGFzc3dvcmQgLSAocmVxdWlyZWQgaWYgbW9yZSBhIGtleWNoYWluIHdhcyBzaGFyZWQpIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3V2FsbGV0UGFzc3BocmFzZSAtIG5ldyB3YWxsZXQgcGFzc3BocmFzZSBmb3Igc2F2aW5nIHRoZSBzaGFyZWQgd2FsbGV0IHBydi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbGVmdCBibGFuayBhbmQgYSB3YWxsZXQgd2l0aCBtb3JlIHRoYW4gdmlldyBwZXJtaXNzaW9ucyB3YXMgc2hhcmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIHRoZSB1c2VyJ3MgbG9naW4gcGFzc3dvcmQgaXMgdXNlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5vdmVycmlkZUVuY3J5cHRlZFBydiAtIHNldCBvbmx5IGlmIHRoZSBwcnYgd2FzIHJlY2VpdmVkIG91dC1vZi1iYW5kLlxuICAgKi9cbiAgYXN5bmMgYWNjZXB0U2hhcmUocGFyYW1zOiBBY2NlcHRTaGFyZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFsnb3ZlcnJpZGVFbmNyeXB0ZWRQcnYnLCAndXNlclBhc3N3b3JkJywgJ25ld1dhbGxldFBhc3NwaHJhc2UnXSk7XG5cbiAgICBsZXQgZW5jcnlwdGVkUHJ2ID0gcGFyYW1zLm92ZXJyaWRlRW5jcnlwdGVkUHJ2O1xuXG4gICAgY29uc3Qgd2FsbGV0U2hhcmUgPSAoYXdhaXQgdGhpcy5nZXRTaGFyZSh7IHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkIH0pKSBhcyBhbnk7XG5cbiAgICAvLyBSZXR1cm4gcmlnaHQgYXdheSBpZiB0aGVyZSBpcyBubyBrZXljaGFpbiB0byBkZWNyeXB0LCBvciBpZiBleHBsaWNpdCBlbmNyeXB0ZWRQcnYgd2FzIHByb3ZpZGVkXG4gICAgaWYgKCF3YWxsZXRTaGFyZS5rZXljaGFpbiB8fCAhd2FsbGV0U2hhcmUua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2IHx8IGVuY3J5cHRlZFBydikge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmUoe1xuICAgICAgICB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCxcbiAgICAgICAgc3RhdGU6ICdhY2NlcHRlZCcsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNb3JlIHRoYW4gdmlld2luZyB3YXMgcmVxdWVzdGVkLCBzbyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIHdhbGxldCBrZXlzIHVzaW5nIHRoZSBzaGFyZWQgZWNkaCBzY2hlbWVcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlclBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFzc3dvcmQgcGFyYW0gbXVzdCBiZSBwcm92aWRlZCB0byBkZWNyeXB0IHNoYXJlZCBrZXknKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFyaW5nS2V5Y2hhaW4gPSAoYXdhaXQgdGhpcy5iaXRnby5nZXRFQ0RIU2hhcmluZ0tleWNoYWluKCkpIGFzIGFueTtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChzaGFyaW5nS2V5Y2hhaW4uZW5jcnlwdGVkWHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZW5jcnlwdGVkWHBydiB3YXMgbm90IGZvdW5kIG9uIHNoYXJpbmcga2V5Y2hhaW4nKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSB0aGUgc2hhcmluZyBrZXljaGFpbiwgd2UgY2FuIHdvcmsgb3V0IHRoZSBzZWNyZXQgdXNlZCBmb3Igc2hhcmluZyB0aGUgd2FsbGV0IHdpdGggdXNcbiAgICBzaGFyaW5nS2V5Y2hhaW4ucHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgIHBhc3N3b3JkOiBwYXJhbXMudXNlclBhc3N3b3JkLFxuICAgICAgaW5wdXQ6IHNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2LFxuICAgIH0pO1xuICAgIGNvbnN0IHNlY3JldCA9IGdldFNoYXJlZFNlY3JldChcbiAgICAgIC8vIERlcml2ZSBrZXkgYnkgcGF0aCAod2hpY2ggaXMgdXNlZCBiZXR3ZWVuIHRoZXNlIDIgdXNlcnMgb25seSlcbiAgICAgIGJpcDMyLmZyb21CYXNlNTgoc2hhcmluZ0tleWNoYWluLnBydikuZGVyaXZlUGF0aChzYW5pdGl6ZUxlZ2FjeVBhdGgod2FsbGV0U2hhcmUua2V5Y2hhaW4ucGF0aCkpLFxuICAgICAgQnVmZmVyLmZyb20od2FsbGV0U2hhcmUua2V5Y2hhaW4uZnJvbVB1YktleSwgJ2hleCcpXG4gICAgKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICAvLyBZZXMhIFdlIGdvdCB0aGUgc2VjcmV0IHN1Y2Nlc3NmdWxseSBoZXJlLCBub3cgZGVjcnlwdCB0aGUgc2hhcmVkIHdhbGxldCBwcnZcbiAgICBjb25zdCBkZWNyeXB0ZWRTaGFyZWRXYWxsZXRQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgcGFzc3dvcmQ6IHNlY3JldCxcbiAgICAgIGlucHV0OiB3YWxsZXRTaGFyZS5rZXljaGFpbi5lbmNyeXB0ZWRQcnYsXG4gICAgfSk7XG5cbiAgICAvLyBXZSB3aWxsIG5vdyByZS1lbmNyeXB0IHRoZSB3YWxsZXQgd2l0aCBvdXIgb3duIHBhc3N3b3JkXG4gICAgY29uc3QgbmV3V2FsbGV0UGFzc3BocmFzZSA9IHBhcmFtcy5uZXdXYWxsZXRQYXNzcGhyYXNlIHx8IHBhcmFtcy51c2VyUGFzc3dvcmQ7XG4gICAgZW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHtcbiAgICAgIHBhc3N3b3JkOiBuZXdXYWxsZXRQYXNzcGhyYXNlLFxuICAgICAgaW5wdXQ6IGRlY3J5cHRlZFNoYXJlZFdhbGxldFBydixcbiAgICB9KTtcbiAgICBjb25zdCB1cGRhdGVQYXJhbXM6IFVwZGF0ZVNoYXJlT3B0aW9ucyA9IHtcbiAgICAgIHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkLFxuICAgICAgc3RhdGU6ICdhY2NlcHRlZCcsXG4gICAgfTtcblxuICAgIGlmIChlbmNyeXB0ZWRQcnYpIHtcbiAgICAgIHVwZGF0ZVBhcmFtcy5lbmNyeXB0ZWRQcnYgPSBlbmNyeXB0ZWRQcnY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmUodXBkYXRlUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB3YWxsZXQgYnkgaXRzIElEXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5pZCB3YWxsZXQgaWRcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBnZXRXYWxsZXQocGFyYW1zOiBHZXRXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPFdhbGxldD4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10pO1xuXG4gICAgY29uc3QgcXVlcnk6IEdldFdhbGxldE9wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCkpO1xuXG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgcGFyYW1zLmlkKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3YWxsZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSBpdHMgYWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyB3YWxsZXQgYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFdhbGxldEJ5QWRkcmVzcyhwYXJhbXM6IEdldFdhbGxldEJ5QWRkcmVzc09wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFtdKTtcblxuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKSk7XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC9hZGRyZXNzLycgKyBwYXJhbXMuYWRkcmVzcykpLnJlc3VsdCgpO1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIHdhbGxldCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGFueSBnaXZlbiBzdXBwb3J0ZWQgY29pbiwgZ2V0IHRvdGFsIGJhbGFuY2VzIGZvciBhbGwgd2FsbGV0cyBvZiB0aGF0XG4gICAqIGNvaW4gdHlwZSBvbiB0aGUgYWNjb3VudC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsQmFsYW5jZXMocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0L2JhbGFuY2VzJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFRTUyBvciBCTFMtREtHIFdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZU1wY1dhbGxldChwYXJhbXM6IEdlbmVyYXRlTXBjV2FsbGV0T3B0aW9ucyk6IFByb21pc2U8V2FsbGV0V2l0aEtleWNoYWlucz4ge1xuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuXG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWw6IHBhcmFtcy5sYWJlbCxcbiAgICAgIG06IDIsXG4gICAgICBuOiAzLFxuICAgICAga2V5czogW10sXG4gICAgICBpc0NvbGQ6IGZhbHNlLFxuICAgICAgbXVsdGlzaWdUeXBlOiBwYXJhbXMubXVsdGlzaWdUeXBlLFxuICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBNUEMgS2V5Y2hhaW5zXG5cbiAgICBjb25zdCBrZXljaGFpbnMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZU1wYyh7XG4gICAgICBtdWx0aXNpZ1R5cGU6IHBhcmFtcy5tdWx0aXNpZ1R5cGUsXG4gICAgICBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSxcbiAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMub3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgdXNlcktleWNoYWluLCBiYWNrdXBLZXljaGFpbiwgYml0Z29LZXljaGFpbiB9ID0ga2V5Y2hhaW5zO1xuICAgIHdhbGxldFBhcmFtcy5rZXlzID0gW3VzZXJLZXljaGFpbi5pZCwgYmFja3VwS2V5Y2hhaW4uaWQsIGJpdGdvS2V5Y2hhaW4uaWRdO1xuXG4gICAgLy8gQ3JlYXRlIFdhbGxldFxuICAgIGNvbnN0IGZpbmFsV2FsbGV0UGFyYW1zID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5zdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQod2FsbGV0UGFyYW1zLCBrZXljaGFpbnMpO1xuICAgIGNvbnN0IG5ld1dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5zZW5kKGZpbmFsV2FsbGV0UGFyYW1zKS5yZXN1bHQoKTtcblxuICAgIGNvbnN0IHJlc3VsdDogV2FsbGV0V2l0aEtleWNoYWlucyA9IHtcbiAgICAgIHdhbGxldDogbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgICAgdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgIH07XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoYmFja3VwS2V5Y2hhaW4ucHJ2KSkge1xuICAgICAgcmVzdWx0Lndhcm5pbmcgPSAnQmUgc3VyZSB0byBiYWNrdXAgdGhlIGJhY2t1cCBrZXljaGFpbiAtLSBpdCBpcyBub3Qgc3RvcmVkIGFueXdoZXJlIGVsc2UhJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iXX0=