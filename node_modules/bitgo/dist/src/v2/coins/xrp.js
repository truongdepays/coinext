"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xrp = void 0;
/**
 * @prettier
 */
const bip32 = require("bip32");
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const _ = require("lodash");
const url = require("url");
const querystring = require("querystring");
const rippleAddressCodec = require("ripple-address-codec");
const rippleBinaryCodec = require("ripple-binary-codec");
const hashes_1 = require("ripple-lib/dist/npm/common/hashes");
const rippleKeypairs = require("ripple-keypairs");
const baseCoin_1 = require("../baseCoin");
const errors_1 = require("../../errors");
const promise_utils_1 = require("../promise-utils");
const initiate_1 = require("../recovery/initiate");
const ripple = require('../../ripple');
class Xrp extends baseCoin_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
    }
    static createInstance(bitgo) {
        return new Xrp(bitgo);
    }
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e6;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xrp';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xrp';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Ripple';
    }
    /**
     * Parse an address string into address and destination tag
     */
    getAddressDetails(address) {
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !rippleAddressCodec.isValidClassicAddress(destinationAddress)) {
            throw new errors_1.InvalidAddressError(`destination address "${destinationAddress}" is not valid`);
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError('no query params present');
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new errors_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new errors_1.InvalidAddressError(`destination tag can appear at most once, but ${queryDetails.dt.length} destination tags were found`);
        }
        const parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new errors_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xffffffff || parsedTag < 0) {
            throw new errors_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag,
        };
    }
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    normalizeAddress({ address, destinationTag }) {
        if (!_.isString(address)) {
            throw new errors_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return `${address}?dt=${destinationTag}`;
        }
        return address;
    }
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        try {
            return bip32.fromBase58(pub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Get fee info from server
     */
    async getFeeInfo() {
        return this.bitgo.get(this.url('/public/feeinfo')).result();
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns Bluebird<HalfSignedTransaction>
     */
    async signTransaction({ txPrebuild, prv }) {
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(prv) || !_.isString(prv)) {
            if (!_.isUndefined(prv) && !_.isString(prv)) {
                throw new Error(`prv must be a string, got type ${typeof prv}`);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        const userKey = bip32.fromBase58(prv);
        const userPrivateKey = userKey.privateKey;
        if (!userPrivateKey) {
            throw new Error(`no privateKey`);
        }
        const userAddress = rippleKeypairs.deriveAddress(userKey.publicKey.toString('hex'));
        const rippleLib = ripple();
        const halfSigned = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), {
            signAs: userAddress,
        });
        return { halfSigned: { txHex: halfSigned.signedTransaction } };
    }
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     */
    async supplementGenerateWallet(walletParams) {
        if (walletParams.rootPrivateKey) {
            if (walletParams.rootPrivateKey.length !== 64) {
                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
            }
        }
        else {
            const keyPair = utxo_lib_1.ECPair.makeRandom();
            if (!keyPair.privateKey) {
                throw new Error('no privateKey');
            }
            walletParams.rootPrivateKey = keyPair.privateKey.toString('hex');
        }
        return walletParams;
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params = {}) {
        if (!params.txHex) {
            throw new Error('missing required param txHex');
        }
        let transaction;
        let txHex;
        try {
            transaction = rippleBinaryCodec.decode(params.txHex);
            txHex = params.txHex;
        }
        catch (e) {
            try {
                transaction = JSON.parse(params.txHex);
                txHex = rippleBinaryCodec.encode(transaction);
            }
            catch (e) {
                throw new Error('txHex needs to be either hex or JSON string for XRP');
            }
        }
        const id = hashes_1.computeBinaryTransactionHash(txHex);
        if (transaction.TransactionType == 'AccountSet') {
            return {
                displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'accountSet'],
                id: id,
                changeOutputs: [],
                outputAmount: 0,
                changeAmount: 0,
                outputs: [],
                fee: {
                    fee: transaction.Fee,
                    feeRate: null,
                    size: txHex.length / 2,
                },
                accountSet: {
                    messageKey: transaction.MessageKey,
                },
            };
        }
        const address = transaction.Destination + (transaction.DestinationTag >= 0 ? '?dt=' + transaction.DestinationTag : '');
        return {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
            id: id,
            changeOutputs: [],
            outputAmount: transaction.Amount,
            changeAmount: 0,
            outputs: [
                {
                    address,
                    amount: transaction.Amount,
                },
            ],
            fee: {
                fee: transaction.Fee,
                feeRate: null,
                size: txHex.length / 2,
            },
        };
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @returns {boolean}
     */
    async verifyTransaction({ txParams, txPrebuild }) {
        const explanation = await this.explainTransaction({
            txHex: txPrebuild.txHex,
        });
        const output = [...explanation.outputs, ...explanation.changeOutputs][0];
        const expectedOutput = txParams.recipients && txParams.recipients[0];
        const comparator = (recipient1, recipient2) => {
            if (recipient1.address !== recipient2.address) {
                return false;
            }
            const amount1 = new bignumber_js_1.BigNumber(recipient1.amount);
            const amount2 = new bignumber_js_1.BigNumber(recipient2.amount);
            return amount1.toFixed() === amount2.toFixed();
        };
        if (!comparator(output, expectedOutput)) {
            throw new Error('transaction prebuild does not match expected output');
        }
        return true;
    }
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     * @return true iff address is a wallet address (based on rootAddress)
     */
    isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError(`address verification failure: address "${address}" is not valid`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError(`address validation failure: ${addressDetails.address} vs. ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    getRippledUrl() {
        return 'https://s1.ripple.com:51234';
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        const rippledUrl = this.getRippledUrl();
        const isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
        const isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
        const accountInfoParams = {
            method: 'account_info',
            params: [
                {
                    account: params.rootAddress,
                    strict: true,
                    ledger_index: 'current',
                    queue: true,
                    signer_lists: true,
                },
            ],
        };
        if (isKrsRecovery) {
            initiate_1.checkKrsProvider(this, params.krsProvider);
        }
        // Validate the destination address
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        const keys = initiate_1.getBip32Keys(this.bitgo, params, { requireBitGoXpub: false });
        const { addressDetails, feeDetails, serverDetails } = await promise_utils_1.promiseProps({
            addressDetails: this.bitgo.post(rippledUrl).send(accountInfoParams),
            feeDetails: this.bitgo.post(rippledUrl).send({ method: 'fee' }),
            serverDetails: this.bitgo.post(rippledUrl).send({ method: 'server_info' }),
        });
        const openLedgerFee = new bignumber_js_1.BigNumber(feeDetails.body.result.drops.open_ledger_fee);
        const baseReserve = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(this.getBaseFactor());
        const reserveDelta = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(this.getBaseFactor());
        const currentLedger = serverDetails.body.result.info.validated_ledger.seq;
        const sequenceId = addressDetails.body.result.account_data.Sequence;
        const balance = new bignumber_js_1.BigNumber(addressDetails.body.result.account_data.Balance);
        const signerLists = addressDetails.body.result.account_data.signer_lists;
        const accountFlags = addressDetails.body.result.account_data.Flags;
        // make sure there is only one signer list set
        if (signerLists.length !== 1) {
            throw new Error('unexpected set of signer lists');
        }
        // make sure the signers are user, backup, bitgo
        const userAddress = rippleKeypairs.deriveAddress(keys[0].publicKey.toString('hex'));
        const backupAddress = rippleKeypairs.deriveAddress(keys[1].publicKey.toString('hex'));
        const signerList = signerLists[0];
        if (signerList.SignerQuorum !== 2) {
            throw new Error('invalid minimum signature count');
        }
        const foundAddresses = {};
        const signerEntries = signerList.SignerEntries;
        if (signerEntries.length !== 3) {
            throw new Error('invalid signer list length');
        }
        for (const { SignerEntry } of signerEntries) {
            const weight = SignerEntry.SignerWeight;
            const address = SignerEntry.Account;
            if (weight !== 1) {
                throw new Error('invalid signer weight');
            }
            // if it's a dupe of an address we already know, block
            if (foundAddresses[address] >= 1) {
                throw new Error('duplicate signer address');
            }
            foundAddresses[address] = (foundAddresses[address] || 0) + 1;
        }
        if (foundAddresses[userAddress] !== 1) {
            throw new Error('unexpected incidence frequency of user signer address');
        }
        if (foundAddresses[backupAddress] !== 1) {
            throw new Error('unexpected incidence frequency of user signer address');
        }
        // make sure the flags disable the master key and enforce destination tags
        const USER_KEY_SETTING_FLAG = 65536;
        const MASTER_KEY_DEACTIVATION_FLAG = 1048576;
        const REQUIRE_DESTINATION_TAG_FLAG = 131072;
        if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
            throw new Error('a custom user key has been set');
        }
        if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
            throw new Error('the master key has not been deactivated');
        }
        if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
            throw new Error('the destination flag requirement has not been activated');
        }
        // recover the funds
        const reserve = baseReserve.plus(reserveDelta.times(5));
        const recoverableBalance = balance.minus(reserve);
        const rawDestination = params.recoveryDestination;
        const destinationDetails = url.parse(rawDestination);
        const destinationAddress = destinationDetails.pathname;
        // parse destination tag from query
        let destinationTag;
        if (destinationDetails.query) {
            const queryDetails = querystring.parse(destinationDetails.query);
            if (Array.isArray(queryDetails.dt)) {
                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                throw new errors_1.InvalidAddressError(`destination tag can appear at most once, but ${queryDetails.dt.length} destination tags were found`);
            }
            const parsedTag = parseInt(queryDetails.dt, 10);
            if (Number.isInteger(parsedTag)) {
                destinationTag = parsedTag;
            }
        }
        const transaction = {
            TransactionType: 'Payment',
            Account: params.rootAddress,
            Destination: destinationAddress,
            DestinationTag: destinationTag,
            Amount: recoverableBalance.toFixed(0),
            Flags: 2147483648,
            LastLedgerSequence: currentLedger + 1000000,
            Fee: openLedgerFee.times(3).toFixed(0),
            Sequence: sequenceId,
        };
        const txJSON = JSON.stringify(transaction);
        if (isUnsignedSweep) {
            return txJSON;
        }
        const rippleLib = ripple();
        if (!keys[0].privateKey) {
            throw new Error(`userKey is not a private key`);
        }
        const userKey = keys[0].privateKey.toString('hex');
        const userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
        let signedTransaction;
        if (isKrsRecovery) {
            signedTransaction = userSignature;
        }
        else {
            if (!keys[1].privateKey) {
                throw new Error(`backupKey is not a private key`);
            }
            const backupKey = keys[1].privateKey.toString('hex');
            const backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
            signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
        }
        const transactionExplanation = (await this.explainTransaction({
            txHex: signedTransaction.signedTransaction,
        }));
        transactionExplanation.txHex = signedTransaction.signedTransaction;
        if (isKrsRecovery) {
            transactionExplanation.backupKey = params.backupKey;
            transactionExplanation.coin = this.getChain();
        }
        return transactionExplanation;
    }
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const extendedKey = bip32.fromSeed(seed);
        const xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    }
    async parseTransaction(params) {
        return {};
    }
}
exports.Xrp = Xrp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILCtCQUErQjtBQUMvQiwrQ0FBeUM7QUFDekMsOENBQXlDO0FBQ3pDLG1DQUFxQztBQUNyQyw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDJDQUEyQztBQUUzQywyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELDhEQUFpRjtBQUNqRixrREFBa0Q7QUFFbEQsMENBVXFCO0FBRXJCLHlDQUEyRTtBQUMzRSxvREFBZ0Q7QUFDaEQsbURBSThCO0FBRTlCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQXlEdkMsTUFBYSxHQUFJLFNBQVEsbUJBQVE7SUFDL0IsWUFBc0IsS0FBWTtRQUNoQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDZixDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTtRQUNsQixPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDYixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVM7UUFDZCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVc7UUFDaEIsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksaUJBQWlCLENBQUMsT0FBZTtRQUN0QyxNQUFNLGtCQUFrQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUMsTUFBTSxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUM7UUFDdkQsSUFBSSxDQUFDLGtCQUFr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QkFraEJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcblxuaW1wb3J0ICogYXMgcmlwcGxlQWRkcmVzc0NvZGVjIGZyb20gJ3JpcHBsZS1hZGRyZXNzLWNvZGVjJztcbmltcG9ydCAqIGFzIHJpcHBsZUJpbmFyeUNvZGVjIGZyb20gJ3JpcHBsZS1iaW5hcnktY29kZWMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCB9IGZyb20gJ3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2hhc2hlcyc7XG5pbXBvcnQgKiBhcyByaXBwbGVLZXlwYWlycyBmcm9tICdyaXBwbGUta2V5cGFpcnMnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgS2V5UGFpcixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBJbnZhbGlkQWRkcmVzc0Vycm9yLCBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IHByb21pc2VQcm9wcyB9IGZyb20gJy4uL3Byb21pc2UtdXRpbHMnO1xuaW1wb3J0IHtcbiAgY2hlY2tLcnNQcm92aWRlcixcbiAgZ2V0QmlwMzJLZXlzLFxuICBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyBhcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMsXG59IGZyb20gJy4uL3JlY292ZXJ5L2luaXRpYXRlJztcblxuY29uc3QgcmlwcGxlID0gcmVxdWlyZSgnLi4vLi4vcmlwcGxlJyk7XG5cbmludGVyZmFjZSBBZGRyZXNzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBkZXN0aW5hdGlvblRhZz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEZlZUluZm8ge1xuICBkYXRlOiBzdHJpbmc7XG4gIGhlaWdodDogbnVtYmVyO1xuICBiYXNlUmVzZXJ2ZTogc3RyaW5nO1xuICBiYXNlRmVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICB0eEhleDogc3RyaW5nO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMgZXh0ZW5kcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICByb290QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGJpdGdvS2V5Pzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG59XG5cbmludGVyZmFjZSBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgcm9vdFByaXZhdGVLZXk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBYcnAgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28pIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgWHJwKGJpdGdvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3IgYmV0d2VlbiB0aGUgY29pbidzIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICovXG4gIHB1YmxpYyBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDFlNjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgYmxvY2tjaGFpbiB3aGljaCBzdXBwb3J0cyB0aGlzIGNvaW5cbiAgICovXG4gIHB1YmxpYyBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAneHJwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgY29pbiBmYW1pbHlcbiAgICovXG4gIHB1YmxpYyBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hycCc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGlzIGNvaW5cbiAgICovXG4gIHB1YmxpYyBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnUmlwcGxlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBhZGRyZXNzIHN0cmluZyBpbnRvIGFkZHJlc3MgYW5kIGRlc3RpbmF0aW9uIHRhZ1xuICAgKi9cbiAgcHVibGljIGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3Mge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShhZGRyZXNzKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWU7XG4gICAgaWYgKCFkZXN0aW5hdGlvbkFkZHJlc3MgfHwgIXJpcHBsZUFkZHJlc3NDb2RlYy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MoZGVzdGluYXRpb25BZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGRlc3RpbmF0aW9uIGFkZHJlc3MgXCIke2Rlc3RpbmF0aW9uQWRkcmVzc31cIiBpcyBub3QgdmFsaWRgKTtcbiAgICB9XG4gICAgLy8gdGhlcmUgYXJlIG5vIG90aGVyIHByb3BlcnRpZXMgbGlrZSBkZXN0aW5hdGlvbiB0YWdzXG4gICAgaWYgKGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSA9PT0gYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgZGVzdGluYXRpb25UYWc6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdubyBxdWVyeSBwYXJhbXMgcHJlc2VudCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgaWYgKCFxdWVyeURldGFpbHMuZHQpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMsIHRoZSBxdWVyeSBkZXRhaWxzIG5lZWQgdG8gY29udGFpbiB0aGUgZGVzdGluYXRpb24gdGFnIHByb3BlcnR5LlxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2Rlc3RpbmF0aW9uIHRhZyBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLmR0KSkge1xuICAgICAgLy8gaWYgcXVlcnlEZXRhaWxzLmR0IGlzIGFuIGFycmF5LCB0aGF0IG1lYW5zIGR0IHdhcyBnaXZlbiBtdWx0aXBsZSB0aW1lcywgd2hpY2ggaXMgbm90IHZhbGlkXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYGRlc3RpbmF0aW9uIHRhZyBjYW4gYXBwZWFyIGF0IG1vc3Qgb25jZSwgYnV0ICR7cXVlcnlEZXRhaWxzLmR0Lmxlbmd0aH0gZGVzdGluYXRpb24gdGFncyB3ZXJlIGZvdW5kYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRUYWcgPSBwYXJzZUludChxdWVyeURldGFpbHMuZHQsIDEwKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHBhcnNlZFRhZykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdpbnZhbGlkIGRlc3RpbmF0aW9uIHRhZycpO1xuICAgIH1cblxuICAgIGlmIChwYXJzZWRUYWcgPiAweGZmZmZmZmZmIHx8IHBhcnNlZFRhZyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdkZXN0aW5hdGlvbiB0YWcgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgIGRlc3RpbmF0aW9uVGFnOiBwYXJzZWRUYWcsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBmdWxsLCBub3JtYWxpemVkIGFkZHJlc3MgZnJvbSBhbiBhZGRyZXNzIGFuZCBkZXN0aW5hdGlvbiB0YWdcbiAgICovXG4gIHB1YmxpYyBub3JtYWxpemVBZGRyZXNzKHsgYWRkcmVzcywgZGVzdGluYXRpb25UYWcgfTogQWRkcmVzcyk6IHN0cmluZyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignaW52YWxpZCBhZGRyZXNzIGRldGFpbHMnKTtcbiAgICB9XG4gICAgaWYgKF8uaXNJbnRlZ2VyKGRlc3RpbmF0aW9uVGFnKSkge1xuICAgICAgcmV0dXJuIGAke2FkZHJlc3N9P2R0PSR7ZGVzdGluYXRpb25UYWd9YDtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGVzIHdoZXRoZXIgYW4gYWRkcmVzcyBzdHJpbmcgaXMgdmFsaWQgZm9yIHRoaXMgY29pblxuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKi9cbiAgcHVibGljIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWRkcmVzcyA9PT0gdGhpcy5ub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgcHVibGljIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJpcDMyLmZyb21CYXNlNTgocHViKS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmVlIGluZm8gZnJvbSBzZXJ2ZXJcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRGZWVJbmZvKCk6IFByb21pc2U8RmVlSW5mbz4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3B1YmxpYy9mZWVpbmZvJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHR4UHJlYnVpbGRcbiAgICogLSBwcnZcbiAgICogQHJldHVybnMgQmx1ZWJpcmQ8SGFsZlNpZ25lZFRyYW5zYWN0aW9uPlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih7IHR4UHJlYnVpbGQsIHBydiB9OiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSB8fCAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpICYmICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikgfHwgIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBydikgJiYgIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlcktleSA9IGJpcDMyLmZyb21CYXNlNTgocHJ2KTtcbiAgICBjb25zdCB1c2VyUHJpdmF0ZUtleSA9IHVzZXJLZXkucHJpdmF0ZUtleTtcbiAgICBpZiAoIXVzZXJQcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHByaXZhdGVLZXlgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKHVzZXJLZXkucHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKSk7XG5cbiAgICBjb25zdCByaXBwbGVMaWIgPSByaXBwbGUoKTtcbiAgICBjb25zdCBoYWxmU2lnbmVkID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eFByZWJ1aWxkLnR4SGV4LCB1c2VyUHJpdmF0ZUtleS50b1N0cmluZygnaGV4JyksIHtcbiAgICAgIHNpZ25BczogdXNlckFkZHJlc3MsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogeyB0eEhleDogaGFsZlNpZ25lZC5zaWduZWRUcmFuc2FjdGlvbiB9IH07XG4gIH1cblxuICAvKipcbiAgICogUmlwcGxlIHJlcXVpcmVzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3Igd2FsbGV0IGdlbmVyYXRpb24gdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLiBUaGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFyZVxuICAgKiB0aGUgcm9vdCBwdWJsaWMga2V5LCB3aGljaCBpcyB0aGUgYmFzaXMgb2YgdGhlIHJvb3QgYWRkcmVzcywgdHdvIHNpZ25lZCwgYW5kIG9uZSBoYWxmLXNpZ25lZCBpbml0aWFsaXphdGlvbiB0eHNcbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKiAtIHJvb3RQcml2YXRlS2V5OiBvcHRpb25hbCBoZXgtZW5jb2RlZCBSaXBwbGUgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGFzeW5jIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldChcbiAgICB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPiB7XG4gICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdFByaXZhdGVLZXkgbmVlZHMgdG8gYmUgYSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5UGFpciA9IEVDUGFpci5tYWtlUmFuZG9tKCk7XG4gICAgICBpZiAoIWtleVBhaXIucHJpdmF0ZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGVLZXknKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zID0ge30pOiBQcm9taXNlPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBpZiAoIXBhcmFtcy50eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIHR4SGV4Jyk7XG4gICAgfVxuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBsZXQgdHhIZXg7XG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zYWN0aW9uID0gcmlwcGxlQmluYXJ5Q29kZWMuZGVjb2RlKHBhcmFtcy50eEhleCk7XG4gICAgICB0eEhleCA9IHBhcmFtcy50eEhleDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IEpTT04ucGFyc2UocGFyYW1zLnR4SGV4KTtcbiAgICAgICAgdHhIZXggPSByaXBwbGVCaW5hcnlDb2RlYy5lbmNvZGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4SGV4IG5lZWRzIHRvIGJlIGVpdGhlciBoZXggb3IgSlNPTiBzdHJpbmcgZm9yIFhSUCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpZCA9IGNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2godHhIZXgpO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLlRyYW5zYWN0aW9uVHlwZSA9PSAnQWNjb3VudFNldCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnLCAnYWNjb3VudFNldCddLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IDAsXG4gICAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGZlZToge1xuICAgICAgICAgIGZlZTogdHJhbnNhY3Rpb24uRmVlLFxuICAgICAgICAgIGZlZVJhdGU6IG51bGwsXG4gICAgICAgICAgc2l6ZTogdHhIZXgubGVuZ3RoIC8gMixcbiAgICAgICAgfSxcbiAgICAgICAgYWNjb3VudFNldDoge1xuICAgICAgICAgIG1lc3NhZ2VLZXk6IHRyYW5zYWN0aW9uLk1lc3NhZ2VLZXksXG4gICAgICAgIH0sXG4gICAgICB9IGFzIGFueTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzID1cbiAgICAgIHRyYW5zYWN0aW9uLkRlc3RpbmF0aW9uICsgKHRyYW5zYWN0aW9uLkRlc3RpbmF0aW9uVGFnID49IDAgPyAnP2R0PScgKyB0cmFuc2FjdGlvbi5EZXN0aW5hdGlvblRhZyA6ICcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyOiBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdjaGFuZ2VBbW91bnQnLCAnb3V0cHV0cycsICdjaGFuZ2VPdXRwdXRzJywgJ2ZlZSddLFxuICAgICAgaWQ6IGlkLFxuICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICBvdXRwdXRBbW91bnQ6IHRyYW5zYWN0aW9uLkFtb3VudCxcbiAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiB0cmFuc2FjdGlvbi5BbW91bnQsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZmVlOiB7XG4gICAgICAgIGZlZTogdHJhbnNhY3Rpb24uRmVlLFxuICAgICAgICBmZWVSYXRlOiBudWxsLFxuICAgICAgICBzaXplOiB0eEhleC5sZW5ndGggLyAyLFxuICAgICAgfSxcbiAgICB9IGFzIGFueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0gdHhQYXJhbXMgcGFyYW1zIG9iamVjdCBwYXNzZWQgdG8gc2VuZFxuICAgKiBAcGFyYW0gdHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSB3YWxsZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24oeyB0eFBhcmFtcywgdHhQcmVidWlsZCB9OiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBleHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgIHR4SGV4OiB0eFByZWJ1aWxkLnR4SGV4LFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gWy4uLmV4cGxhbmF0aW9uLm91dHB1dHMsIC4uLmV4cGxhbmF0aW9uLmNoYW5nZU91dHB1dHNdWzBdO1xuICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0ID0gdHhQYXJhbXMucmVjaXBpZW50cyAmJiB0eFBhcmFtcy5yZWNpcGllbnRzWzBdO1xuXG4gICAgY29uc3QgY29tcGFyYXRvciA9IChyZWNpcGllbnQxLCByZWNpcGllbnQyKSA9PiB7XG4gICAgICBpZiAocmVjaXBpZW50MS5hZGRyZXNzICE9PSByZWNpcGllbnQyLmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYW1vdW50MSA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50MS5hbW91bnQpO1xuICAgICAgY29uc3QgYW1vdW50MiA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50Mi5hbW91bnQpO1xuICAgICAgcmV0dXJuIGFtb3VudDEudG9GaXhlZCgpID09PSBhbW91bnQyLnRvRml4ZWQoKTtcbiAgICB9O1xuXG4gICAgaWYgKCFjb21wYXJhdG9yKG91dHB1dCwgZXhwZWN0ZWRPdXRwdXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIG91dHB1dCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFkZHJlc3MgaXMgYSB2YWxpZCBYUlAgYWRkcmVzcywgYW5kIHRoZW4gbWFrZSBzdXJlIHRoZSByb290IGFkZHJlc3NlcyBtYXRjaC5cbiAgICogVGhpcyBwcmV2ZW50cyBhdHRhY2tzIHdoZXJlIGFuIGF0dGFjayBtYXkgc3dpdGNoIG91dCB0aGUgbmV3IGFkZHJlc3MgZm9yIG9uZSBvZiB0aGVpciBvd25cbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSByb290QWRkcmVzcyB7U3RyaW5nfSB0aGUgd2FsbGV0J3Mgcm9vdCBhZGRyZXNzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZmYgYWRkcmVzcyBpcyBhIHdhbGxldCBhZGRyZXNzIChiYXNlZCBvbiByb290QWRkcmVzcylcbiAgICovXG4gIHB1YmxpYyBpc1dhbGxldEFkZHJlc3MoeyBhZGRyZXNzLCByb290QWRkcmVzcyB9OiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmVyaWZpY2F0aW9uIGZhaWx1cmU6IGFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgIGNvbnN0IHJvb3RBZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMocm9vdEFkZHJlc3MpO1xuXG4gICAgaWYgKGFkZHJlc3NEZXRhaWxzLmFkZHJlc3MgIT09IHJvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9IHZzLiAke3Jvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVVJMIG9mIGEgd2VsbC1rbm93biwgcHVibGljIGZhY2luZyAobm9uLWJpdGdvKSByaXBwbGVkIGluc3RhbmNlIHdoaWNoIGNhbiBiZSB1c2VkIGZvciByZWNvdmVyeVxuICAgKi9cbiAgcHVibGljIGdldFJpcHBsZWRVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2h0dHBzOi8vczEucmlwcGxlLmNvbTo1MTIzNCc7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gcm9vdEFkZHJlc3M6IHJvb3QgWFJQIHdhbGxldCBhZGRyZXNzIHRvIHJlY292ZXIgZnVuZHMgZnJvbVxuICAgKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIHhwcnZcbiAgICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiAtIHdhbGxldFBhc3NwaHJhc2U6IG5lY2Vzc2FyeSBpZiBvbmUgb2YgdGhlIHhwcnZzIGlzIGVuY3J5cHRlZFxuICAgKiAtIGJpdGdvS2V5OiB4cHViXG4gICAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIC0gcmVjb3ZlcnlEZXN0aW5hdGlvbjogdGFyZ2V0IGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeUluZm8gfCBzdHJpbmc+IHtcbiAgICBjb25zdCByaXBwbGVkVXJsID0gdGhpcy5nZXRSaXBwbGVkVXJsKCk7XG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuXG4gICAgY29uc3QgYWNjb3VudEluZm9QYXJhbXMgPSB7XG4gICAgICBtZXRob2Q6ICdhY2NvdW50X2luZm8nLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBhY2NvdW50OiBwYXJhbXMucm9vdEFkZHJlc3MsXG4gICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIGxlZGdlcl9pbmRleDogJ2N1cnJlbnQnLFxuICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgIHNpZ25lcl9saXN0czogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBjaGVja0tyc1Byb3ZpZGVyKHRoaXMsIHBhcmFtcy5rcnNQcm92aWRlcik7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVzdGluYXRpb24gYWRkcmVzcyEnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKHRoaXMuYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiBmYWxzZSB9KTtcblxuICAgIGNvbnN0IHsgYWRkcmVzc0RldGFpbHMsIGZlZURldGFpbHMsIHNlcnZlckRldGFpbHMgfSA9IGF3YWl0IHByb21pc2VQcm9wcyh7XG4gICAgICBhZGRyZXNzRGV0YWlsczogdGhpcy5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoYWNjb3VudEluZm9QYXJhbXMpLFxuICAgICAgZmVlRGV0YWlsczogdGhpcy5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoeyBtZXRob2Q6ICdmZWUnIH0pLFxuICAgICAgc2VydmVyRGV0YWlsczogdGhpcy5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoeyBtZXRob2Q6ICdzZXJ2ZXJfaW5mbycgfSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBvcGVuTGVkZ2VyRmVlID0gbmV3IEJpZ051bWJlcihmZWVEZXRhaWxzLmJvZHkucmVzdWx0LmRyb3BzLm9wZW5fbGVkZ2VyX2ZlZSk7XG4gICAgY29uc3QgYmFzZVJlc2VydmUgPSBuZXcgQmlnTnVtYmVyKHNlcnZlckRldGFpbHMuYm9keS5yZXN1bHQuaW5mby52YWxpZGF0ZWRfbGVkZ2VyLnJlc2VydmVfYmFzZV94cnApLnRpbWVzKFxuICAgICAgdGhpcy5nZXRCYXNlRmFjdG9yKClcbiAgICApO1xuICAgIGNvbnN0IHJlc2VydmVEZWx0YSA9IG5ldyBCaWdOdW1iZXIoc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIucmVzZXJ2ZV9pbmNfeHJwKS50aW1lcyhcbiAgICAgIHRoaXMuZ2V0QmFzZUZhY3RvcigpXG4gICAgKTtcbiAgICBjb25zdCBjdXJyZW50TGVkZ2VyID0gc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIuc2VxO1xuICAgIGNvbnN0IHNlcXVlbmNlSWQgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuU2VxdWVuY2U7XG4gICAgY29uc3QgYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLkJhbGFuY2UpO1xuICAgIGNvbnN0IHNpZ25lckxpc3RzID0gYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLnNpZ25lcl9saXN0cztcbiAgICBjb25zdCBhY2NvdW50RmxhZ3MgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuRmxhZ3M7XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgc2lnbmVyIGxpc3Qgc2V0XG4gICAgaWYgKHNpZ25lckxpc3RzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHNldCBvZiBzaWduZXIgbGlzdHMnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHNpZ25lcnMgYXJlIHVzZXIsIGJhY2t1cCwgYml0Z29cbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3Moa2V5c1swXS5wdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBjb25zdCBiYWNrdXBBZGRyZXNzID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhrZXlzWzFdLnB1YmxpY0tleS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgY29uc3Qgc2lnbmVyTGlzdCA9IHNpZ25lckxpc3RzWzBdO1xuICAgIGlmIChzaWduZXJMaXN0LlNpZ25lclF1b3J1bSAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1pbmltdW0gc2lnbmF0dXJlIGNvdW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kQWRkcmVzc2VzID0ge307XG5cbiAgICBjb25zdCBzaWduZXJFbnRyaWVzID0gc2lnbmVyTGlzdC5TaWduZXJFbnRyaWVzO1xuICAgIGlmIChzaWduZXJFbnRyaWVzLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25lciBsaXN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgU2lnbmVyRW50cnkgfSBvZiBzaWduZXJFbnRyaWVzKSB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBTaWduZXJFbnRyeS5TaWduZXJXZWlnaHQ7XG4gICAgICBjb25zdCBhZGRyZXNzID0gU2lnbmVyRW50cnkuQWNjb3VudDtcbiAgICAgIGlmICh3ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25lciB3ZWlnaHQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgaXQncyBhIGR1cGUgb2YgYW4gYWRkcmVzcyB3ZSBhbHJlYWR5IGtub3csIGJsb2NrXG4gICAgICBpZiAoZm91bmRBZGRyZXNzZXNbYWRkcmVzc10gPj0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZSBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgZm91bmRBZGRyZXNzZXNbYWRkcmVzc10gPSAoZm91bmRBZGRyZXNzZXNbYWRkcmVzc10gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIGlmIChmb3VuZEFkZHJlc3Nlc1t1c2VyQWRkcmVzc10gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBpbmNpZGVuY2UgZnJlcXVlbmN5IG9mIHVzZXIgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgaWYgKGZvdW5kQWRkcmVzc2VzW2JhY2t1cEFkZHJlc3NdICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgaW5jaWRlbmNlIGZyZXF1ZW5jeSBvZiB1c2VyIHNpZ25lciBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBmbGFncyBkaXNhYmxlIHRoZSBtYXN0ZXIga2V5IGFuZCBlbmZvcmNlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICBjb25zdCBVU0VSX0tFWV9TRVRUSU5HX0ZMQUcgPSA2NTUzNjtcbiAgICBjb25zdCBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHID0gMTA0ODU3NjtcbiAgICBjb25zdCBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHID0gMTMxMDcyO1xuICAgIGlmICgoYWNjb3VudEZsYWdzICYgVVNFUl9LRVlfU0VUVElOR19GTEFHKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGN1c3RvbSB1c2VyIGtleSBoYXMgYmVlbiBzZXQnKTtcbiAgICB9XG4gICAgaWYgKChhY2NvdW50RmxhZ3MgJiBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHKSAhPT0gTUFTVEVSX0tFWV9ERUFDVElWQVRJT05fRkxBRykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgbWFzdGVyIGtleSBoYXMgbm90IGJlZW4gZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgaWYgKChhY2NvdW50RmxhZ3MgJiBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHKSAhPT0gUkVRVUlSRV9ERVNUSU5BVElPTl9UQUdfRkxBRykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgZGVzdGluYXRpb24gZmxhZyByZXF1aXJlbWVudCBoYXMgbm90IGJlZW4gYWN0aXZhdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gcmVjb3ZlciB0aGUgZnVuZHNcbiAgICBjb25zdCByZXNlcnZlID0gYmFzZVJlc2VydmUucGx1cyhyZXNlcnZlRGVsdGEudGltZXMoNSkpO1xuICAgIGNvbnN0IHJlY292ZXJhYmxlQmFsYW5jZSA9IGJhbGFuY2UubWludXMocmVzZXJ2ZSk7XG5cbiAgICBjb25zdCByYXdEZXN0aW5hdGlvbiA9IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShyYXdEZXN0aW5hdGlvbik7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuXG4gICAgLy8gcGFyc2UgZGVzdGluYXRpb24gdGFnIGZyb20gcXVlcnlcbiAgICBsZXQgZGVzdGluYXRpb25UYWc6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLmR0KSkge1xuICAgICAgICAvLyBpZiBxdWVyeURldGFpbHMuZHQgaXMgYW4gYXJyYXksIHRoYXQgbWVhbnMgZHQgd2FzIGdpdmVuIG11bHRpcGxlIHRpbWVzLCB3aGljaCBpcyBub3QgdmFsaWRcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoXG4gICAgICAgICAgYGRlc3RpbmF0aW9uIHRhZyBjYW4gYXBwZWFyIGF0IG1vc3Qgb25jZSwgYnV0ICR7cXVlcnlEZXRhaWxzLmR0Lmxlbmd0aH0gZGVzdGluYXRpb24gdGFncyB3ZXJlIGZvdW5kYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRUYWcgPSBwYXJzZUludChxdWVyeURldGFpbHMuZHQsIDEwKTtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlZFRhZykpIHtcbiAgICAgICAgZGVzdGluYXRpb25UYWcgPSBwYXJzZWRUYWc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICBUcmFuc2FjdGlvblR5cGU6ICdQYXltZW50JyxcbiAgICAgIEFjY291bnQ6IHBhcmFtcy5yb290QWRkcmVzcywgLy8gc291cmNlIGFkZHJlc3NcbiAgICAgIERlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBEZXN0aW5hdGlvblRhZzogZGVzdGluYXRpb25UYWcsXG4gICAgICBBbW91bnQ6IHJlY292ZXJhYmxlQmFsYW5jZS50b0ZpeGVkKDApLFxuICAgICAgRmxhZ3M6IDIxNDc0ODM2NDgsXG4gICAgICBMYXN0TGVkZ2VyU2VxdWVuY2U6IGN1cnJlbnRMZWRnZXIgKyAxMDAwMDAwLCAvLyBnaXZlIGl0IDEgbWlsbGlvbiBsZWRnZXJzJyB0aW1lICh+MSBtb250aCwgc3VpdGFibGUgZm9yIEtSUylcbiAgICAgIEZlZTogb3BlbkxlZGdlckZlZS50aW1lcygzKS50b0ZpeGVkKDApLCAvLyB0aGUgZmFjdG9yIHRocmVlIGlzIGZvciB0aGUgbXVsdGlzaWduaW5nXG4gICAgICBTZXF1ZW5jZTogc2VxdWVuY2VJZCxcbiAgICB9O1xuICAgIGNvbnN0IHR4SlNPTjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24pO1xuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgcmV0dXJuIHR4SlNPTjtcbiAgICB9XG4gICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgaWYgKCFrZXlzWzBdLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlcktleSBpcyBub3QgYSBwcml2YXRlIGtleWApO1xuICAgIH1cbiAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIHVzZXJLZXksIHsgc2lnbkFzOiB1c2VyQWRkcmVzcyB9KTtcblxuICAgIGxldCBzaWduZWRUcmFuc2FjdGlvbjtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHVzZXJTaWduYXR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgha2V5c1sxXS5wcml2YXRlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFja3VwS2V5IGlzIG5vdCBhIHByaXZhdGUga2V5YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBrZXlzWzFdLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgYmFja3VwU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIGJhY2t1cEtleSwgeyBzaWduQXM6IGJhY2t1cEFkZHJlc3MgfSk7XG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHJpcHBsZUxpYi5jb21iaW5lKFt1c2VyU2lnbmF0dXJlLnNpZ25lZFRyYW5zYWN0aW9uLCBiYWNrdXBTaWduYXR1cmUuc2lnbmVkVHJhbnNhY3Rpb25dKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uOiBSZWNvdmVyeUluZm8gPSAoYXdhaXQgdGhpcy5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgdHhIZXg6IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIH0pKSBhcyBhbnk7XG4gICAgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi50eEhleCA9IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uO1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uY29pbiA9IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gIH1cblxuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoaXMgY29pbi5cbiAgICogQHBhcmFtIHNlZWQgU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4iXX0=