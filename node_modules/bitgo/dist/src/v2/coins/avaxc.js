"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaxC = void 0;
/**
 * @prettier
 */
const bignumber_js_1 = require("bignumber.js");
const bip32 = require("bip32");
const Keccak = require("keccak");
const secp256k1 = require("secp256k1");
const _ = require("lodash");
const baseCoin_1 = require("../baseCoin");
const errors_1 = require("../../errors");
const account_lib_1 = require("@bitgo/account-lib");
const sdk_core_1 = require("@bitgo/sdk-core");
const eth_1 = require("./eth");
class AvaxC extends baseCoin_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new AvaxC(bitgo, staticsCoin);
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    /**
     * Get the base chain that the coin exists on.
     */
    getBaseChain() {
        return this.getChain();
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    valuelessTransferAllowed() {
        return true;
    }
    isValidAddress(address) {
        return !!address && account_lib_1.AvaxC.Utils.isValidEthAddress(address);
    }
    isToken() {
        return false;
    }
    generateKeyPair(seed) {
        const avaxKeyPair = seed ? new account_lib_1.AvaxC.KeyPair({ seed }) : new account_lib_1.AvaxC.KeyPair();
        const extendedKeys = avaxKeyPair.getExtendedKeys();
        return {
            pub: extendedKeys.xpub,
            prv: extendedKeys.xprv,
        };
    }
    async parseTransaction(params) {
        return {};
    }
    verifyAddress({ address }) {
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError(`invalid address: ${address}`);
        }
        return true;
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.wallet Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    async verifyTransaction(params) {
        const { txParams, txPrebuild, wallet } = params;
        if (!(txParams === null || txParams === void 0 ? void 0 : txParams.recipients) || !(txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.recipients) || !wallet) {
            throw new Error(`missing params`);
        }
        if (txParams.hop && txParams.recipients.length > 1) {
            throw new Error(`tx cannot be both a batch and hop transaction`);
        }
        if (txPrebuild.recipients.length !== 1) {
            throw new Error(`txPrebuild should only have 1 recipient but ${txPrebuild.recipients.length} found`);
        }
        if (txParams.hop && txPrebuild.hopTransaction) {
            // Check recipient amount for hop transaction
            if (txParams.recipients.length !== 1) {
                throw new Error(`hop transaction only supports 1 recipient but ${txParams.recipients.length} found`);
            }
            // Check tx sends to hop address
            const decodedHopTx = eth_1.optionalDeps.EthTx.TransactionFactory.fromSerializedData(eth_1.optionalDeps.ethUtil.toBuffer(txPrebuild.hopTransaction.tx));
            const expectedHopAddress = eth_1.optionalDeps.ethUtil.stripHexPrefix(decodedHopTx.getSenderAddress().toString());
            const actualHopAddress = eth_1.optionalDeps.ethUtil.stripHexPrefix(txPrebuild.recipients[0].address);
            if (expectedHopAddress.toLowerCase() !== actualHopAddress.toLowerCase()) {
                throw new Error('recipient address of txPrebuild does not match hop address');
            }
            // Convert TransactionRecipient array to Recipient array
            const recipients = txParams.recipients.map((r) => {
                return {
                    address: r.address,
                    amount: typeof r.amount === 'number' ? r.amount.toString() : r.amount,
                };
            });
            // Check destination address and amount
            await this.validateHopPrebuild(wallet, txPrebuild.hopTransaction, { recipients });
        }
        else if (txParams.recipients.length > 1) {
            // Check total amount for batch transaction
            let expectedTotalAmount = new bignumber_js_1.BigNumber(0);
            for (let i = 0; i < txParams.recipients.length; i++) {
                expectedTotalAmount = expectedTotalAmount.plus(txParams.recipients[i].amount);
            }
            if (!expectedTotalAmount.isEqualTo(txPrebuild.recipients[0].amount)) {
                throw new Error('batch transaction amount in txPrebuild received from BitGo servers does not match txParams supplied by client');
            }
        }
        else {
            // Check recipient address and amount for normal transaction
            if (txParams.recipients.length !== 1) {
                throw new Error(`normal transaction only supports 1 recipient but ${txParams.recipients.length} found`);
            }
            const expectedAmount = new bignumber_js_1.BigNumber(txParams.recipients[0].amount);
            if (!expectedAmount.isEqualTo(txPrebuild.recipients[0].amount)) {
                throw new Error('normal transaction amount in txPrebuild received from BitGo servers does not match txParams supplied by client');
            }
            if (AvaxC.isAVAXCAddress(txParams.recipients[0].address) &&
                txParams.recipients[0].address !== txPrebuild.recipients[0].address) {
                throw new Error('destination address in normal txPrebuild does not match that in txParams supplied by client');
            }
        }
        // Check coin is correct for all transaction types
        if (!this.verifyCoin(txPrebuild)) {
            throw new Error(`coin in txPrebuild did not match that in txParams supplied by client`);
        }
        return true;
    }
    static isAVAXCAddress(address) {
        return !!address.match(/0x[a-fA-F0-9]{40}/);
    }
    verifyCoin(txPrebuild) {
        return txPrebuild.coin === this.getChain();
    }
    isValidPub(pub) {
        let valid = true;
        try {
            new account_lib_1.AvaxC.KeyPair({ pub });
        }
        catch (e) {
            valid = false;
        }
        return valid;
    }
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params The options with which to recover
     */
    async recover(params) {
        throw new errors_1.MethodNotImplementedError();
    }
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    getTransactionBuilder() {
        return account_lib_1.getBuilder(this.getBaseChain());
    }
    /**
     * Explain a transaction from txHex, overriding BaseCoins
     * @param params The options with which to explain the transaction
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = this.getTransactionBuilder();
        txBuilder.from(txHex);
        const tx = await txBuilder.build();
        const outputs = tx.outputs.map((output) => {
            return {
                address: output.address,
                amount: output.value,
            };
        });
        const displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'];
        return {
            displayOrder,
            id: tx.id,
            outputs: outputs,
            outputAmount: outputs
                .reduce((accumulator, output) => accumulator.plus(output.amount), new bignumber_js_1.BigNumber('0'))
                .toFixed(0),
            changeOutputs: [],
            changeAmount: '0',
            fee: params.feeInfo,
        };
    }
    /**
     * Above is standard BaseCoins functions
     * ================================================================================================================
     * ================================================================================================================
     * Below is transaction functions
     */
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     */
    async presignTransaction(params) {
        if (!_.isUndefined(params.hopTransaction) && !_.isUndefined(params.wallet) && !_.isUndefined(params.buildParams)) {
            await this.validateHopPrebuild(params.wallet, params.hopTransaction);
        }
        return params;
    }
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    async postProcessPrebuild(params) {
        if (!_.isUndefined(params.hopTransaction) && !_.isUndefined(params.wallet) && !_.isUndefined(params.buildParams)) {
            await this.validateHopPrebuild(params.wallet, params.hopTransaction, params.buildParams);
        }
        return params;
    }
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    async validateHopPrebuild(wallet, hopPrebuild, originalParams) {
        const { tx, id, signature } = hopPrebuild;
        // first, validate the HSM signature
        const serverXpub = sdk_core_1.common.Environments[this.bitgo.getEnv()].hsmXpub;
        const serverPubkeyBuffer = bip32.fromBase58(serverXpub).publicKey;
        const signatureBuffer = Buffer.from(eth_1.optionalDeps.ethUtil.stripHexPrefix(signature), 'hex');
        const messageBuffer = Buffer.from(eth_1.optionalDeps.ethUtil.stripHexPrefix(id), 'hex');
        const sig = new Uint8Array(signatureBuffer.slice(1));
        const isValidSignature = secp256k1.ecdsaVerify(sig, messageBuffer, serverPubkeyBuffer);
        if (!isValidSignature) {
            throw new Error(`Hop txid signature invalid`);
        }
        const builtHopTx = eth_1.optionalDeps.EthTx.TransactionFactory.fromSerializedData(eth_1.optionalDeps.ethUtil.toBuffer(tx));
        // If original params are given, we can check them against the transaction prebuild params
        if (!_.isNil(originalParams)) {
            const { recipients } = originalParams;
            // Then validate that the tx params actually equal the requested params
            const originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount);
            const originalDestination = recipients[0].address;
            const hopAmount = new bignumber_js_1.BigNumber(eth_1.optionalDeps.ethUtil.bufferToHex(builtHopTx.value));
            if (!builtHopTx.to) {
                throw new Error(`Transaction does not have a destination address`);
            }
            const hopDestination = builtHopTx.to.toString();
            if (!hopAmount.eq(originalAmount)) {
                throw new Error(`Hop amount: ${hopAmount} does not equal original amount: ${originalAmount}`);
            }
            if (hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                throw new Error(`Hop destination: ${hopDestination} does not equal original recipient: ${hopDestination}`);
            }
        }
        if (!builtHopTx.verifySignature()) {
            // We dont want to continue at all in this case, at risk of AVAX being stuck on the hop address
            throw new Error(`Invalid hop transaction signature, txid: ${id}`);
        }
        if (eth_1.optionalDeps.ethUtil.addHexPrefix(builtHopTx.hash().toString('hex')) !== id) {
            throw new Error(`Signed hop txid does not equal actual txid`);
        }
    }
    /**
     * Assemble half-sign prebuilt transaction
     * @param params
     */
    async signTransaction(params) {
        const txBuilder = this.getTransactionBuilder();
        txBuilder.from(params.txPrebuild.txHex);
        txBuilder.transfer().key(new account_lib_1.AvaxC.KeyPair({ prv: params.prv }).getKeys().prv);
        const transaction = await txBuilder.build();
        const recipients = transaction.outputs.map((output) => ({ address: output.address, amount: output.value }));
        const txParams = {
            eip1559: params.txPrebuild.eip1559,
            txHex: transaction.toBroadcastFormat(),
            recipients: recipients,
            expiration: params.txPrebuild.expireTime,
            hopTransaction: params.txPrebuild.hopTransaction,
        };
        return { halfSigned: txParams };
    }
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    async getExtraPrebuildParams(buildParams) {
        if (!_.isUndefined(buildParams.hop) &&
            buildParams.hop &&
            !_.isUndefined(buildParams.wallet) &&
            !_.isUndefined(buildParams.recipients) &&
            !_.isUndefined(buildParams.walletPassphrase)) {
            if (this.isToken()) {
                throw new Error(`Hop transactions are not enabled for AVAXC tokens, nor are they necessary. Please remove the 'hop' parameter and try again.`);
            }
            return (await this.createHopTransactionParams({
                wallet: buildParams.wallet,
                recipients: buildParams.recipients,
                walletPassphrase: buildParams.walletPassphrase,
            }));
        }
        return {};
    }
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    async createHopTransactionParams(buildParams) {
        const wallet = buildParams.wallet;
        const recipients = buildParams.recipients;
        const walletPassphrase = buildParams.walletPassphrase;
        const userKeychain = await this.keychains().get({ id: wallet.keyIds()[0] });
        const userPrv = wallet.getUserPrv({ keychain: userKeychain, walletPassphrase });
        const userPrvBuffer = bip32.fromBase58(userPrv).privateKey;
        if (!userPrvBuffer) {
            throw new Error('invalid userPrv');
        }
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        const recipientAddress = recipients[0].address;
        const recipientAmount = recipients[0].amount;
        const feeEstimateParams = {
            recipient: recipientAddress,
            amount: recipientAmount,
            hop: true,
        };
        const feeEstimate = await this.feeEstimate(feeEstimateParams);
        const gasLimit = feeEstimate.gasLimitEstimate;
        const gasPrice = Math.round(feeEstimate.feeEstimate / gasLimit);
        const gasPriceMax = gasPrice * 5;
        // Payment id a random number so its different for every tx
        const paymentId = Math.floor(Math.random() * 10000000000).toString();
        const hopDigest = AvaxC.getHopDigest([
            recipientAddress,
            recipientAmount,
            gasPriceMax.toString(),
            gasLimit.toString(),
            paymentId,
        ]);
        const userReqSig = eth_1.optionalDeps.ethUtil.addHexPrefix(Buffer.from(secp256k1.ecdsaSign(hopDigest, userPrvBuffer).signature).toString('hex'));
        return {
            hopParams: {
                gasPriceMax,
                userReqSig,
                paymentId,
            },
            gasLimit,
        };
    }
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    async feeEstimate(params) {
        const query = {};
        if (params && params.hop) {
            query.hop = params.hop;
        }
        if (params && params.recipient) {
            query.recipient = params.recipient;
        }
        if (params && params.data) {
            query.data = params.data;
        }
        if (params && params.amount) {
            query.amount = params.amount;
        }
        return await this.bitgo.get(this.url('/tx/fee')).query(query).result();
    }
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    static getHopDigest(paramsArr) {
        const hash = new Keccak('keccak256');
        hash.update([AvaxC.hopTransactionSalt, ...paramsArr].join('$'));
        return hash.digest();
    }
    isWalletAddress(params) {
        // TODO: Fix this later
        return true;
    }
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error(`preCreateBitGo must be passed a params object. Got ${params} (type ${typeof params})`);
        }
        if (_.isUndefined(params.enterprise) && _.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new AVAX bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!_.isUndefined(params.enterprise) && !_.isUndefined(params.newFeeAddress)) {
            throw new Error(`Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.`);
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error(`enterprise should be a string - got ${params.enterprise} (type ${typeof params.enterprise})`);
        }
        if (!_.isUndefined(params.newFeeAddress) && !_.isBoolean(params.newFeeAddress)) {
            throw new Error(`newFeeAddress should be a boolean - got ${params.newFeeAddress} (type ${typeof params.newFeeAddress})`);
        }
    }
}
exports.AvaxC = AvaxC;
AvaxC.hopTransactionSalt = 'bitgoHopAddressRequestSalt';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZheGMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvY29pbnMvYXZheGMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0dBRUc7QUFDSCwrQ0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkMsNEJBQTRCO0FBQzVCLDBDQWlCcUI7QUFFckIseUNBQThFO0FBRTlFLG9EQUErRTtBQUMvRSw4Q0FBeUM7QUFFekMsK0JBQXFDO0FBd0pyQyxNQUFhLEtBQU0sU0FBUSxtQkFBUTtJQUtqQyxZQUFzQixLQUFZLEVBQUUsV0FBdUM7UUFDekUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFZLEVBQUUsV0FBdUM7UUFDekUsT0FBTyxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFB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VUFBVSxPQUFPLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDekc7UUFFRCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQzNFLE1BQU0sSUFBSSxLQUFLLENBQ2Isa0lBQWtJLENBQ25JLENBQUM7U0FDSDtRQUVELHFGQUFxRjtRQUNyRixJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUM3RSxNQUFNLElBQUksS0FBSyxDQUFDLG1GQUFtRixDQUFDLENBQUM7U0FDdEc7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN2RSxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxNQUFNLENBQUMsVUFBVSxVQUFVLE9BQU8sTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7U0FDaEg7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUM5RSxNQUFNLElBQUksS0FBSyxDQUNiLDJDQUEyQyxNQUFNLENBQUMsYUFBYSxVQUFVLE9BQU8sTUFBTSxDQUFDLGFBQWEsR0FBRyxDQUN4RyxDQUFDO1NBQ0g7SUFDSCxDQUFDOztBQXBmSCxzQkFxZkM7QUFwZlEsd0JBQWtCLEdBQUcsNEJBQTRCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0ICogYXMgS2VjY2FrIGZyb20gJ2tlY2Nhayc7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24sXG4gIEhhbGZTaWduZWRBY2NvdW50VHJhbnNhY3Rpb24sXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25GZWUsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblBhcmFtcyxcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBJbnZhbGlkQWRkcmVzc0Vycm9yLCBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IGdldEJ1aWxkZXIsIEV0aCwgQXZheEMgYXMgQXZheENBY2NvdW50TGliIH0gZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcbmltcG9ydCB7IGNvbW1vbiB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5cbmltcG9ydCB7IG9wdGlvbmFsRGVwcyB9IGZyb20gJy4vZXRoJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4uL3dhbGxldCc7XG5cbi8vIEZvciBwcmVjcmVhdGVCaXRnb1xuaW50ZXJmYWNlIFByZWNyZWF0ZUJpdEdvT3B0aW9ucyB7XG4gIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gIG5ld0ZlZUFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbi8vIEZvciBleHBsYWluVHJhbnNhY3Rpb25cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5pbnRlcmZhY2UgQXZheGNUcmFuc2FjdGlvblBhcmFtcyBleHRlbmRzIFRyYW5zYWN0aW9uUGFyYW1zIHtcbiAgZ2FzUHJpY2U/OiBudW1iZXI7XG4gIGdhc0xpbWl0PzogbnVtYmVyO1xuICBob3BQYXJhbXM/OiBIb3BQYXJhbXM7XG4gIGhvcD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBWZXJpZnlBdmF4Y1RyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHR4UGFyYW1zOiBBdmF4Y1RyYW5zYWN0aW9uUGFyYW1zO1xufVxuXG4vLyBGb3IgcHJlU2lnblxuaW50ZXJmYWNlIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBUcmFuc2FjdGlvblByZWJ1aWxkLCBCYXNlUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHdhbGxldDogV2FsbGV0O1xufVxuXG5pbnRlcmZhY2UgRUlQMTU1OSB7XG4gIG1heFByaW9yaXR5RmVlUGVyR2FzOiBudW1iZXI7XG4gIG1heEZlZVBlckdhczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIGhvcFRyYW5zYWN0aW9uPzogSG9wUHJlYnVpbGQ7XG4gIGJ1aWxkUGFyYW1zOiB7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIH07XG4gIHJlY2lwaWVudHM6IFRyYW5zYWN0aW9uUmVjaXBpZW50W107XG4gIG5leHRDb250cmFjdFNlcXVlbmNlSWQ6IHN0cmluZztcbiAgZ2FzUHJpY2U6IG51bWJlcjtcbiAgZ2FzTGltaXQ6IG51bWJlcjtcbiAgaXNCYXRjaDogYm9vbGVhbjtcbiAgY29pbjogc3RyaW5nO1xuICB0b2tlbj86IHN0cmluZztcbn1cblxuLy8gRm9yIGNyZWF0ZUhvcFRyYW5zYWN0aW9uUGFyYW1zXG5pbnRlcmZhY2UgSG9wVHJhbnNhY3Rpb25CdWlsZE9wdGlvbnMge1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmc7XG59XG5cbi8vIEZvciBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zXG5pbnRlcmZhY2UgQnVpbGRPcHRpb25zIHtcbiAgaG9wPzogYm9vbGVhbjtcbiAgd2FsbGV0PzogV2FsbGV0O1xuICByZWNpcGllbnRzPzogUmVjaXBpZW50W107XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuLy8gRm9yIEZlZUVzdGltYXRlXG5pbnRlcmZhY2UgRmVlRXN0aW1hdGUge1xuICBnYXNMaW1pdEVzdGltYXRlOiBudW1iZXI7XG4gIGZlZUVzdGltYXRlOiBudW1iZXI7XG59XG5cbi8qKlxuICogVGhlIGV4dHJhIHBhcmFtZXRlcnMgdG8gc2VuZCB0byBwbGF0Zm9ybSBidWlsZCByb3V0ZSBmb3IgaG9wIHRyYW5zYWN0aW9uc1xuICovXG5pbnRlcmZhY2UgSG9wUGFyYW1zIHtcbiAgaG9wUGFyYW1zOiB7XG4gICAgZ2FzUHJpY2VNYXg6IG51bWJlcjtcbiAgICB1c2VyUmVxU2lnOiBzdHJpbmc7XG4gICAgcGF5bWVudElkOiBzdHJpbmc7XG4gIH07XG4gIGdhc0xpbWl0OiBudW1iZXI7XG59XG5cbi8qKlxuICogVGhlIHByZWJ1aWx0IGhvcCB0cmFuc2FjdGlvbiByZXR1cm5lZCBmcm9tIHRoZSBIU01cbiAqL1xuaW50ZXJmYWNlIEhvcFByZWJ1aWxkIHtcbiAgdHg6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gIHBheW1lbnRJZDogc3RyaW5nO1xuICBnYXNQcmljZTogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICBhbW91bnQ6IG51bWJlcjtcbiAgcmVjaXBpZW50OiBzdHJpbmc7XG4gIG5vbmNlOiBudW1iZXI7XG4gIHVzZXJSZXFTaWc6IHN0cmluZztcbiAgZ2FzUHJpY2VNYXg6IG51bWJlcjtcbn1cblxuLy8gRm9yIHR4UHJlQnVpbGRcbmV4cG9ydCBpbnRlcmZhY2UgVHhJbmZvIHtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIGZyb206IHN0cmluZztcbiAgdHhpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV0aFRyYW5zYWN0aW9uRmVlIHtcbiAgZmVlOiBzdHJpbmc7XG4gIGdhc0xpbWl0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4UHJlQnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHR4SW5mbzogVHhJbmZvO1xuICBmZWVJbmZvOiBFdGhUcmFuc2FjdGlvbkZlZTtcbiAgc291cmNlOiBzdHJpbmc7XG4gIGRhdGFUb1NpZ246IHN0cmluZztcbiAgbmV4dENvbnRyYWN0U2VxdWVuY2VJZD86IHN0cmluZztcbiAgZXhwaXJlVGltZT86IG51bWJlcjtcbiAgaG9wVHJhbnNhY3Rpb24/OiBzdHJpbmc7XG4gIGVpcDE1NTk/OiBFSVAxNTU5O1xufVxuXG4vLyBGb3Igc2lnblRyYW5zYWN0aW9uXG5leHBvcnQgaW50ZXJmYWNlIEF2YXhTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUeFByZUJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gZXh0ZW5kcyBIYWxmU2lnbmVkQWNjb3VudFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4PzogbmV2ZXI7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gICAgZXhwaXJhdGlvbj86IG51bWJlcjtcbiAgICBlaXAxNTU5PzogRUlQMTU1OTtcbiAgfTtcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmVkVHJhbnNhY3Rpb24gPSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gfCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uO1xuXG5leHBvcnQgY2xhc3MgQXZheEMgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHN0YXRpYyBob3BUcmFuc2FjdGlvblNhbHQgPSAnYml0Z29Ib3BBZGRyZXNzUmVxdWVzdFNhbHQnO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBdmF4QyhiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhc2UgY2hhaW4gdGhhdCB0aGUgY29pbiBleGlzdHMgb24uXG4gICAqL1xuICBnZXRCYXNlQ2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhYWRkcmVzcyAmJiBBdmF4Q0FjY291bnRMaWIuVXRpbHMuaXNWYWxpZEV0aEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICBpc1Rva2VuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3QgYXZheEtleVBhaXIgPSBzZWVkID8gbmV3IEF2YXhDQWNjb3VudExpYi5LZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBBdmF4Q0FjY291bnRMaWIuS2V5UGFpcigpO1xuICAgIGNvbnN0IGV4dGVuZGVkS2V5cyA9IGF2YXhLZXlQYWlyLmdldEV4dGVuZGVkS2V5cygpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGV4dGVuZGVkS2V5cy54cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleXMueHBydiEsXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHsgYWRkcmVzcyB9OiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQYXJhbXMgcGFyYW1zIG9iamVjdCBwYXNzZWQgdG8gc2VuZFxuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGQgcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHNlcnZlclxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldCBXYWxsZXQgb2JqZWN0IHRvIG9idGFpbiBrZXlzIHRvIHZlcmlmeSBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlBdmF4Y1RyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHsgdHhQYXJhbXMsIHR4UHJlYnVpbGQsIHdhbGxldCB9ID0gcGFyYW1zO1xuICAgIGlmICghdHhQYXJhbXM/LnJlY2lwaWVudHMgfHwgIXR4UHJlYnVpbGQ/LnJlY2lwaWVudHMgfHwgIXdhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHBhcmFtc2ApO1xuICAgIH1cbiAgICBpZiAodHhQYXJhbXMuaG9wICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eCBjYW5ub3QgYmUgYm90aCBhIGJhdGNoIGFuZCBob3AgdHJhbnNhY3Rpb25gKTtcbiAgICB9XG4gICAgaWYgKHR4UHJlYnVpbGQucmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBzaG91bGQgb25seSBoYXZlIDEgcmVjaXBpZW50IGJ1dCAke3R4UHJlYnVpbGQucmVjaXBpZW50cy5sZW5ndGh9IGZvdW5kYCk7XG4gICAgfVxuICAgIGlmICh0eFBhcmFtcy5ob3AgJiYgdHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbikge1xuICAgICAgLy8gQ2hlY2sgcmVjaXBpZW50IGFtb3VudCBmb3IgaG9wIHRyYW5zYWN0aW9uXG4gICAgICBpZiAodHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBob3AgdHJhbnNhY3Rpb24gb25seSBzdXBwb3J0cyAxIHJlY2lwaWVudCBidXQgJHt0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aH0gZm91bmRgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdHggc2VuZHMgdG8gaG9wIGFkZHJlc3NcbiAgICAgIGNvbnN0IGRlY29kZWRIb3BUeCA9IG9wdGlvbmFsRGVwcy5FdGhUeC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKFxuICAgICAgICBvcHRpb25hbERlcHMuZXRoVXRpbC50b0J1ZmZlcih0eFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uLnR4KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkSG9wQWRkcmVzcyA9IG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KGRlY29kZWRIb3BUeC5nZXRTZW5kZXJBZGRyZXNzKCkudG9TdHJpbmcoKSk7XG4gICAgICBjb25zdCBhY3R1YWxIb3BBZGRyZXNzID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgodHhQcmVidWlsZC5yZWNpcGllbnRzWzBdLmFkZHJlc3MpO1xuICAgICAgaWYgKGV4cGVjdGVkSG9wQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhY3R1YWxIb3BBZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnQgYWRkcmVzcyBvZiB0eFByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGhvcCBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXJyYXkgdG8gUmVjaXBpZW50IGFycmF5XG4gICAgICBjb25zdCByZWNpcGllbnRzOiBSZWNpcGllbnRbXSA9IHR4UGFyYW1zLnJlY2lwaWVudHMubWFwKChyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWRkcmVzczogci5hZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdHlwZW9mIHIuYW1vdW50ID09PSAnbnVtYmVyJyA/IHIuYW1vdW50LnRvU3RyaW5nKCkgOiByLmFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDaGVjayBkZXN0aW5hdGlvbiBhZGRyZXNzIGFuZCBhbW91bnRcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVIb3BQcmVidWlsZCh3YWxsZXQsIHR4UHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24sIHsgcmVjaXBpZW50cyB9KTtcbiAgICB9IGVsc2UgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gQ2hlY2sgdG90YWwgYW1vdW50IGZvciBiYXRjaCB0cmFuc2FjdGlvblxuICAgICAgbGV0IGV4cGVjdGVkVG90YWxBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdGVkVG90YWxBbW91bnQgPSBleHBlY3RlZFRvdGFsQW1vdW50LnBsdXModHhQYXJhbXMucmVjaXBpZW50c1tpXS5hbW91bnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFleHBlY3RlZFRvdGFsQW1vdW50LmlzRXF1YWxUbyh0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0uYW1vdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2JhdGNoIHRyYW5zYWN0aW9uIGFtb3VudCBpbiB0eFByZWJ1aWxkIHJlY2VpdmVkIGZyb20gQml0R28gc2VydmVycyBkb2VzIG5vdCBtYXRjaCB0eFBhcmFtcyBzdXBwbGllZCBieSBjbGllbnQnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIHJlY2lwaWVudCBhZGRyZXNzIGFuZCBhbW91bnQgZm9yIG5vcm1hbCB0cmFuc2FjdGlvblxuICAgICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm9ybWFsIHRyYW5zYWN0aW9uIG9ubHkgc3VwcG9ydHMgMSByZWNpcGllbnQgYnV0ICR7dHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGh9IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBlY3RlZEFtb3VudCA9IG5ldyBCaWdOdW1iZXIodHhQYXJhbXMucmVjaXBpZW50c1swXS5hbW91bnQpO1xuICAgICAgaWYgKCFleHBlY3RlZEFtb3VudC5pc0VxdWFsVG8odHhQcmVidWlsZC5yZWNpcGllbnRzWzBdLmFtb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdub3JtYWwgdHJhbnNhY3Rpb24gYW1vdW50IGluIHR4UHJlYnVpbGQgcmVjZWl2ZWQgZnJvbSBCaXRHbyBzZXJ2ZXJzIGRvZXMgbm90IG1hdGNoIHR4UGFyYW1zIHN1cHBsaWVkIGJ5IGNsaWVudCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgQXZheEMuaXNBVkFYQ0FkZHJlc3ModHhQYXJhbXMucmVjaXBpZW50c1swXS5hZGRyZXNzKSAmJlxuICAgICAgICB0eFBhcmFtcy5yZWNpcGllbnRzWzBdLmFkZHJlc3MgIT09IHR4UHJlYnVpbGQucmVjaXBpZW50c1swXS5hZGRyZXNzXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0aW5hdGlvbiBhZGRyZXNzIGluIG5vcm1hbCB0eFByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIHRoYXQgaW4gdHhQYXJhbXMgc3VwcGxpZWQgYnkgY2xpZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGNvaW4gaXMgY29ycmVjdCBmb3IgYWxsIHRyYW5zYWN0aW9uIHR5cGVzXG4gICAgaWYgKCF0aGlzLnZlcmlmeUNvaW4odHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY29pbiBpbiB0eFByZWJ1aWxkIGRpZCBub3QgbWF0Y2ggdGhhdCBpbiB0eFBhcmFtcyBzdXBwbGllZCBieSBjbGllbnRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBpc0FWQVhDQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISFhZGRyZXNzLm1hdGNoKC8weFthLWZBLUYwLTldezQwfS8pO1xuICB9XG5cbiAgdmVyaWZ5Q29pbih0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR4UHJlYnVpbGQuY29pbiA9PT0gdGhpcy5nZXRDaGFpbigpO1xuICB9XG5cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBBdmF4Q0FjY291bnRMaWIuS2V5UGFpcih7IHB1YiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAgICogV2UgbmVlZCB0byBkbyB0aHJlZSBxdWVyaWVzIGR1cmluZyB0aGlzOlxuICAgKiAxKSBOb2RlIHF1ZXJ5IC0gaG93IG11Y2ggbW9uZXkgaXMgaW4gdGhlIGFjY291bnRcbiAgICogMikgQnVpbGQgdHJhbnNhY3Rpb24gLSBidWlsZCBvdXIgdHJhbnNhY3Rpb24gZm9yIHRoZSBhbW91bnRcbiAgICogMykgU2VuZCBzaWduZWQgYnVpbGQgLSBzZW5kIG91ciBzaWduZWQgYnVpbGQgdG8gYSBwdWJsaWMgbm9kZVxuICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBvcHRpb25zIHdpdGggd2hpY2ggdG8gcmVjb3ZlclxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlcihwYXJhbXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gYnVpbGRlciBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICogQHJldHVybiBhIG5ldyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCk6IEV0aC5UcmFuc2FjdGlvbkJ1aWxkZXIge1xuICAgIHJldHVybiBnZXRCdWlsZGVyKHRoaXMuZ2V0QmFzZUNoYWluKCkpIGFzIEV0aC5UcmFuc2FjdGlvbkJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbiBhIHRyYW5zYWN0aW9uIGZyb20gdHhIZXgsIG92ZXJyaWRpbmcgQmFzZUNvaW5zXG4gICAqIEBwYXJhbSBwYXJhbXMgVGhlIG9wdGlvbnMgd2l0aCB3aGljaCB0byBleHBsYWluIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgaWYgKCF0eEhleCB8fCAhcGFyYW1zLmZlZUluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCBvdXRwdXRzID0gdHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogb3V0cHV0LnZhbHVlLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJ107XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgaWQ6IHR4LmlkLFxuICAgICAgb3V0cHV0czogb3V0cHV0cyxcbiAgICAgIG91dHB1dEFtb3VudDogb3V0cHV0c1xuICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgb3V0cHV0KSA9PiBhY2N1bXVsYXRvci5wbHVzKG91dHB1dC5hbW91bnQpLCBuZXcgQmlnTnVtYmVyKCcwJykpXG4gICAgICAgIC50b0ZpeGVkKDApLFxuICAgICAgY2hhbmdlT3V0cHV0czogW10sIC8vIGFjY291bnQgYmFzZWQgZG9lcyBub3QgdXNlIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjaGFuZ2VBbW91bnQ6ICcwJywgLy8gYWNjb3VudCBiYXNlIGRvZXMgbm90IG1ha2UgY2hhbmdlXG4gICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWJvdmUgaXMgc3RhbmRhcmQgQmFzZUNvaW5zIGZ1bmN0aW9uc1xuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICogQmVsb3cgaXMgdHJhbnNhY3Rpb24gZnVuY3Rpb25zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb2luLXNwZWNpZmljIHRoaW5ncyBkb25lIGJlZm9yZSBzaWduaW5nIGEgdHJhbnNhY3Rpb24sIGkuZS4gdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIHByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnM+IHtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmhvcFRyYW5zYWN0aW9uKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMuYnVpbGRQYXJhbXMpKSB7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSG9wUHJlYnVpbGQocGFyYW1zLndhbGxldCwgcGFyYW1zLmhvcFRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgcHJlYnVpbGQgYWZ0ZXIgcmVjZWl2aW5nIGl0IGZyb20gdGhlIHNlcnZlci4gQWRkIHRoaW5ncyBsaWtlIG5sb2NrdGltZVxuICAgKi9cbiAgYXN5bmMgcG9zdFByb2Nlc3NQcmVidWlsZChwYXJhbXM6IFRyYW5zYWN0aW9uUHJlYnVpbGQpOiBQcm9taXNlPFRyYW5zYWN0aW9uUHJlYnVpbGQ+IHtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmhvcFRyYW5zYWN0aW9uKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMuYnVpbGRQYXJhbXMpKSB7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSG9wUHJlYnVpbGQocGFyYW1zLndhbGxldCwgcGFyYW1zLmhvcFRyYW5zYWN0aW9uLCBwYXJhbXMuYnVpbGRQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBob3AgcHJlYnVpbGQgZnJvbSB0aGUgSFNNIGlzIHZhbGlkIGFuZCBjb3JyZWN0XG4gICAqIEBwYXJhbSB3YWxsZXQgVGhlIHdhbGxldCB0aGF0IHRoZSBwcmVidWlsZCBpcyBmb3JcbiAgICogQHBhcmFtIGhvcFByZWJ1aWxkIFRoZSBwcmVidWlsZCB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxQYXJhbXMgVGhlIG9yaWdpbmFsIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHByZWJ1aWxkVHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMgdm9pZFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIFRoZSBwcmVidWlsZCBpcyBpbnZhbGlkXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZUhvcFByZWJ1aWxkKFxuICAgIHdhbGxldDogV2FsbGV0LFxuICAgIGhvcFByZWJ1aWxkOiBIb3BQcmVidWlsZCxcbiAgICBvcmlnaW5hbFBhcmFtcz86IHsgcmVjaXBpZW50czogUmVjaXBpZW50W10gfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHR4LCBpZCwgc2lnbmF0dXJlIH0gPSBob3BQcmVidWlsZDtcblxuICAgIC8vIGZpcnN0LCB2YWxpZGF0ZSB0aGUgSFNNIHNpZ25hdHVyZVxuICAgIGNvbnN0IHNlcnZlclhwdWIgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLmhzbVhwdWI7XG4gICAgY29uc3Qgc2VydmVyUHVia2V5QnVmZmVyOiBCdWZmZXIgPSBiaXAzMi5mcm9tQmFzZTU4KHNlcnZlclhwdWIpLnB1YmxpY0tleTtcbiAgICBjb25zdCBzaWduYXR1cmVCdWZmZXI6IEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHNpZ25hdHVyZSksICdoZXgnKTtcbiAgICBjb25zdCBtZXNzYWdlQnVmZmVyOiBCdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChpZCksICdoZXgnKTtcblxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgxKSk7XG4gICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZTogYm9vbGVhbiA9IHNlY3AyNTZrMS5lY2RzYVZlcmlmeShzaWcsIG1lc3NhZ2VCdWZmZXIsIHNlcnZlclB1YmtleUJ1ZmZlcik7XG4gICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcCB0eGlkIHNpZ25hdHVyZSBpbnZhbGlkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVpbHRIb3BUeCA9IG9wdGlvbmFsRGVwcy5FdGhUeC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnRvQnVmZmVyKHR4KSk7XG4gICAgLy8gSWYgb3JpZ2luYWwgcGFyYW1zIGFyZSBnaXZlbiwgd2UgY2FuIGNoZWNrIHRoZW0gYWdhaW5zdCB0aGUgdHJhbnNhY3Rpb24gcHJlYnVpbGQgcGFyYW1zXG4gICAgaWYgKCFfLmlzTmlsKG9yaWdpbmFsUGFyYW1zKSkge1xuICAgICAgY29uc3QgeyByZWNpcGllbnRzIH0gPSBvcmlnaW5hbFBhcmFtcztcblxuICAgICAgLy8gVGhlbiB2YWxpZGF0ZSB0aGF0IHRoZSB0eCBwYXJhbXMgYWN0dWFsbHkgZXF1YWwgdGhlIHJlcXVlc3RlZCBwYXJhbXNcbiAgICAgIGNvbnN0IG9yaWdpbmFsQW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCk7XG4gICAgICBjb25zdCBvcmlnaW5hbERlc3RpbmF0aW9uOiBzdHJpbmcgPSByZWNpcGllbnRzWzBdLmFkZHJlc3M7XG5cbiAgICAgIGNvbnN0IGhvcEFtb3VudCA9IG5ldyBCaWdOdW1iZXIob3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoPEJ1ZmZlcj5idWlsdEhvcFR4LnZhbHVlKSk7XG4gICAgICBpZiAoIWJ1aWx0SG9wVHgudG8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBkb2VzIG5vdCBoYXZlIGEgZGVzdGluYXRpb24gYWRkcmVzc2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgaG9wRGVzdGluYXRpb24gPSBidWlsdEhvcFR4LnRvLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIWhvcEFtb3VudC5lcShvcmlnaW5hbEFtb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb3AgYW1vdW50OiAke2hvcEFtb3VudH0gZG9lcyBub3QgZXF1YWwgb3JpZ2luYWwgYW1vdW50OiAke29yaWdpbmFsQW1vdW50fWApO1xuICAgICAgfVxuICAgICAgaWYgKGhvcERlc3RpbmF0aW9uLnRvTG93ZXJDYXNlKCkgIT09IG9yaWdpbmFsRGVzdGluYXRpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcCBkZXN0aW5hdGlvbjogJHtob3BEZXN0aW5hdGlvbn0gZG9lcyBub3QgZXF1YWwgb3JpZ2luYWwgcmVjaXBpZW50OiAke2hvcERlc3RpbmF0aW9ufWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYnVpbHRIb3BUeC52ZXJpZnlTaWduYXR1cmUoKSkge1xuICAgICAgLy8gV2UgZG9udCB3YW50IHRvIGNvbnRpbnVlIGF0IGFsbCBpbiB0aGlzIGNhc2UsIGF0IHJpc2sgb2YgQVZBWCBiZWluZyBzdHVjayBvbiB0aGUgaG9wIGFkZHJlc3NcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3AgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLCB0eGlkOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KGJ1aWx0SG9wVHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKSkgIT09IGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25lZCBob3AgdHhpZCBkb2VzIG5vdCBlcXVhbCBhY3R1YWwgdHhpZGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogQXZheFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgdHhCdWlsZGVyLnRyYW5zZmVyKCkua2V5KG5ldyBBdmF4Q0FjY291bnRMaWIuS2V5UGFpcih7IHBydjogcGFyYW1zLnBydiB9KS5nZXRLZXlzKCkucHJ2ISk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0cmFuc2FjdGlvbi5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiAoeyBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcywgYW1vdW50OiBvdXRwdXQudmFsdWUgfSkpO1xuXG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICBlaXAxNTU5OiBwYXJhbXMudHhQcmVidWlsZC5laXAxNTU5LFxuICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgICByZWNpcGllbnRzOiByZWNpcGllbnRzLFxuICAgICAgZXhwaXJhdGlvbjogcGFyYW1zLnR4UHJlYnVpbGQuZXhwaXJlVGltZSxcbiAgICAgIGhvcFRyYW5zYWN0aW9uOiBwYXJhbXMudHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbixcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogdHhQYXJhbXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgcHJlYnVpbGQgYmVmb3JlIHNlbmRpbmcgaXQgdG8gdGhlIHNlcnZlci4gQWRkIHRoaW5ncyBsaWtlIGhvcCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zIFRoZSB3aGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIGZvciB0aGlzIHByZWJ1aWxkXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy5ob3AgVHJ1ZSBpZiB0aGlzIHNob3VsZCBwcmVidWlsZCBhIGhvcCB0eCwgZWxzZSBmYWxzZVxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMucmVjaXBpZW50cyBUaGUgcmVjaXBpZW50cyBhcnJheSBvZiB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy53YWxsZXQgVGhlIHdhbGxldCBzZW5kaW5nIHRoaXMgdHhcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UgdGhlIHBhc3NwaHJhc2UgZm9yIHRoaXMgd2FsbGV0XG4gICAqL1xuICBhc3luYyBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBCdWlsZE9wdGlvbnMpOiBQcm9taXNlPEJ1aWxkT3B0aW9ucz4ge1xuICAgIGlmIChcbiAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLmhvcCkgJiZcbiAgICAgIGJ1aWxkUGFyYW1zLmhvcCAmJlxuICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMud2FsbGV0KSAmJlxuICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMucmVjaXBpZW50cykgJiZcbiAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UpXG4gICAgKSB7XG4gICAgICBpZiAodGhpcy5pc1Rva2VuKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBIb3AgdHJhbnNhY3Rpb25zIGFyZSBub3QgZW5hYmxlZCBmb3IgQVZBWEMgdG9rZW5zLCBub3IgYXJlIHRoZXkgbmVjZXNzYXJ5LiBQbGVhc2UgcmVtb3ZlIHRoZSAnaG9wJyBwYXJhbWV0ZXIgYW5kIHRyeSBhZ2Fpbi5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGF3YWl0IHRoaXMuY3JlYXRlSG9wVHJhbnNhY3Rpb25QYXJhbXMoe1xuICAgICAgICB3YWxsZXQ6IGJ1aWxkUGFyYW1zLndhbGxldCxcbiAgICAgICAgcmVjaXBpZW50czogYnVpbGRQYXJhbXMucmVjaXBpZW50cyxcbiAgICAgICAgd2FsbGV0UGFzc3BocmFzZTogYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIH0pKSBhcyBhbnk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBleHRyYSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIG9yaWdpbmFsIGJ1aWxkIHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMgZXh0cmEgcGFyYW1ldGVycyBvYmplY3QgdG8gbWVyZ2Ugd2l0aCB0aGUgb3JpZ2luYWwgYnVpbGQgcGFyYW1ldGVycyBvYmplY3QgYW5kIHNlbmQgdG8gdGhlIHBsYXRmb3JtXG4gICAqL1xuICBhc3luYyBjcmVhdGVIb3BUcmFuc2FjdGlvblBhcmFtcyhidWlsZFBhcmFtczogSG9wVHJhbnNhY3Rpb25CdWlsZE9wdGlvbnMpOiBQcm9taXNlPEhvcFBhcmFtcz4ge1xuICAgIGNvbnN0IHdhbGxldCA9IGJ1aWxkUGFyYW1zLndhbGxldDtcbiAgICBjb25zdCByZWNpcGllbnRzID0gYnVpbGRQYXJhbXMucmVjaXBpZW50cztcbiAgICBjb25zdCB3YWxsZXRQYXNzcGhyYXNlID0gYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IGF3YWl0IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVswXSB9KTtcbiAgICBjb25zdCB1c2VyUHJ2ID0gd2FsbGV0LmdldFVzZXJQcnYoeyBrZXljaGFpbjogdXNlcktleWNoYWluLCB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIGNvbnN0IHVzZXJQcnZCdWZmZXIgPSBiaXAzMi5mcm9tQmFzZTU4KHVzZXJQcnYpLnByaXZhdGVLZXk7XG4gICAgaWYgKCF1c2VyUHJ2QnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdXNlclBydicpO1xuICAgIH1cbiAgICBpZiAoIXJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocmVjaXBpZW50cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGFycmF5IG9mIHJlY2lwaWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBSaWdodCBub3cgd2Ugb25seSBzdXBwb3J0IDEgcmVjaXBpZW50XG4gICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc2VuZCB0byBleGFjdGx5IDEgcmVjaXBpZW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEFkZHJlc3MgPSByZWNpcGllbnRzWzBdLmFkZHJlc3M7XG4gICAgY29uc3QgcmVjaXBpZW50QW1vdW50ID0gcmVjaXBpZW50c1swXS5hbW91bnQ7XG4gICAgY29uc3QgZmVlRXN0aW1hdGVQYXJhbXMgPSB7XG4gICAgICByZWNpcGllbnQ6IHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICBhbW91bnQ6IHJlY2lwaWVudEFtb3VudCxcbiAgICAgIGhvcDogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IGZlZUVzdGltYXRlOiBGZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZmVlRXN0aW1hdGUoZmVlRXN0aW1hdGVQYXJhbXMpO1xuXG4gICAgY29uc3QgZ2FzTGltaXQgPSBmZWVFc3RpbWF0ZS5nYXNMaW1pdEVzdGltYXRlO1xuICAgIGNvbnN0IGdhc1ByaWNlID0gTWF0aC5yb3VuZChmZWVFc3RpbWF0ZS5mZWVFc3RpbWF0ZSAvIGdhc0xpbWl0KTtcbiAgICBjb25zdCBnYXNQcmljZU1heCA9IGdhc1ByaWNlICogNTtcbiAgICAvLyBQYXltZW50IGlkIGEgcmFuZG9tIG51bWJlciBzbyBpdHMgZGlmZmVyZW50IGZvciBldmVyeSB0eFxuICAgIGNvbnN0IHBheW1lbnRJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGhvcERpZ2VzdDogQnVmZmVyID0gQXZheEMuZ2V0SG9wRGlnZXN0KFtcbiAgICAgIHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICByZWNpcGllbnRBbW91bnQsXG4gICAgICBnYXNQcmljZU1heC50b1N0cmluZygpLFxuICAgICAgZ2FzTGltaXQudG9TdHJpbmcoKSxcbiAgICAgIHBheW1lbnRJZCxcbiAgICBdKTtcblxuICAgIGNvbnN0IHVzZXJSZXFTaWcgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoXG4gICAgICBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FTaWduKGhvcERpZ2VzdCwgdXNlclBydkJ1ZmZlcikuc2lnbmF0dXJlKS50b1N0cmluZygnaGV4JylcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhvcFBhcmFtczoge1xuICAgICAgICBnYXNQcmljZU1heCxcbiAgICAgICAgdXNlclJlcVNpZyxcbiAgICAgICAgcGF5bWVudElkLFxuICAgICAgfSxcbiAgICAgIGdhc0xpbWl0LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZmVlIGVzdGltYXRlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5ob3BdIFRydWUgaWYgd2Ugc2hvdWxkIGVzdGltYXRlIGZlZSBmb3IgYSBob3AgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucmVjaXBpZW50XSBUaGUgcmVjaXBpZW50IG9mIHRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBhIHNlbmQgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZGF0YV0gVGhlIEVUSCB0eCBkYXRhIHRvIGVzdGltYXRlIGEgc2VuZCBmb3JcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGZlZSBpbmZvIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgYXN5bmMgZmVlRXN0aW1hdGUocGFyYW1zOiBGZWVFc3RpbWF0ZU9wdGlvbnMpOiBQcm9taXNlPEZlZUVzdGltYXRlPiB7XG4gICAgY29uc3QgcXVlcnk6IEZlZUVzdGltYXRlT3B0aW9ucyA9IHt9O1xuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmhvcCkge1xuICAgICAgcXVlcnkuaG9wID0gcGFyYW1zLmhvcDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucmVjaXBpZW50KSB7XG4gICAgICBxdWVyeS5yZWNpcGllbnQgPSBwYXJhbXMucmVjaXBpZW50O1xuICAgIH1cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5kYXRhKSB7XG4gICAgICBxdWVyeS5kYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmFtb3VudCkge1xuICAgICAgcXVlcnkuYW1vdW50ID0gcGFyYW1zLmFtb3VudDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90eC9mZWUnKSkucXVlcnkocXVlcnkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhvcCBkaWdlc3QgZm9yIHRoZSB1c2VyIHRvIHNpZ24uIFRoaXMgaXMgdmFsaWRhdGVkIGluIHRoZSBIU00gdG8gcHJvdmUgdGhhdCB0aGUgdXNlciByZXF1ZXN0ZWQgdGhpcyB0eFxuICAgKiBAcGFyYW0gcGFyYW1zQXJyIFRoZSBwYXJhbWV0ZXJzIHRvIGhhc2ggdG9nZXRoZXIgZm9yIHRoZSBkaWdlc3RcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEhvcERpZ2VzdChwYXJhbXNBcnI6IHN0cmluZ1tdKTogQnVmZmVyIHtcbiAgICBjb25zdCBoYXNoID0gbmV3IEtlY2Nhaygna2VjY2FrMjU2Jyk7XG4gICAgaGFzaC51cGRhdGUoW0F2YXhDLmhvcFRyYW5zYWN0aW9uU2FsdCwgLi4ucGFyYW1zQXJyXS5qb2luKCckJykpO1xuICAgIHJldHVybiBoYXNoLmRpZ2VzdCgpO1xuICB9XG5cbiAgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBsYXRlclxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBlaXRoZXIgZW50ZXJwcmlzZSBvciBuZXdGZWVBZGRyZXNzIGlzIHBhc3NlZCwgdG8ga25vdyB3aGV0aGVyIHRvIGNyZWF0ZSBuZXcga2V5IG9yIHVzZSBlbnRlcnByaXNlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuZW50ZXJwcmlzZSB7U3RyaW5nfSB0aGUgZW50ZXJwcmlzZSBpZCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld0ZlZUFkZHJlc3Mge0Jvb2xlYW59IGNyZWF0ZSBhIG5ldyBmZWUgYWRkcmVzcyAoZW50ZXJwcmlzZSBub3QgbmVlZGVkIGluIHRoaXMgY2FzZSlcbiAgICovXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gV2UgYWx3YXlzIG5lZWQgcGFyYW1zIG9iamVjdCwgc2luY2UgZWl0aGVyIGVudGVycHJpc2Ugb3IgbmV3RmVlQWRkcmVzcyBpcyByZXF1aXJlZFxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZUNyZWF0ZUJpdEdvIG11c3QgYmUgcGFzc2VkIGEgcGFyYW1zIG9iamVjdC4gR290ICR7cGFyYW1zfSAodHlwZSAke3R5cGVvZiBwYXJhbXN9KWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZXhwZWN0aW5nIGVudGVycHJpc2Ugd2hlbiBhZGRpbmcgQml0R28ga2V5LiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBuZXcgQVZBWCBiaXRnbyBrZXksIHNldCB0aGUgbmV3RmVlQWRkcmVzcyBwYXJhbWV0ZXIgdG8gdHJ1ZS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHdoZXRoZXIga2V5IHNob3VsZCBiZSBhbiBlbnRlcnByaXNlIGtleSBvciBhIEJpdEdvIGtleSBmb3IgYSBuZXcgZmVlIGFkZHJlc3NcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgYXJndW1lbnRzIC0gY2Fubm90IHBhc3MgYm90aCBlbnRlcnByaXNlIGFuZCBuZXdGZWVBZGRyZXNzIHBhcmFtZXRlci5gKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5lbnRlcnByaXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbnRlcnByaXNlIHNob3VsZCBiZSBhIHN0cmluZyAtIGdvdCAke3BhcmFtcy5lbnRlcnByaXNlfSAodHlwZSAke3R5cGVvZiBwYXJhbXMuZW50ZXJwcmlzZX0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBuZXdGZWVBZGRyZXNzIHNob3VsZCBiZSBhIGJvb2xlYW4gLSBnb3QgJHtwYXJhbXMubmV3RmVlQWRkcmVzc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLm5ld0ZlZUFkZHJlc3N9KWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=