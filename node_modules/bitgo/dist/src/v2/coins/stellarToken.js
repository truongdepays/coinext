"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StellarToken = void 0;
/**
 * @prettier
 */
const _ = require("lodash");
const xlm_1 = require("./xlm");
const sdk_core_1 = require("@bitgo/sdk-core");
const stellar = require("stellar-sdk");
class StellarToken extends xlm_1.Xlm {
    constructor(bitgo, tokenConfig) {
        super(bitgo);
        this.tokenConfig = tokenConfig;
        const [tokenCoin, token] = _.split(this.tokenConfig.type, xlm_1.Xlm.coinTokenPatternSeparator);
        if (tokenCoin !== tokenConfig.coin) {
            throw new sdk_core_1.BitGoJsError(`invalid coin found in token: ${this.tokenConfig.type}`);
        }
        if (!token || !token.match(StellarToken.tokenPattern)) {
            throw new sdk_core_1.BitGoJsError(`invalid token: ${this.tokenConfig.type}`);
        }
        [this._code, this._issuer] = _.split(token, '-');
    }
    static createTokenConstructor(config) {
        return (bitgo) => new StellarToken(bitgo, config);
    }
    get type() {
        return this.tokenConfig.type;
    }
    get name() {
        return this.tokenConfig.name;
    }
    get coin() {
        return this.tokenConfig.coin;
    }
    get network() {
        return this.tokenConfig.network;
    }
    get code() {
        return this._code;
    }
    get issuer() {
        return this._issuer;
    }
    get decimalPlaces() {
        return this.tokenConfig.decimalPlaces;
    }
    getStellarNetwork() {
        return this.tokenConfig.network === 'Testnet' ? stellar.Networks.TESTNET : stellar.Networks.PUBLIC;
    }
    getChain() {
        return this.tokenConfig.type;
    }
    getFullName() {
        return 'Stellar Token';
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
}
exports.StellarToken = StellarToken;
StellarToken.tokenPattern = /[A-Z]{1,12}-G[A-Z0-9]{55}/;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlbGxhclRva2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3N0ZWxsYXJUb2tlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILDRCQUE0QjtBQUU1QiwrQkFBNEI7QUFFNUIsOENBQStDO0FBQy9DLHVDQUF1QztBQVV2QyxNQUFhLFlBQWEsU0FBUSxTQUFHO0lBTW5DLFlBQVksS0FBWSxFQUFFLFdBQStCO1FBQ3ZELEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBRS9CLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxTQUFHLENBQUMseUJBQXlCLENBQUMsQ0FBQztRQUN6RixJQUFJLFNBQVMsS0FBSyxXQUFXLENBQUMsSUFBSSxFQUFFO1lBQ2xDLE1BQU0sSUFBSSx1QkFBWSxDQUFDLGdDQUFnQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDakY7UUFDRCxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDckQsTUFBTSxJQUFJLHVCQUFZLENBQUMsa0JBQWtCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNuRTtRQUNELENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxNQUEwQjtRQUN0RCxPQUFPLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUM7SUFDbEMsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRCxJQUFJLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDO0lBQ3hDLENBQUM7SUFFUyxpQkFBaUI7UUFDekIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUNyRyxDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLGVBQWUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0JBQXdCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQzs7QUF0RUgsb0NBdUVDO0FBdEVpQix5QkFBWSxHQUFXLDJCQUEyQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBYbG0gfSBmcm9tICcuL3hsbSc7XG5pbXBvcnQgeyBDb2luQ29uc3RydWN0b3IgfSBmcm9tICcuLi9jb2luRmFjdG9yeSc7XG5pbXBvcnQgeyBCaXRHb0pzRXJyb3IgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RlbGxhclRva2VuQ29uZmlnIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgbmV0d29yazogc3RyaW5nO1xuICBkZWNpbWFsUGxhY2VzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTdGVsbGFyVG9rZW4gZXh0ZW5kcyBYbG0ge1xuICBzdGF0aWMgcmVhZG9ubHkgdG9rZW5QYXR0ZXJuOiBSZWdFeHAgPSAvW0EtWl17MSwxMn0tR1tBLVowLTldezU1fS87XG4gIHB1YmxpYyByZWFkb25seSB0b2tlbkNvbmZpZzogU3RlbGxhclRva2VuQ29uZmlnO1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb2RlOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2lzc3Vlcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgdG9rZW5Db25maWc6IFN0ZWxsYXJUb2tlbkNvbmZpZykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICB0aGlzLnRva2VuQ29uZmlnID0gdG9rZW5Db25maWc7XG5cbiAgICBjb25zdCBbdG9rZW5Db2luLCB0b2tlbl0gPSBfLnNwbGl0KHRoaXMudG9rZW5Db25maWcudHlwZSwgWGxtLmNvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3IpO1xuICAgIGlmICh0b2tlbkNvaW4gIT09IHRva2VuQ29uZmlnLmNvaW4pIHtcbiAgICAgIHRocm93IG5ldyBCaXRHb0pzRXJyb3IoYGludmFsaWQgY29pbiBmb3VuZCBpbiB0b2tlbjogJHt0aGlzLnRva2VuQ29uZmlnLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmICghdG9rZW4gfHwgIXRva2VuLm1hdGNoKFN0ZWxsYXJUb2tlbi50b2tlblBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgQml0R29Kc0Vycm9yKGBpbnZhbGlkIHRva2VuOiAke3RoaXMudG9rZW5Db25maWcudHlwZX1gKTtcbiAgICB9XG4gICAgW3RoaXMuX2NvZGUsIHRoaXMuX2lzc3Vlcl0gPSBfLnNwbGl0KHRva2VuLCAnLScpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVRva2VuQ29uc3RydWN0b3IoY29uZmlnOiBTdGVsbGFyVG9rZW5Db25maWcpOiBDb2luQ29uc3RydWN0b3Ige1xuICAgIHJldHVybiAoYml0Z286IEJpdEdvKSA9PiBuZXcgU3RlbGxhclRva2VuKGJpdGdvLCBjb25maWcpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcudHlwZTtcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLm5hbWU7XG4gIH1cblxuICBnZXQgY29pbigpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5jb2luO1xuICB9XG5cbiAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcubmV0d29yaztcbiAgfVxuXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2RlO1xuICB9XG5cbiAgZ2V0IGlzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy5faXNzdWVyO1xuICB9XG5cbiAgZ2V0IGRlY2ltYWxQbGFjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuZGVjaW1hbFBsYWNlcztcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRTdGVsbGFyTmV0d29yaygpOiBzdGVsbGFyLk5ldHdvcmtzIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5uZXR3b3JrID09PSAnVGVzdG5ldCcgPyBzdGVsbGFyLk5ldHdvcmtzLlRFU1RORVQgOiBzdGVsbGFyLk5ldHdvcmtzLlBVQkxJQztcbiAgfVxuXG4gIGdldENoYWluKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLnR5cGU7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpIHtcbiAgICByZXR1cm4gJ1N0ZWxsYXIgVG9rZW4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdfQ==