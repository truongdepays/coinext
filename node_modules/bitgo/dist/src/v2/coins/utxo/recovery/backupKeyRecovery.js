"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.backupKeyRecovery = void 0;
const _ = require("lodash");
const utxolib = require("@bitgo/utxo-lib");
const bitgo_1 = require("@bitgo/utxo-lib/dist/src/bitgo");
const unspents_1 = require("@bitgo/unspents");
const config = require("../../../../config");
const errors = require("../../../../errors");
const initiate_1 = require("../../../recovery/initiate");
const RecoveryProvider_1 = require("./RecoveryProvider");
const baseApi_1 = require("./baseApi");
const smartbitApi_1 = require("./smartbitApi");
const mempoolApi_1 = require("./mempoolApi");
const coingeckoApi_1 = require("./coingeckoApi");
const triple_1 = require("../../../triple");
const sign_1 = require("../sign");
/**
 * This transforms the txInfo from recover into the format that offline-signing-tool expects
 * @param coinName
 * @param txInfo
 * @param txHex
 * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
 */
function formatForOfflineVault(coinName, txInfo, txHex) {
    return {
        txHex,
        txInfo: {
            unspents: txInfo.inputs,
        },
        feeInfo: {},
        coin: coinName,
    };
}
/**
 * Get the current market price from a third party to be used for recovery
 * This function is only intended for non-bitgo recovery transactions, when it is necessary
 * to calculate the rough fee needed to pay to Keyternal. We are okay with approximating,
 * because the resulting price of this function only has less than 1 dollar influence on the
 * fee that needs to be paid to Keyternal.
 *
 * See calculateFeeAmount function:  return Math.round(feeAmountUsd / currentPrice * self.getBaseFactor());
 *
 * This end function should not be used as an accurate endpoint, since some coins' prices are missing from the provider
 */
async function getRecoveryMarketPrice(coin) {
    return await new coingeckoApi_1.CoingeckoApi().getUSDPrice(coin.getFamily());
}
/**
 * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
 * @param coin
 * @param params
 * @param params.provider {String} the KRS provider that holds the backup key
 * @param params.amount {Number} amount (in base units) to be recovered
 * @returns {*}
 */
async function calculateFeeAmount(coin, params) {
    const krsProvider = config.krsProviders[params.provider];
    if (krsProvider === undefined) {
        throw new Error(`no fee structure specified for provider ${params.provider}`);
    }
    if (krsProvider.feeType === 'flatUsd') {
        const feeAmountUsd = krsProvider.feeAmount;
        const currentPrice = await getRecoveryMarketPrice(coin);
        return Math.round((feeAmountUsd / currentPrice) * coin.getBaseFactor());
    }
    else {
        // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
        throw new Error('Fee structure not implemented');
    }
}
async function queryBlockchainUnspentsPath(coin, params, walletKeys, chain) {
    var _a;
    const recoveryProvider = (_a = params.recoveryProvider) !== null && _a !== void 0 ? _a : RecoveryProvider_1.forCoin(coin.getChain(), params.apiKey);
    const MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
    let numSequentialAddressesWithoutTxs = 0;
    async function gatherUnspents(addrIndex) {
        const walletKeysForUnspent = walletKeys.deriveForChainAndIndex(chain, addrIndex);
        const address = coin.createMultiSigAddress(bitgo_1.scriptTypeForChain(chain), 2, walletKeysForUnspent.publicKeys);
        const addrInfo = await recoveryProvider.getAddressInfo(address.address);
        // we use txCount here because it implies usage - having tx'es means the addr was generated and used
        if (addrInfo.txCount === 0) {
            numSequentialAddressesWithoutTxs++;
        }
        else {
            numSequentialAddressesWithoutTxs = 0;
            if (addrInfo.balance > 0) {
                console.log(`Found an address with balance: ${address.address} with balance ${addrInfo.balance}`);
                const addressUnspents = await recoveryProvider.getUnspentsForAddresses([address.address]);
                walletUnspents.push(...addressUnspents.map((u) => ({
                    ...u,
                    chain: chain,
                    index: addrIndex,
                })));
            }
        }
        if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
            // stop searching for addresses with unspents in them, we've found ${MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS} in a row with none
            // we are done
            return;
        }
        return gatherUnspents(addrIndex + 1);
    }
    // get unspents for these addresses
    const walletUnspents = [];
    // This will populate walletAddresses
    await gatherUnspents(0);
    if (walletUnspents.length === 0) {
        // Couldn't find any addresses with funds
        return [];
    }
    return walletUnspents;
}
async function getRecoveryFeePerBytes(coin, { defaultValue }) {
    try {
        return await mempoolApi_1.MempoolApi.forCoin(coin.getChain()).getRecoveryFeePerBytes();
    }
    catch (e) {
        console.dir(e);
        return defaultValue;
    }
}
/**
 * Builds a funds recovery transaction without BitGo
 * @param coin
 * @param bitgo
 * @param params
 * - userKey: [encrypted] xprv, or xpub
 * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
 * - walletPassphrase: necessary if one of the xprvs is encrypted
 * - bitgoKey: xpub
 * - krsProvider: necessary if backup key is held by KRS
 * - recoveryDestination: target address to send recovered funds to
 * - scan: the amount of consecutive addresses without unspents to scan through before stopping
 * - ignoreAddressTypes: (optional) scripts to ignore
 *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
 */
async function backupKeyRecovery(coin, bitgo, params) {
    if (_.isUndefined(params.userKey)) {
        throw new Error('missing userKey');
    }
    if (_.isUndefined(params.backupKey)) {
        throw new Error('missing backupKey');
    }
    if (_.isUndefined(params.recoveryDestination) || !coin.isValidAddress(params.recoveryDestination)) {
        throw new Error('invalid recoveryDestination');
    }
    if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
        throw new Error('scan must be a positive integer');
    }
    const isKrsRecovery = initiate_1.getIsKrsRecovery(params);
    const isUnsignedSweep = initiate_1.getIsUnsignedSweep(params);
    const krsProvider = isKrsRecovery ? initiate_1.getKrsProvider(coin, params.krsProvider) : undefined;
    // check whether key material and password authenticate the users and return parent keys of all three keys of the wallet
    const keys = initiate_1.getBip32Keys(bitgo, params, { requireBitGoXpub: true });
    if (!triple_1.isTriple(keys)) {
        throw new Error(`expected key triple`);
    }
    const walletKeys = new bitgo_1.RootWalletKeys(keys, [
        params.userKeyPath || bitgo_1.RootWalletKeys.defaultPrefix,
        bitgo_1.RootWalletKeys.defaultPrefix,
        bitgo_1.RootWalletKeys.defaultPrefix,
    ]);
    const unspents = (await Promise.all(bitgo_1.outputScripts.scriptTypes2Of3
        .filter((addressType) => { var _a; return coin.supportsAddressType(addressType) && !((_a = params.ignoreAddressTypes) === null || _a === void 0 ? void 0 : _a.includes(addressType)); })
        .reduce((queries, addressType) => [
        ...queries,
        queryBlockchainUnspentsPath(coin, params, walletKeys, bitgo_1.getExternalChainCode(addressType)),
        queryBlockchainUnspentsPath(coin, params, walletKeys, bitgo_1.getInternalChainCode(addressType)),
    ], []))).flat();
    // Execute the queries and gather the unspents
    const totalInputAmount = unspents.reduce((sum, u) => sum + u.value, 0);
    if (totalInputAmount <= 0) {
        throw new errors.ErrorNoInputToRecover();
    }
    // Build the transaction
    const transactionBuilder = utxolib.bitgo.createTransactionBuilderForNetwork(coin.network);
    const txInfo = {};
    const feePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    // KRS recovery transactions have a 2nd output to pay the recovery fee, like paygo fees. Use p2wsh outputs because
    // they are the largest outputs and thus the most conservative estimate to use in calculating fees. Also use
    // segwit overhead size and p2sh inputs for the same reason.
    const outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
    const approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + unspents_1.VirtualSizes.txP2shInputSize * unspents.length;
    const approximateFee = approximateSize * feePerByte;
    // Construct a transaction
    txInfo.inputs = unspents;
    unspents.forEach((unspent) => {
        const { txid, vout } = bitgo_1.parseOutputId(unspent.id);
        transactionBuilder.addInput(txid, vout, 0xffffffff, utxolib.address.toOutputScript(unspent.address, coin.network), unspent.value);
    });
    let recoveryAmount = totalInputAmount - approximateFee;
    let krsFee;
    if (isKrsRecovery && params.krsProvider) {
        try {
            krsFee = await calculateFeeAmount(coin, {
                provider: params.krsProvider,
                amount: recoveryAmount,
            });
            recoveryAmount -= krsFee;
        }
        catch (err) {
            // Don't let this error block the recovery -
            console.dir(err);
        }
    }
    if (recoveryAmount < 0) {
        throw new Error(`this wallet\'s balance is too low to pay the fees specified by the KRS provider. 
          Existing balance on wallet: ${totalInputAmount}. Estimated network fee for the recovery transaction
          : ${approximateFee}, KRS fee to pay: ${krsFee}. After deducting fees, your total recoverable balance
          is ${recoveryAmount}`);
    }
    transactionBuilder.addOutput(params.recoveryDestination, recoveryAmount);
    if (krsProvider && krsFee > 0) {
        if (!krsProvider.feeAddresses) {
            throw new Error(`keyProvider must define feeAddresses`);
        }
        const krsFeeAddress = krsProvider.feeAddresses[coin.getChain()];
        if (!krsFeeAddress) {
            throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
        }
        transactionBuilder.addOutput(krsFeeAddress, krsFee);
    }
    if (isUnsignedSweep) {
        const txHex = transactionBuilder.buildIncomplete().toBuffer().toString('hex');
        return formatForOfflineVault(coin.getChain(), txInfo, txHex);
    }
    else {
        let transaction = sign_1.signAndVerifyWalletTransaction(transactionBuilder, unspents, new bitgo_1.WalletUnspentSigner(walletKeys, walletKeys.user, walletKeys.backup), { isLastSignature: false });
        if (!isKrsRecovery) {
            transaction = sign_1.signAndVerifyWalletTransaction(transaction, unspents, new bitgo_1.WalletUnspentSigner(walletKeys, walletKeys.backup, walletKeys.user), { isLastSignature: true });
        }
        txInfo.transactionHex = transaction.toBuffer().toString('hex');
        let transactionDetails;
        try {
            transactionDetails = await smartbitApi_1.SmartbitApi.forCoin(coin.getChain()).getTransactionDetails(transaction);
        }
        catch (e) {
            // some coins don't have a reliable third party verification endpoint, or sometimes the third party endpoint
            // could be unavailable due to service outage, so we continue without verification for those coins, but we will
            // let users know that they should verify their own
            // this message should be piped to WRW and displayed on the UI
            if (e instanceof baseApi_1.ApiNotImplementedError || e instanceof baseApi_1.ApiRequestError) {
                console.log('Please verify your transaction by decoding the tx hex using a third-party api of your choice');
            }
            else {
                throw e;
            }
        }
        if (transactionDetails) {
            /**
             * Verify that the txhex user signs correspond to the correct tx they intended
             * by 1) getting back the decoded transaction based on the txhex
             * and then 2) compute the txid (hash), h1 of the decoded transaction 3) compare h1
             * to the txid (hash) of the transaction (including unspent info) we constructed
             */
            if (transactionDetails.TxId !== transaction.getId()) {
                console.log('txhash/txid returned by blockexplorer: ', transactionDetails.TxId);
                console.log('txhash/txid of the transaction bitgo constructed', transaction.getId());
                throw new Error('inconsistent recovery transaction id');
            }
            txInfo.tx = transactionDetails;
        }
    }
    if (isKrsRecovery) {
        txInfo.coin = coin.getChain();
        txInfo.backupKey = params.backupKey;
        txInfo.recoveryAmount = recoveryAmount;
    }
    return txInfo;
}
exports.backupKeyRecovery = backupKeyRecovery;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja3VwS2V5UmVjb3ZlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvdjIvY29pbnMvdXR4by9yZWNvdmVyeS9iYWNrdXBLZXlSZWNvdmVyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7OztBQUVILDRCQUE0QjtBQUM1QiwyQ0FBMkM7QUFDM0MsMERBVXdDO0FBRXhDLDhDQUErQztBQUcvQyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLHlEQUFnSDtBQUdoSCx5REFBK0Q7QUFDL0QsdUNBQW9FO0FBQ3BFLCtDQUE0QztBQUM1Qyw2Q0FBMEM7QUFDMUMsaURBQThDO0FBQzlDLDRDQUEyQztBQUMzQyxrQ0FBeUQ7QUFlekQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxxQkFBcUIsQ0FDNUIsUUFBZ0IsRUFDaEIsTUFBMEIsRUFDMUIsS0FBYTtJQUViLE9BQU87UUFDTCxLQUFLO1FBQ0wsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFFLE1BQU0sQ0FBQyxNQUFNO1NBQ3hCO1FBQ0QsT0FBTyxFQUFFLEVBQUU7UUFDWCxJQUFJLEVBQUUsUUFBUTtLQUNmLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxJQUFzQjtJQUMxRCxPQUFPLE1BQU0sSUFBSSwyQkFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsS0FBSyxVQUFVLGtCQUFrQixDQUMvQixJQUFzQixFQUN0QixNQUE2QztJQUU3QyxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUV6RCxJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUU7UUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsTUFBTSxDQUFDLFFB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QyxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ3BHO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDViw0R0FBNEc7WUFDNUcsK0dBQStHO1lBQy9HLG1EQUFtRDtZQUNuRCw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDLFlBQVksZ0NBQXNCLElBQUksQ0FBQyxZQUFZLHlCQUFlLEVBQUU7Z0JBQ3ZFLE9BQU8sQ0FBQyxHQUFHLENBQUMsOEZBQThGLENBQUMsQ0FBQzthQUM3RztpQkFBTTtnQkFDTCxNQUFNLENBQUMsQ0FBQzthQUNUO1NBQ0Y7UUFFRCxJQUFJLGtCQUFrQixFQUFFO1lBQ3RCOzs7OztlQUtHO1lBQ0gsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLEtBQUssV0FBVyxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUNuRCxPQUFPLENBQUMsR0FBRyxDQUFDLHlDQUF5QyxFQUFFLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNoRixPQUFPLENBQUMsR0FBRyxDQUFDLGtEQUFrRCxFQUFFLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRixNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7YUFDekQ7WUFDRCxNQUFNLENBQUMsRUFBRSxHQUFHLGtCQUFrQixDQUFDO1NBQ2hDO0tBQ0Y7SUFFRCxJQUFJLGFBQWEsRUFBRTtRQUNqQixNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM5QixNQUFNLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDcEMsTUFBTSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7S0FDeEM7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBeExELDhDQXdMQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cblxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHtcbiAgQ2hhaW5Db2RlLFxuICBnZXRJbnRlcm5hbENoYWluQ29kZSxcbiAgcGFyc2VPdXRwdXRJZCxcbiAgUm9vdFdhbGxldEtleXMsXG4gIHNjcmlwdFR5cGVGb3JDaGFpbixcbiAgV2FsbGV0VW5zcGVudCxcbiAgV2FsbGV0VW5zcGVudFNpZ25lcixcbiAgb3V0cHV0U2NyaXB0cyxcbiAgZ2V0RXh0ZXJuYWxDaGFpbkNvZGUsXG59IGZyb20gJ0BiaXRnby91dHhvLWxpYi9kaXN0L3NyYy9iaXRnbyc7XG5cbmltcG9ydCB7IFZpcnR1YWxTaXplcyB9IGZyb20gJ0BiaXRnby91bnNwZW50cyc7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vLi4vLi4vYml0Z28nO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4uLy4uLy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBlcnJvcnMgZnJvbSAnLi4vLi4vLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldEtyc1Byb3ZpZGVyLCBnZXRCaXAzMktleXMsIGdldElzS3JzUmVjb3ZlcnksIGdldElzVW5zaWduZWRTd2VlcCB9IGZyb20gJy4uLy4uLy4uL3JlY292ZXJ5L2luaXRpYXRlJztcbmltcG9ydCB7IEFic3RyYWN0VXR4b0NvaW4gfSBmcm9tICcuLi8uLi9hYnN0cmFjdFV0eG9Db2luJztcblxuaW1wb3J0IHsgZm9yQ29pbiwgUmVjb3ZlcnlQcm92aWRlciB9IGZyb20gJy4vUmVjb3ZlcnlQcm92aWRlcic7XG5pbXBvcnQgeyBBcGlOb3RJbXBsZW1lbnRlZEVycm9yLCBBcGlSZXF1ZXN0RXJyb3IgfSBmcm9tICcuL2Jhc2VBcGknO1xuaW1wb3J0IHsgU21hcnRiaXRBcGkgfSBmcm9tICcuL3NtYXJ0Yml0QXBpJztcbmltcG9ydCB7IE1lbXBvb2xBcGkgfSBmcm9tICcuL21lbXBvb2xBcGknO1xuaW1wb3J0IHsgQ29pbmdlY2tvQXBpIH0gZnJvbSAnLi9jb2luZ2Vja29BcGknO1xuaW1wb3J0IHsgaXNUcmlwbGUgfSBmcm9tICcuLi8uLi8uLi90cmlwbGUnO1xuaW1wb3J0IHsgc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vc2lnbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgaW5wdXRzOiBXYWxsZXRVbnNwZW50W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgdHhJbmZvOiB7XG4gICAgdW5zcGVudHM6IFdhbGxldFVuc3BlbnRbXTtcbiAgfTtcbiAgdHhIZXg6IHN0cmluZztcbiAgZmVlSW5mbzogUmVjb3JkPHN0cmluZywgbmV2ZXI+O1xuICBjb2luOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyB0cmFuc2Zvcm1zIHRoZSB0eEluZm8gZnJvbSByZWNvdmVyIGludG8gdGhlIGZvcm1hdCB0aGF0IG9mZmxpbmUtc2lnbmluZy10b29sIGV4cGVjdHNcbiAqIEBwYXJhbSBjb2luTmFtZVxuICogQHBhcmFtIHR4SW5mb1xuICogQHBhcmFtIHR4SGV4XG4gKiBAcmV0dXJucyB7e3R4SGV4OiAqLCB0eEluZm86IHt1bnNwZW50czogKn0sIGZlZUluZm86IHt9LCBjb2luOiB2b2lkfX1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KFxuICBjb2luTmFtZTogc3RyaW5nLFxuICB0eEluZm86IE9mZmxpbmVWYXVsdFR4SW5mbyxcbiAgdHhIZXg6IHN0cmluZ1xuKTogRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgcmV0dXJuIHtcbiAgICB0eEhleCxcbiAgICB0eEluZm86IHtcbiAgICAgIHVuc3BlbnRzOiB0eEluZm8uaW5wdXRzLFxuICAgIH0sXG4gICAgZmVlSW5mbzoge30sXG4gICAgY29pbjogY29pbk5hbWUsXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IG1hcmtldCBwcmljZSBmcm9tIGEgdGhpcmQgcGFydHkgdG8gYmUgdXNlZCBmb3IgcmVjb3ZlcnlcbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSBpbnRlbmRlZCBmb3Igbm9uLWJpdGdvIHJlY292ZXJ5IHRyYW5zYWN0aW9ucywgd2hlbiBpdCBpcyBuZWNlc3NhcnlcbiAqIHRvIGNhbGN1bGF0ZSB0aGUgcm91Z2ggZmVlIG5lZWRlZCB0byBwYXkgdG8gS2V5dGVybmFsLiBXZSBhcmUgb2theSB3aXRoIGFwcHJveGltYXRpbmcsXG4gKiBiZWNhdXNlIHRoZSByZXN1bHRpbmcgcHJpY2Ugb2YgdGhpcyBmdW5jdGlvbiBvbmx5IGhhcyBsZXNzIHRoYW4gMSBkb2xsYXIgaW5mbHVlbmNlIG9uIHRoZVxuICogZmVlIHRoYXQgbmVlZHMgdG8gYmUgcGFpZCB0byBLZXl0ZXJuYWwuXG4gKlxuICogU2VlIGNhbGN1bGF0ZUZlZUFtb3VudCBmdW5jdGlvbjogIHJldHVybiBNYXRoLnJvdW5kKGZlZUFtb3VudFVzZCAvIGN1cnJlbnRQcmljZSAqIHNlbGYuZ2V0QmFzZUZhY3RvcigpKTtcbiAqXG4gKiBUaGlzIGVuZCBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgYXMgYW4gYWNjdXJhdGUgZW5kcG9pbnQsIHNpbmNlIHNvbWUgY29pbnMnIHByaWNlcyBhcmUgbWlzc2luZyBmcm9tIHRoZSBwcm92aWRlclxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZWNvdmVyeU1hcmtldFByaWNlKGNvaW46IEFic3RyYWN0VXR4b0NvaW4pOiBQcm9taXNlPG51bWJlcj4ge1xuICByZXR1cm4gYXdhaXQgbmV3IENvaW5nZWNrb0FwaSgpLmdldFVTRFByaWNlKGNvaW4uZ2V0RmFtaWx5KCkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCAoaW4gYmFzZSB1bml0cykgdG8gcGF5IGEgS1JTIHByb3ZpZGVyIHdoZW4gYnVpbGRpbmcgYSByZWNvdmVyeSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGNvaW5cbiAqIEBwYXJhbSBwYXJhbXNcbiAqIEBwYXJhbSBwYXJhbXMucHJvdmlkZXIge1N0cmluZ30gdGhlIEtSUyBwcm92aWRlciB0aGF0IGhvbGRzIHRoZSBiYWNrdXAga2V5XG4gKiBAcGFyYW0gcGFyYW1zLmFtb3VudCB7TnVtYmVyfSBhbW91bnQgKGluIGJhc2UgdW5pdHMpIHRvIGJlIHJlY292ZXJlZFxuICogQHJldHVybnMgeyp9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUZlZUFtb3VudChcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbixcbiAgcGFyYW1zOiB7IHByb3ZpZGVyOiBzdHJpbmc7IGFtb3VudD86IG51bWJlciB9XG4pOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBrcnNQcm92aWRlciA9IGNvbmZpZy5rcnNQcm92aWRlcnNbcGFyYW1zLnByb3ZpZGVyXTtcblxuICBpZiAoa3JzUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm8gZmVlIHN0cnVjdHVyZSBzcGVjaWZpZWQgZm9yIHByb3ZpZGVyICR7cGFyYW1zLnByb3ZpZGVyfWApO1xuICB9XG5cbiAgaWYgKGtyc1Byb3ZpZGVyLmZlZVR5cGUgPT09ICdmbGF0VXNkJykge1xuICAgIGNvbnN0IGZlZUFtb3VudFVzZCA9IGtyc1Byb3ZpZGVyLmZlZUFtb3VudDtcbiAgICBjb25zdCBjdXJyZW50UHJpY2U6IG51bWJlciA9IGF3YWl0IGdldFJlY292ZXJ5TWFya2V0UHJpY2UoY29pbik7XG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoZmVlQW1vdW50VXNkIC8gY3VycmVudFByaWNlKSAqIGNvaW4uZ2V0QmFzZUZhY3RvcigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBjYW4gYWRkIG1vcmUgZmVlIHN0cnVjdHVyZXMgaGVyZSBhcyBuZWVkZWQgZm9yIGRpZmZlcmVudCBwcm92aWRlcnMsIHN1Y2ggYXMgcGVyY2VudGFnZSBvZiByZWNvdmVyeSBhbW91bnRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZSBzdHJ1Y3R1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyUGFyYW1zIHtcbiAgc2Nhbj86IG51bWJlcjtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgYml0Z29LZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbiAgaWdub3JlQWRkcmVzc1R5cGVzOiBvdXRwdXRTY3JpcHRzLlNjcmlwdFR5cGUyT2YzW107XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIGFwaUtleT86IHN0cmluZztcbiAgdXNlcktleVBhdGg/OiBzdHJpbmc7XG4gIHJlY292ZXJ5UHJvdmlkZXI/OiBSZWNvdmVyeVByb3ZpZGVyO1xufVxuXG5hc3luYyBmdW5jdGlvbiBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoXG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW4sXG4gIHBhcmFtczogUmVjb3ZlclBhcmFtcyxcbiAgd2FsbGV0S2V5czogUm9vdFdhbGxldEtleXMsXG4gIGNoYWluOiBDaGFpbkNvZGVcbik6IFByb21pc2U8V2FsbGV0VW5zcGVudFtdPiB7XG4gIGNvbnN0IHJlY292ZXJ5UHJvdmlkZXIgPSBwYXJhbXMucmVjb3ZlcnlQcm92aWRlciA/PyBmb3JDb2luKGNvaW4uZ2V0Q2hhaW4oKSwgcGFyYW1zLmFwaUtleSk7XG4gIGNvbnN0IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUyA9IHBhcmFtcy5zY2FuIHx8IDIwO1xuICBsZXQgbnVtU2VxdWVudGlhbEFkZHJlc3Nlc1dpdGhvdXRUeHMgPSAwO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgd2FsbGV0S2V5c0ZvclVuc3BlbnQgPSB3YWxsZXRLZXlzLmRlcml2ZUZvckNoYWluQW5kSW5kZXgoY2hhaW4sIGFkZHJJbmRleCk7XG4gICAgY29uc3QgYWRkcmVzcyA9IGNvaW4uY3JlYXRlTXVsdGlTaWdBZGRyZXNzKHNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbiksIDIsIHdhbGxldEtleXNGb3JVbnNwZW50LnB1YmxpY0tleXMpO1xuXG4gICAgY29uc3QgYWRkckluZm8gPSBhd2FpdCByZWNvdmVyeVByb3ZpZGVyLmdldEFkZHJlc3NJbmZvKGFkZHJlc3MuYWRkcmVzcyk7XG4gICAgLy8gd2UgdXNlIHR4Q291bnQgaGVyZSBiZWNhdXNlIGl0IGltcGxpZXMgdXNhZ2UgLSBoYXZpbmcgdHgnZXMgbWVhbnMgdGhlIGFkZHIgd2FzIGdlbmVyYXRlZCBhbmQgdXNlZFxuICAgIGlmIChhZGRySW5mby50eENvdW50ID09PSAwKSB7XG4gICAgICBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA9IDA7XG5cbiAgICAgIGlmIChhZGRySW5mby5iYWxhbmNlID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgYW4gYWRkcmVzcyB3aXRoIGJhbGFuY2U6ICR7YWRkcmVzcy5hZGRyZXNzfSB3aXRoIGJhbGFuY2UgJHthZGRySW5mby5iYWxhbmNlfWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzVW5zcGVudHMgPSBhd2FpdCByZWNvdmVyeVByb3ZpZGVyLmdldFVuc3BlbnRzRm9yQWRkcmVzc2VzKFthZGRyZXNzLmFkZHJlc3NdKTtcblxuICAgICAgICB3YWxsZXRVbnNwZW50cy5wdXNoKFxuICAgICAgICAgIC4uLmFkZHJlc3NVbnNwZW50cy5tYXAoXG4gICAgICAgICAgICAodSk6IFdhbGxldFVuc3BlbnQgPT4gKHtcbiAgICAgICAgICAgICAgLi4udSxcbiAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICBpbmRleDogYWRkckluZGV4LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID49IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUykge1xuICAgICAgLy8gc3RvcCBzZWFyY2hpbmcgZm9yIGFkZHJlc3NlcyB3aXRoIHVuc3BlbnRzIGluIHRoZW0sIHdlJ3ZlIGZvdW5kICR7TUFYX1NFUVVFTlRJQUxfQUREUkVTU0VTX1dJVEhPVVRfVFhTfSBpbiBhIHJvdyB3aXRoIG5vbmVcbiAgICAgIC8vIHdlIGFyZSBkb25lXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleCArIDEpO1xuICB9XG5cbiAgLy8gZ2V0IHVuc3BlbnRzIGZvciB0aGVzZSBhZGRyZXNzZXNcblxuICBjb25zdCB3YWxsZXRVbnNwZW50czogV2FsbGV0VW5zcGVudFtdID0gW107XG4gIC8vIFRoaXMgd2lsbCBwb3B1bGF0ZSB3YWxsZXRBZGRyZXNzZXNcbiAgYXdhaXQgZ2F0aGVyVW5zcGVudHMoMCk7XG5cbiAgaWYgKHdhbGxldFVuc3BlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIENvdWxkbid0IGZpbmQgYW55IGFkZHJlc3NlcyB3aXRoIGZ1bmRzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHdhbGxldFVuc3BlbnRzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZWNvdmVyeUZlZVBlckJ5dGVzKFxuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luLFxuICB7IGRlZmF1bHRWYWx1ZSB9OiB7IGRlZmF1bHRWYWx1ZTogbnVtYmVyIH1cbik6IFByb21pc2U8bnVtYmVyPiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IE1lbXBvb2xBcGkuZm9yQ29pbihjb2luLmdldENoYWluKCkpLmdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZGlyKGUpO1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQmFja3VwS2V5UmVjb3ZlcnlUcmFuc2Fuc2FjdGlvbiA9IHtcbiAgaW5wdXRzOiBXYWxsZXRVbnNwZW50W107XG4gIHRyYW5zYWN0aW9uSGV4OiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHJlY292ZXJ5QW1vdW50OiBudW1iZXI7XG4gIC8vIHNtYXJ0Yml0IGFwaSByZXNwb25zZVxuICB0eD86IHVua25vd247XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAqIEBwYXJhbSBjb2luXG4gKiBAcGFyYW0gYml0Z29cbiAqIEBwYXJhbSBwYXJhbXNcbiAqIC0gdXNlcktleTogW2VuY3J5cHRlZF0geHBydiwgb3IgeHB1YlxuICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAqIC0gYml0Z29LZXk6IHhwdWJcbiAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gKiAtIHNjYW46IHRoZSBhbW91bnQgb2YgY29uc2VjdXRpdmUgYWRkcmVzc2VzIHdpdGhvdXQgdW5zcGVudHMgdG8gc2NhbiB0aHJvdWdoIGJlZm9yZSBzdG9wcGluZ1xuICogLSBpZ25vcmVBZGRyZXNzVHlwZXM6IChvcHRpb25hbCkgc2NyaXB0cyB0byBpZ25vcmVcbiAqICAgICAgICBmb3IgZXhhbXBsZTogWydwMnNoUDJ3c2gnLCAncDJ3c2gnXSB3aWxsIHByZXZlbnQgY29kZSBmcm9tIGNoZWNraW5nIGZvciB3cmFwcGVkLXNlZ3dpdCBhbmQgbmF0aXZlLXNlZ3dpdCBjaGFpbnMgb24gdGhlIHB1YmxpYyBibG9jayBleHBsb3JlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhY2t1cEtleVJlY292ZXJ5KFxuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luLFxuICBiaXRnbzogQml0R28sXG4gIHBhcmFtczogUmVjb3ZlclBhcmFtc1xuKTogUHJvbWlzZTxCYWNrdXBLZXlSZWNvdmVyeVRyYW5zYW5zYWN0aW9uIHwgRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvPiB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy51c2VyS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuYmFja3VwS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgfVxuXG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSB8fCAhY29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICB9XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zY2FuKSAmJiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5zY2FuKSB8fCBwYXJhbXMuc2NhbiA8IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FuIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gIH1cblxuICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gZ2V0SXNLcnNSZWNvdmVyeShwYXJhbXMpO1xuICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICBjb25zdCBrcnNQcm92aWRlciA9IGlzS3JzUmVjb3ZlcnkgPyBnZXRLcnNQcm92aWRlcihjb2luLCBwYXJhbXMua3JzUHJvdmlkZXIpIDogdW5kZWZpbmVkO1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIga2V5IG1hdGVyaWFsIGFuZCBwYXNzd29yZCBhdXRoZW50aWNhdGUgdGhlIHVzZXJzIGFuZCByZXR1cm4gcGFyZW50IGtleXMgb2YgYWxsIHRocmVlIGtleXMgb2YgdGhlIHdhbGxldFxuICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKGJpdGdvLCBwYXJhbXMsIHsgcmVxdWlyZUJpdEdvWHB1YjogdHJ1ZSB9KTtcbiAgaWYgKCFpc1RyaXBsZShrZXlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5IHRyaXBsZWApO1xuICB9XG4gIGNvbnN0IHdhbGxldEtleXMgPSBuZXcgUm9vdFdhbGxldEtleXMoa2V5cywgW1xuICAgIHBhcmFtcy51c2VyS2V5UGF0aCB8fCBSb290V2FsbGV0S2V5cy5kZWZhdWx0UHJlZml4LFxuICAgIFJvb3RXYWxsZXRLZXlzLmRlZmF1bHRQcmVmaXgsXG4gICAgUm9vdFdhbGxldEtleXMuZGVmYXVsdFByZWZpeCxcbiAgXSk7XG5cbiAgY29uc3QgdW5zcGVudHM6IFdhbGxldFVuc3BlbnRbXSA9IChcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG91dHB1dFNjcmlwdHMuc2NyaXB0VHlwZXMyT2YzXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgKGFkZHJlc3NUeXBlKSA9PiBjb2luLnN1cHBvcnRzQWRkcmVzc1R5cGUoYWRkcmVzc1R5cGUpICYmICFwYXJhbXMuaWdub3JlQWRkcmVzc1R5cGVzPy5pbmNsdWRlcyhhZGRyZXNzVHlwZSlcbiAgICAgICAgKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChxdWVyaWVzLCBhZGRyZXNzVHlwZSkgPT4gW1xuICAgICAgICAgICAgLi4ucXVlcmllcyxcbiAgICAgICAgICAgIHF1ZXJ5QmxvY2tjaGFpblVuc3BlbnRzUGF0aChjb2luLCBwYXJhbXMsIHdhbGxldEtleXMsIGdldEV4dGVybmFsQ2hhaW5Db2RlKGFkZHJlc3NUeXBlKSksXG4gICAgICAgICAgICBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoY29pbiwgcGFyYW1zLCB3YWxsZXRLZXlzLCBnZXRJbnRlcm5hbENoYWluQ29kZShhZGRyZXNzVHlwZSkpLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW10gYXMgUHJvbWlzZTxXYWxsZXRVbnNwZW50W10+W11cbiAgICAgICAgKVxuICAgIClcbiAgKS5mbGF0KCk7XG5cbiAgLy8gRXhlY3V0ZSB0aGUgcXVlcmllcyBhbmQgZ2F0aGVyIHRoZSB1bnNwZW50c1xuICBjb25zdCB0b3RhbElucHV0QW1vdW50ID0gdW5zcGVudHMucmVkdWNlKChzdW0sIHUpID0+IHN1bSArIHUudmFsdWUsIDApO1xuICBpZiAodG90YWxJbnB1dEFtb3VudCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FcnJvck5vSW5wdXRUb1JlY292ZXIoKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICBjb25zdCB0cmFuc2FjdGlvbkJ1aWxkZXIgPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uQnVpbGRlckZvck5ldHdvcmsoY29pbi5uZXR3b3JrKTtcbiAgY29uc3QgdHhJbmZvID0ge30gYXMgQmFja3VwS2V5UmVjb3ZlcnlUcmFuc2Fuc2FjdGlvbjtcblxuICBjb25zdCBmZWVQZXJCeXRlOiBudW1iZXIgPSBhd2FpdCBnZXRSZWNvdmVyeUZlZVBlckJ5dGVzKGNvaW4sIHsgZGVmYXVsdFZhbHVlOiAxMDAgfSk7XG5cbiAgLy8gS1JTIHJlY292ZXJ5IHRyYW5zYWN0aW9ucyBoYXZlIGEgMm5kIG91dHB1dCB0byBwYXkgdGhlIHJlY292ZXJ5IGZlZSwgbGlrZSBwYXlnbyBmZWVzLiBVc2UgcDJ3c2ggb3V0cHV0cyBiZWNhdXNlXG4gIC8vIHRoZXkgYXJlIHRoZSBsYXJnZXN0IG91dHB1dHMgYW5kIHRodXMgdGhlIG1vc3QgY29uc2VydmF0aXZlIGVzdGltYXRlIHRvIHVzZSBpbiBjYWxjdWxhdGluZyBmZWVzLiBBbHNvIHVzZVxuICAvLyBzZWd3aXQgb3ZlcmhlYWQgc2l6ZSBhbmQgcDJzaCBpbnB1dHMgZm9yIHRoZSBzYW1lIHJlYXNvbi5cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IChpc0tyc1JlY292ZXJ5ID8gMiA6IDEpICogVmlydHVhbFNpemVzLnR4UDJ3c2hPdXRwdXRTaXplO1xuICBjb25zdCBhcHByb3hpbWF0ZVNpemUgPSBWaXJ0dWFsU2l6ZXMudHhTZWdPdmVyaGVhZFZTaXplICsgb3V0cHV0U2l6ZSArIFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiB1bnNwZW50cy5sZW5ndGg7XG4gIGNvbnN0IGFwcHJveGltYXRlRmVlID0gYXBwcm94aW1hdGVTaXplICogZmVlUGVyQnl0ZTtcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvblxuICB0eEluZm8uaW5wdXRzID0gdW5zcGVudHM7XG5cbiAgdW5zcGVudHMuZm9yRWFjaCgodW5zcGVudCkgPT4ge1xuICAgIGNvbnN0IHsgdHhpZCwgdm91dCB9ID0gcGFyc2VPdXRwdXRJZCh1bnNwZW50LmlkKTtcbiAgICB0cmFuc2FjdGlvbkJ1aWxkZXIuYWRkSW5wdXQoXG4gICAgICB0eGlkLFxuICAgICAgdm91dCxcbiAgICAgIDB4ZmZmZmZmZmYsXG4gICAgICB1dHhvbGliLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQodW5zcGVudC5hZGRyZXNzLCBjb2luLm5ldHdvcmspLFxuICAgICAgdW5zcGVudC52YWx1ZVxuICAgICk7XG4gIH0pO1xuXG4gIGxldCByZWNvdmVyeUFtb3VudCA9IHRvdGFsSW5wdXRBbW91bnQgLSBhcHByb3hpbWF0ZUZlZTtcbiAgbGV0IGtyc0ZlZTtcbiAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGtyc0ZlZSA9IGF3YWl0IGNhbGN1bGF0ZUZlZUFtb3VudChjb2luLCB7XG4gICAgICAgIHByb3ZpZGVyOiBwYXJhbXMua3JzUHJvdmlkZXIsXG4gICAgICAgIGFtb3VudDogcmVjb3ZlcnlBbW91bnQsXG4gICAgICB9KTtcbiAgICAgIHJlY292ZXJ5QW1vdW50IC09IGtyc0ZlZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIERvbid0IGxldCB0aGlzIGVycm9yIGJsb2NrIHRoZSByZWNvdmVyeSAtXG4gICAgICBjb25zb2xlLmRpcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZWNvdmVyeUFtb3VudCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHRoaXMgd2FsbGV0XFwncyBiYWxhbmNlIGlzIHRvbyBsb3cgdG8gcGF5IHRoZSBmZWVzIHNwZWNpZmllZCBieSB0aGUgS1JTIHByb3ZpZGVyLiBcbiAgICAgICAgICBFeGlzdGluZyBiYWxhbmNlIG9uIHdhbGxldDogJHt0b3RhbElucHV0QW1vdW50fS4gRXN0aW1hdGVkIG5ldHdvcmsgZmVlIGZvciB0aGUgcmVjb3ZlcnkgdHJhbnNhY3Rpb25cbiAgICAgICAgICA6ICR7YXBwcm94aW1hdGVGZWV9LCBLUlMgZmVlIHRvIHBheTogJHtrcnNGZWV9LiBBZnRlciBkZWR1Y3RpbmcgZmVlcywgeW91ciB0b3RhbCByZWNvdmVyYWJsZSBiYWxhbmNlXG4gICAgICAgICAgaXMgJHtyZWNvdmVyeUFtb3VudH1gKTtcbiAgfVxuXG4gIHRyYW5zYWN0aW9uQnVpbGRlci5hZGRPdXRwdXQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIHJlY292ZXJ5QW1vdW50KTtcblxuICBpZiAoa3JzUHJvdmlkZXIgJiYga3JzRmVlID4gMCkge1xuICAgIGlmICgha3JzUHJvdmlkZXIuZmVlQWRkcmVzc2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleVByb3ZpZGVyIG11c3QgZGVmaW5lIGZlZUFkZHJlc3Nlc2ApO1xuICAgIH1cblxuICAgIGNvbnN0IGtyc0ZlZUFkZHJlc3MgPSBrcnNQcm92aWRlci5mZWVBZGRyZXNzZXNbY29pbi5nZXRDaGFpbigpXTtcblxuICAgIGlmICgha3JzRmVlQWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIEtSUyBwcm92aWRlciBoYXMgbm90IGNvbmZpZ3VyZWQgdGhlaXIgZmVlIHN0cnVjdHVyZSB5ZXQgLSByZWNvdmVyeSBjYW5ub3QgYmUgY29tcGxldGVkJyk7XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb25CdWlsZGVyLmFkZE91dHB1dChrcnNGZWVBZGRyZXNzLCBrcnNGZWUpO1xuICB9XG5cbiAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgIGNvbnN0IHR4SGV4ID0gdHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkSW5jb21wbGV0ZSgpLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBmb3JtYXRGb3JPZmZsaW5lVmF1bHQoY29pbi5nZXRDaGFpbigpLCB0eEluZm8gYXMgT2ZmbGluZVZhdWx0VHhJbmZvLCB0eEhleCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHRyYW5zYWN0aW9uID0gc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uKFxuICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyLFxuICAgICAgdW5zcGVudHMsXG4gICAgICBuZXcgV2FsbGV0VW5zcGVudFNpZ25lcjxSb290V2FsbGV0S2V5cz4od2FsbGV0S2V5cywgd2FsbGV0S2V5cy51c2VyLCB3YWxsZXRLZXlzLmJhY2t1cCksXG4gICAgICB7IGlzTGFzdFNpZ25hdHVyZTogZmFsc2UgfVxuICAgICk7XG4gICAgaWYgKCFpc0tyc1JlY292ZXJ5KSB7XG4gICAgICB0cmFuc2FjdGlvbiA9IHNpZ25BbmRWZXJpZnlXYWxsZXRUcmFuc2FjdGlvbihcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHVuc3BlbnRzLFxuICAgICAgICBuZXcgV2FsbGV0VW5zcGVudFNpZ25lcjxSb290V2FsbGV0S2V5cz4od2FsbGV0S2V5cywgd2FsbGV0S2V5cy5iYWNrdXAsIHdhbGxldEtleXMudXNlciksXG4gICAgICAgIHsgaXNMYXN0U2lnbmF0dXJlOiB0cnVlIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgdHhJbmZvLnRyYW5zYWN0aW9uSGV4ID0gdHJhbnNhY3Rpb24udG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICBsZXQgdHJhbnNhY3Rpb25EZXRhaWxzO1xuICAgIHRyeSB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHMgPSBhd2FpdCBTbWFydGJpdEFwaS5mb3JDb2luKGNvaW4uZ2V0Q2hhaW4oKSkuZ2V0VHJhbnNhY3Rpb25EZXRhaWxzKHRyYW5zYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzb21lIGNvaW5zIGRvbid0IGhhdmUgYSByZWxpYWJsZSB0aGlyZCBwYXJ0eSB2ZXJpZmljYXRpb24gZW5kcG9pbnQsIG9yIHNvbWV0aW1lcyB0aGUgdGhpcmQgcGFydHkgZW5kcG9pbnRcbiAgICAgIC8vIGNvdWxkIGJlIHVuYXZhaWxhYmxlIGR1ZSB0byBzZXJ2aWNlIG91dGFnZSwgc28gd2UgY29udGludWUgd2l0aG91dCB2ZXJpZmljYXRpb24gZm9yIHRob3NlIGNvaW5zLCBidXQgd2Ugd2lsbFxuICAgICAgLy8gbGV0IHVzZXJzIGtub3cgdGhhdCB0aGV5IHNob3VsZCB2ZXJpZnkgdGhlaXIgb3duXG4gICAgICAvLyB0aGlzIG1lc3NhZ2Ugc2hvdWxkIGJlIHBpcGVkIHRvIFdSVyBhbmQgZGlzcGxheWVkIG9uIHRoZSBVSVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBcGlOb3RJbXBsZW1lbnRlZEVycm9yIHx8IGUgaW5zdGFuY2VvZiBBcGlSZXF1ZXN0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BsZWFzZSB2ZXJpZnkgeW91ciB0cmFuc2FjdGlvbiBieSBkZWNvZGluZyB0aGUgdHggaGV4IHVzaW5nIGEgdGhpcmQtcGFydHkgYXBpIG9mIHlvdXIgY2hvaWNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZ5IHRoYXQgdGhlIHR4aGV4IHVzZXIgc2lnbnMgY29ycmVzcG9uZCB0byB0aGUgY29ycmVjdCB0eCB0aGV5IGludGVuZGVkXG4gICAgICAgKiBieSAxKSBnZXR0aW5nIGJhY2sgdGhlIGRlY29kZWQgdHJhbnNhY3Rpb24gYmFzZWQgb24gdGhlIHR4aGV4XG4gICAgICAgKiBhbmQgdGhlbiAyKSBjb21wdXRlIHRoZSB0eGlkIChoYXNoKSwgaDEgb2YgdGhlIGRlY29kZWQgdHJhbnNhY3Rpb24gMykgY29tcGFyZSBoMVxuICAgICAgICogdG8gdGhlIHR4aWQgKGhhc2gpIG9mIHRoZSB0cmFuc2FjdGlvbiAoaW5jbHVkaW5nIHVuc3BlbnQgaW5mbykgd2UgY29uc3RydWN0ZWRcbiAgICAgICAqL1xuICAgICAgaWYgKHRyYW5zYWN0aW9uRGV0YWlscy5UeElkICE9PSB0cmFuc2FjdGlvbi5nZXRJZCgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0eGhhc2gvdHhpZCByZXR1cm5lZCBieSBibG9ja2V4cGxvcmVyOiAnLCB0cmFuc2FjdGlvbkRldGFpbHMuVHhJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0eGhhc2gvdHhpZCBvZiB0aGUgdHJhbnNhY3Rpb24gYml0Z28gY29uc3RydWN0ZWQnLCB0cmFuc2FjdGlvbi5nZXRJZCgpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvbnNpc3RlbnQgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gaWQnKTtcbiAgICAgIH1cbiAgICAgIHR4SW5mby50eCA9IHRyYW5zYWN0aW9uRGV0YWlscztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgIHR4SW5mby5jb2luID0gY29pbi5nZXRDaGFpbigpO1xuICAgIHR4SW5mby5iYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5O1xuICAgIHR4SW5mby5yZWNvdmVyeUFtb3VudCA9IHJlY292ZXJ5QW1vdW50O1xuICB9XG5cbiAgcmV0dXJuIHR4SW5mbztcbn1cbiJdfQ==