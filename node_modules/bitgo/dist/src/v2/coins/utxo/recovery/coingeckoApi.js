"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoingeckoApi = void 0;
/**
 * @prettier
 */
const baseApi_1 = require("./baseApi");
const familyNamesToCoinGeckoIds = new Map()
    .set('BTC', 'bitcoin')
    .set('LTC', 'litecoin')
    .set('BCH', 'bitcoin-cash')
    .set('ZEC', 'zcash')
    .set('DASH', 'dash')
    // note: we don't have a source for price data of BCHA and BSV, but we will use BCH as a proxy. We will substitute
    // it out for a better source when it becomes available.  TODO BG-26359.
    .set('BCHA', 'bitcoin-cash')
    .set('BSV', 'bitcoin-cash');
class CoingeckoApi extends baseApi_1.BaseApi {
    constructor() {
        super('https://api.coingecko.com/api/v3');
    }
    async getUSDPrice(coinFamily) {
        const coinGeckoId = familyNamesToCoinGeckoIds.get(coinFamily.toUpperCase());
        if (!coinGeckoId) {
            throw new Error(`There is no CoinGecko id for family name ${coinFamily.toUpperCase()}.`);
        }
        const coinGeckoUrl = `/simple/price?ids=${coinGeckoId}&vs_currencies=USD`;
        const res = await this.get(coinGeckoUrl, { retry: 2 });
        return res.map((body) => {
            // An example of response
            // {
            //   "ethereum": {
            //     "usd": 220.64
            //   }
            // }
            if (!body) {
                throw new Error('Unable to reach Coin Gecko API for price data');
            }
            if (!body[coinGeckoId]['usd'] || typeof body[coinGeckoId]['usd'] !== 'number') {
                throw new Error('Unexpected response from Coin Gecko API for price data');
            }
            return body[coinGeckoId]['usd'];
        });
    }
}
exports.CoingeckoApi = CoingeckoApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29pbmdlY2tvQXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3V0eG8vcmVjb3ZlcnkvY29pbmdlY2tvQXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztHQUVHO0FBQ0gsdUNBQW9DO0FBRXBDLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxHQUFHLEVBQUU7S0FDeEMsR0FBRyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUM7S0FDckIsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUM7S0FDdEIsR0FBRyxDQUFDLEtBQUssRUFBRSxjQUFjLENBQUM7S0FDMUIsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUM7S0FDbkIsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7SUFDcEIsa0hBQWtIO0lBQ2xILHdFQUF3RTtLQUN2RSxHQUFHLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQztLQUMzQixHQUFHLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0FBRTlCLE1BQWEsWUFBYSxTQUFRLGlCQUFPO0lBQ3ZDO1FBQ0UsS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBa0I7UUFDbEMsTUFBTSxXQUFXLEdBQUcseUJBQXlCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQzVFLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsVUFBVSxDQUFDLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUMxRjtRQUNELE1BQU0sWUFBWSxHQUFHLHFCQUFxQixXQUFXLG9CQUFvQixDQUFDO1FBQzFFLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBTSxZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM1RCxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUN0Qix5QkFBeUI7WUFDekIsSUFBSTtZQUNKLGtCQUFrQjtZQUNsQixvQkFBb0I7WUFDcEIsTUFBTTtZQUNOLElBQUk7WUFDSixJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQzthQUNsRTtZQUNELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUM3RSxNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7YUFDM0U7WUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQTdCRCxvQ0E2QkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCYXNlQXBpIH0gZnJvbSAnLi9iYXNlQXBpJztcblxuY29uc3QgZmFtaWx5TmFtZXNUb0NvaW5HZWNrb0lkcyA9IG5ldyBNYXAoKVxuICAuc2V0KCdCVEMnLCAnYml0Y29pbicpXG4gIC5zZXQoJ0xUQycsICdsaXRlY29pbicpXG4gIC5zZXQoJ0JDSCcsICdiaXRjb2luLWNhc2gnKVxuICAuc2V0KCdaRUMnLCAnemNhc2gnKVxuICAuc2V0KCdEQVNIJywgJ2Rhc2gnKVxuICAvLyBub3RlOiB3ZSBkb24ndCBoYXZlIGEgc291cmNlIGZvciBwcmljZSBkYXRhIG9mIEJDSEEgYW5kIEJTViwgYnV0IHdlIHdpbGwgdXNlIEJDSCBhcyBhIHByb3h5LiBXZSB3aWxsIHN1YnN0aXR1dGVcbiAgLy8gaXQgb3V0IGZvciBhIGJldHRlciBzb3VyY2Ugd2hlbiBpdCBiZWNvbWVzIGF2YWlsYWJsZS4gIFRPRE8gQkctMjYzNTkuXG4gIC5zZXQoJ0JDSEEnLCAnYml0Y29pbi1jYXNoJylcbiAgLnNldCgnQlNWJywgJ2JpdGNvaW4tY2FzaCcpO1xuXG5leHBvcnQgY2xhc3MgQ29pbmdlY2tvQXBpIGV4dGVuZHMgQmFzZUFwaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdodHRwczovL2FwaS5jb2luZ2Vja28uY29tL2FwaS92MycpO1xuICB9XG5cbiAgYXN5bmMgZ2V0VVNEUHJpY2UoY29pbkZhbWlseTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBjb2luR2Vja29JZCA9IGZhbWlseU5hbWVzVG9Db2luR2Vja29JZHMuZ2V0KGNvaW5GYW1pbHkudG9VcHBlckNhc2UoKSk7XG4gICAgaWYgKCFjb2luR2Vja29JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBDb2luR2Vja28gaWQgZm9yIGZhbWlseSBuYW1lICR7Y29pbkZhbWlseS50b1VwcGVyQ2FzZSgpfS5gKTtcbiAgICB9XG4gICAgY29uc3QgY29pbkdlY2tvVXJsID0gYC9zaW1wbGUvcHJpY2U/aWRzPSR7Y29pbkdlY2tvSWR9JnZzX2N1cnJlbmNpZXM9VVNEYDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldDxhbnk+KGNvaW5HZWNrb1VybCwgeyByZXRyeTogMiB9KTtcbiAgICByZXR1cm4gcmVzLm1hcCgoYm9keSkgPT4ge1xuICAgICAgLy8gQW4gZXhhbXBsZSBvZiByZXNwb25zZVxuICAgICAgLy8ge1xuICAgICAgLy8gICBcImV0aGVyZXVtXCI6IHtcbiAgICAgIC8vICAgICBcInVzZFwiOiAyMjAuNjRcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlYWNoIENvaW4gR2Vja28gQVBJIGZvciBwcmljZSBkYXRhJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJvZHlbY29pbkdlY2tvSWRdWyd1c2QnXSB8fCB0eXBlb2YgYm9keVtjb2luR2Vja29JZF1bJ3VzZCddICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSBDb2luIEdlY2tvIEFQSSBmb3IgcHJpY2UgZGF0YScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm9keVtjb2luR2Vja29JZF1bJ3VzZCddO1xuICAgIH0pO1xuICB9XG59XG4iXX0=