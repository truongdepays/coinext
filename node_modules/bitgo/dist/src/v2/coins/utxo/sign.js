"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndVerifyWalletTransaction = exports.TransactionSigningError = exports.InputSigningError = void 0;
/**
 * @prettier
 */
const utxolib = require("@bitgo/utxo-lib");
const bitgo_1 = require("@bitgo/utxo-lib/dist/src/bitgo");
const debugLib = require("debug");
const replayProtection_1 = require("./replayProtection");
const debug = debugLib('bitgo:v2:utxo');
class InputSigningError extends Error {
    constructor(inputIndex, unspent, reason) {
        super(`signing error at input ${inputIndex}: unspentId=${unspent.id}: ${reason}`);
        this.inputIndex = inputIndex;
        this.unspent = unspent;
        this.reason = reason;
    }
    static expectedWalletUnspent(inputIndex, unspent) {
        return new InputSigningError(inputIndex, unspent, `not a wallet unspent, not a replay protection unspent`);
    }
}
exports.InputSigningError = InputSigningError;
class TransactionSigningError extends Error {
    constructor(signErrors, verifyError) {
        super(`sign errors at inputs: [${signErrors.join(',')}], ` +
            `verify errors at inputs: [${verifyError.join(',')}], see log for details`);
    }
}
exports.TransactionSigningError = TransactionSigningError;
/**
 * Sign all inputs of a wallet transaction and verify signatures after signing.
 * Collects and logs signing errors and verification errors, throws error in the end if any of them
 * failed.
 *
 * @param transaction - wallet transaction (builder) to be signed
 * @param unspents - transaction unspents
 * @param walletSigner - signing parameters
 * @param isLastSignature - Returns full-signed transaction when true. Builds half-signed when false.
 */
function signAndVerifyWalletTransaction(transaction, unspents, walletSigner, { isLastSignature }) {
    const network = transaction.network;
    const prevOutputs = unspents.map((u) => bitgo_1.toOutput(u, network));
    let txBuilder;
    if (transaction instanceof utxolib.bitgo.UtxoTransaction) {
        txBuilder = utxolib.bitgo.createTransactionBuilderFromTransaction(transaction, prevOutputs);
        if (transaction.ins.length !== unspents.length) {
            throw new Error(`transaction inputs must match unspents`);
        }
    }
    else if (transaction instanceof utxolib.bitgo.UtxoTransactionBuilder) {
        txBuilder = transaction;
    }
    else {
        throw new Error(`must pass UtxoTransaction or UtxoTransactionBuilder`);
    }
    const signErrors = unspents
        .map((unspent, inputIndex) => {
        if (replayProtection_1.isReplayProtectionUnspent(unspent, network)) {
            debug('Skipping signature for input %d of %d (RP input?)', inputIndex + 1, unspents.length);
            return;
        }
        if (!bitgo_1.isWalletUnspent(unspent)) {
            return InputSigningError.expectedWalletUnspent(inputIndex, unspent);
        }
        try {
            bitgo_1.signInputWithUnspent(txBuilder, inputIndex, unspent, walletSigner);
            debug('Successfully signed input %d of %d', inputIndex + 1, unspents.length);
        }
        catch (e) {
            return new InputSigningError(inputIndex, unspent, e);
        }
    })
        .filter((e) => e !== undefined);
    const signedTransaction = isLastSignature ? txBuilder.build() : txBuilder.buildIncomplete();
    const verifyErrors = signedTransaction.ins
        .map((input, inputIndex) => {
        const unspent = unspents[inputIndex];
        if (replayProtection_1.isReplayProtectionUnspent(unspent, network)) {
            debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', inputIndex + 1, unspents.length);
            return;
        }
        if (!bitgo_1.isWalletUnspent(unspent)) {
            return InputSigningError.expectedWalletUnspent(inputIndex, unspent);
        }
        try {
            const publicKey = walletSigner.deriveForChainAndIndex(unspent.chain, unspent.index).signer.publicKey;
            if (!utxolib.bitgo.verifySignatureWithPublicKey(signedTransaction, inputIndex, prevOutputs, publicKey)) {
                return new InputSigningError(inputIndex, unspent, new Error(`invalid signature`));
            }
        }
        catch (e) {
            debug('Invalid signature');
            return new InputSigningError(inputIndex, unspent, e);
        }
    })
        .filter((e) => e !== undefined);
    if (signErrors.length || verifyErrors.length) {
        throw new TransactionSigningError(signErrors, verifyErrors);
    }
    return signedTransaction;
}
exports.signAndVerifyWalletTransaction = signAndVerifyWalletTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy91dHhvL3NpZ24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0dBRUc7QUFDSCwyQ0FBMkM7QUFDM0MsMERBT3dDO0FBQ3hDLGtDQUFrQztBQUVsQyx5REFBK0Q7QUFFL0QsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBRXhDLE1BQWEsaUJBQWtCLFNBQVEsS0FBSztJQUsxQyxZQUFtQixVQUFrQixFQUFTLE9BQWdCLEVBQVMsTUFBc0I7UUFDM0YsS0FBSyxDQUFDLDBCQUEwQixVQUFVLGVBQWUsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBRGpFLGVBQVUsR0FBVixVQUFVLENBQVE7UUFBUyxZQUFPLEdBQVAsT0FBTyxDQUFTO1FBQVMsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7SUFFN0YsQ0FBQztJQU5ELE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxVQUFrQixFQUFFLE9BQWdCO1FBQy9ELE9BQU8sSUFBSSxpQkFBaUIsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLHVEQUF1RCxDQUFDLENBQUM7SUFDN0csQ0FBQztDQUtGO0FBUkQsOENBUUM7QUFFRCxNQUFhLHVCQUF3QixTQUFRLEtBQUs7SUFDaEQsWUFBWSxVQUErQixFQUFFLFdBQWdDO1FBQzNFLEtBQUssQ0FDSCwyQkFBMkIsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSztZQUNsRCw2QkFBNkIsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQzdFLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFQRCwwREFPQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLDhCQUE4QixDQUM1QyxXQUFpRixFQUNqRixRQUFtQixFQUNuQixZQUFpRCxFQUNqRCxFQUFFLGVBQWUsRUFBZ0M7SUFFakQs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LEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxFQUFFO2dCQUN0RyxPQUFPLElBQUksaUJBQWlCLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7YUFDbkY7U0FDRjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDM0IsT0FBTyxJQUFJLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDdEQ7SUFDSCxDQUFDLENBQUM7U0FDRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQTBCLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUM7SUFFMUQsSUFBSSxVQUFVLENBQUMsTUFBTSxJQUFJLFlBQVksQ0FBQyxNQUFNLEVBQUU7UUFDNUMsTUFBTSxJQUFJLHVCQUF1QixDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQztLQUM3RDtJQUVELE9BQU8saUJBQWlCLENBQUM7QUFDM0IsQ0FBQztBQXhFRCx3RUF3RUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQge1xuICBpc1dhbGxldFVuc3BlbnQsXG4gIFJvb3RXYWxsZXRLZXlzLFxuICBzaWduSW5wdXRXaXRoVW5zcGVudCxcbiAgdG9PdXRwdXQsXG4gIFVuc3BlbnQsXG4gIFdhbGxldFVuc3BlbnRTaWduZXIsXG59IGZyb20gJ0BiaXRnby91dHhvLWxpYi9kaXN0L3NyYy9iaXRnbyc7XG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5cbmltcG9ydCB7IGlzUmVwbGF5UHJvdGVjdGlvblVuc3BlbnQgfSBmcm9tICcuL3JlcGxheVByb3RlY3Rpb24nO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2Mjp1dHhvJyk7XG5cbmV4cG9ydCBjbGFzcyBJbnB1dFNpZ25pbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdGljIGV4cGVjdGVkV2FsbGV0VW5zcGVudChpbnB1dEluZGV4OiBudW1iZXIsIHVuc3BlbnQ6IFVuc3BlbnQpOiBJbnB1dFNpZ25pbmdFcnJvciB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFNpZ25pbmdFcnJvcihpbnB1dEluZGV4LCB1bnNwZW50LCBgbm90IGEgd2FsbGV0IHVuc3BlbnQsIG5vdCBhIHJlcGxheSBwcm90ZWN0aW9uIHVuc3BlbnRgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBpbnB1dEluZGV4OiBudW1iZXIsIHB1YmxpYyB1bnNwZW50OiBVbnNwZW50LCBwdWJsaWMgcmVhc29uOiBFcnJvciB8IHN0cmluZykge1xuICAgIHN1cGVyKGBzaWduaW5nIGVycm9yIGF0IGlucHV0ICR7aW5wdXRJbmRleH06IHVuc3BlbnRJZD0ke3Vuc3BlbnQuaWR9OiAke3JlYXNvbn1gKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25TaWduaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25FcnJvcnM6IElucHV0U2lnbmluZ0Vycm9yW10sIHZlcmlmeUVycm9yOiBJbnB1dFNpZ25pbmdFcnJvcltdKSB7XG4gICAgc3VwZXIoXG4gICAgICBgc2lnbiBlcnJvcnMgYXQgaW5wdXRzOiBbJHtzaWduRXJyb3JzLmpvaW4oJywnKX1dLCBgICtcbiAgICAgICAgYHZlcmlmeSBlcnJvcnMgYXQgaW5wdXRzOiBbJHt2ZXJpZnlFcnJvci5qb2luKCcsJyl9XSwgc2VlIGxvZyBmb3IgZGV0YWlsc2BcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogU2lnbiBhbGwgaW5wdXRzIG9mIGEgd2FsbGV0IHRyYW5zYWN0aW9uIGFuZCB2ZXJpZnkgc2lnbmF0dXJlcyBhZnRlciBzaWduaW5nLlxuICogQ29sbGVjdHMgYW5kIGxvZ3Mgc2lnbmluZyBlcnJvcnMgYW5kIHZlcmlmaWNhdGlvbiBlcnJvcnMsIHRocm93cyBlcnJvciBpbiB0aGUgZW5kIGlmIGFueSBvZiB0aGVtXG4gKiBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gd2FsbGV0IHRyYW5zYWN0aW9uIChidWlsZGVyKSB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB1bnNwZW50cyAtIHRyYW5zYWN0aW9uIHVuc3BlbnRzXG4gKiBAcGFyYW0gd2FsbGV0U2lnbmVyIC0gc2lnbmluZyBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gaXNMYXN0U2lnbmF0dXJlIC0gUmV0dXJucyBmdWxsLXNpZ25lZCB0cmFuc2FjdGlvbiB3aGVuIHRydWUuIEJ1aWxkcyBoYWxmLXNpZ25lZCB3aGVuIGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uKFxuICB0cmFuc2FjdGlvbjogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb24gfCB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbkJ1aWxkZXIsXG4gIHVuc3BlbnRzOiBVbnNwZW50W10sXG4gIHdhbGxldFNpZ25lcjogV2FsbGV0VW5zcGVudFNpZ25lcjxSb290V2FsbGV0S2V5cz4sXG4gIHsgaXNMYXN0U2lnbmF0dXJlIH06IHsgaXNMYXN0U2lnbmF0dXJlOiBib29sZWFuIH1cbik6IHV0eG9saWIuYml0Z28uVXR4b1RyYW5zYWN0aW9uIHtcbiAgY29uc3QgbmV0d29yayA9IHRyYW5zYWN0aW9uLm5ldHdvcmsgYXMgdXR4b2xpYi5OZXR3b3JrO1xuICBjb25zdCBwcmV2T3V0cHV0cyA9IHVuc3BlbnRzLm1hcCgodSkgPT4gdG9PdXRwdXQodSwgbmV0d29yaykpO1xuXG4gIGxldCB0eEJ1aWxkZXI6IHV0eG9saWIuYml0Z28uVXR4b1RyYW5zYWN0aW9uQnVpbGRlcjtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb24pIHtcbiAgICB0eEJ1aWxkZXIgPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uQnVpbGRlckZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgcHJldk91dHB1dHMpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5pbnMubGVuZ3RoICE9PSB1bnNwZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNhY3Rpb24gaW5wdXRzIG11c3QgbWF0Y2ggdW5zcGVudHNgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbkJ1aWxkZXIpIHtcbiAgICB0eEJ1aWxkZXIgPSB0cmFuc2FjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11c3QgcGFzcyBVdHhvVHJhbnNhY3Rpb24gb3IgVXR4b1RyYW5zYWN0aW9uQnVpbGRlcmApO1xuICB9XG5cbiAgY29uc3Qgc2lnbkVycm9yczogSW5wdXRTaWduaW5nRXJyb3JbXSA9IHVuc3BlbnRzXG4gICAgLm1hcCgodW5zcGVudDogVW5zcGVudCwgaW5wdXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoaXNSZXBsYXlQcm90ZWN0aW9uVW5zcGVudCh1bnNwZW50LCBuZXR3b3JrKSkge1xuICAgICAgICBkZWJ1ZygnU2tpcHBpbmcgc2lnbmF0dXJlIGZvciBpbnB1dCAlZCBvZiAlZCAoUlAgaW5wdXQ/KScsIGlucHV0SW5kZXggKyAxLCB1bnNwZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzV2FsbGV0VW5zcGVudCh1bnNwZW50KSkge1xuICAgICAgICByZXR1cm4gSW5wdXRTaWduaW5nRXJyb3IuZXhwZWN0ZWRXYWxsZXRVbnNwZW50KGlucHV0SW5kZXgsIHVuc3BlbnQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2lnbklucHV0V2l0aFVuc3BlbnQodHhCdWlsZGVyLCBpbnB1dEluZGV4LCB1bnNwZW50LCB3YWxsZXRTaWduZXIpO1xuICAgICAgICBkZWJ1ZygnU3VjY2Vzc2Z1bGx5IHNpZ25lZCBpbnB1dCAlZCBvZiAlZCcsIGlucHV0SW5kZXggKyAxLCB1bnNwZW50cy5sZW5ndGgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IElucHV0U2lnbmluZ0Vycm9yKGlucHV0SW5kZXgsIHVuc3BlbnQsIGUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZSk6IGUgaXMgSW5wdXRTaWduaW5nRXJyb3IgPT4gZSAhPT0gdW5kZWZpbmVkKTtcblxuICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGlzTGFzdFNpZ25hdHVyZSA/IHR4QnVpbGRlci5idWlsZCgpIDogdHhCdWlsZGVyLmJ1aWxkSW5jb21wbGV0ZSgpO1xuXG4gIGNvbnN0IHZlcmlmeUVycm9yczogSW5wdXRTaWduaW5nRXJyb3JbXSA9IHNpZ25lZFRyYW5zYWN0aW9uLmluc1xuICAgIC5tYXAoKGlucHV0LCBpbnB1dEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB1bnNwZW50ID0gdW5zcGVudHNbaW5wdXRJbmRleF0gYXMgVW5zcGVudDtcbiAgICAgIGlmIChpc1JlcGxheVByb3RlY3Rpb25VbnNwZW50KHVuc3BlbnQsIG5ldHdvcmspKSB7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgICdTa2lwcGluZyBpbnB1dCBzaWduYXR1cmUgJWQgb2YgJWQgKHVuc3BlbnQgZnJvbSByZXBsYXkgcHJvdGVjdGlvbiBhZGRyZXNzIHdoaWNoIGlzIHBsYXRmb3JtIHNpZ25lZCBvbmx5KScsXG4gICAgICAgICAgaW5wdXRJbmRleCArIDEsXG4gICAgICAgICAgdW5zcGVudHMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNXYWxsZXRVbnNwZW50KHVuc3BlbnQpKSB7XG4gICAgICAgIHJldHVybiBJbnB1dFNpZ25pbmdFcnJvci5leHBlY3RlZFdhbGxldFVuc3BlbnQoaW5wdXRJbmRleCwgdW5zcGVudCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSB3YWxsZXRTaWduZXIuZGVyaXZlRm9yQ2hhaW5BbmRJbmRleCh1bnNwZW50LmNoYWluLCB1bnNwZW50LmluZGV4KS5zaWduZXIucHVibGljS2V5O1xuICAgICAgICBpZiAoIXV0eG9saWIuYml0Z28udmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleShzaWduZWRUcmFuc2FjdGlvbiwgaW5wdXRJbmRleCwgcHJldk91dHB1dHMsIHB1YmxpY0tleSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IElucHV0U2lnbmluZ0Vycm9yKGlucHV0SW5kZXgsIHVuc3BlbnQsIG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmVgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3IoaW5wdXRJbmRleCwgdW5zcGVudCwgZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlKTogZSBpcyBJbnB1dFNpZ25pbmdFcnJvciA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChzaWduRXJyb3JzLmxlbmd0aCB8fCB2ZXJpZnlFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU2lnbmluZ0Vycm9yKHNpZ25FcnJvcnMsIHZlcmlmeUVycm9ycyk7XG4gIH1cblxuICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG59XG4iXX0=