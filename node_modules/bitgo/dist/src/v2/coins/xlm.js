"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xlm = void 0;
/**
 * @prettier
 */
const _ = require("lodash");
const utxolib = require("@bitgo/utxo-lib");
const account_lib_1 = require("@bitgo/account-lib");
const querystring = require("querystring");
const url = require("url");
const request = require("superagent");
const stellar = require("stellar-sdk");
const bignumber_js_1 = require("bignumber.js");
const keychains_1 = require("../keychains");
const sdk_core_1 = require("@bitgo/sdk-core");
const errors_1 = require("../../errors");
const baseCoin_1 = require("../baseCoin");
const promise_utils_1 = require("../promise-utils");
const sdk_api_1 = require("@bitgo/sdk-api");
const initiate_1 = require("../recovery/initiate");
class Xlm extends baseCoin_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
    }
    static createInstance(bitgo) {
        return new Xlm(bitgo);
    }
    getStellarNetwork() {
        return stellar.Networks.PUBLIC;
    }
    /**
     * Factor between the base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e7;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xlm';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xlm';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Stellar';
    }
    /**
     * Url at which the stellar federation server can be reached
     */
    getFederationServerUrl() {
        return sdk_core_1.common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    }
    /**
     * Url at which horizon can be reached
     */
    getHorizonUrl() {
        return 'https://horizon.stellar.org';
    }
    /**
     * Generate a new key pair on the ed25519 curve
     * @param seed
     * @returns generated pub and prv
     */
    generateKeyPair(seed) {
        const pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret(),
        };
    }
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    getPubFromRaw(pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    }
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    getPrvFromRaw(prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId);
    }
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    isValidMemo({ value, type }) {
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    /**
     * Create instance of stellar.MuxedAccount from M address
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     */
    getMuxedAccount(address) {
        try {
            return stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            throw new Error(`invalid muxed address: ${address}`);
        }
    }
    /**
     * Return boolean indicating whether a muxed address is valid
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     *
     * @param address
     * @returns {boolean}
     */
    isValidMuxedAddress(address) {
        if (!_.isString(address) || !address.startsWith('M')) {
            return false;
        }
        try {
            // return true if muxed account is valid or throw
            return !!stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    async getMinimumReserve() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        const baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
        return 5 * baseReserve;
    }
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    async getBaseTransactionFee() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        return horizonLedgerInfo.records[0].base_fee_in_stroops;
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        if (address.startsWith('M')) {
            if (this.isValidMuxedAddress(address)) {
                const muxedAccount = this.getMuxedAccount(address);
                return {
                    baseAddress: muxedAccount.baseAccount().accountId(),
                    address,
                    id: muxedAccount.id(),
                    memoId: undefined,
                };
            }
            else {
                throw new errors_1.InvalidAddressError(`invalid muxed address: ${address}`);
            }
        }
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error(`invalid address: ${address}`);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                baseAddress: address,
                address: address,
                id: undefined,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new errors_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new errors_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new errors_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new errors_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            baseAddress: destinationAddress,
            address: destinationAddress,
            id: undefined,
            memoId,
        };
    }
    /**
     * Validate and return address with appended memo id or muxed address
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    normalizeAddress({ address, memoId }) {
        if (this.isValidMuxedAddress(address)) {
            return address;
        }
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error(`invalid address details: ${address}`);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return `${address}?memoId=${memoId}`;
        }
        return address;
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    getTokenNameFromStellarAsset(asset) {
        const code = asset.getCode();
        const issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return `${this.getChain()}${baseCoin_1.BaseCoin.coinTokenPatternSeparator}${code}${Xlm.tokenPatternSeparator}${issuer}`;
    }
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    isValidStellarUsername(username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    }
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    getBitGoFederationServer() {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        const isNonSecureEnv = !_.startsWith(sdk_core_1.common.Environments[this.bitgo.env].uri, 'https');
        const federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    }
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    async federationLookup({ address, accountId, }) {
        try {
            const federationServer = this.getBitGoFederationServer();
            if (address) {
                return await federationServer.resolveAddress(address);
            }
            else if (accountId) {
                return await federationServer.resolveAccountId(accountId);
            }
            else {
                throw new Error('invalid argument - must provide Stellar address or account id');
            }
        }
        catch (e) {
            const error = _.get(e, 'response.data.detail');
            if (error) {
                throw new errors_1.StellarFederationUserNotFoundError(error);
            }
            else {
                throw e;
            }
        }
    }
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    async federationLookupByName(address) {
        if (!address) {
            throw new Error('invalid Stellar address');
        }
        return this.federationLookup({ address });
    }
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    async federationLookupByAccountId(accountId) {
        if (!accountId) {
            throw new Error('invalid Stellar account');
        }
        return this.federationLookup({ accountId });
    }
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.baseAddress !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError(`address validation failure: ${addressDetails.baseAddress} vs ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    async getExtraPrebuildParams(buildParams) {
        const params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return params;
    }
    /**
     * @deprecated
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        // Stellar's Ed25519 public keys start with a G, while private keys start with an S
        const isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
        const isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
        if (isKrsRecovery) {
            initiate_1.checkKrsProvider(this, params.krsProvider);
        }
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new errors_1.InvalidAddressError('Invalid destination address!');
        }
        const [userKey, backupKey] = initiate_1.getStellarKeys(this.bitgo, params);
        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
            throw new Error(`Invalid wallet address: ${params.rootAddress}`);
        }
        const accountDataUrl = `${this.getHorizonUrl()}/accounts/${params.rootAddress}`;
        const destinationUrl = `${this.getHorizonUrl()}/accounts/${params.recoveryDestination}`;
        let accountData;
        try {
            accountData = await sdk_api_1.toBitgoRequest(request.get(accountDataUrl)).result();
        }
        catch (e) {
            throw new Error('Unable to reach the Stellar network via Horizon.');
        }
        // Now check if the destination account is empty or not
        let unfundedDestination = false;
        try {
            await request.get(destinationUrl);
        }
        catch (e) {
            if (e.status === 404) {
                // If the destination account does not yet exist, horizon responds with 404
                unfundedDestination = true;
            }
        }
        if (!accountData.sequence || !accountData.balances) {
            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
        }
        const account = new stellar.Account(params.rootAddress, accountData.sequence);
        // Stellar supports multiple assets on chain, we're only interested in the balances entry whose type is "native" (XLM)
        const nativeBalanceInfo = accountData.balances.find((assetBalance) => assetBalance['asset_type'] === 'native');
        if (!nativeBalanceInfo) {
            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
        }
        const walletBalance = Number(this.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
        const minimumReserve = await this.getMinimumReserve();
        const baseTxFee = await this.getBaseTransactionFee();
        const recoveryAmount = walletBalance - minimumReserve - baseTxFee;
        const formattedRecoveryAmount = this.baseUnitsToBigUnits(recoveryAmount).toString();
        const txBuilder = new stellar.TransactionBuilder(account, {
            fee: baseTxFee.toFixed(0),
            networkPassphrase: this.getStellarNetwork(),
        });
        const operation = unfundedDestination
            ? // In this case, we need to create the account
                stellar.Operation.createAccount({
                    destination: params.recoveryDestination,
                    startingBalance: formattedRecoveryAmount,
                })
            : // Otherwise if the account already exists, we do a normal send
                stellar.Operation.payment({
                    destination: params.recoveryDestination,
                    asset: stellar.Asset.native(),
                    amount: formattedRecoveryAmount,
                });
        const tx = txBuilder.addOperation(operation).setTimeout(stellar.TimeoutInfinite).build();
        if (!isUnsignedSweep) {
            tx.sign(userKey);
        }
        if (!isKrsRecovery && !isUnsignedSweep) {
            tx.sign(backupKey);
        }
        const transaction = {
            tx: Xlm.txToString(tx),
            recoveryAmount,
        };
        if (isKrsRecovery) {
            transaction.backupKey = params.backupKey;
            transaction.coin = this.getChain();
        }
        return transaction;
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<HalfSignedTransaction>}
     */
    async signTransaction(params) {
        const { txPrebuild, prv } = params;
        if (_.isUndefined(txPrebuild)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isObject(txPrebuild)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        const keyPair = stellar.Keypair.fromSecret(prv);
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        tx.sign(keyPair);
        return {
            halfSigned: {
                txBase64: Xlm.txToString(tx),
            },
        };
    }
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    async supplementGenerateWallet(walletParams) {
        let seed;
        const rootPrv = walletParams.rootPrivateKey;
        if (rootPrv) {
            if (!this.isValidPrv(rootPrv)) {
                throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
            }
            seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
        }
        const keyPair = this.generateKeyPair(seed);
        // extend the wallet initialization params
        walletParams.rootPrivateKey = keyPair.prv;
        return walletParams;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        if (!this.isValidPrv(key.prv)) {
            throw new Error(`invalid prv: ${key.prv}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keypair = stellar.Keypair.fromSecret(key.prv);
        return keypair.sign(message);
    }
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    verifySignature(pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error(`invalid pub: ${pub}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const { txBase64 } = params;
        let tx;
        try {
            tx = new stellar.Transaction(txBase64, this.getStellarNetwork());
        }
        catch (e) {
            throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
        }
        const id = tx.hash().toString('hex');
        // In a Stellar tx, the _memo property is an object with the methods:
        // value() and arm() that provide memo value and type, respectively.
        const memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm')
            ? {
                value: _.result(tx, '_memo.value').toString(),
                type: _.result(tx, '_memo.arm'),
            }
            : {};
        let spendAmount = new bignumber_js_1.BigNumber(0); // amount of XLM used in XLM-only txs
        const spendAmounts = {}; // track both xlm and token amounts
        if (_.isEmpty(tx.operations)) {
            throw new Error('missing operations');
        }
        const outputs = [];
        const operations = []; // non-payment operations
        _.forEach(tx.operations, (op) => {
            if (op.type === 'createAccount' || op.type === 'payment') {
                // TODO Remove memoId from address
                // Get memo to attach to address, if type is 'id'
                const memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ? `?memoId=${memo.value}` : '';
                let asset;
                if (op.type === 'payment') {
                    if (op.asset.getAssetType() === 'liquidity_pool_shares') {
                        throw new Error('Invalid asset type');
                    }
                    asset = op.asset;
                }
                else {
                    asset = stellar.Asset.native();
                }
                const coin = this.getTokenNameFromStellarAsset(asset); // coin or token id
                const output = {
                    amount: this.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                    address: op.destination + memoId,
                    coin,
                };
                if (!_.isUndefined(spendAmounts[coin])) {
                    spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                }
                else {
                    spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                }
                if (asset.isNative()) {
                    spendAmount = spendAmount.plus(output.amount);
                }
                outputs.push(output);
            }
            else if (op.type === 'changeTrust') {
                if (op.line.getAssetType() === 'liquidity_pool_shares') {
                    throw new Error('Invalid asset type');
                }
                const asset = op.line;
                operations.push({
                    type: op.type,
                    coin: this.getTokenNameFromStellarAsset(asset),
                    asset,
                    limit: this.bigUnitsToBaseUnits(op.limit),
                });
            }
        });
        const outputAmount = spendAmount.toFixed(0);
        const outputAmounts = _.mapValues(spendAmounts, (amount) => amount.toFixed(0));
        const fee = {
            fee: new bignumber_js_1.BigNumber(tx.fee).toFixed(0),
            feeRate: null,
            size: null,
        };
        return {
            displayOrder: [
                'id',
                'outputAmount',
                'outputAmounts',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'operations',
            ],
            id,
            outputs,
            outputAmount,
            outputAmounts,
            changeOutputs: [],
            changeAmount: '0',
            memo,
            fee,
            operations,
        };
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyTrustlineTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.trustlines, (trustline) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                const noLimit = _.isUndefined(trustline.limit);
                const addTrustlineWithDefaultLimit = trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit;
                const removeTrustline = trustline.action === 'remove' && opLimitBaseUnits === '0';
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     */
    async verifyTransaction(options) {
        // TODO BG-5600 Add parseTransaction / improve verification
        const { txParams, txPrebuild, wallet, verification = {} } = options;
        const disableNetworking = !!verification.disableNetworking;
        if (!txPrebuild.txBase64) {
            throw new Error('missing required tx prebuild property txBase64');
        }
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        if (txParams.recipients && txParams.recipients.length > 1) {
            throw new Error('cannot specify more than 1 recipient');
        }
        // Stellar txs are made up of operations. We only care about Create Account and Payment for sending funds.
        const outputOperations = _.filter(tx.operations, (operation) => operation.type === 'createAccount' || operation.type === 'payment');
        if (txParams.type === 'trustline') {
            this.verifyTrustlineTxOperations(tx.operations, txParams);
        }
        else {
            if (_.isEmpty(outputOperations)) {
                throw new Error('transaction prebuild does not have any operations');
            }
            _.forEach(txParams.recipients, (expectedOutput, index) => {
                const expectedOutputAddressDetails = this.getAddressDetails(expectedOutput.address);
                // for muxed accounts, the destination will be the baseAddress
                const expectedOutputAddress = expectedOutputAddressDetails.baseAddress;
                const output = outputOperations[index];
                if (output.destination !== expectedOutputAddress) {
                    throw new Error('transaction prebuild does not match expected recipient');
                }
                const expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                const outputAmountString = output.type === 'createAccount' ? output.startingBalance : output.amount;
                const outputAmount = new bignumber_js_1.BigNumber(this.bigUnitsToBaseUnits(outputAmountString));
                if (!outputAmount.eq(expectedOutputAmount)) {
                    throw new Error('transaction prebuild does not match expected amount');
                }
            });
        }
        // Verify the user signature, if the tx is half-signed
        if (!_.isEmpty(tx.signatures)) {
            const userSignature = tx.signatures[0].signature();
            // obtain the keychains and key signatures
            let keychains = verification.keychains;
            if (!keychains && disableNetworking) {
                throw new Error('cannot fetch keychains without networking');
            }
            else if (!keychains) {
                keychains = await promise_utils_1.promiseProps({
                    user: this.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER] }),
                    backup: this.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP] }),
                });
            }
            if (!keychains || !keychains.backup || !keychains.user) {
                throw new Error('keychains are required, but could not be fetched');
            }
            if (this.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signed with wrong key');
            }
            if (!this.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signature invalid');
            }
        }
        return true;
    }
    /**
     * Derive a hardened child public key from a master key seed using an additional seed for randomness.
     *
     * Due to technical differences between keypairs on the ed25519 curve and the secp256k1 curve,
     * only hardened private key derivation is supported.
     *
     * @param key seed for the master key. Note: Not the public key or encoded private key. This is the raw seed.
     * @param entropySeed random seed which is hashed to generate the derivation path
     */
    deriveKeyWithSeed({ key, seed }) {
        const derivationPathInput = utxolib.crypto.hash256(Buffer.from(seed, 'utf8')).toString('hex');
        const derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/' + derivationPathParts.map((part) => `${part}'`).join('/');
        const derivedKey = account_lib_1.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        const keypair = stellar.Keypair.fromRawEd25519Seed(derivedKey);
        return {
            key: keypair.publicKey(),
            derivationPath,
        };
    }
    async parseTransaction(params) {
        return {};
    }
}
exports.Xlm = Xlm;
Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
// max int64 number supported by the network (2^63)-1
// See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
Xlm.maxTrustlineLimit = '9223372036854775807';
/**
 * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
 * correct one to use, so we have to be very explicit as to which one we want.
 * @param tx transaction to convert
 */
Xlm.txToString = (tx) => tx.toEnvelope().toXDR('base64');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILDRCQUE0QjtBQUM1QiwyQ0FBMkM7QUFDM0Msb0RBQXVEO0FBQ3ZELDJDQUEyQztBQUMzQywyQkFBMkI7QUFDM0Isc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QywrQ0FBeUM7QUFFekMsNENBQTBDO0FBRTFDLDhDQUF5QztBQUN6Qyx5Q0FLc0I7QUFDdEIsMENBYXFCO0FBQ3JCLG9EQUFnRDtBQUVoRCw0Q0FBZ0Q7QUFDaEQsbURBQXdFO0FBNEd4RSxNQUFhLEdBQUksU0FBUSxtQkFBUTtJQVEvQixZQUFZLEtBQVk7UUFDdEIsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxxQ0FBcUM7SUFDdEUsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBWTtRQUNoQyxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFUyxpQkFBaUI7UUFDekIsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxhQUFhO1FBQ1gsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRO1FBQ04sT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTO1FBQ1AsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCxXQUFXO1FBQ1QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsc0JBQXNCO1FBQ3BCLE9BQU8saUJBQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFD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K0I7UUFDcEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDOztBQXA3Qkgsa0JBcTdCQztBQW43QndCLHlCQUFxQixHQUFHLEdBQUcsQ0FBQyxDQUFDLHNDQUFzQztBQUMxRSxhQUFTLEdBQVcsb0JBQW9CLENBQUMsQ0FBQyxvREFBb0Q7QUFDOUcscURBQXFEO0FBQ3JELDBHQUEwRztBQUMxRixxQkFBaUIsR0FBVyxxQkFBcUIsQ0FBQztBQW82QmxFOzs7O0dBSUc7QUFDYyxjQUFVLEdBQUcsQ0FBQyxFQUF1QixFQUFVLEVBQUUsQ0FDL0QsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQStCLENBQUMsUUFBUSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBFZDI1NTE5S2V5RGVyaXZlciB9IGZyb20gJ0BiaXRnby9hY2NvdW50LWxpYic7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgKiBhcyBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IEtleUluZGljZXMgfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuXG5pbXBvcnQgeyBjb21tb24gfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHtcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZE1lbW9JZEVycm9yLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBTdGVsbGFyRmVkZXJhdGlvblVzZXJOb3RGb3VuZEVycm9yLFxufSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50IGFzIEJhc2VUcmFuc2FjdGlvbk91dHB1dCxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBhcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgS2V5UGFpcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvblBhcmFtcyBhcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMsXG4gIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBwcm9taXNlUHJvcHMgfSBmcm9tICcuLi9wcm9taXNlLXV0aWxzJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4uL3dhbGxldCc7XG5pbXBvcnQgeyB0b0JpdGdvUmVxdWVzdCB9IGZyb20gJ0BiaXRnby9zZGstYXBpJztcbmltcG9ydCB7IGNoZWNrS3JzUHJvdmlkZXIsIGdldFN0ZWxsYXJLZXlzIH0gZnJvbSAnLi4vcmVjb3ZlcnkvaW5pdGlhdGUnO1xuXG4vKipcbiAqIFhMTSBhY2NvdW50cyBzdXBwb3J0IHZpcnR1YWwgKG11eGVkKSBhZGRyZXNzZXNcbiAqIEEgYmFzZSBhZGRyZXNzIHN0YXJ0cyB3aXRoIFwiR1wiIGFuZCBpcyB0aWVkIHRvIHRoZSB1bmRlcmx5aW5nIFwicmVhbFwiIGFjY291bnRcbiAqIEEgbXV4ZWQgYWRkcmVzcyBzdGFydHMgd2l0aCBcIk1cIiBhbmQgY29tYmluZXMgdGhlIGJhc2UgYWRkcmVzcyB3aXRoIGEgNjQtYml0IGludGVnZXIgSUQgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICogYW4gYWx0ZXJuYXRpdmUgdG8gbWVtbyBpZHMuXG4gKi9cbmludGVyZmFjZSBBZGRyZXNzRGV0YWlscyB7XG4gIGJhc2VBZGRyZXNzOiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIG1lbW9JZD86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIE1lbW8ge1xuICB0eXBlOiBzdGVsbGFyLk1lbW9UeXBlO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICByb290QWRkcmVzcz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICB0eDogc3RyaW5nO1xuICByZWNvdmVyeUFtb3VudDogbnVtYmVyO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBCdWlsZE9wdGlvbnMge1xuICB3YWxsZXQ/OiBXYWxsZXQ7XG4gIHJlY2lwaWVudHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+W107XG4gIHR5cGU/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICB0eEJhc2U2NDogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB7XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk1lbW8ge1xuICB2YWx1ZT86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGxpbWl0Pzogc3RyaW5nO1xuICBhc3NldD86IHN0ZWxsYXIuQXNzZXQ7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk91dHB1dCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbk91dHB1dCB7XG4gIGNvaW46IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIG1lbW86IFRyYW5zYWN0aW9uTWVtbztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRydXN0bGluZU9wdGlvbnMge1xuICB0b2tlbjogc3RyaW5nO1xuICBhY3Rpb246IHN0cmluZztcbiAgbGltaXQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblBhcmFtcyBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyB7XG4gIHRydXN0bGluZXM/OiBUcnVzdGxpbmVPcHRpb25zW107XG59XG5cbmludGVyZmFjZSBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xufVxuXG5leHBvcnQgY2xhc3MgWGxtIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgcmVhZG9ubHkgaG9tZURvbWFpbjogc3RyaW5nO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHRva2VuUGF0dGVyblNlcGFyYXRvciA9ICctJzsgLy8gc2VwYXJhdG9yIGZvciB0b2tlbiBjb2RlIGFuZCBpc3N1ZXJcbiAgc3RhdGljIHJlYWRvbmx5IG1heE1lbW9JZDogc3RyaW5nID0gJzB4RkZGRkZGRkZGRkZGRkZGRic7IC8vIG1heCB1bnNpZ25lZCA2NC1iaXQgbnVtYmVyID0gMTg0NDY3NDQwNzM3MDk1NTE2MTVcbiAgLy8gbWF4IGludDY0IG51bWJlciBzdXBwb3J0ZWQgYnkgdGhlIG5ldHdvcmsgKDJeNjMpLTFcbiAgLy8gU2VlOiBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9hc3NldHMuaHRtbCNhbW91bnQtcHJlY2lzaW9uLWFuZC1yZXByZXNlbnRhdGlvblxuICBzdGF0aWMgcmVhZG9ubHkgbWF4VHJ1c3RsaW5lTGltaXQ6IHN0cmluZyA9ICc5MjIzMzcyMDM2ODU0Nzc1ODA3JztcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28pIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gICAgdGhpcy5ob21lRG9tYWluID0gJ2JpdGdvLmNvbSc7IC8vIHVzZWQgZm9yIHJldmVyc2UgZmVkZXJhdGlvbiBsb29rdXBcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBYbG0oYml0Z28pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFN0ZWxsYXJOZXR3b3JrKCk6IHN0ZWxsYXIuTmV0d29ya3Mge1xuICAgIHJldHVybiBzdGVsbGFyLk5ldHdvcmtzLlBVQkxJQztcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gMWU3O1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hsbSc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGNvaW4gZmFtaWx5XG4gICAqL1xuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hsbSc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGlzIGNvaW5cbiAgICovXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdTdGVsbGFyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgYXQgd2hpY2ggdGhlIHN0ZWxsYXIgZmVkZXJhdGlvbiBzZXJ2ZXIgY2FuIGJlIHJlYWNoZWRcbiAgICovXG4gIGdldEZlZGVyYXRpb25TZXJ2ZXJVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgYXQgd2hpY2ggaG9yaXpvbiBjYW4gYmUgcmVhY2hlZFxuICAgKi9cbiAgZ2V0SG9yaXpvblVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnaHR0cHM6Ly9ob3Jpem9uLnN0ZWxsYXIub3JnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBrZXkgcGFpciBvbiB0aGUgZWQyNTUxOSBjdXJ2ZVxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyBnZW5lcmF0ZWQgcHViIGFuZCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkOiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBwYWlyID0gc2VlZCA/IHN0ZWxsYXIuS2V5cGFpci5mcm9tUmF3RWQyNTUxOVNlZWQoc2VlZCkgOiBzdGVsbGFyLktleXBhaXIucmFuZG9tKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogcGFpci5wdWJsaWNLZXkoKSxcbiAgICAgIHBydjogcGFpci5zZWNyZXQoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZWNvZGVkIGVkMjU1MTkgcHVibGljIGtleSBmcm9tIHJhdyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgUmF3IHB1YmxpYyBrZXlcbiAgICogQHJldHVybnMgRW5jb2RlZCBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRQdWJGcm9tUmF3KHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuZW5jb2RlRWQyNTUxOVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRlY29kZWQgZWQyNTUxOSBwcml2YXRlIGtleSBmcm9tIHJhdyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgUmF3IHByaXZhdGUga2V5XG4gICAqIEByZXR1cm5zIEVuY29kZWQgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGdldFBydkZyb21SYXcocHJ2OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5lbmNvZGVFZDI1NTE5U2VjcmV0U2VlZChCdWZmZXIuZnJvbShwcnYsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHJpdmF0ZSBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVNlY3JldFNlZWQocHJ2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSBtZW1vIGlkIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIG1lbW8gaWQgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRNZW1vSWQobWVtb0lkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgbWVtb0lkTnVtYmVyO1xuICAgIHRyeSB7XG4gICAgICBzdGVsbGFyLk1lbW8uaWQobWVtb0lkKTsgLy8gdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgbWVtbyBpZFxuICAgICAgbWVtb0lkTnVtYmVyID0gbmV3IEJpZ051bWJlcihtZW1vSWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb0lkTnVtYmVyLmd0ZSgwKSAmJiBtZW1vSWROdW1iZXIubHQoWGxtLm1heE1lbW9JZCk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGVzIHdoZXRoZXIgYSBtZW1vIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgbWVtb1xuICAgKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSBtZW1vXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdmFsdWUgYW5kIHR5cGUgYXJlIGEgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRNZW1vKHsgdmFsdWUsIHR5cGUgfTogTWVtbyk6IGJvb2xlYW4ge1xuICAgIGlmICghdmFsdWUgfHwgIXR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkIGZvciB0aGUgdHlwZVxuICAgICAgLy8gdmFsaWQgdHlwZXMgYXJlOiAnaWQnLCAndGV4dCcsICdoYXNoJywgJ3JldHVybidcbiAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy90cmFuc2FjdGlvbnMuaHRtbCNtZW1vXG4gICAgICBzdGVsbGFyLk1lbW9bdHlwZV0odmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHN0ZWxsYXIuTXV4ZWRBY2NvdW50IGZyb20gTSBhZGRyZXNzXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLnN0ZWxsYXIub3JnL2RvY3MvZ2xvc3NhcnkvbXV4ZWQtYWNjb3VudHNcbiAgICovXG4gIGdldE11eGVkQWNjb3VudChhZGRyZXNzOiBzdHJpbmcpOiBzdGVsbGFyLk11eGVkQWNjb3VudCB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdGVsbGFyLk11eGVkQWNjb3VudC5mcm9tQWRkcmVzcyhhZGRyZXNzLCAnMCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBtdXhlZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIG11eGVkIGFkZHJlc3MgaXMgdmFsaWRcbiAgICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuc3RlbGxhci5vcmcvZG9jcy9nbG9zc2FyeS9tdXhlZC1hY2NvdW50c1xuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzVmFsaWRNdXhlZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGFkZHJlc3MpIHx8ICFhZGRyZXNzLnN0YXJ0c1dpdGgoJ00nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBtdXhlZCBhY2NvdW50IGlzIHZhbGlkIG9yIHRocm93XG4gICAgICByZXR1cm4gISFzdGVsbGFyLk11eGVkQWNjb3VudC5mcm9tQWRkcmVzcyhhZGRyZXNzLCAnMCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWluaW11bSBiYWxhbmNlIG9mIGEgMi1vZi0zIG11bHRpc2lnIHdhbGxldFxuICAgKiBAcmV0dXJucyBtaW5pbXVtIGJhbGFuY2UgaW4gc3Ryb29wc1xuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bVJlc2VydmUoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgc3RlbGxhci5TZXJ2ZXIodGhpcy5nZXRIb3Jpem9uVXJsKCkpO1xuXG4gICAgY29uc3QgaG9yaXpvbkxlZGdlckluZm8gPSBhd2FpdCBzZXJ2ZXIubGVkZ2VycygpLm9yZGVyKCdkZXNjJykubGltaXQoMSkuY2FsbCgpO1xuXG4gICAgaWYgKCFob3Jpem9uTGVkZ2VySW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gY29ubmVjdCB0byBIb3Jpem9uIGZvciByZXNlcnZlIHJlcXVpcmVtZW50IGRhdGEnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlUmVzZXJ2ZSA9IGhvcml6b25MZWRnZXJJbmZvLnJlY29yZHNbMF0uYmFzZV9yZXNlcnZlX2luX3N0cm9vcHM7XG5cbiAgICAvLyAyLW9mLTMgd2FsbGV0cyBoYXZlIGEgbWluaW11bSByZXNlcnZlIG9mIDV4IHRoZSBiYXNlIHJlc2VydmVcbiAgICByZXR1cm4gNSAqIGJhc2VSZXNlcnZlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zYWN0aW9uIGZlZSBmb3IgZWFjaCBvcGVyYXRpb25cbiAgICogQHJldHVybnMgdHJhbnNhY3Rpb24gZmVlIGluIHN0cm9vcHNcbiAgICovXG4gIGFzeW5jIGdldEJhc2VUcmFuc2FjdGlvbkZlZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlcnZlciA9IG5ldyBzdGVsbGFyLlNlcnZlcih0aGlzLmdldEhvcml6b25VcmwoKSk7XG5cbiAgICBjb25zdCBob3Jpem9uTGVkZ2VySW5mbyA9IGF3YWl0IHNlcnZlci5sZWRnZXJzKCkub3JkZXIoJ2Rlc2MnKS5saW1pdCgxKS5jYWxsKCk7XG5cbiAgICBpZiAoIWhvcml6b25MZWRnZXJJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBjb25uZWN0IHRvIEhvcml6b24gZm9yIHJlc2VydmUgcmVxdWlyZW1lbnQgZGF0YScpO1xuICAgIH1cblxuICAgIHJldHVybiBob3Jpem9uTGVkZ2VySW5mby5yZWNvcmRzWzBdLmJhc2VfZmVlX2luX3N0cm9vcHM7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhZGRyZXNzIGludG8gYWRkcmVzcyBhbmQgbWVtbyBpZFxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB0aGUgYWRkcmVzc1xuICAgKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqL1xuICBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgaWYgKGFkZHJlc3Muc3RhcnRzV2l0aCgnTScpKSB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkTXV4ZWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIGNvbnN0IG11eGVkQWNjb3VudCA9IHRoaXMuZ2V0TXV4ZWRBY2NvdW50KGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJhc2VBZGRyZXNzOiBtdXhlZEFjY291bnQuYmFzZUFjY291bnQoKS5hY2NvdW50SWQoKSxcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGlkOiBtdXhlZEFjY291bnQuaWQoKSxcbiAgICAgICAgICBtZW1vSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIG11eGVkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lIHx8ICcnO1xuICAgIGlmICghZGVzdGluYXRpb25BZGRyZXNzIHx8ICFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICAvLyBhZGRyZXNzIGRvZXNuJ3QgaGF2ZSBhIG1lbW8gaWRcbiAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lID09PSBhZGRyZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlQWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVtb0lkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5RGV0YWlscy5tZW1vSWQpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMsIHRoZSBxdWVyeSBkZXRhaWxzIG5lZWQgdG8gY29udGFpbiB0aGUgbWVtbyBpZCBwcm9wZXJ0eVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYG1lbW9JZCBtYXkgb25seSBiZSBnaXZlbiBhdCBtb3N0IG9uY2UsIGJ1dCBmb3VuZCAke3F1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RofSBpbnN0YW5jZXMgaW4gYWRkcmVzcyAke2FkZHJlc3N9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSAmJiBxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aCAhPT0gMSkge1xuICAgICAgLy8gdmFsaWQgYWRkcmVzc2VzIGNhbiBvbmx5IGNvbnRhaW4gb25lIG1lbW8gaWRcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3MgJyR7YWRkcmVzc30nLCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUgbWVtb0lkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgW21lbW9JZF0gPSBfLmNhc3RBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSB8fCB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZW1vSWRFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAnJHthZGRyZXNzfScsIG1lbW9JZCBpcyBub3QgdmFsaWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgIGFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICBtZW1vSWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbmQgcmV0dXJuIGFkZHJlc3Mgd2l0aCBhcHBlbmRlZCBtZW1vIGlkIG9yIG11eGVkIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgYWRkcmVzc1xuICAgKiBAcGFyYW0gbWVtb0lkIG1lbW8gaWRcbiAgICogQHJldHVybnMgYWRkcmVzcyB3aXRoIG1lbW8gaWRcbiAgICovXG4gIG5vcm1hbGl6ZUFkZHJlc3MoeyBhZGRyZXNzLCBtZW1vSWQgfTogQWRkcmVzc0RldGFpbHMpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmlzVmFsaWRNdXhlZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICBpZiAoIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWRkcmVzcyBkZXRhaWxzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGlmIChtZW1vSWQgJiYgdGhpcy5pc1ZhbGlkTWVtb0lkKG1lbW9JZCkpIHtcbiAgICAgIHJldHVybiBgJHthZGRyZXNzfT9tZW1vSWQ9JHttZW1vSWR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWRkcmVzcyA9PT0gdGhpcy5ub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFN0ZWxsYXIgQXNzZXQgaW4gY29pbjp0b2tlbiBmb3JtIChpLmUuICh0KXhsbTo8Y29kZT4tPGlzc3Vlcj4pXG4gICAqIElmIHRoZSBhc3NldCBpcyBYTE0sIHJldHVybiB0aGUgY2hhaW5cbiAgICogQHBhcmFtIHtzdGVsbGFyLkFzc2V0fSBhc3NldCAtIGluc3RhbmNlIG9mIFN0ZWxsYXIgQXNzZXRcbiAgICovXG4gIGdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQ6IHN0ZWxsYXIuQXNzZXQpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvZGUgPSBhc3NldC5nZXRDb2RlKCk7XG4gICAgY29uc3QgaXNzdWVyID0gYXNzZXQuZ2V0SXNzdWVyKCk7XG4gICAgaWYgKGFzc2V0LmlzTmF0aXZlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmdldENoYWluKCl9JHtCYXNlQ29pbi5jb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yfSR7Y29kZX0ke1hsbS50b2tlblBhdHRlcm5TZXBhcmF0b3J9JHtpc3N1ZXJ9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB3aGV0aGVyIGEgc3RlbGxhciB1c2VybmFtZSBoYXMgdmFsaWQgZm9ybWF0XG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIGNsaWVudCB3aGVuIGEgc3RlbGxhciBhZGRyZXNzIGlzIGJlaW5nIGFkZGVkIHRvIGEgd2FsbGV0XG4gICAqIEV4YW1wbGUgb2YgYSBjb21tb24gc3RlbGxhciB1c2VybmFtZTogZm9vQGJhci5iYXpcbiAgICogVGhlIGFib3ZlIGV4YW1wbGUgd291bGQgcmVzdWx0IGluIHRoZSBTdGVsbGFyIGFkZHJlc3M6IGZvb0BiYXIuYmF6KmJpdGdvLmNvbVxuICAgKlxuICAgKiBAcGFyYW0gdXNlcm5hbWUgLSBzdGVsbGFyIHVzZXJuYW1lXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBzdGVsbGFyIHVzZXJuYW1lIGlzIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkU3RlbGxhclVzZXJuYW1lKHVzZXJuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL15bYS16MC05XFwtXy4rQF0rJC8udGVzdCh1c2VybmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZlZGVyYXRpb25TZXJ2ZXIgZm9yIEJpdEdvIGxvb2t1cHNcbiAgICpcbiAgICogQHJldHVybnMgaW5zdGFuY2Ugb2YgQml0R28gRmVkZXJhdGlvbiBTZXJ2ZXJcbiAgICovXG4gIGdldEJpdEdvRmVkZXJhdGlvblNlcnZlcigpOiBzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIge1xuICAgIC8vIElkZW50aWZ5IHRoZSBVUkkgc2NoZW1lIGluIGNhc2Ugd2UgbmVlZCB0byBhbGxvdyBjb25uZWN0aW5nIHRvIEhUVFAgc2VydmVyLlxuICAgIGNvbnN0IGlzTm9uU2VjdXJlRW52ID0gIV8uc3RhcnRzV2l0aChjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZW52XS51cmksICdodHRwcycpO1xuICAgIGNvbnN0IGZlZGVyYXRpb25TZXJ2ZXJPcHRpb25zID0geyBhbGxvd0h0dHA6IGlzTm9uU2VjdXJlRW52IH07XG4gICAgcmV0dXJuIG5ldyBzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIodGhpcy5nZXRGZWRlcmF0aW9uU2VydmVyVXJsKCksICdiaXRnby5jb20nLCBmZWRlcmF0aW9uU2VydmVyT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBmZWRlcmF0aW9uIGxvb2t1cHNcbiAgICogT3VyIGZlZGVyYXRpb24gc2VydmVyIGhhbmRsZXMgbG9va3VwcyBmb3IgYml0Z28gYXMgd2VsbCBhcyBmb3Igb3RoZXIgZmVkZXJhdGlvbiBkb21haW5zXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYWRkcmVzc10gLSBhZGRyZXNzIHRvIGxvb2sgdXBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthY2NvdW50SWRdIC0gYWNjb3VudCBpZCB0byBsb29rIHVwXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGZlZGVyYXRpb25Mb29rdXAoe1xuICAgIGFkZHJlc3MsXG4gICAgYWNjb3VudElkLFxuICB9OiB7XG4gICAgYWRkcmVzcz86IHN0cmluZztcbiAgICBhY2NvdW50SWQ/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmVkZXJhdGlvblNlcnZlciA9IHRoaXMuZ2V0Qml0R29GZWRlcmF0aW9uU2VydmVyKCk7XG4gICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZmVkZXJhdGlvblNlcnZlci5yZXNvbHZlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSBpZiAoYWNjb3VudElkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmZWRlcmF0aW9uU2VydmVyLnJlc29sdmVBY2NvdW50SWQoYWNjb3VudElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCAtIG11c3QgcHJvdmlkZSBTdGVsbGFyIGFkZHJlc3Mgb3IgYWNjb3VudCBpZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gXy5nZXQoZSwgJ3Jlc3BvbnNlLmRhdGEuZGV0YWlsJyk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0ZWxsYXJGZWRlcmF0aW9uVXNlck5vdEZvdW5kRXJyb3IoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byByZXNvbHZlIGEgc3RlbGxhciBhZGRyZXNzIGludG8gYSBzdGVsbGFyIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBzdGVsbGFyIGFkZHJlc3MgdG8gbG9vayBmb3JcbiAgICovXG4gIGFzeW5jIGZlZGVyYXRpb25Mb29rdXBCeU5hbWUoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPiB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU3RlbGxhciBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmVkZXJhdGlvbkxvb2t1cCh7IGFkZHJlc3MgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byByZXNvbHZlIGFuIGFjY291bnQgaWQgaW50byBhIHN0ZWxsYXIgYWNjb3VudFxuICAgKiBPbmx5IHdvcmtzIGZvciBhY2NvdW50cyB0aGF0IGNhbiBiZSByZXNvbHZlZCBieSBvdXIgZmVkZXJhdGlvbiBzZXJ2ZXJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCAtIHN0ZWxsYXIgYWNjb3VudCBpZFxuICAgKi9cbiAgYXN5bmMgZmVkZXJhdGlvbkxvb2t1cEJ5QWNjb3VudElkKGFjY291bnRJZDogc3RyaW5nKTogUHJvbWlzZTxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPiB7XG4gICAgaWYgKCFhY2NvdW50SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTdGVsbGFyIGFjY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmVkZXJhdGlvbkxvb2t1cCh7IGFjY291bnRJZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGlzIGEgdmFsaWQgWExNIGFkZHJlc3MsIGFuZCB0aGVuIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZSByb290IGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IHRoZSBhZGRyZXNzIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0gcm9vdEFkZHJlc3Mge1N0cmluZ30gdGhlIHdhbGxldCdzIHJvb3QgYWRkcmVzc1xuICAgKi9cbiAgaXNXYWxsZXRBZGRyZXNzKHsgYWRkcmVzcywgcm9vdEFkZHJlc3MgfTogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgY29uc3Qgcm9vdEFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhyb290QWRkcmVzcyk7XG4gICAgaWYgKGFkZHJlc3NEZXRhaWxzLmJhc2VBZGRyZXNzICE9PSByb290QWRkcmVzc0RldGFpbHMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoXG4gICAgICAgIGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogJHthZGRyZXNzRGV0YWlscy5iYXNlQWRkcmVzc30gdnMgJHtyb290QWRkcmVzc0RldGFpbHMuYWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBleHRyYSBwYXJhbWV0ZXJzIGZvciBwcmVidWlsZGluZyBhIHR4XG4gICAqIFNldCBlbXB0eSByZWNpcGllbnRzIGFycmF5IGluIHRydXN0bGluZSB0eHNcbiAgICovXG4gIGFzeW5jIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zKTogUHJvbWlzZTxCdWlsZE9wdGlvbnM+IHtcbiAgICBjb25zdCBwYXJhbXM6IHsgcmVjaXBpZW50cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXSB9ID0ge307XG4gICAgaWYgKGJ1aWxkUGFyYW1zLnR5cGUgPT09ICd0cnVzdGxpbmUnKSB7XG4gICAgICBwYXJhbXMucmVjaXBpZW50cyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogbmV2ZXIge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVwcmVjYXRlZCBtZXRob2QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSBTdGVsbGFyIHByaXZhdGUga2V5XG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSBTdGVsbGFyIHByaXZhdGUga2V5LCBvciBwdWJsaWMga2V5IGlmIHRoZSBwcml2YXRlIGtleSBpcyBoZWxkIGJ5IGEgS1JTIHByb3ZpZGVyXG4gICAqIC0gd2FsbGV0UGFzc3BocmFzZTogbmVjZXNzYXJ5IGlmIG9uZSBvZiB0aGUgcHJpdmF0ZSBrZXlzIGlzIGVuY3J5cHRlZFxuICAgKiAtIHJvb3RBZGRyZXNzOiBiYXNlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byByZWNvdmVyIGZ1bmRzIGZyb21cbiAgICogLSBrcnNQcm92aWRlcjogbmVjZXNzYXJ5IGlmIGJhY2t1cCBrZXkgaXMgaGVsZCBieSBLUlNcbiAgICogLSByZWNvdmVyeURlc3RpbmF0aW9uOiB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKi9cbiAgYXN5bmMgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlcnlUcmFuc2FjdGlvbj4ge1xuICAgIC8vIFN0ZWxsYXIncyBFZDI1NTE5IHB1YmxpYyBrZXlzIHN0YXJ0IHdpdGggYSBHLCB3aGlsZSBwcml2YXRlIGtleXMgc3RhcnQgd2l0aCBhbiBTXG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgnRycpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgnRycpO1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIGNoZWNrS3JzUHJvdmlkZXIodGhpcywgcGFyYW1zLmtyc1Byb3ZpZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgIH1cblxuICAgIGNvbnN0IFt1c2VyS2V5LCBiYWNrdXBLZXldID0gZ2V0U3RlbGxhcktleXModGhpcy5iaXRnbywgcGFyYW1zKTtcblxuICAgIGlmICghcGFyYW1zLnJvb3RBZGRyZXNzIHx8ICFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwYXJhbXMucm9vdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2FsbGV0IGFkZHJlc3M6ICR7cGFyYW1zLnJvb3RBZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnREYXRhVXJsID0gYCR7dGhpcy5nZXRIb3Jpem9uVXJsKCl9L2FjY291bnRzLyR7cGFyYW1zLnJvb3RBZGRyZXNzfWA7XG4gICAgY29uc3QgZGVzdGluYXRpb25VcmwgPSBgJHt0aGlzLmdldEhvcml6b25VcmwoKX0vYWNjb3VudHMvJHtwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbn1gO1xuXG4gICAgbGV0IGFjY291bnREYXRhO1xuICAgIHRyeSB7XG4gICAgICBhY2NvdW50RGF0YSA9IGF3YWl0IHRvQml0Z29SZXF1ZXN0KHJlcXVlc3QuZ2V0KGFjY291bnREYXRhVXJsKSkucmVzdWx0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVhY2ggdGhlIFN0ZWxsYXIgbmV0d29yayB2aWEgSG9yaXpvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgaXMgZW1wdHkgb3Igbm90XG4gICAgbGV0IHVuZnVuZGVkRGVzdGluYXRpb24gPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmVxdWVzdC5nZXQoZGVzdGluYXRpb25VcmwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIC8vIElmIHRoZSBkZXN0aW5hdGlvbiBhY2NvdW50IGRvZXMgbm90IHlldCBleGlzdCwgaG9yaXpvbiByZXNwb25kcyB3aXRoIDQwNFxuICAgICAgICB1bmZ1bmRlZERlc3RpbmF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFjY291bnREYXRhLnNlcXVlbmNlIHx8ICFhY2NvdW50RGF0YS5iYWxhbmNlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3Jpem9uIHNlcnZlciBlcnJvciAtIHVuYWJsZSB0byByZXRyaWV2ZSBzZXF1ZW5jZSBJRCBvciBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY2NvdW50ID0gbmV3IHN0ZWxsYXIuQWNjb3VudChwYXJhbXMucm9vdEFkZHJlc3MsIGFjY291bnREYXRhLnNlcXVlbmNlKTtcblxuICAgIC8vIFN0ZWxsYXIgc3VwcG9ydHMgbXVsdGlwbGUgYXNzZXRzIG9uIGNoYWluLCB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIGJhbGFuY2VzIGVudHJ5IHdob3NlIHR5cGUgaXMgXCJuYXRpdmVcIiAoWExNKVxuICAgIGNvbnN0IG5hdGl2ZUJhbGFuY2VJbmZvID0gYWNjb3VudERhdGEuYmFsYW5jZXMuZmluZCgoYXNzZXRCYWxhbmNlKSA9PiBhc3NldEJhbGFuY2VbJ2Fzc2V0X3R5cGUnXSA9PT0gJ25hdGl2ZScpO1xuXG4gICAgaWYgKCFuYXRpdmVCYWxhbmNlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCB3YWxsZXQgaGFzIGEgYmFsYW5jZSBvZiAwIFhMTSwgcmVjb3ZlcnkgYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHdhbGxldEJhbGFuY2UgPSBOdW1iZXIodGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG5hdGl2ZUJhbGFuY2VJbmZvLmJhbGFuY2UpKTtcbiAgICBjb25zdCBtaW5pbXVtUmVzZXJ2ZSA9IGF3YWl0IHRoaXMuZ2V0TWluaW11bVJlc2VydmUoKTtcbiAgICBjb25zdCBiYXNlVHhGZWUgPSBhd2FpdCB0aGlzLmdldEJhc2VUcmFuc2FjdGlvbkZlZSgpO1xuICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gd2FsbGV0QmFsYW5jZSAtIG1pbmltdW1SZXNlcnZlIC0gYmFzZVR4RmVlO1xuICAgIGNvbnN0IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50ID0gdGhpcy5iYXNlVW5pdHNUb0JpZ1VuaXRzKHJlY292ZXJ5QW1vdW50KS50b1N0cmluZygpO1xuXG4gICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb25CdWlsZGVyKGFjY291bnQsIHtcbiAgICAgIGZlZTogYmFzZVR4RmVlLnRvRml4ZWQoMCksXG4gICAgICBuZXR3b3JrUGFzc3BocmFzZTogdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpLFxuICAgIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHVuZnVuZGVkRGVzdGluYXRpb25cbiAgICAgID8gLy8gSW4gdGhpcyBjYXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgYWNjb3VudFxuICAgICAgICBzdGVsbGFyLk9wZXJhdGlvbi5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBkZXN0aW5hdGlvbjogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgc3RhcnRpbmdCYWxhbmNlOiBmb3JtYXR0ZWRSZWNvdmVyeUFtb3VudCxcbiAgICAgICAgfSlcbiAgICAgIDogLy8gT3RoZXJ3aXNlIGlmIHRoZSBhY2NvdW50IGFscmVhZHkgZXhpc3RzLCB3ZSBkbyBhIG5vcm1hbCBzZW5kXG4gICAgICAgIHN0ZWxsYXIuT3BlcmF0aW9uLnBheW1lbnQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICBhc3NldDogc3RlbGxhci5Bc3NldC5uYXRpdmUoKSxcbiAgICAgICAgICBhbW91bnQ6IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50LFxuICAgICAgICB9KTtcbiAgICBjb25zdCB0eCA9IHR4QnVpbGRlci5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKS5zZXRUaW1lb3V0KHN0ZWxsYXIuVGltZW91dEluZmluaXRlKS5idWlsZCgpO1xuXG4gICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIHR4LnNpZ24odXNlcktleSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0tyc1JlY292ZXJ5ICYmICFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIHR4LnNpZ24oYmFja3VwS2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbjogUmVjb3ZlcnlUcmFuc2FjdGlvbiA9IHtcbiAgICAgIHR4OiBYbG0udHhUb1N0cmluZyh0eCksXG4gICAgICByZWNvdmVyeUFtb3VudCxcbiAgICB9O1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7XG4gICAgICB0cmFuc2FjdGlvbi5jb2luID0gdGhpcy5nZXRDaGFpbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8SGFsZlNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgeyB0eFByZWJ1aWxkLCBwcnYgfSA9IHBhcmFtcztcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldChwcnYpO1xuICAgIGNvbnN0IHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhQcmVidWlsZC50eEJhc2U2NCwgdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpKTtcbiAgICB0eC5zaWduKGtleVBhaXIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgdHhCYXNlNjQ6IFhsbS50eFRvU3RyaW5nKHR4KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgd2FsbGV0UGFyYW1zIHdpdGggZXh0cmEgcGFyYW1zIHJlcXVpcmVkIGZvciBnZW5lcmF0aW5nIGFuIFhMTSB3YWxsZXRcbiAgICpcbiAgICogU3RlbGxhciB3YWxsZXRzIGhhdmUgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZW0uIFR3byBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBwbGF0Zm9ybSwgYW5kIHRoZSBsYXN0IGlzIGdlbmVyYXRlZCBieSB0aGUgdXNlci5cbiAgICogSW5pdGlhbGx5LCB3ZSBuZWVkIGEgcm9vdCBwcnYgdG8gZ2VuZXJhdGUgdGhlIGFjY291bnQsIHdoaWNoIG11c3QgYmUgZGlzdGluY3QgZnJvbSBhbGwgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZSB3YWxsZXQuXG4gICAqIElmIGEgcm9vdCBwcnYgaXMgbm90IHByb3ZpZGVkLCBhIHJhbmRvbSBvbmUgaXMgZ2VuZXJhdGVkLlxuICAgKi9cbiAgYXN5bmMgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KFxuICAgIHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9uc1xuICApOiBQcm9taXNlPFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnM+IHtcbiAgICBsZXQgc2VlZDtcbiAgICBjb25zdCByb290UHJ2ID0gd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgIGlmIChyb290UHJ2KSB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFBydihyb290UHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RQcml2YXRlS2V5IG5lZWRzIHRvIGJlIHZhbGlkIGVkMjU1MTkgc2VjcmV0IHNlZWQnKTtcbiAgICAgIH1cbiAgICAgIHNlZWQgPSBzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5U2VjcmV0U2VlZChyb290UHJ2KTtcbiAgICB9XG4gICAgY29uc3Qga2V5UGFpciA9IHRoaXMuZ2VuZXJhdGVLZXlQYWlyKHNlZWQpO1xuICAgIC8vIGV4dGVuZCB0aGUgd2FsbGV0IGluaXRpYWxpemF0aW9uIHBhcmFtc1xuICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IGtleVBhaXIucHJ2O1xuICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHJ2KGtleS5wcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJ2OiAke2tleS5wcnZ9YCk7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleXBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldChrZXkucHJ2KTtcbiAgICByZXR1cm4ga2V5cGFpci5zaWduKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGlmIHNpZ25hdHVyZSBmb3IgbWVzc2FnZSBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHB1YiBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlIHNpZ25lZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgc2lnbmF0dXJlIHRvIHZlcmlmeVxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZShwdWI6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHViKHB1YikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwdWI6ICR7cHVifWApO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21QdWJsaWNLZXkocHViKTtcbiAgICByZXR1cm4ga2V5UGFpci52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCB7IHR4QmFzZTY0IH0gPSBwYXJhbXM7XG4gICAgbGV0IHR4OiBzdGVsbGFyLlRyYW5zYWN0aW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhCYXNlNjQsIHRoaXMuZ2V0U3RlbGxhck5ldHdvcmsoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEJhc2U2NCBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHR4Lmhhc2goKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICAvLyBJbiBhIFN0ZWxsYXIgdHgsIHRoZSBfbWVtbyBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgbWV0aG9kczpcbiAgICAvLyB2YWx1ZSgpIGFuZCBhcm0oKSB0aGF0IHByb3ZpZGUgbWVtbyB2YWx1ZSBhbmQgdHlwZSwgcmVzcGVjdGl2ZWx5LlxuICAgIGNvbnN0IG1lbW86IFRyYW5zYWN0aW9uTWVtbyA9XG4gICAgICBfLnJlc3VsdCh0eCwgJ19tZW1vLnZhbHVlJykgJiYgXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHZhbHVlOiAoXy5yZXN1bHQodHgsICdfbWVtby52YWx1ZScpIGFzIGFueSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6IF8ucmVzdWx0KHR4LCAnX21lbW8uYXJtJyksXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9O1xuXG4gICAgbGV0IHNwZW5kQW1vdW50ID0gbmV3IEJpZ051bWJlcigwKTsgLy8gYW1vdW50IG9mIFhMTSB1c2VkIGluIFhMTS1vbmx5IHR4c1xuICAgIGNvbnN0IHNwZW5kQW1vdW50cyA9IHt9OyAvLyB0cmFjayBib3RoIHhsbSBhbmQgdG9rZW4gYW1vdW50c1xuICAgIGlmIChfLmlzRW1wdHkodHgub3BlcmF0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVyYXRpb25zJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0czogVHJhbnNhY3Rpb25PdXRwdXRbXSA9IFtdO1xuICAgIGNvbnN0IG9wZXJhdGlvbnM6IFRyYW5zYWN0aW9uT3BlcmF0aW9uW10gPSBbXTsgLy8gbm9uLXBheW1lbnQgb3BlcmF0aW9uc1xuXG4gICAgXy5mb3JFYWNoKHR4Lm9wZXJhdGlvbnMsIChvcDogc3RlbGxhci5PcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChvcC50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3AudHlwZSA9PT0gJ3BheW1lbnQnKSB7XG4gICAgICAgIC8vIFRPRE8gUmVtb3ZlIG1lbW9JZCBmcm9tIGFkZHJlc3NcbiAgICAgICAgLy8gR2V0IG1lbW8gdG8gYXR0YWNoIHRvIGFkZHJlc3MsIGlmIHR5cGUgaXMgJ2lkJ1xuICAgICAgICBjb25zdCBtZW1vSWQgPSBfLmdldChtZW1vLCAndHlwZScpID09PSAnaWQnICYmICFfLmdldChtZW1vLCAndmFsdWUnKSA/IGA/bWVtb0lkPSR7bWVtby52YWx1ZX1gIDogJyc7XG4gICAgICAgIGxldCBhc3NldDtcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09ICdwYXltZW50Jykge1xuICAgICAgICAgIGlmIChvcC5hc3NldC5nZXRBc3NldFR5cGUoKSA9PT0gJ2xpcXVpZGl0eV9wb29sX3NoYXJlcycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2V0ID0gb3AuYXNzZXQgYXMgc3RlbGxhci5Bc3NldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NldCA9IHN0ZWxsYXIuQXNzZXQubmF0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29pbiA9IHRoaXMuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldCk7IC8vIGNvaW4gb3IgdG9rZW4gaWRcbiAgICAgICAgY29uc3Qgb3V0cHV0OiBUcmFuc2FjdGlvbk91dHB1dCA9IHtcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYmlnVW5pdHNUb0Jhc2VVbml0cyhcbiAgICAgICAgICAgIChvcCBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DcmVhdGVBY2NvdW50KS5zdGFydGluZ0JhbGFuY2UgfHwgKG9wIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLlBheW1lbnQpLmFtb3VudFxuICAgICAgICAgICksXG4gICAgICAgICAgYWRkcmVzczogb3AuZGVzdGluYXRpb24gKyBtZW1vSWQsXG4gICAgICAgICAgY29pbixcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3BlbmRBbW91bnRzW2NvaW5dKSkge1xuICAgICAgICAgIHNwZW5kQW1vdW50c1tjb2luXSA9IHNwZW5kQW1vdW50c1tjb2luXS5wbHVzKG91dHB1dC5hbW91bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwZW5kQW1vdW50c1tjb2luXSA9IG5ldyBCaWdOdW1iZXIob3V0cHV0LmFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzc2V0LmlzTmF0aXZlKCkpIHtcbiAgICAgICAgICBzcGVuZEFtb3VudCA9IHNwZW5kQW1vdW50LnBsdXMob3V0cHV0LmFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0cy5wdXNoKG91dHB1dCk7XG4gICAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09ICdjaGFuZ2VUcnVzdCcpIHtcbiAgICAgICAgaWYgKG9wLmxpbmUuZ2V0QXNzZXRUeXBlKCkgPT09ICdsaXF1aWRpdHlfcG9vbF9zaGFyZXMnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzc2V0IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3NldCA9IG9wLmxpbmUgYXMgc3RlbGxhci5Bc3NldDtcblxuICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IG9wLnR5cGUsXG4gICAgICAgICAgY29pbjogdGhpcy5nZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0KSxcbiAgICAgICAgICBhc3NldCxcbiAgICAgICAgICBsaW1pdDogdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBbW91bnQgPSBzcGVuZEFtb3VudC50b0ZpeGVkKDApO1xuICAgIGNvbnN0IG91dHB1dEFtb3VudHMgPSBfLm1hcFZhbHVlcyhzcGVuZEFtb3VudHMsIChhbW91bnQ6IEJpZ051bWJlcikgPT4gYW1vdW50LnRvRml4ZWQoMCkpO1xuICAgIGNvbnN0IGZlZSA9IHtcbiAgICAgIGZlZTogbmV3IEJpZ051bWJlcih0eC5mZWUpLnRvRml4ZWQoMCksXG4gICAgICBmZWVSYXRlOiBudWxsLFxuICAgICAgc2l6ZTogbnVsbCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlPcmRlcjogW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgJ291dHB1dEFtb3VudHMnLFxuICAgICAgICAnY2hhbmdlQW1vdW50JyxcbiAgICAgICAgJ291dHB1dHMnLFxuICAgICAgICAnY2hhbmdlT3V0cHV0cycsXG4gICAgICAgICdmZWUnLFxuICAgICAgICAnbWVtbycsXG4gICAgICAgICdvcGVyYXRpb25zJyxcbiAgICAgIF0sXG4gICAgICBpZCxcbiAgICAgIG91dHB1dHMsXG4gICAgICBvdXRwdXRBbW91bnQsXG4gICAgICBvdXRwdXRBbW91bnRzLFxuICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICBjaGFuZ2VBbW91bnQ6ICcwJyxcbiAgICAgIG1lbW8sXG4gICAgICBmZWUsXG4gICAgICBvcGVyYXRpb25zLFxuICAgIH0gYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHggcHJlYnVpbGQncyBvcGVyYXRpb25zIGNvbXBseSB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICogQHBhcmFtIHtzdGVsbGFyLk9wZXJhdGlvbn0gb3BlcmF0aW9ucyAtIHR4IG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblBhcmFtc30gdHhQYXJhbXMgLSBwYXJhbXMgdXNlZCB0byBidWlsZCB0aGUgdHhcbiAgICovXG4gIHZlcmlmeVRydXN0bGluZVR4T3BlcmF0aW9ucyhvcGVyYXRpb25zOiBzdGVsbGFyLk9wZXJhdGlvbltdLCB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXMpOiB2b2lkIHtcbiAgICBjb25zdCB0cnVzdGxpbmVPcGVyYXRpb25zID0gXy5maWx0ZXIob3BlcmF0aW9ucywgWyd0eXBlJywgJ2NoYW5nZVRydXN0J10pIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLkNoYW5nZVRydXN0W107XG4gICAgaWYgKHRydXN0bGluZU9wZXJhdGlvbnMubGVuZ3RoICE9PSBfLmdldCh0eFBhcmFtcywgJ3RydXN0bGluZXMnLCBbXSkubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSBvcGVyYXRpb25zJyk7XG4gICAgfVxuICAgIF8uZm9yRWFjaCh0cnVzdGxpbmVPcGVyYXRpb25zLCAob3A6IHN0ZWxsYXIuT3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKG9wLmxpbmUuZ2V0QXNzZXRUeXBlKCkgPT09ICdsaXF1aWRpdHlfcG9vbF9zaGFyZXMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBhc3NldCA9IG9wLmxpbmUgYXMgc3RlbGxhci5Bc3NldDtcbiAgICAgIGNvbnN0IG9wVG9rZW4gPSB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpO1xuICAgICAgY29uc3QgdG9rZW5UcnVzdGxpbmUgPSBfLmZpbmQodHhQYXJhbXMudHJ1c3RsaW5lcywgKHRydXN0bGluZSkgPT4ge1xuICAgICAgICAvLyB0cnVzdGxpbmUgcGFyYW1zIHVzZSBsaW1pdHMgaW4gYmFzZSB1bml0c1xuICAgICAgICBjb25zdCBvcExpbWl0QmFzZVVuaXRzID0gdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KTtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgY29uZGl0aW9ucyB0byBjaGVjayBmb3JcbiAgICAgICAgLy8gTGltaXQgd2lsbCBhbHdheXMgYmUgc2V0IGluIHRoZSBvcGVyYXRpb24sIGV2ZW4gaWYgaXQgd2FzIG9taXR0ZWQgZnJvbSB0eFBhcmFtcyBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBBY3Rpb24gaXMgJ2FkZCcgLSBsaW1pdCBpcyBzZXQgdG8gWGxtLm1heFRydXN0bGluZUxpbWl0IGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gMi4gQWN0aW9uIGlzICdyZW1vdmUnIC0gbGltaXQgaXMgc2V0IHRvICcwJ1xuICAgICAgICBjb25zdCBub0xpbWl0ID0gXy5pc1VuZGVmaW5lZCh0cnVzdGxpbmUubGltaXQpO1xuICAgICAgICBjb25zdCBhZGRUcnVzdGxpbmVXaXRoRGVmYXVsdExpbWl0ID0gdHJ1c3RsaW5lLmFjdGlvbiA9PT0gJ2FkZCcgJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0O1xuICAgICAgICBjb25zdCByZW1vdmVUcnVzdGxpbmUgPSB0cnVzdGxpbmUuYWN0aW9uID09PSAncmVtb3ZlJyAmJiBvcExpbWl0QmFzZVVuaXRzID09PSAnMCc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdHJ1c3RsaW5lLnRva2VuID09PSBvcFRva2VuICYmXG4gICAgICAgICAgKHRydXN0bGluZS5saW1pdCA9PT0gb3BMaW1pdEJhc2VVbml0cyB8fCAobm9MaW1pdCAmJiAoYWRkVHJ1c3RsaW5lV2l0aERlZmF1bHRMaW1pdCB8fCByZW1vdmVUcnVzdGxpbmUpKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0b2tlblRydXN0bGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSB0b2tlbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkLnR4QmFzZTY0IHByZWJ1aWx0IHRyYW5zYWN0aW9uIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXQgd2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24gc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZyBEaXNhbGxvdyBmZXRjaGluZyBhbnkgZGF0YSBmcm9tIHRoZSBpbnRlcm5ldCBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5rZXljaGFpbnMgUGFzcyBrZXljaGFpbnMgbWFudWFsbHkgcmF0aGVyIHRoYW4gZmV0Y2hpbmcgdGhlbSBieSBpZFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ob3B0aW9uczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gVE9ETyBCRy01NjAwIEFkZCBwYXJzZVRyYW5zYWN0aW9uIC8gaW1wcm92ZSB2ZXJpZmljYXRpb25cbiAgICBjb25zdCB7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiA9IHt9IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG5cbiAgICBpZiAoIXR4UHJlYnVpbGQudHhCYXNlNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwcmVidWlsZCBwcm9wZXJ0eSB0eEJhc2U2NCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhQcmVidWlsZC50eEJhc2U2NCwgdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpKTtcblxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBtb3JlIHRoYW4gMSByZWNpcGllbnQnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVsbGFyIHR4cyBhcmUgbWFkZSB1cCBvZiBvcGVyYXRpb25zLiBXZSBvbmx5IGNhcmUgYWJvdXQgQ3JlYXRlIEFjY291bnQgYW5kIFBheW1lbnQgZm9yIHNlbmRpbmcgZnVuZHMuXG4gICAgY29uc3Qgb3V0cHV0T3BlcmF0aW9ucyA9IF8uZmlsdGVyKFxuICAgICAgdHgub3BlcmF0aW9ucyxcbiAgICAgIChvcGVyYXRpb24pID0+IG9wZXJhdGlvbi50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3BlcmF0aW9uLnR5cGUgPT09ICdwYXltZW50J1xuICAgICk7XG5cbiAgICBpZiAodHhQYXJhbXMudHlwZSA9PT0gJ3RydXN0bGluZScpIHtcbiAgICAgIHRoaXMudmVyaWZ5VHJ1c3RsaW5lVHhPcGVyYXRpb25zKHR4Lm9wZXJhdGlvbnMsIHR4UGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF8uaXNFbXB0eShvdXRwdXRPcGVyYXRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IGhhdmUgYW55IG9wZXJhdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgXy5mb3JFYWNoKHR4UGFyYW1zLnJlY2lwaWVudHMsIChleHBlY3RlZE91dHB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoZXhwZWN0ZWRPdXRwdXQuYWRkcmVzcyk7XG4gICAgICAgIC8vIGZvciBtdXhlZCBhY2NvdW50cywgdGhlIGRlc3RpbmF0aW9uIHdpbGwgYmUgdGhlIGJhc2VBZGRyZXNzXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0QWRkcmVzcyA9IGV4cGVjdGVkT3V0cHV0QWRkcmVzc0RldGFpbHMuYmFzZUFkZHJlc3M7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dE9wZXJhdGlvbnNbaW5kZXhdIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLlBheW1lbnQgfCBzdGVsbGFyLk9wZXJhdGlvbi5DcmVhdGVBY2NvdW50O1xuICAgICAgICBpZiAob3V0cHV0LmRlc3RpbmF0aW9uICE9PSBleHBlY3RlZE91dHB1dEFkZHJlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHJlY2lwaWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGV4cGVjdGVkT3V0cHV0LmFtb3VudCk7XG4gICAgICAgIC8vIFRoZSBvdXRwdXQgYW1vdW50IGlzIGV4cHJlc3NlZCBhcyBzdGFydGluZ0JhbGFuY2UgaW4gY3JlYXRlQWNjb3VudCBvcGVyYXRpb25zIGFuZCBhcyBhbW91bnQgaW4gcGF5bWVudCBvcGVyYXRpb25zLlxuICAgICAgICBjb25zdCBvdXRwdXRBbW91bnRTdHJpbmcgPSBvdXRwdXQudHlwZSA9PT0gJ2NyZWF0ZUFjY291bnQnID8gb3V0cHV0LnN0YXJ0aW5nQmFsYW5jZSA6IG91dHB1dC5hbW91bnQ7XG4gICAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IG5ldyBCaWdOdW1iZXIodGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG91dHB1dEFtb3VudFN0cmluZykpO1xuXG4gICAgICAgIGlmICghb3V0cHV0QW1vdW50LmVxKGV4cGVjdGVkT3V0cHV0QW1vdW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgYW1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSB0aGUgdXNlciBzaWduYXR1cmUsIGlmIHRoZSB0eCBpcyBoYWxmLXNpZ25lZFxuICAgIGlmICghXy5pc0VtcHR5KHR4LnNpZ25hdHVyZXMpKSB7XG4gICAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gdHguc2lnbmF0dXJlc1swXS5zaWduYXR1cmUoKTtcblxuICAgICAgLy8gb2J0YWluIHRoZSBrZXljaGFpbnMgYW5kIGtleSBzaWduYXR1cmVzXG4gICAgICBsZXQga2V5Y2hhaW5zID0gdmVyaWZpY2F0aW9uLmtleWNoYWlucztcbiAgICAgIGlmICgha2V5Y2hhaW5zICYmIGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGZldGNoIGtleWNoYWlucyB3aXRob3V0IG5ldHdvcmtpbmcnKTtcbiAgICAgIH0gZWxzZSBpZiAoIWtleWNoYWlucykge1xuICAgICAgICBrZXljaGFpbnMgPSBhd2FpdCBwcm9taXNlUHJvcHMoe1xuICAgICAgICAgIHVzZXI6IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLlVTRVJdIH0pLFxuICAgICAgICAgIGJhY2t1cDogdGhpcy5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQkFDS1VQXSB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5Y2hhaW5zIHx8ICFrZXljaGFpbnMuYmFja3VwIHx8ICFrZXljaGFpbnMudXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWNoYWlucyBhcmUgcmVxdWlyZWQsIGJ1dCBjb3VsZCBub3QgYmUgZmV0Y2hlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLmJhY2t1cC5wdWIsIHR4Lmhhc2goKSwgdXNlclNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBzaWduZWQgd2l0aCB3cm9uZyBrZXknKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLnVzZXIucHViLCB0eC5oYXNoKCksIHVzZXJTaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gc2lnbmF0dXJlIGludmFsaWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBoYXJkZW5lZCBjaGlsZCBwdWJsaWMga2V5IGZyb20gYSBtYXN0ZXIga2V5IHNlZWQgdXNpbmcgYW4gYWRkaXRpb25hbCBzZWVkIGZvciByYW5kb21uZXNzLlxuICAgKlxuICAgKiBEdWUgdG8gdGVjaG5pY2FsIGRpZmZlcmVuY2VzIGJldHdlZW4ga2V5cGFpcnMgb24gdGhlIGVkMjU1MTkgY3VydmUgYW5kIHRoZSBzZWNwMjU2azEgY3VydmUsXG4gICAqIG9ubHkgaGFyZGVuZWQgcHJpdmF0ZSBrZXkgZGVyaXZhdGlvbiBpcyBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgc2VlZCBmb3IgdGhlIG1hc3RlciBrZXkuIE5vdGU6IE5vdCB0aGUgcHVibGljIGtleSBvciBlbmNvZGVkIHByaXZhdGUga2V5LiBUaGlzIGlzIHRoZSByYXcgc2VlZC5cbiAgICogQHBhcmFtIGVudHJvcHlTZWVkIHJhbmRvbSBzZWVkIHdoaWNoIGlzIGhhc2hlZCB0byBnZW5lcmF0ZSB0aGUgZGVyaXZhdGlvbiBwYXRoXG4gICAqL1xuICBkZXJpdmVLZXlXaXRoU2VlZCh7IGtleSwgc2VlZCB9OiB7IGtleTogc3RyaW5nOyBzZWVkOiBzdHJpbmcgfSk6IHsgZGVyaXZhdGlvblBhdGg6IHN0cmluZzsga2V5OiBzdHJpbmcgfSB7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhJbnB1dCA9IHV0eG9saWIuY3J5cHRvLmhhc2gyNTYoQnVmZmVyLmZyb20oc2VlZCwgJ3V0ZjgnKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgICA5OTk5OTksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDAsIDcpLCAxNiksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICAgIF07XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSAnbS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5tYXAoKHBhcnQpID0+IGAke3BhcnR9J2ApLmpvaW4oJy8nKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gRWQyNTUxOUtleURlcml2ZXIuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCwga2V5KS5rZXk7XG4gICAgY29uc3Qga2V5cGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tUmF3RWQyNTUxOVNlZWQoZGVyaXZlZEtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleToga2V5cGFpci5wdWJsaWNLZXkoKSxcbiAgICAgIGRlcml2YXRpb25QYXRoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogc3RlbGxhci1zZGsgaGFzIHR3byBvdmVybG9hZHMgZm9yIHRvWERSLCBhbmQgdHlwZXNjcmlwdCBjYW4ndCBzZWVtIHRvIGZpZ3VyZSBvdXQgdGhlXG4gICAqIGNvcnJlY3Qgb25lIHRvIHVzZSwgc28gd2UgaGF2ZSB0byBiZSB2ZXJ5IGV4cGxpY2l0IGFzIHRvIHdoaWNoIG9uZSB3ZSB3YW50LlxuICAgKiBAcGFyYW0gdHggdHJhbnNhY3Rpb24gdG8gY29udmVydFxuICAgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyB0eFRvU3RyaW5nID0gKHR4OiBzdGVsbGFyLlRyYW5zYWN0aW9uKTogc3RyaW5nID0+XG4gICAgKHR4LnRvRW52ZWxvcGUoKS50b1hEUiBhcyAoXzogc3RyaW5nKSA9PiBzdHJpbmcpKCdiYXNlNjQnKTtcblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4iXX0=