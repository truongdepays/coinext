"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Algo = void 0;
/**
 * @prettier
 */
const accountLib = require("@bitgo/account-lib");
const utxolib = require("@bitgo/utxo-lib");
const _ = require("lodash");
const seedValidator_1 = require("../internal/seedValidator");
const statics_1 = require("@bitgo/statics");
const baseCoin_1 = require("../baseCoin");
const keychains_1 = require("../keychains");
const errors = require("../../errors");
const errors_1 = require("@bitgo/account-lib/dist/src/coin/baseCoin/errors");
const stellar_sdk_1 = require("stellar-sdk");
const SUPPORTED_ADDRESS_VERSION = 1;
const MSIG_THRESHOLD = 2; // m in m-of-n
class Algo extends baseCoin_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.ENABLE_TOKEN = 'enabletoken';
        this.DISABLE_TOKEN = 'disabletoken';
    }
    static createInstance(bitgo) {
        return new Algo(bitgo);
    }
    getChain() {
        return 'algo';
    }
    getBaseChain() {
        return 'algo';
    }
    getFamily() {
        return 'algo';
    }
    getFullName() {
        return 'Algorand';
    }
    getBaseFactor() {
        return 1e6;
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new accountLib.Algo.KeyPair({ seed }) : new accountLib.Algo.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keyPair.getAddress(),
            prv: accountLib.Algo.algoUtils.encodeSeed(Buffer.from(keyPair.getSigningKey())),
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return accountLib.Algo.algoUtils.isValidAddress(pub);
    }
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv) {
        return accountLib.Algo.algoUtils.isValidSeed(prv);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address) {
        return accountLib.Algo.algoUtils.isValidAddress(address);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const algoKeypair = new accountLib.Algo.KeyPair({ prv: key.prv });
        if (Buffer.isBuffer(message)) {
            message = message.toString('base64');
        }
        return Buffer.from(algoKeypair.signMessage(message));
    }
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    keyIdsForSigning() {
        return [keychains_1.KeyIndices.USER, keychains_1.KeyIndices.BACKUP, keychains_1.KeyIndices.BITGO];
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const factory = accountLib.getBuilder(this.getBaseChain());
        const txBuilder = factory.from(txHex);
        const tx = await txBuilder.build();
        const txJson = tx.toJson();
        if (tx.type === accountLib.BaseCoin.TransactionType.Send) {
            const outputs = [
                {
                    address: txJson.to,
                    amount: txJson.amount,
                    memo: txJson.note,
                },
            ];
            const operations = [];
            const isTokenTx = this.isTokenTx(txJson.type);
            if (isTokenTx) {
                const type = accountLib.Algo.algoUtils.getTokenTxType(txJson.amount, txJson.from, txJson.to, txJson.closeRemainderTo);
                operations.push({
                    type: type,
                    coin: `${this.getChain()}:${txJson.tokenId}`,
                });
            }
            const displayOrder = [
                'id',
                'outputAmount',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'type',
                'operations',
            ];
            const explanationResult = {
                displayOrder,
                id: txJson.id,
                outputAmount: txJson.amount.toString(),
                changeAmount: '0',
                outputs,
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.note,
                type: tx.type.toString(),
                operations,
            };
            if (txJson.tokenId) {
                explanationResult.tokenId = txJson.tokenId;
            }
            return explanationResult;
        }
        if (tx.type === accountLib.BaseCoin.TransactionType.WalletInitialization) {
            const displayOrder = [
                'id',
                'fee',
                'memo',
                'type',
                'voteKey',
                'selectionKey',
                'voteFirst',
                'voteLast',
                'voteKeyDilution',
            ];
            return {
                displayOrder,
                id: txJson.id,
                outputAmount: '0',
                changeAmount: '0',
                outputs: [],
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.note,
                type: tx.type,
                voteKey: txJson.voteKey,
                selectionKey: txJson.selectionKey,
                voteFirst: txJson.voteFirst,
                voteLast: txJson.voteLast,
                voteKeyDilution: txJson.voteKeyDilution,
            };
        }
    }
    /**
     * returns if a tx is a token tx
     * @param type {string} - tx type
     * @returns true if it's a token tx
     */
    isTokenTx(type) {
        return type === 'axfer';
    }
    /**
     * Check if a seed is a valid stellar seed
     *
     * @param {String} seed the seed to check
     * @returns {Boolean} true if the input is a Stellar seed
     */
    isStellarSeed(seed) {
        return seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM);
    }
    /**
     * Convert a stellar seed to an algo seed
     *
     * @param {String} seed the seed to convert
     * @returns {Boolean | null} seed in algo encoding
     */
    convertFromStellarSeed(seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed) || seedValidator_1.SeedValidator.hasCompetingSeedFormats(seed)) {
            return null;
        }
        if (seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM)) {
            return accountLib.Algo.algoUtils.convertFromStellarSeed(seed);
        }
        return null;
    }
    verifySignTransactionParams(params) {
        const prv = params.prv;
        const addressVersion = params.txPrebuild.addressVersion;
        let isHalfSigned = false;
        // it's possible this tx was already signed - take the halfSigned
        // txHex if it is
        let txHex = params.txPrebuild.txHex;
        if (params.txPrebuild.halfSigned) {
            isHalfSigned = true;
            txHex = params.txPrebuild.halfSigned.txHex;
        }
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txHex}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        if (!_.has(params.txPrebuild, 'keys')) {
            throw new Error('missing public keys parameter to sign transaction');
        }
        if (!_.isNumber(addressVersion)) {
            throw new Error('missing addressVersion parameter to sign transaction');
        }
        const signers = params.txPrebuild.keys.map((key) => {
            // if we are receiving addresses do not try to convert them
            if (!accountLib.Algo.algoUtils.isValidAddress(key)) {
                return accountLib.Algo.algoUtils.publicKeyToAlgoAddress(accountLib.Algo.algoUtils.toUint8Array(key));
            }
            return key;
        });
        // TODO(https://bitgoinc.atlassian.net/browse/STLX-6067): fix the number of signers using
        // should be similar to other coins implementation
        // If we have a number with digits to eliminate them without taking any rounding criteria.
        const numberSigners = Math.trunc(signers.length / 2) + 1;
        return { txHex, addressVersion, signers, prv, isHalfSigned, numberSigners };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        const { txHex, signers, prv, isHalfSigned, numberSigners } = this.verifySignTransactionParams(params);
        const factory = accountLib.register(this.getChain(), accountLib.Algo.TransactionBuilderFactory);
        const txBuilder = factory.from(txHex);
        txBuilder.numberOfRequiredSigners(numberSigners);
        txBuilder.sign({ key: prv });
        txBuilder.setSigners(signers);
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const signedTxHex = Buffer.from(transaction.toBroadcastFormat()).toString('base64');
        if (numberSigners === 1) {
            return { txHex: signedTxHex };
        }
        else if (isHalfSigned) {
            return { txHex: signedTxHex };
        }
        else {
            return { halfSigned: { txHex: signedTxHex } };
        }
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Check if address can be used to send funds.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    isWalletAddress(params) {
        const { address, keychains, coinSpecific: { bitgoPubKey }, } = params;
        if (!this.isValidAddress(address)) {
            throw new errors.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        const effectiveKeychain = bitgoPubKey ? keychains.slice(0, -1).concat([{ pub: bitgoPubKey }]) : keychains;
        const pubKeys = effectiveKeychain.map((key) => this.stellarAddressToAlgoAddress(key.pub));
        if (!pubKeys.every((pubKey) => this.isValidPub(pubKey))) {
            throw new errors_1.InvalidKey('invalid public key');
        }
        const rootAddress = accountLib.Algo.algoUtils.multisigAddress(SUPPORTED_ADDRESS_VERSION, MSIG_THRESHOLD, pubKeys);
        return rootAddress === address;
    }
    async verifyTransaction(params) {
        return true;
    }
    /** @inheritDoc */
    deriveKeyWithSeed({ key, seed }) {
        const derivationPathInput = utxolib.crypto.hash256(Buffer.from(seed, 'utf8')).toString('hex');
        const derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/' + derivationPathParts.map((part) => `${part}'`).join('/');
        const derivedKey = accountLib.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        const keypair = new accountLib.Algo.KeyPair({ seed: derivedKey });
        return {
            key: keypair.getAddress(),
            derivationPath,
        };
    }
    decodeTx(txn) {
        return accountLib.Algo.algoUtils.decodeAlgoTxn(txn);
    }
    getAddressFromPublicKey(pubKey) {
        return accountLib.Algo.algoUtils.publicKeyToAlgoAddress(pubKey);
    }
    /**
     * Stellar and Algorand both use keys on the ed25519 curve, but use different encodings.
     * As the HSM doesn't have explicit support to create Algorand addresses, we use the Stellar
     * keys and re-encode them to the Algorand encoding.
     *
     * This method should only be used when creating Algorand custodial wallets reusing Stellar keys.
     *
     * @param {string} addressOrPubKey a Stellar pubkey or Algorand address
     * @return {*}
     */
    stellarAddressToAlgoAddress(addressOrPubKey) {
        if (this.isValidAddress(addressOrPubKey)) {
            // we have an Algorand address
            return addressOrPubKey;
        }
        if (!stellar_sdk_1.default.StrKey.isValidEd25519PublicKey(addressOrPubKey)) {
            throw new errors.UnexpectedAddressError('Neither an Algorand address nor a stellar pubkey.');
        }
        // we have a stellar key
        const stellarPub = stellar_sdk_1.default.StrKey.decodeEd25519PublicKey(addressOrPubKey);
        const algoAddress = accountLib.Algo.algoUtils.encodeAddress(stellarPub);
        if (!this.isValidAddress(algoAddress)) {
            throw new errors.UnexpectedAddressError('Cannot convert Stellar address to an Algorand address via pubkey.');
        }
        return algoAddress;
    }
}
exports.Algo = Algo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztHQUVHO0FBQ0gsaURBQWlEO0FBQ2pELDJDQUEyQztBQUMzQyw0QkFBNEI7QUFFNUIsNkRBQTBEO0FBQzFELDRDQUE0QztBQUU1QywwQ0FZcUI7QUFDckIsNENBQTBDO0FBRTFDLHVDQUF1QztBQUN2Qyw2RUFBOEU7QUFDOUUsNkNBQWtDO0FBRWxDLE1BQU0seUJBQXlCLEdBQUcsQ0FBQyxDQUFDO0FBQ3BDLE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDLGNBQWM7QUEyRnhDLE1BQWEsSUFBSyxTQUFRLG1CQUFRO0lBSWhDLFlBQVksS0FBWTtRQUN0QixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFKTixpQkFBWSxHQUF3QixhQUFhLENBQUM7UUFDbEQsa0JBQWEsR0FBd0IsY0FBYyxDQUFDO0lBSTdELENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQVk7UUFDaEMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELFNBQVM7UUFDUCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsV0FBVztRQUNULE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxhQUFhO1FBQ1gsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0JBQXdCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILDJCQUEyQjtRQUN6QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGVBQWUsQ0FBQyxJ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QyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIGFjY291bnRMaWIgZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcbmltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgU2VlZFZhbGlkYXRvciB9IGZyb20gJy4uL2ludGVybmFsL3NlZWRWYWxpZGF0b3InO1xuaW1wb3J0IHsgQ29pbkZhbWlseSB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcblxuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIEtleVBhaXIsXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBBZGRyZXNzQ29pblNwZWNpZmljLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBLZXlJbmRpY2VzIH0gZnJvbSAnLi4va2V5Y2hhaW5zJztcbmltcG9ydCB7IFRva2VuTWFuYWdlbWVudFR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBlcnJvcnMgZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEludmFsaWRLZXkgfSBmcm9tICdAYml0Z28vYWNjb3VudC1saWIvZGlzdC9zcmMvY29pbi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuXG5jb25zdCBTVVBQT1JURURfQUREUkVTU19WRVJTSU9OID0gMTtcbmNvbnN0IE1TSUdfVEhSRVNIT0xEID0gMjsgLy8gbSBpbiBtLW9mLW5cblxuZXhwb3J0IGludGVyZmFjZSBBbGdvQWRkcmVzc0NvaW5TcGVjaWZpY3MgZXh0ZW5kcyBBZGRyZXNzQ29pblNwZWNpZmljIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbiAgYml0Z29LZXk6IHN0cmluZztcbiAgYml0Z29QdWJLZXk/OiBzdHJpbmc7XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG4gIHRocmVzaG9sZDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUFsZ29BZGRyZXNzT3B0aW9ucyBleHRlbmRzIFZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgY2hhaW46IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgY29pbjogc3RyaW5nO1xuICB3YWxsZXQ6IHN0cmluZztcbiAgY29pblNwZWNpZmljOiBBbGdvQWRkcmVzc0NvaW5TcGVjaWZpY3M7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxnb1RyYW5zYWN0aW9uRXhwbGFuYXRpb24gZXh0ZW5kcyBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgbWVtbz86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZyB8IG51bWJlcjtcbiAgdm90ZUtleT86IHN0cmluZztcbiAgc2VsZWN0aW9uS2V5Pzogc3RyaW5nO1xuICB2b3RlRmlyc3Q/OiBudW1iZXI7XG4gIHZvdGVMYXN0PzogbnVtYmVyO1xuICB2b3RlS2V5RGlsdXRpb24/OiBudW1iZXI7XG4gIHRva2VuSWQ/OiBudW1iZXI7XG4gIG9wZXJhdGlvbnM/OiBUcmFuc2FjdGlvbk9wZXJhdGlvbltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbiAgdHhJbmZvOiB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG4gICAgYW1vdW50OiBzdHJpbmc7XG4gICAgZmVlOiBudW1iZXI7XG4gICAgZmlyc3RSb3VuZDogbnVtYmVyO1xuICAgIGxhc3RSb3VuZDogbnVtYmVyO1xuICAgIGdlbmVzaXNJRDogc3RyaW5nO1xuICAgIGdlbmVzaXNIYXNoOiBzdHJpbmc7XG4gICAgbm90ZT86IHN0cmluZztcbiAgfTtcbiAga2V5czogc3RyaW5nW107XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVsbHlTaWduZWRUcmFuc2FjdGlvbiB7XG4gIHR4SGV4OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25GZWUge1xuICBmZWU6IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG4gIHB1YmxpY0tleXM/OiBzdHJpbmdbXTtcbiAgZmVlSW5mbzogVHJhbnNhY3Rpb25GZWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICB0eEhleDogc3RyaW5nO1xuICBhZGRyZXNzVmVyc2lvbjogbnVtYmVyO1xuICBzaWduZXJzOiBzdHJpbmdbXTtcbiAgcHJ2OiBzdHJpbmc7XG4gIGlzSGFsZlNpZ25lZDogYm9vbGVhbjtcbiAgbnVtYmVyU2lnbmVyczogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQWxnbyBleHRlbmRzIEJhc2VDb2luIHtcbiAgcmVhZG9ubHkgRU5BQkxFX1RPS0VOOiBUb2tlbk1hbmFnZW1lbnRUeXBlID0gJ2VuYWJsZXRva2VuJztcbiAgcmVhZG9ubHkgRElTQUJMRV9UT0tFTjogVG9rZW5NYW5hZ2VtZW50VHlwZSA9ICdkaXNhYmxldG9rZW4nO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBbGdvKGJpdGdvKTtcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdhbGdvJztcbiAgfVxuXG4gIGdldEJhc2VDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnYWxnbyc7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2FsZ28nO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0FsZ29yYW5kJztcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogbnVtYmVyIHwgc3RyaW5nIHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWxnb3JhbmQgc3VwcG9ydHMgYWNjb3VudCBjb25zb2xpZGF0aW9ucy4gVGhlc2UgYXJlIHRyYW5zZmVycyBmcm9tIHRoZSByZWNlaXZlIGFkZHJlc3Nlc1xuICAgKiB0byB0aGUgbWFpbiBhZGRyZXNzLlxuICAgKi9cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGVkMjU1MTkga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiwgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IGFjY291bnRMaWIuQWxnby5LZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBhY2NvdW50TGliLkFsZ28uS2V5UGFpcigpO1xuICAgIGNvbnN0IGtleXMgPSBrZXlQYWlyLmdldEtleXMoKTtcbiAgICBpZiAoIWtleXMucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJ2IGluIGtleSBnZW5lcmF0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGtleVBhaXIuZ2V0QWRkcmVzcygpLFxuICAgICAgcHJ2OiBhY2NvdW50TGliLkFsZ28uYWxnb1V0aWxzLmVuY29kZVNlZWQoQnVmZmVyLmZyb20oa2V5UGFpci5nZXRTaWduaW5nS2V5KCkpKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhY2NvdW50TGliLkFsZ28uYWxnb1V0aWxzLmlzVmFsaWRBZGRyZXNzKHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHNlZWQgZm9yIHRoZSBjb2luXG4gICAqIEluIEFsZ29yYW5kLCB3aGVuIHRoZSBwcml2YXRlIGtleSBpcyBlbmNvZGVkIGFzIGJhc2UzMiBzdHJpbmcgb25seSB0aGUgZmlyc3QgMzIgYnl0ZXMgYXJlIHRha2VuLFxuICAgKiBzbyB0aGUgZW5jb2RlZCB2YWx1ZSBpcyBhY3R1YWxseSB0aGUgc2VlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJ2IHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFjY291bnRMaWIuQWxnby5hbGdvVXRpbHMuaXNWYWxpZFNlZWQocHJ2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhY2NvdW50TGliLkFsZ28uYWxnb1V0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBjb25zdCBhbGdvS2V5cGFpciA9IG5ldyBhY2NvdW50TGliLkFsZ28uS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShhbGdvS2V5cGFpci5zaWduTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQga2V5IHdlIHdpbGwgbmVlZCBmb3Igc2lnbmluZ2AgLSBBbGdvcmFuZCBuZWVkcyB0aGUgYmFja3VwLCBiaXRnbyBwdWJzLlxuICAgKi9cbiAga2V5SWRzRm9yU2lnbmluZygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPEFsZ29UcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSBhY2NvdW50TGliLmdldEJ1aWxkZXIodGhpcy5nZXRCYXNlQ2hhaW4oKSkgYXMgdW5rbm93biBhcyBhY2NvdW50TGliLkFsZ28uVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeTtcblxuICAgIGNvbnN0IHR4QnVpbGRlciA9IGZhY3RvcnkuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eC50b0pzb24oKTtcblxuICAgIGlmICh0eC50eXBlID09PSBhY2NvdW50TGliLkJhc2VDb2luLlRyYW5zYWN0aW9uVHlwZS5TZW5kKSB7XG4gICAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvblJlY2lwaWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzczogdHhKc29uLnRvLFxuICAgICAgICAgIGFtb3VudDogdHhKc29uLmFtb3VudCxcbiAgICAgICAgICBtZW1vOiB0eEpzb24ubm90ZSxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgICBjb25zdCBvcGVyYXRpb25zOiBUcmFuc2FjdGlvbk9wZXJhdGlvbltdID0gW107XG5cbiAgICAgIGNvbnN0IGlzVG9rZW5UeCA9IHRoaXMuaXNUb2tlblR4KHR4SnNvbi50eXBlKTtcbiAgICAgIGlmIChpc1Rva2VuVHgpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGFjY291bnRMaWIuQWxnby5hbGdvVXRpbHMuZ2V0VG9rZW5UeFR5cGUoXG4gICAgICAgICAgdHhKc29uLmFtb3VudCxcbiAgICAgICAgICB0eEpzb24uZnJvbSxcbiAgICAgICAgICB0eEpzb24udG8sXG4gICAgICAgICAgdHhKc29uLmNsb3NlUmVtYWluZGVyVG9cbiAgICAgICAgKTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGNvaW46IGAke3RoaXMuZ2V0Q2hhaW4oKX06JHt0eEpzb24udG9rZW5JZH1gLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICdvdXRwdXRzJyxcbiAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ21lbW8nLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICdvcGVyYXRpb25zJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uUmVzdWx0OiBBbGdvVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IHR4SnNvbi5hbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBmZWU6IHR4SnNvbi5mZWUsXG4gICAgICAgIG1lbW86IHR4SnNvbi5ub3RlLFxuICAgICAgICB0eXBlOiB0eC50eXBlLnRvU3RyaW5nKCksXG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICB9O1xuXG4gICAgICBpZiAodHhKc29uLnRva2VuSWQpIHtcbiAgICAgICAgZXhwbGFuYXRpb25SZXN1bHQudG9rZW5JZCA9IHR4SnNvbi50b2tlbklkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwbGFuYXRpb25SZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHR4LnR5cGUgPT09IGFjY291bnRMaWIuQmFzZUNvaW4uVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uKSB7XG4gICAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbXG4gICAgICAgICdpZCcsXG4gICAgICAgICdmZWUnLFxuICAgICAgICAnbWVtbycsXG4gICAgICAgICd0eXBlJyxcbiAgICAgICAgJ3ZvdGVLZXknLFxuICAgICAgICAnc2VsZWN0aW9uS2V5JyxcbiAgICAgICAgJ3ZvdGVGaXJzdCcsXG4gICAgICAgICd2b3RlTGFzdCcsXG4gICAgICAgICd2b3RlS2V5RGlsdXRpb24nLFxuICAgICAgXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgICBvdXRwdXRBbW91bnQ6ICcwJyxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgZmVlOiB0eEpzb24uZmVlLFxuICAgICAgICBtZW1vOiB0eEpzb24ubm90ZSxcbiAgICAgICAgdHlwZTogdHgudHlwZSxcbiAgICAgICAgdm90ZUtleTogdHhKc29uLnZvdGVLZXksXG4gICAgICAgIHNlbGVjdGlvbktleTogdHhKc29uLnNlbGVjdGlvbktleSxcbiAgICAgICAgdm90ZUZpcnN0OiB0eEpzb24udm90ZUZpcnN0LFxuICAgICAgICB2b3RlTGFzdDogdHhKc29uLnZvdGVMYXN0LFxuICAgICAgICB2b3RlS2V5RGlsdXRpb246IHR4SnNvbi52b3RlS2V5RGlsdXRpb24sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGlmIGEgdHggaXMgYSB0b2tlbiB0eFxuICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSAtIHR4IHR5cGVcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBpdCdzIGEgdG9rZW4gdHhcbiAgICovXG4gIGlzVG9rZW5UeCh0eXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2F4ZmVyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHNlZWQgaXMgYSB2YWxpZCBzdGVsbGFyIHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlZWQgdGhlIHNlZWQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGlucHV0IGlzIGEgU3RlbGxhciBzZWVkXG4gICAqL1xuICBpc1N0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBTZWVkVmFsaWRhdG9yLmlzVmFsaWRFZDI1NTE5U2VlZEZvckNvaW4oc2VlZCwgQ29pbkZhbWlseS5YTE0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzdGVsbGFyIHNlZWQgdG8gYW4gYWxnbyBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIHRoZSBzZWVkIHRvIGNvbnZlcnRcbiAgICogQHJldHVybnMge0Jvb2xlYW4gfCBudWxsfSBzZWVkIGluIGFsZ28gZW5jb2RpbmdcbiAgICovXG4gIGNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gYXNzdW1lIHRoaXMgaXMgYSB0cnVzdCBjdXN0b2RpYWwgc2VlZCBpZiBpdHMgYSB2YWxpZCBlZDI1NTE5IHBydlxuICAgIGlmICghdGhpcy5pc1N0ZWxsYXJTZWVkKHNlZWQpIHx8IFNlZWRWYWxpZGF0b3IuaGFzQ29tcGV0aW5nU2VlZEZvcm1hdHMoc2VlZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChTZWVkVmFsaWRhdG9yLmlzVmFsaWRFZDI1NTE5U2VlZEZvckNvaW4oc2VlZCwgQ29pbkZhbWlseS5YTE0pKSB7XG4gICAgICByZXR1cm4gYWNjb3VudExpYi5BbGdvLmFsZ29VdGlscy5jb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmVyaWZ5U2lnblRyYW5zYWN0aW9uUGFyYW1zKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFZlcmlmaWVkVHJhbnNhY3Rpb25QYXJhbWV0ZXJzIHtcbiAgICBjb25zdCBwcnYgPSBwYXJhbXMucHJ2O1xuICAgIGNvbnN0IGFkZHJlc3NWZXJzaW9uID0gcGFyYW1zLnR4UHJlYnVpbGQuYWRkcmVzc1ZlcnNpb247XG4gICAgbGV0IGlzSGFsZlNpZ25lZCA9IGZhbHNlO1xuXG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGlzIHR4IHdhcyBhbHJlYWR5IHNpZ25lZCAtIHRha2UgdGhlIGhhbGZTaWduZWRcbiAgICAvLyB0eEhleCBpZiBpdCBpc1xuICAgIGxldCB0eEhleCA9IHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4O1xuICAgIGlmIChwYXJhbXMudHhQcmVidWlsZC5oYWxmU2lnbmVkKSB7XG4gICAgICBpc0hhbGZTaWduZWQgPSB0cnVlO1xuICAgICAgdHhIZXggPSBwYXJhbXMudHhQcmVidWlsZC5oYWxmU2lnbmVkLnR4SGV4O1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eEhleH1gKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaGFzKHBhcmFtcy50eFByZWJ1aWxkLCAna2V5cycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHVibGljIGtleXMgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoYWRkcmVzc1ZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYWRkcmVzc1ZlcnNpb24gcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduZXJzID0gcGFyYW1zLnR4UHJlYnVpbGQua2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgLy8gaWYgd2UgYXJlIHJlY2VpdmluZyBhZGRyZXNzZXMgZG8gbm90IHRyeSB0byBjb252ZXJ0IHRoZW1cbiAgICAgIGlmICghYWNjb3VudExpYi5BbGdvLmFsZ29VdGlscy5pc1ZhbGlkQWRkcmVzcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBhY2NvdW50TGliLkFsZ28uYWxnb1V0aWxzLnB1YmxpY0tleVRvQWxnb0FkZHJlc3MoYWNjb3VudExpYi5BbGdvLmFsZ29VdGlscy50b1VpbnQ4QXJyYXkoa2V5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xuICAgIC8vIFRPRE8oaHR0cHM6Ly9iaXRnb2luYy5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9TVExYLTYwNjcpOiBmaXggdGhlIG51bWJlciBvZiBzaWduZXJzIHVzaW5nXG4gICAgLy8gc2hvdWxkIGJlIHNpbWlsYXIgdG8gb3RoZXIgY29pbnMgaW1wbGVtZW50YXRpb25cbiAgICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIHdpdGggZGlnaXRzIHRvIGVsaW1pbmF0ZSB0aGVtIHdpdGhvdXQgdGFraW5nIGFueSByb3VuZGluZyBjcml0ZXJpYS5cbiAgICBjb25zdCBudW1iZXJTaWduZXJzID0gTWF0aC50cnVuYyhzaWduZXJzLmxlbmd0aCAvIDIpICsgMTtcbiAgICByZXR1cm4geyB0eEhleCwgYWRkcmVzc1ZlcnNpb24sIHNpZ25lcnMsIHBydiwgaXNIYWxmU2lnbmVkLCBudW1iZXJTaWduZXJzIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7VHJhbnNhY3Rpb25QcmVidWlsZH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgeyB0eEhleCwgc2lnbmVycywgcHJ2LCBpc0hhbGZTaWduZWQsIG51bWJlclNpZ25lcnMgfSA9IHRoaXMudmVyaWZ5U2lnblRyYW5zYWN0aW9uUGFyYW1zKHBhcmFtcyk7XG4gICAgY29uc3QgZmFjdG9yeSA9IGFjY291bnRMaWIucmVnaXN0ZXIodGhpcy5nZXRDaGFpbigpLCBhY2NvdW50TGliLkFsZ28uVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHR4SGV4KTtcbiAgICB0eEJ1aWxkZXIubnVtYmVyT2ZSZXF1aXJlZFNpZ25lcnMobnVtYmVyU2lnbmVycyk7XG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHBydiB9KTtcbiAgICB0eEJ1aWxkZXIuc2V0U2lnbmVycyhzaWduZXJzKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZWRUeEhleCA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBpZiAobnVtYmVyU2lnbmVycyA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgdHhIZXg6IHNpZ25lZFR4SGV4IH07XG4gICAgfSBlbHNlIGlmIChpc0hhbGZTaWduZWQpIHtcbiAgICAgIHJldHVybiB7IHR4SGV4OiBzaWduZWRUeEhleCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4SGV4OiBzaWduZWRUeEhleCB9IH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGNhbiBiZSB1c2VkIHRvIHNlbmQgZnVuZHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zIHB1YmxpYyBrZXlzIHRvIGdlbmVyYXRlIHRoZSB3YWxsZXRcbiAgICovXG4gIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFsZ29BZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBrZXljaGFpbnMsXG4gICAgICBjb2luU3BlY2lmaWM6IHsgYml0Z29QdWJLZXkgfSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0ga2V5Y2hhaW5zJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZWZmZWN0aXZlS2V5Y2hhaW4gPSBiaXRnb1B1YktleSA/IGtleWNoYWlucy5zbGljZSgwLCAtMSkuY29uY2F0KFt7IHB1YjogYml0Z29QdWJLZXkgfV0pIDoga2V5Y2hhaW5zO1xuICAgIGNvbnN0IHB1YktleXMgPSBlZmZlY3RpdmVLZXljaGFpbi5tYXAoKGtleSkgPT4gdGhpcy5zdGVsbGFyQWRkcmVzc1RvQWxnb0FkZHJlc3Moa2V5LnB1YikpO1xuXG4gICAgaWYgKCFwdWJLZXlzLmV2ZXJ5KChwdWJLZXkpID0+IHRoaXMuaXNWYWxpZFB1YihwdWJLZXkpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRLZXkoJ2ludmFsaWQgcHVibGljIGtleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3RBZGRyZXNzID0gYWNjb3VudExpYi5BbGdvLmFsZ29VdGlscy5tdWx0aXNpZ0FkZHJlc3MoU1VQUE9SVEVEX0FERFJFU1NfVkVSU0lPTiwgTVNJR19USFJFU0hPTEQsIHB1YktleXMpO1xuXG4gICAgcmV0dXJuIHJvb3RBZGRyZXNzID09PSBhZGRyZXNzO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBkZXJpdmVLZXlXaXRoU2VlZCh7IGtleSwgc2VlZCB9OiB7IGtleTogc3RyaW5nOyBzZWVkOiBzdHJpbmcgfSk6IHsgZGVyaXZhdGlvblBhdGg6IHN0cmluZzsga2V5OiBzdHJpbmcgfSB7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhJbnB1dCA9IHV0eG9saWIuY3J5cHRvLmhhc2gyNTYoQnVmZmVyLmZyb20oc2VlZCwgJ3V0ZjgnKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgICA5OTk5OTksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDAsIDcpLCAxNiksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICAgIF07XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSAnbS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5tYXAoKHBhcnQpID0+IGAke3BhcnR9J2ApLmpvaW4oJy8nKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gYWNjb3VudExpYi5FZDI1NTE5S2V5RGVyaXZlci5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoLCBrZXkpLmtleTtcbiAgICBjb25zdCBrZXlwYWlyID0gbmV3IGFjY291bnRMaWIuQWxnby5LZXlQYWlyKHsgc2VlZDogZGVyaXZlZEtleSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBrZXlwYWlyLmdldEFkZHJlc3MoKSxcbiAgICAgIGRlcml2YXRpb25QYXRoLFxuICAgIH07XG4gIH1cblxuICBkZWNvZGVUeCh0eG46IEJ1ZmZlcik6IHVua25vd24ge1xuICAgIHJldHVybiBhY2NvdW50TGliLkFsZ28uYWxnb1V0aWxzLmRlY29kZUFsZ29UeG4odHhuKTtcbiAgfVxuXG4gIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KHB1YktleTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFjY291bnRMaWIuQWxnby5hbGdvVXRpbHMucHVibGljS2V5VG9BbGdvQWRkcmVzcyhwdWJLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0ZWxsYXIgYW5kIEFsZ29yYW5kIGJvdGggdXNlIGtleXMgb24gdGhlIGVkMjU1MTkgY3VydmUsIGJ1dCB1c2UgZGlmZmVyZW50IGVuY29kaW5ncy5cbiAgICogQXMgdGhlIEhTTSBkb2Vzbid0IGhhdmUgZXhwbGljaXQgc3VwcG9ydCB0byBjcmVhdGUgQWxnb3JhbmQgYWRkcmVzc2VzLCB3ZSB1c2UgdGhlIFN0ZWxsYXJcbiAgICoga2V5cyBhbmQgcmUtZW5jb2RlIHRoZW0gdG8gdGhlIEFsZ29yYW5kIGVuY29kaW5nLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgQWxnb3JhbmQgY3VzdG9kaWFsIHdhbGxldHMgcmV1c2luZyBTdGVsbGFyIGtleXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzT3JQdWJLZXkgYSBTdGVsbGFyIHB1YmtleSBvciBBbGdvcmFuZCBhZGRyZXNzXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBwcml2YXRlIHN0ZWxsYXJBZGRyZXNzVG9BbGdvQWRkcmVzcyhhZGRyZXNzT3JQdWJLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgLy8gd2UgaGF2ZSBhbiBBbGdvcmFuZCBhZGRyZXNzXG4gICAgICByZXR1cm4gYWRkcmVzc09yUHViS2V5O1xuICAgIH1cblxuICAgIGlmICghc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5VbmV4cGVjdGVkQWRkcmVzc0Vycm9yKCdOZWl0aGVyIGFuIEFsZ29yYW5kIGFkZHJlc3Mgbm9yIGEgc3RlbGxhciBwdWJrZXkuJyk7XG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSBhIHN0ZWxsYXIga2V5XG4gICAgY29uc3Qgc3RlbGxhclB1YiA9IHN0ZWxsYXIuU3RyS2V5LmRlY29kZUVkMjU1MTlQdWJsaWNLZXkoYWRkcmVzc09yUHViS2V5KTtcbiAgICBjb25zdCBhbGdvQWRkcmVzcyA9IGFjY291bnRMaWIuQWxnby5hbGdvVXRpbHMuZW5jb2RlQWRkcmVzcyhzdGVsbGFyUHViKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhbGdvQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5leHBlY3RlZEFkZHJlc3NFcnJvcignQ2Fubm90IGNvbnZlcnQgU3RlbGxhciBhZGRyZXNzIHRvIGFuIEFsZ29yYW5kIGFkZHJlc3MgdmlhIHB1YmtleS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxnb0FkZHJlc3M7XG4gIH1cbn1cbiJdfQ==