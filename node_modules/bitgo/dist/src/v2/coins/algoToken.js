"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoToken = void 0;
const algo_1 = require("./algo");
const sdk_core_1 = require("@bitgo/sdk-core");
class AlgoToken extends algo_1.Algo {
    constructor(bitgo, tokenConfig) {
        super(bitgo);
        this.tokenConfig = tokenConfig;
        const match = this.tokenConfig.type.match(AlgoToken.tokenNamePattern) || [];
        const tokenCoin = match[1];
        this._code = match[2];
        const token = match[3];
        if (tokenCoin !== tokenConfig.coin) {
            throw new sdk_core_1.BitGoJsError(`invalid coin found in token: ${this.tokenConfig.type}`);
        }
        if (!token) {
            throw new sdk_core_1.BitGoJsError(`invalid token: ${this.tokenConfig.type}`);
        }
    }
    static createTokenConstructor(config) {
        return (bitgo) => new AlgoToken(bitgo, config);
    }
    get type() {
        return this.tokenConfig.type;
    }
    get name() {
        return this.tokenConfig.name;
    }
    get coin() {
        return this.tokenConfig.coin;
    }
    get network() {
        return this.tokenConfig.network;
    }
    get code() {
        return this._code;
    }
    get issuer() {
        return undefined; // Not defined for Algorand
    }
    get decimalPlaces() {
        return this.tokenConfig.decimalPlaces;
    }
    getChain() {
        return this.tokenConfig.type;
    }
    getBaseChain() {
        return this.coin;
    }
    getFullName() {
        return 'Algo Token';
    }
    getBaseFactor() {
        return Math.pow(10, this.tokenConfig.decimalPlaces);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
}
exports.AlgoToken = AlgoToken;
AlgoToken.tokenNamePattern = /^([^:]+):(?:([^.]+)-)?([0-9]+)$/;
AlgoToken.tokenPattern = /[0-9]/;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnb1Rva2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL2FsZ29Ub2tlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFJQSxpQ0FBOEI7QUFFOUIsOENBQStDO0FBVy9DLE1BQWEsU0FBVSxTQUFRLFdBQUk7SUFNakMsWUFBWSxLQUFZLEVBQUUsV0FBNEI7UUFDcEQsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFFL0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUU1RSxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXZCLElBQUksU0FBUyxLQUFLLFdBQVcsQ0FBQyxJQUFJLEVBQUU7WUFDbEMsTUFBTSxJQUFJLHVCQUFZLENBQUMsZ0NBQWdDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNqRjtRQUNELElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixNQUFNLElBQUksdUJBQVksQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQ25FO0lBQ0gsQ0FBQztJQUVELE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxNQUF1QjtRQUNuRCxPQUFPLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUM7SUFDbEMsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBSSxNQUFNO1FBQ1IsT0FBTyxTQUFTLENBQUMsQ0FBQywyQkFBMkI7SUFDL0MsQ0FBQztJQUVELElBQUksYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUM7SUFDeEMsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO0lBQy9CLENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztJQUVELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7T0FHRztJQUNILHdCQUF3QjtRQUN0QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7O0FBOUVILDhCQStFQztBQTlFaUIsMEJBQWdCLEdBQUcsaUNBQWlDLENBQUM7QUFDckQsc0JBQVksR0FBVyxPQUFPLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IEFsZ28gfSBmcm9tICcuL2FsZ28nO1xuaW1wb3J0IHsgQ29pbkNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vY29pbkZhY3RvcnknO1xuaW1wb3J0IHsgQml0R29Kc0Vycm9yIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBBbGdvVG9rZW5Db25maWcge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFsaWFzPzogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgbmV0d29yazogc3RyaW5nO1xuICBkZWNpbWFsUGxhY2VzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBbGdvVG9rZW4gZXh0ZW5kcyBBbGdvIHtcbiAgc3RhdGljIHJlYWRvbmx5IHRva2VuTmFtZVBhdHRlcm4gPSAvXihbXjpdKyk6KD86KFteLl0rKS0pPyhbMC05XSspJC87XG4gIHN0YXRpYyByZWFkb25seSB0b2tlblBhdHRlcm46IFJlZ0V4cCA9IC9bMC05XS87XG4gIHB1YmxpYyByZWFkb25seSB0b2tlbkNvbmZpZzogQWxnb1Rva2VuQ29uZmlnO1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCB0b2tlbkNvbmZpZzogQWxnb1Rva2VuQ29uZmlnKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICAgIHRoaXMudG9rZW5Db25maWcgPSB0b2tlbkNvbmZpZztcblxuICAgIGNvbnN0IG1hdGNoID0gdGhpcy50b2tlbkNvbmZpZy50eXBlLm1hdGNoKEFsZ29Ub2tlbi50b2tlbk5hbWVQYXR0ZXJuKSB8fCBbXTtcblxuICAgIGNvbnN0IHRva2VuQ29pbiA9IG1hdGNoWzFdO1xuICAgIHRoaXMuX2NvZGUgPSBtYXRjaFsyXTtcbiAgICBjb25zdCB0b2tlbiA9IG1hdGNoWzNdO1xuXG4gICAgaWYgKHRva2VuQ29pbiAhPT0gdG9rZW5Db25maWcuY29pbikge1xuICAgICAgdGhyb3cgbmV3IEJpdEdvSnNFcnJvcihgaW52YWxpZCBjb2luIGZvdW5kIGluIHRva2VuOiAke3RoaXMudG9rZW5Db25maWcudHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEJpdEdvSnNFcnJvcihgaW52YWxpZCB0b2tlbjogJHt0aGlzLnRva2VuQ29uZmlnLnR5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVRva2VuQ29uc3RydWN0b3IoY29uZmlnOiBBbGdvVG9rZW5Db25maWcpOiBDb2luQ29uc3RydWN0b3Ige1xuICAgIHJldHVybiAoYml0Z286IEJpdEdvKSA9PiBuZXcgQWxnb1Rva2VuKGJpdGdvLCBjb25maWcpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy50eXBlO1xuICB9XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5uYW1lO1xuICB9XG5cbiAgZ2V0IGNvaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5jb2luO1xuICB9XG5cbiAgZ2V0IG5ldHdvcmsoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5uZXR3b3JrO1xuICB9XG5cbiAgZ2V0IGNvZGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY29kZTtcbiAgfVxuXG4gIGdldCBpc3N1ZXIoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBOb3QgZGVmaW5lZCBmb3IgQWxnb3JhbmRcbiAgfVxuXG4gIGdldCBkZWNpbWFsUGxhY2VzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuZGVjaW1hbFBsYWNlcztcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcudHlwZTtcbiAgfVxuXG4gIGdldEJhc2VDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvaW47XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQWxnbyBUb2tlbic7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLnRva2VuQ29uZmlnLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdfQ==