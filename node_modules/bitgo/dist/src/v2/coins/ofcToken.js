"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfcToken = void 0;
/**
 * @prettier
 */
const lodash_1 = require("lodash");
const ofc_1 = require("./ofc");
const publicIdRegex = /^[a-f\d]{32}$/i;
class OfcToken extends ofc_1.Ofc {
    constructor(bitgo, tokenConfig) {
        super(bitgo);
        this.tokenConfig = tokenConfig;
    }
    get coin() {
        return this.tokenConfig.coin;
    }
    get decimalPlaces() {
        return this.tokenConfig.decimalPlaces;
    }
    get name() {
        return this.tokenConfig.name;
    }
    get backingCoin() {
        return this.tokenConfig.backingCoin;
    }
    get isFiat() {
        return this.tokenConfig.isFiat;
    }
    getChain() {
        return this.type;
    }
    getFullName() {
        return this.name;
    }
    getBaseFactor() {
        return String(Math.pow(10, this.decimalPlaces));
    }
    get type() {
        return this.tokenConfig.type;
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    static createTokenConstructor(config) {
        return (bitgo) => new OfcToken(bitgo, config);
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        const txPrebuild = params.txPrebuild;
        const payload = txPrebuild.payload;
        const signatureBuffer = (await this.signMessage(params, payload));
        const signature = signatureBuffer.toString('hex');
        return { halfSigned: { payload, signature } };
    }
    /**
     * Check if an address is valid for this ofc token.
     *
     * These addresses are either bg-<publicid>, where public id is the internal address to send to,
     * or are an address which is valid on the backing coin of this ofc token.
     * @param address address to check for validity
     */
    isValidAddress(address) {
        if (!lodash_1.isString(address)) {
            return false;
        }
        if (address.startsWith('bg-')) {
            const parts = address.split('-');
            const accountId = parts[1];
            return parts.length === 2 && publicIdRegex.test(accountId);
        }
        else {
            const backingCoin = this.bitgo.coin(this.backingCoin);
            return backingCoin.isValidAddress(address);
        }
    }
}
exports.OfcToken = OfcToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjVG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvY29pbnMvb2ZjVG9rZW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0dBRUc7QUFDSCxtQ0FBa0M7QUFJbEMsK0JBQTRCO0FBb0I1QixNQUFNLGFBQWEsR0FBRyxnQkFBZ0IsQ0FBQztBQUN2QyxNQUFhLFFBQVMsU0FBUSxTQUFHO0lBRy9CLFlBQVksS0FBWSxFQUFFLFdBQTJCO1FBQ25ELEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxJQUFJLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDO0lBQ3hDLENBQUM7SUFFRCxJQUFJLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO0lBQ2pDLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRCxhQUFhO1FBQ1gsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVELElBQVcsSUFBSTtRQUNiLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILHdCQUF3QjtRQUN0QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxNQUFNLENBQUMsc0JBQXNCLENBQUMsTUFBc0I7UUFDbEQsT0FBTyxDQUFDLEtBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUE4QjtRQUNsRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1FBQ3JDLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7UUFDbkMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFRLENBQUM7UUFDekUsTUFBTSxTQUFTLEdBQVcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxRCxPQUFPLEVBQUUsVUFBVSxFQUFFLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxFQUFTLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGNBQWMsQ0FBQyxPQUFnQjtRQUM3QixJQUFJLENBQUMsaUJBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN0QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM1RDthQUFNO1lBQ0wsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3RELE9BQU8sV0FBVyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUM1QztJQUNILENBQUM7Q0FDRjtBQXpGRCw0QkF5RkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgQ29pbkNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vY29pbkZhY3RvcnknO1xuaW1wb3J0IHsgT2ZjIH0gZnJvbSAnLi9vZmMnO1xuaW1wb3J0IHsgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IFNpZ25lZFRyYW5zYWN0aW9uIH0gZnJvbSAnLi9ldGgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9mY1Rva2VuQ29uZmlnIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBiYWNraW5nQ29pbjogc3RyaW5nO1xuICBpc0ZpYXQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDoge1xuICAgIHBheWxvYWQ6IHN0cmluZztcbiAgfTtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmNvbnN0IHB1YmxpY0lkUmVnZXggPSAvXlthLWZcXGRdezMyfSQvaTtcbmV4cG9ydCBjbGFzcyBPZmNUb2tlbiBleHRlbmRzIE9mYyB7XG4gIHB1YmxpYyByZWFkb25seSB0b2tlbkNvbmZpZzogT2ZjVG9rZW5Db25maWc7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCB0b2tlbkNvbmZpZzogT2ZjVG9rZW5Db25maWcpIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gICAgdGhpcy50b2tlbkNvbmZpZyA9IHRva2VuQ29uZmlnO1xuICB9XG5cbiAgZ2V0IGNvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuY29pbjtcbiAgfVxuXG4gIGdldCBkZWNpbWFsUGxhY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLmRlY2ltYWxQbGFjZXM7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5uYW1lO1xuICB9XG5cbiAgZ2V0IGJhY2tpbmdDb2luKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLmJhY2tpbmdDb2luO1xuICB9XG5cbiAgZ2V0IGlzRmlhdCgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5pc0ZpYXQ7XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnBvdygxMCwgdGhpcy5kZWNpbWFsUGxhY2VzKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUb2tlbkNvbnN0cnVjdG9yKGNvbmZpZzogT2ZjVG9rZW5Db25maWcpOiBDb2luQ29uc3RydWN0b3Ige1xuICAgIHJldHVybiAoYml0Z286IEJpdEdvKSA9PiBuZXcgT2ZjVG9rZW4oYml0Z28sIGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHhQcmVidWlsZCA9IHBhcmFtcy50eFByZWJ1aWxkO1xuICAgIGNvbnN0IHBheWxvYWQgPSB0eFByZWJ1aWxkLnBheWxvYWQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gKGF3YWl0IHRoaXMuc2lnbk1lc3NhZ2UocGFyYW1zLCBwYXlsb2FkKSkgYXMgYW55O1xuICAgIGNvbnN0IHNpZ25hdHVyZTogc3RyaW5nID0gc2lnbmF0dXJlQnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHBheWxvYWQsIHNpZ25hdHVyZSB9IH0gYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWQgZm9yIHRoaXMgb2ZjIHRva2VuLlxuICAgKlxuICAgKiBUaGVzZSBhZGRyZXNzZXMgYXJlIGVpdGhlciBiZy08cHVibGljaWQ+LCB3aGVyZSBwdWJsaWMgaWQgaXMgdGhlIGludGVybmFsIGFkZHJlc3MgdG8gc2VuZCB0byxcbiAgICogb3IgYXJlIGFuIGFkZHJlc3Mgd2hpY2ggaXMgdmFsaWQgb24gdGhlIGJhY2tpbmcgY29pbiBvZiB0aGlzIG9mYyB0b2tlbi5cbiAgICogQHBhcmFtIGFkZHJlc3MgYWRkcmVzcyB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWlzU3RyaW5nKGFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLnN0YXJ0c1dpdGgoJ2JnLScpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy0nKTtcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IHBhcnRzWzFdO1xuICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBwdWJsaWNJZFJlZ2V4LnRlc3QoYWNjb3VudElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFja2luZ0NvaW4gPSB0aGlzLmJpdGdvLmNvaW4odGhpcy5iYWNraW5nQ29pbik7XG4gICAgICByZXR1cm4gYmFja2luZ0NvaW4uaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICB9XG59XG4iXX0=