"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trx = exports.NodeTypes = exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = void 0;
/**
 * @prettier
 */
const bip32 = require("bip32");
const secp256k1 = require("secp256k1");
const crypto_1 = require("crypto");
const bitgoAccountLib = require("@bitgo/account-lib");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const request = require("superagent");
const sdk_core_1 = require("@bitgo/sdk-core");
const baseCoin_1 = require("../baseCoin");
const initiate_1 = require("../recovery/initiate");
const errors_1 = require("../../errors");
exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1e6;
var NodeTypes;
(function (NodeTypes) {
    NodeTypes[NodeTypes["Full"] = 0] = "Full";
    NodeTypes[NodeTypes["Solidity"] = 1] = "Solidity";
})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));
class Trx extends baseCoin_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /** @inheritdoc */
    transactionDataAllowed() {
        return true;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Trx(bitgo, staticsCoin);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    isValidAddress(address) {
        if (!address) {
            return false;
        }
        return this.isValidHexAddress(address) || bitgoAccountLib.Trx.Utils.isBase58Address(address);
    }
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    isValidHexAddress(address) {
        return address.length === 42 && /^(0x)?([0-9a-f]{2})+$/i.test(address);
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        // TODO: move this and address creation logic to account-lib
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256 bit chain code, both of which must be
            // random. 512 bits is therefore the maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const hd = bip32.fromSeed(seed);
        return {
            pub: hd.neutered().toBase58(),
            prv: hd.toBase58(),
        };
    }
    isValidXpub(xpub) {
        try {
            return bip32.fromBase58(xpub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    isValidPub(pub) {
        if (this.isValidXpub(pub)) {
            // xpubs can be converted into regular pubs, so technically it is a valid pub
            return true;
        }
        return new RegExp('^04[a-zA-Z0-9]{128}$').test(pub);
    }
    async parseTransaction(params) {
        return {};
    }
    isWalletAddress(params) {
        throw new errors_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        return true;
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @returns Bluebird<SignedTransaction>
     */
    async signTransaction(params) {
        const txBuilder = bitgoAccountLib.getBuilder(this.getChain()).from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        const response = {
            txHex: JSON.stringify(transaction.toJson()),
        };
        if (transaction.toJson().signature.length >= 2) {
            return response;
        }
        // Half signed transaction
        return {
            halfSigned: response,
        };
    }
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    isValidXprv(prv) {
        try {
            return !bip32.fromBase58(prv).isNeutered();
        }
        catch {
            return false;
        }
    }
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    toHexString(message) {
        if (typeof message === 'string') {
            return Buffer.from(message).toString('hex');
        }
        else if (Buffer.isBuffer(message)) {
            return message.toString('hex');
        }
        else {
            throw new Error('Invalid messaged passed to signMessage');
        }
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        var _a;
        const toSign = this.toHexString(message);
        let prv = key.prv;
        if (this.isValidXprv(prv)) {
            prv = (_a = bip32.fromBase58(prv).privateKey) === null || _a === void 0 ? void 0 : _a.toString('hex');
        }
        if (!prv) {
            throw new Error('no privateKey');
        }
        let sig = bitgoAccountLib.Trx.Utils.signString(toSign, prv, true);
        // remove the preceding 0x
        sig = sig.replace(/^0x/, '');
        return Buffer.from(sig, 'hex');
    }
    /**
     * Converts an xpub to a uncompressed pub
     * @param xpub
     */
    xpubToUncompressedPub(xpub) {
        if (!this.isValidXpub(xpub)) {
            throw new Error('invalid xpub');
        }
        const publicKey = bip32.fromBase58(xpub, utxo_lib_1.networks.bitcoin).publicKey;
        return Buffer.from(secp256k1.publicKeyConvert(publicKey, false /* compressed */)).toString('hex');
    }
    /**
     * Modify prebuild before sending it to the server.
     * @param buildParams The whitelisted parameters for this prebuild
     */
    async getExtraPrebuildParams(buildParams) {
        if (buildParams.recipients[0].data && buildParams.feeLimit) {
            buildParams.recipients[0].feeLimit = buildParams.feeLimit;
        }
    }
    pubToHexAddress(pub) {
        const byteArrayAddr = bitgoAccountLib.Trx.Utils.getByteArrayFromHexAddress(pub);
        const rawAddress = bitgoAccountLib.Trx.Utils.getRawAddressFromPubKey(byteArrayAddr);
        return bitgoAccountLib.Trx.Utils.getHexAddressFromByteArray(rawAddress);
    }
    xprvToCompressedPrv(xprv) {
        if (!this.isValidXprv(xprv)) {
            throw new Error('invalid xprv');
        }
        const hdNode = bip32.fromBase58(xprv, utxo_lib_1.networks.bitcoin);
        if (!hdNode.privateKey) {
            throw new Error('no privateKey');
        }
        return hdNode.privateKey.toString('hex');
    }
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    async recoveryPost(query) {
        let nodeUri = '';
        switch (query.node) {
            case NodeTypes.Full:
                nodeUri = sdk_core_1.common.Environments[this.bitgo.getEnv()].tronNodes.full;
                break;
            case NodeTypes.Solidity:
                nodeUri = sdk_core_1.common.Environments[this.bitgo.getEnv()].tronNodes.solidity;
                break;
            default:
                throw new Error('node type not found');
        }
        const response = await request
            .post(nodeUri + query.path)
            .type('json')
            .send(query.jsonObj);
        if (!response.ok) {
            throw new Error('could not reach Tron node');
        }
        // unfortunately, it doesn't look like most TRON nodes return valid json as body
        return JSON.parse(response.text);
    }
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @returns {BigNumber} address balance
     */
    async getAccountFromNode(address) {
        return await this.recoveryPost({
            path: '/walletsolidity/getaccount',
            jsonObj: { address },
            node: NodeTypes.Solidity,
        });
    }
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    async getBuildTransaction(toAddr, fromAddr, amount) {
        // our addresses should be base58, we'll have to encode to hex
        return await this.recoveryPost({
            path: '/wallet/createtransaction',
            jsonObj: {
                to_address: toAddr,
                owner_address: fromAddr,
                amount,
            },
            node: NodeTypes.Full,
        });
    }
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keys
     */
    checkPermissions(ownerKeys, keys) {
        keys = keys.map((k) => k.toUpperCase());
        ownerKeys.map((key) => {
            const hexKey = key.address.toUpperCase();
            if (!keys.includes(hexKey)) {
                throw new Error(`pub address ${hexKey} not found in account`);
            }
            if (key.weight !== 1) {
                throw new Error('owner permission is invalid for this structure');
            }
        });
    }
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     */
    async recover(params) {
        const isKrsRecovery = initiate_1.getIsKrsRecovery(params);
        const isUnsignedSweep = initiate_1.getIsUnsignedSweep(params);
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        // get our user, backup keys
        const keys = initiate_1.getBip32Keys(this.bitgo, params, { requireBitGoXpub: false });
        // we need to decode our bitgoKey to a base58 address
        const bitgoHexAddr = this.pubToHexAddress(this.xpubToUncompressedPub(params.bitgoKey));
        const recoveryAddressHex = bitgoAccountLib.Trx.Utils.getHexAddressFromBase58Address(params.recoveryDestination);
        // call the node to get our account balance
        const account = await this.getAccountFromNode(bitgoHexAddr);
        const recoveryAmount = account.balance;
        const userXPub = keys[0].neutered().toBase58();
        const userXPrv = keys[0].toBase58();
        const backupXPub = keys[1].neutered().toBase58();
        // construct the tx -
        // there's an assumption here being made about fees: for a wallet that hasn't been used in awhile, the implication is
        // it has maximum bandwidth. thus, a recovery should cost the minimum amount (1e6 sun or 1 Tron)
        if (exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE > recoveryAmount) {
            throw new Error('Amount of funds to recover wouldnt be able to fund a send');
        }
        const recoveryAmountMinusFees = recoveryAmount - exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE;
        const buildTx = await this.getBuildTransaction(recoveryAddressHex, bitgoHexAddr, recoveryAmountMinusFees);
        const keyHexAddresses = [
            this.pubToHexAddress(this.xpubToUncompressedPub(userXPub)),
            this.pubToHexAddress(this.xpubToUncompressedPub(backupXPub)),
            bitgoHexAddr,
        ];
        // run checks to ensure this is a valid tx - permissions match our signer keys
        this.checkPermissions(account.owner_permission.keys, keyHexAddresses);
        this.checkPermissions(account.active_permission[0].keys, keyHexAddresses);
        // construct our tx
        const txBuilder = bitgoAccountLib.getBuilder(this.getChain()).from(buildTx);
        // this tx should be enough to drop into a node
        if (isUnsignedSweep) {
            return {
                tx: (await txBuilder.build()).toJson(),
                recoveryAmount: recoveryAmountMinusFees,
            };
        }
        const userPrv = this.xprvToCompressedPrv(userXPrv);
        txBuilder.sign({ key: userPrv });
        // krs recoveries don't get signed
        if (!isKrsRecovery) {
            const backupXPrv = keys[1].toBase58();
            const backupPrv = this.xprvToCompressedPrv(backupXPrv);
            txBuilder.sign({ key: backupPrv });
        }
        return {
            tx: (await txBuilder.build()).toJson(),
            recoveryAmount: recoveryAmountMinusFees,
        };
    }
    /**
     * Explain a Tron transaction from txHex
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = bitgoAccountLib.getBuilder(this.getChain()).from(txHex);
        const tx = await txBuilder.build();
        const outputs = [
            {
                amount: tx.outputs[0].value.toString(),
                address: tx.outputs[0].address, // Should turn it into a readable format, aka base58
            },
        ];
        const displayOrder = [
            'id',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'fee',
            'timestamp',
            'expiration',
        ];
        return {
            displayOrder,
            id: tx.id,
            outputs,
            outputAmount: outputs[0].amount,
            changeOutputs: [],
            changeAmount: '0',
            fee: params.feeInfo,
            timestamp: tx.validFrom,
            expiration: tx.validTo,
        };
    }
}
exports.Trx = Trx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3RyeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkMsbUNBQXFDO0FBRXJDLHNEQUFzRDtBQUN0RCw4Q0FBMkM7QUFDM0Msc0NBQXNDO0FBQ3RDLDhDQUF5QztBQUV6QywwQ0FhcUI7QUFHckIsbURBQTBGO0FBQzFGLHlDQUF5RDtBQUU1QyxRQUFBLGlDQUFpQyxHQUFHLEdBQUcsQ0FBQztBQThDckQsSUFBWSxTQUdYO0FBSEQsV0FBWSxTQUFTO0lBQ25CLHlDQUFJLENBQUE7SUFDSixpREFBUSxDQUFBO0FBQ1YsQ0FBQyxFQUhXLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBR3BCO0FBY0QsTUFBYSxHQUFJLFNBQVEsbUJBQVE7SUFHL0IsWUFBWSxLQUFZLEVBQUUsV0FBdUM7UUFDL0QsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsa0JBQWtCO0lB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bnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxIGZyb20gJ3NlY3AyNTZrMSc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBDb2luRmFtaWx5LCBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4gfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgKiBhcyBiaXRnb0FjY291bnRMaWIgZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcbmltcG9ydCB7IG5ldHdvcmtzIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgeyBjb21tb24gfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25GZWUsXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50IGFzIFJlY2lwaWVudCxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IGdldEJpcDMyS2V5cywgZ2V0SXNLcnNSZWNvdmVyeSwgZ2V0SXNVbnNpZ25lZFN3ZWVwIH0gZnJvbSAnLi4vcmVjb3ZlcnkvaW5pdGlhdGUnO1xuaW1wb3J0IHsgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmV4cG9ydCBjb25zdCBNSU5JTVVNX1RST05fTVNJR19UUkFOU0FDVElPTl9GRUUgPSAxZTY7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJvblNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhJbmZvIHtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIGZyb206IHN0cmluZztcbiAgdHhpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIGV4cGlyYXRpb246IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZzsgLy8gdHhIZXggaXMgcG9vcmx5IG5hbWVkIGhlcmU7IGl0IGlzIGp1c3QgYSB3cmFwcGVkIEpTT04gb2JqZWN0XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZzsgLy8gdHhIZXggaXMgcG9vcmx5IG5hbWVkIGhlcmU7IGl0IGlzIGp1c3QgYSB3cmFwcGVkIEpTT04gb2JqZWN0XG4gIH07XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZzsgLy8gQm94IEFcbiAgYmFja3VwS2V5OiBzdHJpbmc7IC8vIEJveCBCXG4gIGJpdGdvS2V5OiBzdHJpbmc7IC8vIEJveCBDIC0gdGhpcyBpcyBiaXRnbydzIHhwdWIgYW5kIHdpbGwgYmUgdXNlZCB0byBkZXJpdmUgdGhlaXIgcm9vdCBhZGRyZXNzXG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZzsgLy8gYmFzZTU4IGFkZHJlc3NcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4OiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICByZWNvdmVyeUFtb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBOb2RlVHlwZXMge1xuICBGdWxsLFxuICBTb2xpZGl0eSxcbn1cblxuLyoqXG4gKiBUaGlzIHN0cnVjdHVyZSBpcyBub3QgYSBjb21wbGV0ZSBtb2RlbCBvZiB0aGUgQWNjb3VudFJlc3BvbnNlIGZyb20gYSBub2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjY291bnRSZXNwb25zZSB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBvd25lcl9wZXJtaXNzaW9uOiB7XG4gICAga2V5czogW2JpdGdvQWNjb3VudExpYi5UcnguSW50ZXJmYWNlLlBlcm1pc3Npb25LZXldO1xuICB9O1xuICBhY3RpdmVfcGVybWlzc2lvbjogW3sga2V5czogW2JpdGdvQWNjb3VudExpYi5UcnguSW50ZXJmYWNlLlBlcm1pc3Npb25LZXldIH1dO1xufVxuXG5leHBvcnQgY2xhc3MgVHJ4IGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBUcngoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGlzIGEgdmFsaWQgYmFzZTU4IG9yIGhleCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykgfHwgYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5pc0Jhc2U1OEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaXMgYSB2YWxpZCBoZXggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzcyBoZXggYWRkcmVzc1xuICAgKi9cbiAgaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFkZHJlc3MubGVuZ3RoID09PSA0MiAmJiAvXigweCk/KFswLTlhLWZdezJ9KSskL2kudGVzdChhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBlZDI1NTE5IGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIsIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgYW5kIGFkZHJlc3MgY3JlYXRpb24gbG9naWMgdG8gYWNjb3VudC1saWJcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2IGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmVcbiAgICAgIC8vIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZSBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSByYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgaGQgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBoZC5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBwcnY6IGhkLnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIGlzVmFsaWRYcHViKHhwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmlwMzIuZnJvbUJhc2U1OCh4cHViKS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkWHB1YihwdWIpKSB7XG4gICAgICAvLyB4cHVicyBjYW4gYmUgY29udmVydGVkIGludG8gcmVndWxhciBwdWJzLCBzbyB0ZWNobmljYWxseSBpdCBpcyBhIHZhbGlkIHB1YlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeMDRbYS16QS1aMC05XXsxMjh9JCcpLnRlc3QocHViKTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGQge09iamVjdH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0LmFkZHJlc3NWZXJzaW9uIHtTdHJpbmd9IHRoaXMgaXMgdGhlIHZlcnNpb24gb2YgdGhlIEFsZ29yYW5kIG11bHRpc2lnIGFkZHJlc3MgZ2VuZXJhdGlvbiBmb3JtYXRcbiAgICogQHJldHVybnMgQmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBUcm9uU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBiaXRnb0FjY291bnRMaWIuZ2V0QnVpbGRlcih0aGlzLmdldENoYWluKCkpLmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICB0eEhleDogSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24udG9Kc29uKCkpLFxuICAgIH07XG4gICAgaWYgKHRyYW5zYWN0aW9uLnRvSnNvbigpLnNpZ25hdHVyZS5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBIYWxmIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgIHJldHVybiB7XG4gICAgICBoYWxmU2lnbmVkOiByZXNwb25zZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IC0gdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqL1xuICBpc1ZhbGlkWHBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gIWJpcDMyLmZyb21CYXNlNTgocHJ2KS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBtZXNzYWdlIHRvIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIHRvIHNpZ25cbiAgICogQHJldHVybiB0aGUgbWVzc2FnZSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgdG9IZXhTdHJpbmcobWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IHRvU2lnbiA9IHRoaXMudG9IZXhTdHJpbmcobWVzc2FnZSk7XG5cbiAgICBsZXQgcHJ2OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBrZXkucHJ2O1xuICAgIGlmICh0aGlzLmlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHBydiA9IGJpcDMyLmZyb21CYXNlNTgocHJ2KS5wcml2YXRlS2V5Py50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJpdmF0ZUtleScpO1xuICAgIH1cbiAgICBsZXQgc2lnID0gYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5zaWduU3RyaW5nKHRvU2lnbiwgcHJ2LCB0cnVlKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgcHJlY2VkaW5nIDB4XG4gICAgc2lnID0gc2lnLnJlcGxhY2UoL14weC8sICcnKTtcblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzaWcsICdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiB4cHViIHRvIGEgdW5jb21wcmVzc2VkIHB1YlxuICAgKiBAcGFyYW0geHB1YlxuICAgKi9cbiAgeHB1YlRvVW5jb21wcmVzc2VkUHViKHhwdWI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRYcHViKHhwdWIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgeHB1YicpO1xuICAgIH1cblxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGJpcDMyLmZyb21CYXNlNTgoeHB1YiwgbmV0d29ya3MuYml0Y29pbikucHVibGljS2V5O1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGZhbHNlIC8qIGNvbXByZXNzZWQgKi8pKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGJlZm9yZSBzZW5kaW5nIGl0IHRvIHRoZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcyBUaGUgd2hpdGVsaXN0ZWQgcGFyYW1ldGVycyBmb3IgdGhpcyBwcmVidWlsZFxuICAgKi9cbiAgYXN5bmMgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoYnVpbGRQYXJhbXMucmVjaXBpZW50c1swXS5kYXRhICYmIGJ1aWxkUGFyYW1zLmZlZUxpbWl0KSB7XG4gICAgICBidWlsZFBhcmFtcy5yZWNpcGllbnRzWzBdLmZlZUxpbWl0ID0gYnVpbGRQYXJhbXMuZmVlTGltaXQ7XG4gICAgfVxuICB9XG5cbiAgcHViVG9IZXhBZGRyZXNzKHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlQXJyYXlBZGRyID0gYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5nZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhwdWIpO1xuICAgIGNvbnN0IHJhd0FkZHJlc3MgPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldFJhd0FkZHJlc3NGcm9tUHViS2V5KGJ5dGVBcnJheUFkZHIpO1xuICAgIHJldHVybiBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldEhleEFkZHJlc3NGcm9tQnl0ZUFycmF5KHJhd0FkZHJlc3MpO1xuICB9XG5cbiAgeHBydlRvQ29tcHJlc3NlZFBydih4cHJ2OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkWHBydih4cHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHhwcnYnKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KHhwcnYsIG5ldHdvcmtzLmJpdGNvaW4pO1xuICAgIGlmICghaGROb2RlLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJpdmF0ZUtleScpO1xuICAgIH1cbiAgICByZXR1cm4gaGROb2RlLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBxdWVyeSB0byBUcm9uZ3JpZCBmb3IgaW5mb3JtYXRpb24gc3VjaCBhcyBiYWxhbmNlLCB0b2tlbiBiYWxhbmNlLCBzb2xpZGl0eSBjYWxsc1xuICAgKiBAcGFyYW0gcXVlcnkge09iamVjdH0ga2V5LXZhbHVlIHBhaXJzIG9mIHBhcmFtZXRlcnMgdG8gYXBwZW5kIGFmdGVyIC9hcGlcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzcG9uc2UgZnJvbSBUcm9uZ3JpZFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWNvdmVyeVBvc3QocXVlcnk6IHsgcGF0aDogc3RyaW5nOyBqc29uT2JqOiBhbnk7IG5vZGU6IE5vZGVUeXBlcyB9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBsZXQgbm9kZVVyaSA9ICcnO1xuICAgIHN3aXRjaCAocXVlcnkubm9kZSkge1xuICAgICAgY2FzZSBOb2RlVHlwZXMuRnVsbDpcbiAgICAgICAgbm9kZVVyaSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLmZ1bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOb2RlVHlwZXMuU29saWRpdHk6XG4gICAgICAgIG5vZGVVcmkgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnRyb25Ob2Rlcy5zb2xpZGl0eTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgdHlwZSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RcbiAgICAgIC5wb3N0KG5vZGVVcmkgKyBxdWVyeS5wYXRoKVxuICAgICAgLnR5cGUoJ2pzb24nKVxuICAgICAgLnNlbmQocXVlcnkuanNvbk9iaik7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFjaCBUcm9uIG5vZGUnKTtcbiAgICB9XG5cbiAgICAvLyB1bmZvcnR1bmF0ZWx5LCBpdCBkb2Vzbid0IGxvb2sgbGlrZSBtb3N0IFRST04gbm9kZXMgcmV0dXJuIHZhbGlkIGpzb24gYXMgYm9keVxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlLnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IG91ciBleHBsb3JlciBmb3IgdGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgYWRkcmVzcyBlbmNvZGVkIGluIGhleFxuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBhZGRyZXNzIGJhbGFuY2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0QWNjb3VudEZyb21Ob2RlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QWNjb3VudFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlQb3N0KHtcbiAgICAgIHBhdGg6ICcvd2FsbGV0c29saWRpdHkvZ2V0YWNjb3VudCcsXG4gICAgICBqc29uT2JqOiB7IGFkZHJlc3MgfSxcbiAgICAgIG5vZGU6IE5vZGVUeXBlcy5Tb2xpZGl0eSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgb3VyIGJ1aWxkIHRyYW5zYWN0aW9uIGZyb20gYSBub2RlLlxuICAgKiBAcGFyYW0gdG9BZGRyIGhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICogQHBhcmFtIGZyb21BZGRyIGhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICogQHBhcmFtIGFtb3VudFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRCdWlsZFRyYW5zYWN0aW9uKFxuICAgIHRvQWRkcjogc3RyaW5nLFxuICAgIGZyb21BZGRyOiBzdHJpbmcsXG4gICAgYW1vdW50OiBudW1iZXJcbiAgKTogUHJvbWlzZTxiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5UcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAvLyBvdXIgYWRkcmVzc2VzIHNob3VsZCBiZSBiYXNlNTgsIHdlJ2xsIGhhdmUgdG8gZW5jb2RlIHRvIGhleFxuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlY292ZXJ5UG9zdCh7XG4gICAgICBwYXRoOiAnL3dhbGxldC9jcmVhdGV0cmFuc2FjdGlvbicsXG4gICAgICBqc29uT2JqOiB7XG4gICAgICAgIHRvX2FkZHJlc3M6IHRvQWRkcixcbiAgICAgICAgb3duZXJfYWRkcmVzczogZnJvbUFkZHIsXG4gICAgICAgIGFtb3VudCxcbiAgICAgIH0sXG4gICAgICBub2RlOiBOb2RlVHlwZXMuRnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IGtleXMgaW4gdGhlIG93bmVyS2V5cyBjb2xsZWN0aW9uIGRvbid0IG1hdGNoIHRoZSBrZXlzIGFycmF5IHdlIHBhc3NcbiAgICogQHBhcmFtIG93bmVyS2V5c1xuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgY2hlY2tQZXJtaXNzaW9ucyhvd25lcktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10sIGtleXM6IHN0cmluZ1tdKSB7XG4gICAga2V5cyA9IGtleXMubWFwKChrKSA9PiBrLnRvVXBwZXJDYXNlKCkpO1xuXG4gICAgb3duZXJLZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBoZXhLZXkgPSBrZXkuYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGhleEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwdWIgYWRkcmVzcyAke2hleEtleX0gbm90IGZvdW5kIGluIGFjY291bnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS53ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvd25lciBwZXJtaXNzaW9uIGlzIGludmFsaWQgZm9yIHRoaXMgc3RydWN0dXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAgICogV2UgbmVlZCB0byBkbyB0aHJlZSBxdWVyaWVzIGR1cmluZyB0aGlzOlxuICAgKiAxKSBOb2RlIHF1ZXJ5IC0gaG93IG11Y2ggbW9uZXkgaXMgaW4gdGhlIGFjY291bnRcbiAgICogMikgQnVpbGQgdHJhbnNhY3Rpb24gLSBidWlsZCBvdXIgdHJhbnNhY3Rpb24gZm9yIHRoZSBhbW91bnRcbiAgICogMykgU2VuZCBzaWduZWQgYnVpbGQgLSBzZW5kIG91ciBzaWduZWQgYnVpbGQgdG8gYSBwdWJsaWMgbm9kZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGdldElzS3JzUmVjb3ZlcnkocGFyYW1zKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgIH1cblxuICAgIC8vIGdldCBvdXIgdXNlciwgYmFja3VwIGtleXNcbiAgICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKHRoaXMuYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiBmYWxzZSB9KTtcblxuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIG91ciBiaXRnb0tleSB0byBhIGJhc2U1OCBhZGRyZXNzXG4gICAgY29uc3QgYml0Z29IZXhBZGRyID0gdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIocGFyYW1zLmJpdGdvS2V5KSk7XG4gICAgY29uc3QgcmVjb3ZlcnlBZGRyZXNzSGV4ID0gYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJhc2U1OEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pO1xuXG4gICAgLy8gY2FsbCB0aGUgbm9kZSB0byBnZXQgb3VyIGFjY291bnQgYmFsYW5jZVxuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmdldEFjY291bnRGcm9tTm9kZShiaXRnb0hleEFkZHIpO1xuICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gYWNjb3VudC5iYWxhbmNlO1xuXG4gICAgY29uc3QgdXNlclhQdWIgPSBrZXlzWzBdLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICBjb25zdCB1c2VyWFBydiA9IGtleXNbMF0udG9CYXNlNTgoKTtcbiAgICBjb25zdCBiYWNrdXBYUHViID0ga2V5c1sxXS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG5cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIHR4IC1cbiAgICAvLyB0aGVyZSdzIGFuIGFzc3VtcHRpb24gaGVyZSBiZWluZyBtYWRlIGFib3V0IGZlZXM6IGZvciBhIHdhbGxldCB0aGF0IGhhc24ndCBiZWVuIHVzZWQgaW4gYXdoaWxlLCB0aGUgaW1wbGljYXRpb24gaXNcbiAgICAvLyBpdCBoYXMgbWF4aW11bSBiYW5kd2lkdGguIHRodXMsIGEgcmVjb3Zlcnkgc2hvdWxkIGNvc3QgdGhlIG1pbmltdW0gYW1vdW50ICgxZTYgc3VuIG9yIDEgVHJvbilcbiAgICBpZiAoTUlOSU1VTV9UUk9OX01TSUdfVFJBTlNBQ1RJT05fRkVFID4gcmVjb3ZlcnlBbW91bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW1vdW50IG9mIGZ1bmRzIHRvIHJlY292ZXIgd291bGRudCBiZSBhYmxlIHRvIGZ1bmQgYSBzZW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50TWludXNGZWVzID0gcmVjb3ZlcnlBbW91bnQgLSBNSU5JTVVNX1RST05fTVNJR19UUkFOU0FDVElPTl9GRUU7XG4gICAgY29uc3QgYnVpbGRUeCA9IGF3YWl0IHRoaXMuZ2V0QnVpbGRUcmFuc2FjdGlvbihyZWNvdmVyeUFkZHJlc3NIZXgsIGJpdGdvSGV4QWRkciwgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMpO1xuXG4gICAgY29uc3Qga2V5SGV4QWRkcmVzc2VzID0gW1xuICAgICAgdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIodXNlclhQdWIpKSxcbiAgICAgIHRoaXMucHViVG9IZXhBZGRyZXNzKHRoaXMueHB1YlRvVW5jb21wcmVzc2VkUHViKGJhY2t1cFhQdWIpKSxcbiAgICAgIGJpdGdvSGV4QWRkcixcbiAgICBdO1xuXG4gICAgLy8gcnVuIGNoZWNrcyB0byBlbnN1cmUgdGhpcyBpcyBhIHZhbGlkIHR4IC0gcGVybWlzc2lvbnMgbWF0Y2ggb3VyIHNpZ25lciBrZXlzXG4gICAgdGhpcy5jaGVja1Blcm1pc3Npb25zKGFjY291bnQub3duZXJfcGVybWlzc2lvbi5rZXlzLCBrZXlIZXhBZGRyZXNzZXMpO1xuICAgIHRoaXMuY2hlY2tQZXJtaXNzaW9ucyhhY2NvdW50LmFjdGl2ZV9wZXJtaXNzaW9uWzBdLmtleXMsIGtleUhleEFkZHJlc3Nlcyk7XG5cbiAgICAvLyBjb25zdHJ1Y3Qgb3VyIHR4XG4gICAgY29uc3QgdHhCdWlsZGVyID0gKGJpdGdvQWNjb3VudExpYi5nZXRCdWlsZGVyKHRoaXMuZ2V0Q2hhaW4oKSkgYXMgYml0Z29BY2NvdW50TGliLlRyeC5XcmFwcGVkQnVpbGRlcikuZnJvbShidWlsZFR4KTtcblxuICAgIC8vIHRoaXMgdHggc2hvdWxkIGJlIGVub3VnaCB0byBkcm9wIGludG8gYSBub2RlXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHg6IChhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKSkudG9Kc29uKCksXG4gICAgICAgIHJlY292ZXJ5QW1vdW50OiByZWNvdmVyeUFtb3VudE1pbnVzRmVlcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgdXNlclBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydih1c2VyWFBydik7XG5cbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogdXNlclBydiB9KTtcblxuICAgIC8vIGtycyByZWNvdmVyaWVzIGRvbid0IGdldCBzaWduZWRcbiAgICBpZiAoIWlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIGNvbnN0IGJhY2t1cFhQcnYgPSBrZXlzWzFdLnRvQmFzZTU4KCk7XG4gICAgICBjb25zdCBiYWNrdXBQcnYgPSB0aGlzLnhwcnZUb0NvbXByZXNzZWRQcnYoYmFja3VwWFBydik7XG5cbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrdXBQcnYgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4OiAoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCkpLnRvSnNvbigpLFxuICAgICAgcmVjb3ZlcnlBbW91bnQ6IHJlY292ZXJ5QW1vdW50TWludXNGZWVzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbiBhIFRyb24gdHJhbnNhY3Rpb24gZnJvbSB0eEhleFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgaWYgKCF0eEhleCB8fCAhcGFyYW1zLmZlZUluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gYml0Z29BY2NvdW50TGliLmdldEJ1aWxkZXIodGhpcy5nZXRDaGFpbigpKS5mcm9tKHR4SGV4KTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IG91dHB1dHMgPSBbXG4gICAgICB7XG4gICAgICAgIGFtb3VudDogdHgub3V0cHV0c1swXS52YWx1ZS50b1N0cmluZygpLFxuICAgICAgICBhZGRyZXNzOiB0eC5vdXRwdXRzWzBdLmFkZHJlc3MsIC8vIFNob3VsZCB0dXJuIGl0IGludG8gYSByZWFkYWJsZSBmb3JtYXQsIGFrYSBiYXNlNThcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFtcbiAgICAgICdpZCcsXG4gICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgJ291dHB1dHMnLFxuICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgJ2ZlZScsXG4gICAgICAndGltZXN0YW1wJyxcbiAgICAgICdleHBpcmF0aW9uJyxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgIGlkOiB0eC5pZCxcbiAgICAgIG91dHB1dHMsXG4gICAgICBvdXRwdXRBbW91bnQ6IG91dHB1dHNbMF0uYW1vdW50LFxuICAgICAgY2hhbmdlT3V0cHV0czogW10sIC8vIGFjY291bnQgYmFzZWQgZG9lcyBub3QgdXNlIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjaGFuZ2VBbW91bnQ6ICcwJywgLy8gYWNjb3VudCBiYXNlIGRvZXMgbm90IG1ha2UgY2hhbmdlXG4gICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgICAgdGltZXN0YW1wOiB0eC52YWxpZEZyb20sXG4gICAgICBleHBpcmF0aW9uOiB0eC52YWxpZFRvLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==