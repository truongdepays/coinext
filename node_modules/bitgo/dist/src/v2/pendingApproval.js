"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingApproval = exports.Type = exports.State = exports.OwnerType = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const _ = require("lodash");
const util_1 = require("./internal/util");
const tssUtils_1 = require("./internal/tssUtils");
const { validateParams } = sdk_core_1.common;
var OwnerType;
(function (OwnerType) {
    OwnerType["WALLET"] = "wallet";
    OwnerType["ENTERPRISE"] = "enterprise";
})(OwnerType = exports.OwnerType || (exports.OwnerType = {}));
var State;
(function (State) {
    State["PENDING"] = "pending";
    State["AWAITING_SIGNATURE"] = "awaitingSignature";
    State["PENDING_BITGO_ADMIN_APPROVAL"] = "pendingBitGoAdminApproval";
    State["PENDING_ID_VERIFICATION"] = "pendingIdVerification";
    State["PENDING_CUSTODIAN_APPROVAL"] = "pendingCustodianApproval";
    State["PENDING_FINAL_APPROVAL"] = "pendingFinalApproval";
    State["APPROVED"] = "approved";
    State["PROCESSING"] = "processing";
    State["REJECTED"] = "rejected";
})(State = exports.State || (exports.State = {}));
var Type;
(function (Type) {
    Type["USER_CHANGE_REQUEST"] = "userChangeRequest";
    Type["TRANSACTION_REQUEST"] = "transactionRequest";
    Type["POLICY_RULE_REQUEST"] = "policyRuleRequest";
    Type["UPDATE_APPROVALS_REQUIRED_REQUEST"] = "updateApprovalsRequiredRequest";
})(Type = exports.Type || (exports.Type = {}));
class PendingApproval {
    constructor(bitgo, baseCoin, pendingApprovalData, wallet) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this.wallet = wallet;
        this.tssUtils = new tssUtils_1.TssUtils(this.bitgo, this.baseCoin, wallet);
        this._pendingApproval = pendingApprovalData;
    }
    /**
     * Get the id for this PendingApproval
     */
    id() {
        return this._pendingApproval.id;
    }
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    ownerType() {
        if (this._pendingApproval.wallet) {
            return OwnerType.WALLET;
        }
        else if (this._pendingApproval.enterprise) {
            return OwnerType.ENTERPRISE;
        }
        else {
            throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
        }
    }
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    walletId() {
        return this._pendingApproval.wallet;
    }
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    enterpriseId() {
        return this._pendingApproval.enterprise;
    }
    /**
     * Get the state of this PendingApproval
     */
    state() {
        return this._pendingApproval.state;
    }
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    creator() {
        return this._pendingApproval.creator;
    }
    /**
     * Get the type of the pending approval (what it approves)
     */
    type() {
        if (!this._pendingApproval.info) {
            throw new Error('pending approval info is not available');
        }
        return this._pendingApproval.info.type;
    }
    /**
     * Get information about this PendingApproval
     */
    info() {
        return this._pendingApproval.info;
    }
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    approvalsRequired() {
        return this._pendingApproval.approvalsRequired || 1;
    }
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    url(extra = '') {
        return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
    }
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     */
    async get(params = {}) {
        this._pendingApproval = await this.bitgo.get(this.url()).result();
        return this;
    }
    /**
     * Helper function to ensure that self.wallet is set
     */
    async populateWallet() {
        const transactionRequest = this.info().transactionRequest;
        if (_.isUndefined(transactionRequest)) {
            throw new Error('missing required object property transactionRequest');
        }
        if (_.isUndefined(this.wallet)) {
            const updatedWallet = await this.baseCoin.wallets().get({ id: transactionRequest.sourceWallet });
            if (_.isUndefined(updatedWallet)) {
                throw new Error('unexpected - unable to get wallet using sourcewallet');
            }
            this.wallet = updatedWallet;
        }
        if (this.wallet.id() !== transactionRequest.sourceWallet) {
            throw new Error('unexpected source wallet for pending approval');
        }
        // otherwise returns undefined
        return;
    }
    /**
     * Sets this PendingApproval to an approved state
     */
    async approve(params = {}) {
        validateParams(params, [], ['walletPassphrase', 'otp']);
        let canRecreateTransaction = true;
        /*
         * Cold wallets cannot recreate transactions if the only thing provided is the wallet passphrase
         *
         * The transaction can be recreated if either
         * – there is an xprv
         * – there is a walletPassphrase and the wallet is not cold (because if it's cold, the passphrase is of little use)
         *
         * Therefore, if neither of these is true, the transaction cannot be recreated, which is reflected in the if
         * statement below.
         */
        const isColdWallet = !!_.get(this.wallet, '_wallet.isCold');
        const isOFCWallet = this.baseCoin.getFamily() === 'ofc'; // Off-chain transactions don't need to be rebuilt
        if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
            canRecreateTransaction = false;
        }
        const reqId = new util_1.RequestTracer();
        /*
         * Internal helper function to get the serialized transaction which is being approved
         */
        const getApprovalTransaction = async () => {
            if (this.type() === 'transactionRequest') {
                /*
                 * If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
                 * (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
                 * be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
                 * such as newer unspents, different fees, or a higher sequence id
                 */
                if (params.tx) {
                    // the approval tx was reconstructed and explicitly specified - pass it through
                    return {
                        txHex: params.tx,
                    };
                }
                const transaction = _.get(this.info(), `transactionRequest.coinSpecific.${this.baseCoin.type}`);
                // this user may not have spending privileges or a passphrase may not have been passed in
                if (!canRecreateTransaction) {
                    if (!_.isObject(transaction)) {
                        throw new Error('there is neither an original transaction object nor can a new one be recreated');
                    }
                    return transaction;
                }
                this.bitgo.setRequestTracer(reqId);
                await this.populateWallet();
                if (this._pendingApproval.txRequestId) {
                    return await this.recreateAndSignTSSTransaction(params, reqId);
                }
                return await this.recreateAndSignTransaction(params);
            }
        };
        /*
         * Internal helper function to prepare the approval payload and send it to bitgo
         */
        const sendApproval = (transaction) => {
            const approvalParams = { state: 'approved', otp: params.otp };
            if (transaction) {
                // if the transaction already has a half signed property, we take that directly
                approvalParams.halfSigned = transaction.halfSigned || transaction;
            }
            this.bitgo.setRequestTracer(reqId);
            return this.bitgo.put(this.url()).send(approvalParams).result();
        };
        try {
            const approvalTransaction = (await getApprovalTransaction());
            this.bitgo.setRequestTracer(reqId);
            return await sendApproval(approvalTransaction);
        }
        catch (e) {
            if (!canRecreateTransaction &&
                (e.message.indexOf('could not find unspent output for input') !== -1 ||
                    e.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
                throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
            }
            throw e;
        }
    }
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     */
    async reject(params = {}) {
        return await this.bitgo.put(this.url()).send({ state: 'rejected' }).result();
    }
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     */
    async cancel(params = {}) {
        return await this.reject(params);
    }
    /**
     * Recreate and sign TSS transaction
     * @param {ApproveOptions} params needed to get txs and use the walletPassphrase to tss sign
     * @param {RequestTracer} reqId id tracer.
     */
    async recreateAndSignTSSTransaction(params, reqId) {
        const { walletPassphrase } = params;
        const txRequestId = this._pendingApproval.txRequestId;
        if (!this.wallet) {
            throw new Error('Wallet not found');
        }
        if (!walletPassphrase) {
            throw new Error('walletPassphrase not found');
        }
        if (!txRequestId) {
            throw new Error('txRequestId not found');
        }
        const decryptedPrv = await this.wallet.getPrv({ walletPassphrase });
        const txRequest = await this.tssUtils.recreateTxRequest(txRequestId, decryptedPrv, reqId);
        return {
            txHex: txRequest.unsignedTxs[0].serializedTxHex,
        };
    }
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     */
    async recreateAndSignTransaction(params = {}) {
        // this method only makes sense with existing transaction requests
        const transactionRequest = this.info().transactionRequest;
        if (_.isUndefined(transactionRequest)) {
            throw new Error('cannot recreate transaction without transaction request');
        }
        if (_.isUndefined(this.wallet)) {
            throw new Error('cannot recreate transaction without wallet');
        }
        const originalPrebuild = transactionRequest.coinSpecific[this.baseCoin.type];
        const recipients = transactionRequest.recipients;
        const prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
        if (!_.isUndefined(originalPrebuild.hopTransaction)) {
            prebuildParams.hop = true;
        }
        if (transactionRequest.buildParams && transactionRequest.buildParams.type === 'consolidate') {
            // consolidate tag is in the build params - this is a consolidation transaction, so
            // it needs to be rebuilt using the special consolidation build route
            prebuildParams.prebuildTx = await this.bitgo
                .post(this.wallet.url(`/consolidateUnspents`))
                .send(prebuildParams)
                .result();
            delete prebuildParams.recipients;
        }
        const signedTransaction = await this.wallet.prebuildAndSignTransaction(prebuildParams);
        // compare PAYGo fees
        const originalParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: originalPrebuild,
        }));
        const recreatedParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: signedTransaction,
        }));
        if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            return signedTransaction;
        }
        if (!_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            throw new Error('implicit external spend amount could not be determined');
        }
        if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) &&
            recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount) {
            throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
        }
        return signedTransaction;
    }
}
exports.PendingApproval = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3BlbmRpbmdBcHByb3ZhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFJQSw4Q0FBeUM7QUFDekMsNEJBQTRCO0FBQzVCLDBDQUFnRDtBQUloRCxrREFBK0M7QUFFL0MsTUFBTSxFQUFFLGNBQWMsRUFBRSxHQUFHLGlCQUFNLENBQUM7QUF5QmxDLElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQiw4QkFBaUIsQ0FBQTtJQUNqQixzQ0FBeUIsQ0FBQTtBQUMzQixDQUFDLEVBSFcsU0FBUyxHQUFULGlCQUFTLEtBQVQsaUJBQVMsUUFHcEI7QUFFRCxJQUFZLEtBVVg7QUFWRCxXQUFZLEtBQUs7SUFDZiw0QkFBbUIsQ0FBQTtJQUNuQixpREFBd0MsQ0FBQTtJQUN4QyxtRUFBMEQsQ0FBQTtJQUMxRCwwREFBaUQsQ0FBQTtJQUNqRCxnRUFBdUQsQ0FBQTtJQUN2RCx3REFBK0MsQ0FBQTtJQUMvQyw4QkFBcUIsQ0FBQTtJQUNyQixrQ0FBeUIsQ0FBQTtJQUN6Qiw4QkFBcUIsQ0FBQTtBQUN2QixDQUFDLEVBVlcsS0FBSyxHQUFMLGFBQUssS0FBTCxhQUFLLFFBVWhCO0FBRUQsSUFBWSxJQUtYO0FBTEQsV0FBWSxJQUFJO0lBQ2QsaURBQXlDLENBQUE7SUFDekMsa0RBQTBDLENBQUE7SUFDMUMsaURBQXlDLENBQUE7SUFDekMsNEVBQW9FLENBQUE7QUFDdEUsQ0FBQyxFQUxXLElBQUksR0FBSixZQUFJLEtBQUosWUFBSSxRQUtmO0FBU0QsTUFBYSxlQUFlO0lBTzFCLFlBQVksS0FBWSxFQUFFLFFBQWtCLEVBQUUsbUJBQXdDLEVBQUUsTUFBZTtRQUNyRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztR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Q0FBQztZQUN0RSxRQUFRLEVBQUUsY0FBYztZQUN4QixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsVUFBVSxFQUFFLGdCQUFnQjtTQUM3QixDQUFDLENBQVEsQ0FBQztRQUNYLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUM7WUFDdkUsUUFBUSxFQUFFLGNBQWM7WUFDeEIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLFVBQVUsRUFBRSxpQkFBaUI7U0FDOUIsQ0FBQyxDQUFRLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUMsMkJBQTJCLENBQUMsRUFBRTtZQUN6RSxPQUFPLGlCQUFpQixDQUFDO1NBQzFCO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsMEJBQTBCLENBQUMsMkJBQTJCLENBQUMsRUFBRTtZQUN2RSxNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7U0FDM0U7UUFDRCxJQUNFLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyx5QkFBeUIsQ0FBQywyQkFBMkIsQ0FBQztZQUNyRSwwQkFBMEIsQ0FBQywyQkFBMkIsR0FBRyx5QkFBeUIsQ0FBQywyQkFBMkIsRUFDOUc7WUFDQSxNQUFNLElBQUksS0FBSyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7U0FDOUU7UUFDRCxPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7Q0FDRjtBQXBWRCwwQ0FvVkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCB7IGNvbW1vbiB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsJztcblxuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnO1xuaW1wb3J0IHsgQmFzZUNvaW4gfSBmcm9tICcuL2Jhc2VDb2luJztcbmltcG9ydCB7IFRzc1V0aWxzIH0gZnJvbSAnLi9pbnRlcm5hbC90c3NVdGlscyc7XG5cbmNvbnN0IHsgdmFsaWRhdGVQYXJhbXMgfSA9IGNvbW1vbjtcbmV4cG9ydCBpbnRlcmZhY2UgUGVuZGluZ0FwcHJvdmFsSW5mbyB7XG4gIHR5cGU6IFR5cGU7XG4gIHRyYW5zYWN0aW9uUmVxdWVzdD86IHtcbiAgICBjb2luU3BlY2lmaWM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gICAgcmVjaXBpZW50czogYW55O1xuICAgIGJ1aWxkUGFyYW1zOiB7XG4gICAgICB0eXBlPzogJ2Zhbm91dCcgfCAnY29uc29saWRhdGUnO1xuICAgICAgW2luZGV4OiBzdHJpbmddOiBhbnk7XG4gICAgfTtcbiAgICBzb3VyY2VXYWxsZXQ/OiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVuZGluZ0FwcHJvdmFsRGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIHdhbGxldD86IHN0cmluZztcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgc3RhdGU6IFN0YXRlO1xuICBjcmVhdG9yOiBzdHJpbmc7XG4gIGluZm86IFBlbmRpbmdBcHByb3ZhbEluZm87XG4gIGFwcHJvdmFsc1JlcXVpcmVkPzogbnVtYmVyO1xuICB0eFJlcXVlc3RJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGVudW0gT3duZXJUeXBlIHtcbiAgV0FMTEVUID0gJ3dhbGxldCcsXG4gIEVOVEVSUFJJU0UgPSAnZW50ZXJwcmlzZScsXG59XG5cbmV4cG9ydCBlbnVtIFN0YXRlIHtcbiAgUEVORElORyA9ICdwZW5kaW5nJyxcbiAgQVdBSVRJTkdfU0lHTkFUVVJFID0gJ2F3YWl0aW5nU2lnbmF0dXJlJyxcbiAgUEVORElOR19CSVRHT19BRE1JTl9BUFBST1ZBTCA9ICdwZW5kaW5nQml0R29BZG1pbkFwcHJvdmFsJyxcbiAgUEVORElOR19JRF9WRVJJRklDQVRJT04gPSAncGVuZGluZ0lkVmVyaWZpY2F0aW9uJyxcbiAgUEVORElOR19DVVNUT0RJQU5fQVBQUk9WQUwgPSAncGVuZGluZ0N1c3RvZGlhbkFwcHJvdmFsJyxcbiAgUEVORElOR19GSU5BTF9BUFBST1ZBTCA9ICdwZW5kaW5nRmluYWxBcHByb3ZhbCcsXG4gIEFQUFJPVkVEID0gJ2FwcHJvdmVkJyxcbiAgUFJPQ0VTU0lORyA9ICdwcm9jZXNzaW5nJyxcbiAgUkVKRUNURUQgPSAncmVqZWN0ZWQnLFxufVxuXG5leHBvcnQgZW51bSBUeXBlIHtcbiAgVVNFUl9DSEFOR0VfUkVRVUVTVCA9ICd1c2VyQ2hhbmdlUmVxdWVzdCcsXG4gIFRSQU5TQUNUSU9OX1JFUVVFU1QgPSAndHJhbnNhY3Rpb25SZXF1ZXN0JyxcbiAgUE9MSUNZX1JVTEVfUkVRVUVTVCA9ICdwb2xpY3lSdWxlUmVxdWVzdCcsXG4gIFVQREFURV9BUFBST1ZBTFNfUkVRVUlSRURfUkVRVUVTVCA9ICd1cGRhdGVBcHByb3ZhbHNSZXF1aXJlZFJlcXVlc3QnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwcHJvdmVPcHRpb25zIHtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICB0eD86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFBlbmRpbmdBcHByb3ZhbCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcbiAgcHJpdmF0ZSB0c3NVdGlsczogVHNzVXRpbHM7XG4gIHByaXZhdGUgd2FsbGV0PzogV2FsbGV0O1xuICBwcml2YXRlIF9wZW5kaW5nQXBwcm92YWw6IFBlbmRpbmdBcHByb3ZhbERhdGE7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4sIHBlbmRpbmdBcHByb3ZhbERhdGE6IFBlbmRpbmdBcHByb3ZhbERhdGEsIHdhbGxldD86IFdhbGxldCkge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy50c3NVdGlscyA9IG5ldyBUc3NVdGlscyh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3YWxsZXQpO1xuICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbCA9IHBlbmRpbmdBcHByb3ZhbERhdGE7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpZCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG93bmVyIHR5cGUgKHdhbGxldCBvciBlbnRlcnByaXNlKVxuICAgKiBQZW5kaW5nIGFwcHJvdmFscyBjYW4gYmUgYXBwcm92ZWQgb3IgbW9kaWZpZWQgYnkgZGlmZmVyZW50IHNjb3BlcyAoZGVwZW5kaW5nIG9uIGhvdyB0aGV5IHdlcmUgY3JlYXRlZClcbiAgICogSWYgYSBwZW5kaW5nIGFwcHJvdmFsIGlzIG93bmVkIGJ5IGEgd2FsbGV0LCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgd2FsbGV0XG4gICAqIElmIGEgcGVuZGluZyBhcHByb3ZhbCBpcyBvd25lZCBieSBhbiBlbnRlcnByaXNlLCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgZW50ZXJwcmlzZVxuICAgKi9cbiAgb3duZXJUeXBlKCk6IE93bmVyVHlwZSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC53YWxsZXQpIHtcbiAgICAgIHJldHVybiBPd25lclR5cGUuV0FMTEVUO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2UpIHtcbiAgICAgIHJldHVybiBPd25lclR5cGUuRU5URVJQUklTRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBlbmRpbmcgYXBwcm92YWwgb3duZXI6IG5laXRoZXIgd2FsbGV0IG5vciBlbnRlcnByaXNlIHdhcyBwcmVzZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgb2YgdGhlIHdhbGxldCB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIHdhbGxldElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC53YWxsZXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbnRlcnByaXNlIElEIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBlbnRlcnByaXNlSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgc3RhdGUoKTogU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IHBlcmZvcm1lZCB0aGUgYWN0aW9uIHJlc3VsdGluZyBpbiB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgY3JlYXRvcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuY3JlYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhlIHBlbmRpbmcgYXBwcm92YWwgKHdoYXQgaXQgYXBwcm92ZXMpXG4gICAqL1xuICB0eXBlKCk6IFR5cGUge1xuICAgIGlmICghdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGVuZGluZyBhcHByb3ZhbCBpbmZvIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm8udHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGluZm8oKTogUGVuZGluZ0FwcHJvdmFsSW5mbyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyB0aGF0IGFyZSByZXF1aXJlZCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWwgdG8gYmUgYXBwcm92ZWQuXG4gICAqIERlZmF1bHRzIHRvIDEgaWYgYXBwcm92YWxzUmVxdWlyZWQgZG9lc24ndCBleGlzdCBvbiB0aGUgb2JqZWN0XG4gICAqL1xuICBhcHByb3ZhbHNSZXF1aXJlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuYXBwcm92YWxzUmVxdWlyZWQgfHwgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVybCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWwgZm9yIG1ha2luZyByZXF1ZXN0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0gZXh0cmFcbiAgICovXG4gIHVybChleHRyYSA9ICcnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi51cmwoJy9wZW5kaW5nYXBwcm92YWxzLycgKyB0aGlzLmlkKCkgKyBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmZXRjaGVzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIGZyb20gdGhlIHNlcnZlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbXV0YXRlcyB0aGUgUGVuZGluZ0FwcHJvdmFsIG9iamVjdCBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtczogUmVjb3JkPHN0cmluZywgbmV2ZXI+ID0ge30pOiBQcm9taXNlPFBlbmRpbmdBcHByb3ZhbD4ge1xuICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbCA9IGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCkpLnJlc3VsdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCBzZWxmLndhbGxldCBpcyBzZXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcG9wdWxhdGVXYWxsZXQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB0aGlzLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb25SZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCBwcm9wZXJ0eSB0cmFuc2FjdGlvblJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLndhbGxldCkpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRXYWxsZXQ6IFdhbGxldCA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ud2FsbGV0cygpLmdldCh7IGlkOiB0cmFuc2FjdGlvblJlcXVlc3Quc291cmNlV2FsbGV0IH0pO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh1cGRhdGVkV2FsbGV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgLSB1bmFibGUgdG8gZ2V0IHdhbGxldCB1c2luZyBzb3VyY2V3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy53YWxsZXQgPSB1cGRhdGVkV2FsbGV0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLndhbGxldC5pZCgpICE9PSB0cmFuc2FjdGlvblJlcXVlc3Quc291cmNlV2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc291cmNlIHdhbGxldCBmb3IgcGVuZGluZyBhcHByb3ZhbCcpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZFxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGFuIGFwcHJvdmVkIHN0YXRlXG4gICAqL1xuICBhc3luYyBhcHByb3ZlKHBhcmFtczogQXBwcm92ZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgdmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ290cCddKTtcblxuICAgIGxldCBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAvKlxuICAgICAqIENvbGQgd2FsbGV0cyBjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIGlmIHRoZSBvbmx5IHRoaW5nIHByb3ZpZGVkIGlzIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgICAqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIGNhbiBiZSByZWNyZWF0ZWQgaWYgZWl0aGVyXG4gICAgICog4oCTIHRoZXJlIGlzIGFuIHhwcnZcbiAgICAgKiDigJMgdGhlcmUgaXMgYSB3YWxsZXRQYXNzcGhyYXNlIGFuZCB0aGUgd2FsbGV0IGlzIG5vdCBjb2xkIChiZWNhdXNlIGlmIGl0J3MgY29sZCwgdGhlIHBhc3NwaHJhc2UgaXMgb2YgbGl0dGxlIHVzZSlcbiAgICAgKlxuICAgICAqIFRoZXJlZm9yZSwgaWYgbmVpdGhlciBvZiB0aGVzZSBpcyB0cnVlLCB0aGUgdHJhbnNhY3Rpb24gY2Fubm90IGJlIHJlY3JlYXRlZCwgd2hpY2ggaXMgcmVmbGVjdGVkIGluIHRoZSBpZlxuICAgICAqIHN0YXRlbWVudCBiZWxvdy5cbiAgICAgKi9cbiAgICBjb25zdCBpc0NvbGRXYWxsZXQgPSAhIV8uZ2V0KHRoaXMud2FsbGV0LCAnX3dhbGxldC5pc0NvbGQnKTtcbiAgICBjb25zdCBpc09GQ1dhbGxldCA9IHRoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdvZmMnOyAvLyBPZmYtY2hhaW4gdHJhbnNhY3Rpb25zIGRvbid0IG5lZWQgdG8gYmUgcmVidWlsdFxuICAgIGlmICghcGFyYW1zLnhwcnYgJiYgIShwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAmJiAhaXNDb2xkV2FsbGV0ICYmICFpc09GQ1dhbGxldCkpIHtcbiAgICAgIGNhblJlY3JlYXRlVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXFJZCA9IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG5cbiAgICAvKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gd2hpY2ggaXMgYmVpbmcgYXBwcm92ZWRcbiAgICAgKi9cbiAgICBjb25zdCBnZXRBcHByb3ZhbFRyYW5zYWN0aW9uID0gYXN5bmMgKCk6IFByb21pc2U8eyB0eEhleDogc3RyaW5nIH0gfCB1bmRlZmluZWQ+ID0+IHtcbiAgICAgIGlmICh0aGlzLnR5cGUoKSA9PT0gJ3RyYW5zYWN0aW9uUmVxdWVzdCcpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhpcyBpcyBhIHJlcXVlc3QgZm9yIGFwcHJvdmluZyBhIHRyYW5zYWN0aW9uLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGlzIHVzZXIgaGFzIGEgcHJpdmF0ZSBrZXkgdG8gdGhlIHdhbGxldFxuICAgICAgICAgKiAoc29tZSBhZG1pbnMgbWF5IG5vdCBoYXZlIHRoZSBzcGVuZCBwZXJtaXNzaW9uKSwgdGhlIHRyYW5zYWN0aW9uIGNvdWxkIGVpdGhlciBiZSByZWJyb2FkY2FzdCBhcyBpcywgb3IgaXQgY291bGRcbiAgICAgICAgICogYmUgcmVjb25zdHJ1Y3RlZC4gSXQgaXMgcHJlZmVyYWJsZSB0byByZWNvbnN0cnVjdCBhIHR4IGluIG9yZGVyIHRvIGFkaGVyZSB0byB0aGUgbGF0ZXN0IG5ldHdvcmsgY29uZGl0aW9uc1xuICAgICAgICAgKiBzdWNoIGFzIG5ld2VyIHVuc3BlbnRzLCBkaWZmZXJlbnQgZmVlcywgb3IgYSBoaWdoZXIgc2VxdWVuY2UgaWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChwYXJhbXMudHgpIHtcbiAgICAgICAgICAvLyB0aGUgYXBwcm92YWwgdHggd2FzIHJlY29uc3RydWN0ZWQgYW5kIGV4cGxpY2l0bHkgc3BlY2lmaWVkIC0gcGFzcyBpdCB0aHJvdWdoXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4SGV4OiBwYXJhbXMudHgsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gXy5nZXQodGhpcy5pbmZvKCksIGB0cmFuc2FjdGlvblJlcXVlc3QuY29pblNwZWNpZmljLiR7dGhpcy5iYXNlQ29pbi50eXBlfWApIGFzIHtcbiAgICAgICAgICB0eEhleDogc3RyaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoaXMgdXNlciBtYXkgbm90IGhhdmUgc3BlbmRpbmcgcHJpdmlsZWdlcyBvciBhIHBhc3NwaHJhc2UgbWF5IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGluXG4gICAgICAgIGlmICghY2FuUmVjcmVhdGVUcmFuc2FjdGlvbikge1xuICAgICAgICAgIGlmICghXy5pc09iamVjdCh0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlcmUgaXMgbmVpdGhlciBhbiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBvYmplY3Qgbm9yIGNhbiBhIG5ldyBvbmUgYmUgcmVjcmVhdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMucG9wdWxhdGVXYWxsZXQoKTtcblxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0FwcHJvdmFsLnR4UmVxdWVzdElkKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjcmVhdGVBbmRTaWduVFNTVHJhbnNhY3Rpb24ocGFyYW1zLCByZXFJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjcmVhdGVBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gcHJlcGFyZSB0aGUgYXBwcm92YWwgcGF5bG9hZCBhbmQgc2VuZCBpdCB0byBiaXRnb1xuICAgICAqL1xuICAgIGNvbnN0IHNlbmRBcHByb3ZhbCA9ICh0cmFuc2FjdGlvbjogeyB0eEhleDogc3RyaW5nOyBoYWxmU2lnbmVkPzogc3RyaW5nIH0pOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgY29uc3QgYXBwcm92YWxQYXJhbXM6IGFueSA9IHsgc3RhdGU6ICdhcHByb3ZlZCcsIG90cDogcGFyYW1zLm90cCB9O1xuICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIGlmIHRoZSB0cmFuc2FjdGlvbiBhbHJlYWR5IGhhcyBhIGhhbGYgc2lnbmVkIHByb3BlcnR5LCB3ZSB0YWtlIHRoYXQgZGlyZWN0bHlcbiAgICAgICAgYXBwcm92YWxQYXJhbXMuaGFsZlNpZ25lZCA9IHRyYW5zYWN0aW9uLmhhbGZTaWduZWQgfHwgdHJhbnNhY3Rpb247XG4gICAgICB9XG4gICAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgcmV0dXJuIHRoaXMuYml0Z28ucHV0KHRoaXMudXJsKCkpLnNlbmQoYXBwcm92YWxQYXJhbXMpLnJlc3VsdCgpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYXBwcm92YWxUcmFuc2FjdGlvbiA9IChhd2FpdCBnZXRBcHByb3ZhbFRyYW5zYWN0aW9uKCkpIGFzIGFueTtcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICByZXR1cm4gYXdhaXQgc2VuZEFwcHJvdmFsKGFwcHJvdmFsVHJhbnNhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWNhblJlY3JlYXRlVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgKGUubWVzc2FnZS5pbmRleE9mKCdjb3VsZCBub3QgZmluZCB1bnNwZW50IG91dHB1dCBmb3IgaW5wdXQnKSAhPT0gLTEgfHxcbiAgICAgICAgICBlLm1lc3NhZ2UuaW5kZXhPZigndHJhbnNhY3Rpb24gY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24gaW4gdGhlIHNlbmQgcXVldWUnKSAhPT0gLTEpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNwZW50cyBleHBpcmVkLCB3YWxsZXQgcGFzc3BocmFzZSBvciB4cHJ2IHJlcXVpcmVkIHRvIHJlY3JlYXRlIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGEgcmVqZWN0ZWQgc3RhdGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgcmVqZWN0KHBhcmFtczogUmVjb3JkPHN0cmluZywgbmV2ZXI+ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLnB1dCh0aGlzLnVybCgpKS5zZW5kKHsgc3RhdGU6ICdyZWplY3RlZCcgfSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIFBlbmRpbmdBcHByb3ZhbC5yZWplY3QoKVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBjYW5jZWwocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVqZWN0KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVjcmVhdGUgYW5kIHNpZ24gVFNTIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXBwcm92ZU9wdGlvbnN9IHBhcmFtcyBuZWVkZWQgdG8gZ2V0IHR4cyBhbmQgdXNlIHRoZSB3YWxsZXRQYXNzcGhyYXNlIHRvIHRzcyBzaWduXG4gICAqIEBwYXJhbSB7UmVxdWVzdFRyYWNlcn0gcmVxSWQgaWQgdHJhY2VyLlxuICAgKi9cbiAgYXN5bmMgcmVjcmVhdGVBbmRTaWduVFNTVHJhbnNhY3Rpb24ocGFyYW1zOiBBcHByb3ZlT3B0aW9ucywgcmVxSWQ6IFJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPHsgdHhIZXg6IHN0cmluZyB9PiB7XG4gICAgY29uc3QgeyB3YWxsZXRQYXNzcGhyYXNlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHhSZXF1ZXN0SWQgPSB0aGlzLl9wZW5kaW5nQXBwcm92YWwudHhSZXF1ZXN0SWQ7XG5cbiAgICBpZiAoIXRoaXMud2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXdhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0UGFzc3BocmFzZSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXR4UmVxdWVzdElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4UmVxdWVzdElkIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY3J5cHRlZFBydiA9IGF3YWl0IHRoaXMud2FsbGV0LmdldFBydih7IHdhbGxldFBhc3NwaHJhc2UgfSk7XG4gICAgY29uc3QgdHhSZXF1ZXN0ID0gYXdhaXQgdGhpcy50c3NVdGlscy5yZWNyZWF0ZVR4UmVxdWVzdCh0eFJlcXVlc3RJZCwgZGVjcnlwdGVkUHJ2LCByZXFJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiB0eFJlcXVlc3QudW5zaWduZWRUeHNbMF0uc2VyaWFsaXplZFR4SGV4LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVjcmVhdGUgYSB0cmFuc2FjdGlvbiBmb3IgYSBwZW5kaW5nIGFwcHJvdmFsIHRvIHJlc3BvbmQgdG8gdXBkYXRlZCBuZXR3b3JrIGNvbmRpdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgcmVjcmVhdGVBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBhbnkgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgLy8gdGhpcyBtZXRob2Qgb25seSBtYWtlcyBzZW5zZSB3aXRoIGV4aXN0aW5nIHRyYW5zYWN0aW9uIHJlcXVlc3RzXG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZXF1ZXN0ID0gdGhpcy5pbmZvKCkudHJhbnNhY3Rpb25SZXF1ZXN0O1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHRyYW5zYWN0aW9uUmVxdWVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlY3JlYXRlIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gcmVxdWVzdCcpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMud2FsbGV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb24gd2l0aG91dCB3YWxsZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnaW5hbFByZWJ1aWxkID0gdHJhbnNhY3Rpb25SZXF1ZXN0LmNvaW5TcGVjaWZpY1t0aGlzLmJhc2VDb2luLnR5cGVdO1xuXG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHRyYW5zYWN0aW9uUmVxdWVzdC5yZWNpcGllbnRzO1xuICAgIGNvbnN0IHByZWJ1aWxkUGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcywgeyByZWNpcGllbnRzOiByZWNpcGllbnRzIH0sIHRyYW5zYWN0aW9uUmVxdWVzdC5idWlsZFBhcmFtcyk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQob3JpZ2luYWxQcmVidWlsZC5ob3BUcmFuc2FjdGlvbikpIHtcbiAgICAgIHByZWJ1aWxkUGFyYW1zLmhvcCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zYWN0aW9uUmVxdWVzdC5idWlsZFBhcmFtcyAmJiB0cmFuc2FjdGlvblJlcXVlc3QuYnVpbGRQYXJhbXMudHlwZSA9PT0gJ2NvbnNvbGlkYXRlJykge1xuICAgICAgLy8gY29uc29saWRhdGUgdGFnIGlzIGluIHRoZSBidWlsZCBwYXJhbXMgLSB0aGlzIGlzIGEgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbiwgc29cbiAgICAgIC8vIGl0IG5lZWRzIHRvIGJlIHJlYnVpbHQgdXNpbmcgdGhlIHNwZWNpYWwgY29uc29saWRhdGlvbiBidWlsZCByb3V0ZVxuICAgICAgcHJlYnVpbGRQYXJhbXMucHJlYnVpbGRUeCA9IGF3YWl0IHRoaXMuYml0Z29cbiAgICAgICAgLnBvc3QodGhpcy53YWxsZXQudXJsKGAvY29uc29saWRhdGVVbnNwZW50c2ApKVxuICAgICAgICAuc2VuZChwcmVidWlsZFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgZGVsZXRlIHByZWJ1aWxkUGFyYW1zLnJlY2lwaWVudHM7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLndhbGxldC5wcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwcmVidWlsZFBhcmFtcyk7XG4gICAgLy8gY29tcGFyZSBQQVlHbyBmZWVzXG4gICAgY29uc3Qgb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgd2FsbGV0OiB0aGlzLndhbGxldCxcbiAgICAgIHR4UHJlYnVpbGQ6IG9yaWdpbmFsUHJlYnVpbGQsXG4gICAgfSkpIGFzIGFueTtcbiAgICBjb25zdCByZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgd2FsbGV0OiB0aGlzLndhbGxldCxcbiAgICAgIHR4UHJlYnVpbGQ6IHNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIH0pKSBhcyBhbnk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQpKSB7XG4gICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzRmluaXRlKHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmQgYW1vdW50IGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KSAmJlxuICAgICAgcmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ID4gb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVjcmVhdGVkIHRyYW5zYWN0aW9uIGlzIHVzaW5nIGEgaGlnaGVyIHBheS1hcy15b3UtZ28tZmVlJyk7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgfVxufVxuIl19