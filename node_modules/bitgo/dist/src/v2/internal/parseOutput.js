"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOutput = void 0;
const debugLib = require("debug");
const _ = require("lodash");
const errors = require("../../errors");
const abstractUtxoCoin_1 = require("../coins/abstractUtxoCoin");
const debug = debugLib('bitgo:v2:parseoutput');
/**
 * Check an address which failed initial validation to see if it's the base address of a migrated v1 bch wallet.
 *
 * The wallet in question could be a migrated SafeHD BCH wallet, and the transaction we
 * are currently parsing is trying to spend change back to the v1 wallet base address.
 *
 * It does this since we don't allow new address creation for these wallets,
 * and instead return the base address from the v1 wallet when a new address is requested.
 * If this new address is requested for the purposes of spending change back to the wallet,
 * the change will go to the v1 wallet base address. This address *is* on the wallet,
 * but it will still cause an error to be thrown by verifyAddress, since the derivation path
 * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
 * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
 *
 * This means we need to check for this case explicitly in this catch block, and classify
 * these types of outputs as internal instead of external. Failing to do so would cause the
 * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
 * the recipients array) to add up to more than the 150 basis point limit which we enforce on
 * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
 *
 * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
 * which calls this function to get information on the total external/internal spend amounts
 * for a transaction. The idea here is to protect from the transaction being maliciously modified
 * to add more implicit external spends (eg, to an attacker-controlled wallet).
 *
 * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
 *
 * @param wallet {Wallet} wallet which is making the transaction
 * @param currentAddress {string} address to check for externality relative to v1 wallet base address
 */
function isMigratedAddress(wallet, currentAddress) {
    if (_.isString(wallet.migratedFrom()) && wallet.migratedFrom() === currentAddress) {
        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
        return true;
    }
    return false;
}
/**
 * Check to see if an address is derived from the given custom change keys
 * @param {VerifyCustomChangeAddressOptions} params
 * @return {boolean}
 */
function verifyCustomChangeAddress(params) {
    const { coin, customChangeKeys, addressType, addressDetails, currentAddress } = params;
    try {
        return coin.verifyAddress(_.extend({ addressType }, addressDetails, {
            keychains: customChangeKeys,
            address: currentAddress,
        }));
    }
    catch (e) {
        debug('failed to verify custom change address %s', currentAddress);
        return false;
    }
}
function handleVerifyAddressError({ e, currentAddress, wallet, txParams, customChangeKeys, coin, addressDetails, addressType, considerMigratedFromAddressInternal, }) {
    // Todo: name server-side errors to avoid message-based checking [BG-5124]
    const walletAddressNotFound = e.message.includes('wallet address not found');
    const unexpectedAddress = e instanceof errors.UnexpectedAddressError;
    if (walletAddressNotFound || unexpectedAddress) {
        if (unexpectedAddress && !walletAddressNotFound) {
            // check to see if this is a migrated v1 bch address - it could be internal
            const isMigrated = isMigratedAddress(wallet, currentAddress);
            if (isMigrated) {
                return { external: considerMigratedFromAddressInternal === false };
            }
            debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
            // attempt to verify address using custom change address keys if the wallet has that feature enabled
            if (customChangeKeys &&
                verifyCustomChangeAddress({ coin, addressDetails, addressType, currentAddress, customChangeKeys })) {
                // address is valid against the custom change keys. Mark address as not external
                // and request signature verification for the custom change keys
                debug('Address %s verified as derived from the custom change keys', currentAddress);
                return { external: false, needsCustomChangeKeySignatureVerification: true };
            }
        }
        // the address was found, but not on the wallet, which simply means it's external
        debug('Address %s presumed external', currentAddress);
        return { external: true };
    }
    else if (e instanceof errors.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
        // expect to see this error when passing in a custom changeAddress with no chain or index
        return { external: false };
    }
    console.error('Address classification failed for address', currentAddress);
    console.trace(e);
    /**
     * It might be a completely invalid address or a bad validation attempt or something else completely, in
     * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
     * validation failed simply because it's external to the wallet.
     */
    throw e;
}
async function fetchAddressDetails({ reqId, disableNetworking, addressDetailsPrebuild, addressDetailsVerification, currentAddress, wallet, }) {
    let addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
    debug('Locally available address %s details: %O', currentAddress, addressDetails);
    if (_.isEmpty(addressDetails) && !disableNetworking) {
        addressDetails = await wallet.getAddress({ address: currentAddress, reqId });
        debug('Downloaded address %s details: %O', currentAddress, addressDetails);
    }
    return addressDetails;
}
async function parseOutput({ currentOutput, coin, txPrebuild, verification, keychainArray, wallet, txParams, customChange, reqId, }) {
    const disableNetworking = !!verification.disableNetworking;
    const currentAddress = currentOutput.address;
    // attempt to grab the address details from either the prebuilt tx, or the verification params.
    // If both of these are empty, then we will try to get the address details from bitgo instead
    const addressDetailsPrebuild = _.get(txPrebuild, `txInfo.walletAddressDetails.${currentAddress}`, {});
    const addressDetailsVerification = _.get(verification, `addresses.${currentAddress}`, {});
    debug('Parsing address details for %s', currentAddress);
    let currentAddressDetails = undefined;
    let currentAddressType = undefined;
    try {
        /**
         * The only way to determine whether an address is known on the wallet is to initiate a network request and
         * fetch it. Should the request fail and return a 404, it will throw and therefore has to be caught. For that
         * reason, address wallet ownership detection is wrapped in a try/catch. Additionally, once the address
         * details are fetched on the wallet, a local address validation is run, whose errors however are generated
         * client-side and can therefore be analyzed with more granularity and type checking.
         */
        const addressDetails = await fetchAddressDetails({
            reqId,
            addressDetailsVerification,
            addressDetailsPrebuild,
            currentAddress,
            disableNetworking,
            wallet,
        });
        // verify that the address is on the wallet. verifyAddress throws if
        // it fails to correctly rederive the address, meaning it's external
        currentAddressType = abstractUtxoCoin_1.AbstractUtxoCoin.inferAddressType(addressDetails) || undefined;
        currentAddressDetails = addressDetails;
        coin.verifyAddress(_.extend({ addressType: currentAddressType }, addressDetails, {
            keychains: keychainArray,
            address: currentAddress,
        }));
        debug('Address %s verification passed', currentAddress);
        // verify address succeeded without throwing, so the address was
        // correctly rederived from the wallet keychains, making it not external
        return _.extend({}, currentOutput, addressDetails, { external: false });
    }
    catch (e) {
        debug('Address %s verification threw an error:', currentAddress, e);
        return _.extend({}, currentOutput, handleVerifyAddressError({
            e,
            coin,
            currentAddress,
            wallet,
            txParams,
            customChangeKeys: customChange && customChange.keys,
            addressDetails: currentAddressDetails,
            addressType: currentAddressType,
            considerMigratedFromAddressInternal: verification.considerMigratedFromAddressInternal,
        }));
    }
}
exports.parseOutput = parseOutput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VPdXRwdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvaW50ZXJuYWwvcGFyc2VPdXRwdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLHVDQUF1QztBQUV2QyxnRUFBd0Y7QUFLeEYsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFFL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBQ0gsU0FBUyxpQkFBaUIsQ0FBQyxNQUFjLEVBQUUsY0FBc0I7SUFDL0QsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUUsS0FBSyxjQUFjLEVBQUU7UUFDakYsS0FBSyxDQUFDLDZFQUE2RSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3JHLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFVRDs7OztHQUlHO0FBQ0gsU0FBUyx5QkFBeUIsQ0FBQyxNQUF3QztJQUN6RSxNQUFNLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBQ3ZGLElBQUk7UUFDRixPQUFPLElBQUksQ0FBQyxhQUFhLENBQ3ZCLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxXQUFXLEVBQUUsRUFBRSxjQUFjLEVBQUU7WUFDeEMsU0FBUyxFQUFFLGdCQUFnQjtZQUMzQixPQUFPLEVBQUUsY0FBYztTQUN4QixDQUFDLENBQ0gsQ0FBQztLQUNIO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixLQUFLLENBQUMsMkNBQTJDLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDbkUsT0FBTyxLQUFLLENBQUM7S0FDZDtBQUNILENB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QUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUN6RTtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsS0FBSyxDQUFDLHlDQUF5QyxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwRSxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQ2IsRUFBRSxFQUNGLGFBQWEsRUFDYix3QkFBd0IsQ0FBQztZQUN2QixDQUFDO1lBQ0QsSUFBSTtZQUNKLGNBQWM7WUFDZCxNQUFNO1lBQ04sUUFBUTtZQUNSLGdCQUFnQixFQUFFLFlBQVksSUFBSSxZQUFZLENBQUMsSUFBSTtZQUNuRCxjQUFjLEVBQUUscUJBQXFCO1lBQ3JDLFdBQVcsRUFBRSxrQkFBa0I7WUFDL0IsbUNBQW1DLEVBQUUsWUFBWSxDQUFDLG1DQUFtQztTQUN0RixDQUFDLENBQ0gsQ0FBQztLQUNIO0FBQ0gsQ0FBQztBQXRFRCxrQ0FzRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgQWRkcmVzc1ZlcmlmaWNhdGlvbkRhdGEsIFRyYW5zYWN0aW9uUHJlYnVpbGQsIFZlcmlmaWNhdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBBYnN0cmFjdFV0eG9Db2luLCBPdXRwdXQsIFRyYW5zYWN0aW9uUGFyYW1zIH0gZnJvbSAnLi4vY29pbnMvYWJzdHJhY3RVdHhvQ29pbic7XG5pbXBvcnQgeyBLZXljaGFpbiB9IGZyb20gJy4uL2tleWNoYWlucyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOnBhcnNlb3V0cHV0Jyk7XG5cbi8qKlxuICogQ2hlY2sgYW4gYWRkcmVzcyB3aGljaCBmYWlsZWQgaW5pdGlhbCB2YWxpZGF0aW9uIHRvIHNlZSBpZiBpdCdzIHRoZSBiYXNlIGFkZHJlc3Mgb2YgYSBtaWdyYXRlZCB2MSBiY2ggd2FsbGV0LlxuICpcbiAqIFRoZSB3YWxsZXQgaW4gcXVlc3Rpb24gY291bGQgYmUgYSBtaWdyYXRlZCBTYWZlSEQgQkNIIHdhbGxldCwgYW5kIHRoZSB0cmFuc2FjdGlvbiB3ZVxuICogYXJlIGN1cnJlbnRseSBwYXJzaW5nIGlzIHRyeWluZyB0byBzcGVuZCBjaGFuZ2UgYmFjayB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy5cbiAqXG4gKiBJdCBkb2VzIHRoaXMgc2luY2Ugd2UgZG9uJ3QgYWxsb3cgbmV3IGFkZHJlc3MgY3JlYXRpb24gZm9yIHRoZXNlIHdhbGxldHMsXG4gKiBhbmQgaW5zdGVhZCByZXR1cm4gdGhlIGJhc2UgYWRkcmVzcyBmcm9tIHRoZSB2MSB3YWxsZXQgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIHJlcXVlc3RlZC5cbiAqIElmIHRoaXMgbmV3IGFkZHJlc3MgaXMgcmVxdWVzdGVkIGZvciB0aGUgcHVycG9zZXMgb2Ygc3BlbmRpbmcgY2hhbmdlIGJhY2sgdG8gdGhlIHdhbGxldCxcbiAqIHRoZSBjaGFuZ2Ugd2lsbCBnbyB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy4gVGhpcyBhZGRyZXNzICppcyogb24gdGhlIHdhbGxldCxcbiAqIGJ1dCBpdCB3aWxsIHN0aWxsIGNhdXNlIGFuIGVycm9yIHRvIGJlIHRocm93biBieSB2ZXJpZnlBZGRyZXNzLCBzaW5jZSB0aGUgZGVyaXZhdGlvbiBwYXRoXG4gKiB1c2VkIGZvciB0aGlzIGFkZHJlc3MgaXMgbm9uLXN0YW5kYXJkLiAoSSBoYXZlIHNlZW4gdGhlc2UgYWRkcmVzc2VzIGRlcml2ZWQgdXNpbmcgcGF0aHMgbS8wLzAgYW5kIG0vMTAxLFxuICogd2hlcmVhcyB0aGUgdjIgYWRkcmVzc2VzIGFyZSBkZXJpdmVkIHVzaW5nIHBhdGggIG0vMC8wLyR7Y2hhaW59LyR7aW5kZXh9KS5cbiAqXG4gKiBUaGlzIG1lYW5zIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgY2FzZSBleHBsaWNpdGx5IGluIHRoaXMgY2F0Y2ggYmxvY2ssIGFuZCBjbGFzc2lmeVxuICogdGhlc2UgdHlwZXMgb2Ygb3V0cHV0cyBhcyBpbnRlcm5hbCBpbnN0ZWFkIG9mIGV4dGVybmFsLiBGYWlsaW5nIHRvIGRvIHNvIHdvdWxkIGNhdXNlIHRoZVxuICogdHJhbnNhY3Rpb24ncyBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIChpZSwgb3V0cHV0cyB3aGljaCBnbyB0byBhZGRyZXNzZXMgbm90IHNwZWNpZmllZCBpblxuICogdGhlIHJlY2lwaWVudHMgYXJyYXkpIHRvIGFkZCB1cCB0byBtb3JlIHRoYW4gdGhlIDE1MCBiYXNpcyBwb2ludCBsaW1pdCB3aGljaCB3ZSBlbmZvcmNlIG9uXG4gKiBwYXktYXMteW91LWdvIG91dHB1dHMgKHdoaWNoIHNob3VsZCBiZSB0aGUgb25seSBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIG9uIG91ciB0cmFuc2FjdGlvbnMpLlxuICpcbiAqIFRoZSAxNTAgYmFzaXMgcG9pbnQgbGltaXQgZm9yIGltcGxpY2l0IGV4dGVybmFsIHNlbmRzIGlzIGVuZm9yY2VkIGluIHZlcmlmeVRyYW5zYWN0aW9uLFxuICogd2hpY2ggY2FsbHMgdGhpcyBmdW5jdGlvbiB0byBnZXQgaW5mb3JtYXRpb24gb24gdGhlIHRvdGFsIGV4dGVybmFsL2ludGVybmFsIHNwZW5kIGFtb3VudHNcbiAqIGZvciBhIHRyYW5zYWN0aW9uLiBUaGUgaWRlYSBoZXJlIGlzIHRvIHByb3RlY3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgbWFsaWNpb3VzbHkgbW9kaWZpZWRcbiAqIHRvIGFkZCBtb3JlIGltcGxpY2l0IGV4dGVybmFsIHNwZW5kcyAoZWcsIHRvIGFuIGF0dGFja2VyLWNvbnRyb2xsZWQgd2FsbGV0KS5cbiAqXG4gKiBTZWUgdmVyaWZ5VHJhbnNhY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRyYW5zYWN0aW9uIHByZWJ1aWxkcyBhcmUgdmVyaWZpZWQgYmVmb3JlIHNpZ25pbmcuXG4gKlxuICogQHBhcmFtIHdhbGxldCB7V2FsbGV0fSB3YWxsZXQgd2hpY2ggaXMgbWFraW5nIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGN1cnJlbnRBZGRyZXNzIHtzdHJpbmd9IGFkZHJlc3MgdG8gY2hlY2sgZm9yIGV4dGVybmFsaXR5IHJlbGF0aXZlIHRvIHYxIHdhbGxldCBiYXNlIGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gaXNNaWdyYXRlZEFkZHJlc3Mod2FsbGV0OiBXYWxsZXQsIGN1cnJlbnRBZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNTdHJpbmcod2FsbGV0Lm1pZ3JhdGVkRnJvbSgpKSAmJiB3YWxsZXQubWlncmF0ZWRGcm9tKCkgPT09IGN1cnJlbnRBZGRyZXNzKSB7XG4gICAgZGVidWcoJ2ZvdW5kIGFkZHJlc3MgJXMgd2hpY2ggd2FzIG1pZ3JhdGVkIGZyb20gdjEgd2FsbGV0LCBhZGRyZXNzIGlzIG5vdCBleHRlcm5hbCcsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3NPcHRpb25zIHtcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgY3VzdG9tQ2hhbmdlS2V5czogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snY3VzdG9tQ2hhbmdlS2V5cyddO1xuICBhZGRyZXNzVHlwZTogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snYWRkcmVzc1R5cGUnXTtcbiAgYWRkcmVzc0RldGFpbHM6IEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnNbJ2FkZHJlc3NEZXRhaWxzJ107XG4gIGN1cnJlbnRBZGRyZXNzOiBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JPcHRpb25zWydjdXJyZW50QWRkcmVzcyddO1xufVxuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBhbiBhZGRyZXNzIGlzIGRlcml2ZWQgZnJvbSB0aGUgZ2l2ZW4gY3VzdG9tIGNoYW5nZSBrZXlzXG4gKiBAcGFyYW0ge1ZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3NPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3MocGFyYW1zOiBWZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICBjb25zdCB7IGNvaW4sIGN1c3RvbUNoYW5nZUtleXMsIGFkZHJlc3NUeXBlLCBhZGRyZXNzRGV0YWlscywgY3VycmVudEFkZHJlc3MgfSA9IHBhcmFtcztcbiAgdHJ5IHtcbiAgICByZXR1cm4gY29pbi52ZXJpZnlBZGRyZXNzKFxuICAgICAgXy5leHRlbmQoeyBhZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICBrZXljaGFpbnM6IGN1c3RvbUNoYW5nZUtleXMsXG4gICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgfSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2ZhaWxlZCB0byB2ZXJpZnkgY3VzdG9tIGNoYW5nZSBhZGRyZXNzICVzJywgY3VycmVudEFkZHJlc3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9ucyB7XG4gIGU6IEVycm9yO1xuICBjdXJyZW50QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xuICBjdXN0b21DaGFuZ2VLZXlzPzogQ3VzdG9tQ2hhbmdlT3B0aW9uc1sna2V5cyddO1xuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luO1xuICBhZGRyZXNzRGV0YWlscz86IGFueTtcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG4gIGNvbnNpZGVyTWlncmF0ZWRGcm9tQWRkcmVzc0ludGVybmFsPzogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yKHtcbiAgZSxcbiAgY3VycmVudEFkZHJlc3MsXG4gIHdhbGxldCxcbiAgdHhQYXJhbXMsXG4gIGN1c3RvbUNoYW5nZUtleXMsXG4gIGNvaW4sXG4gIGFkZHJlc3NEZXRhaWxzLFxuICBhZGRyZXNzVHlwZSxcbiAgY29uc2lkZXJNaWdyYXRlZEZyb21BZGRyZXNzSW50ZXJuYWwsXG59OiBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JPcHRpb25zKTogeyBleHRlcm5hbDogYm9vbGVhbjsgbmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb24/OiBib29sZWFuIH0ge1xuICAvLyBUb2RvOiBuYW1lIHNlcnZlci1zaWRlIGVycm9ycyB0byBhdm9pZCBtZXNzYWdlLWJhc2VkIGNoZWNraW5nIFtCRy01MTI0XVxuICBjb25zdCB3YWxsZXRBZGRyZXNzTm90Rm91bmQgPSBlLm1lc3NhZ2UuaW5jbHVkZXMoJ3dhbGxldCBhZGRyZXNzIG5vdCBmb3VuZCcpO1xuICBjb25zdCB1bmV4cGVjdGVkQWRkcmVzcyA9IGUgaW5zdGFuY2VvZiBlcnJvcnMuVW5leHBlY3RlZEFkZHJlc3NFcnJvcjtcbiAgaWYgKHdhbGxldEFkZHJlc3NOb3RGb3VuZCB8fCB1bmV4cGVjdGVkQWRkcmVzcykge1xuICAgIGlmICh1bmV4cGVjdGVkQWRkcmVzcyAmJiAhd2FsbGV0QWRkcmVzc05vdEZvdW5kKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIG1pZ3JhdGVkIHYxIGJjaCBhZGRyZXNzIC0gaXQgY291bGQgYmUgaW50ZXJuYWxcbiAgICAgIGNvbnN0IGlzTWlncmF0ZWQgPSBpc01pZ3JhdGVkQWRkcmVzcyh3YWxsZXQsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICAgIGlmIChpc01pZ3JhdGVkKSB7XG4gICAgICAgIHJldHVybiB7IGV4dGVybmFsOiBjb25zaWRlck1pZ3JhdGVkRnJvbUFkZHJlc3NJbnRlcm5hbCA9PT0gZmFsc2UgfTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoJ0FkZHJlc3MgJXMgd2FzIGZvdW5kIG9uIHdhbGxldCBidXQgY291bGQgbm90IGJlIHJlY29uc3RydWN0ZWQnLCBjdXJyZW50QWRkcmVzcyk7XG5cbiAgICAgIC8vIGF0dGVtcHQgdG8gdmVyaWZ5IGFkZHJlc3MgdXNpbmcgY3VzdG9tIGNoYW5nZSBhZGRyZXNzIGtleXMgaWYgdGhlIHdhbGxldCBoYXMgdGhhdCBmZWF0dXJlIGVuYWJsZWRcbiAgICAgIGlmIChcbiAgICAgICAgY3VzdG9tQ2hhbmdlS2V5cyAmJlxuICAgICAgICB2ZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzKHsgY29pbiwgYWRkcmVzc0RldGFpbHMsIGFkZHJlc3NUeXBlLCBjdXJyZW50QWRkcmVzcywgY3VzdG9tQ2hhbmdlS2V5cyB9KVxuICAgICAgKSB7XG4gICAgICAgIC8vIGFkZHJlc3MgaXMgdmFsaWQgYWdhaW5zdCB0aGUgY3VzdG9tIGNoYW5nZSBrZXlzLiBNYXJrIGFkZHJlc3MgYXMgbm90IGV4dGVybmFsXG4gICAgICAgIC8vIGFuZCByZXF1ZXN0IHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZm9yIHRoZSBjdXN0b20gY2hhbmdlIGtleXNcbiAgICAgICAgZGVidWcoJ0FkZHJlc3MgJXMgdmVyaWZpZWQgYXMgZGVyaXZlZCBmcm9tIHRoZSBjdXN0b20gY2hhbmdlIGtleXMnLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB7IGV4dGVybmFsOiBmYWxzZSwgbmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb246IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGUgYWRkcmVzcyB3YXMgZm91bmQsIGJ1dCBub3Qgb24gdGhlIHdhbGxldCwgd2hpY2ggc2ltcGx5IG1lYW5zIGl0J3MgZXh0ZXJuYWxcbiAgICBkZWJ1ZygnQWRkcmVzcyAlcyBwcmVzdW1lZCBleHRlcm5hbCcsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICByZXR1cm4geyBleHRlcm5hbDogdHJ1ZSB9O1xuICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBlcnJvcnMuSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvciAmJiBjdXJyZW50QWRkcmVzcyA9PT0gdHhQYXJhbXMuY2hhbmdlQWRkcmVzcykge1xuICAgIC8vIGV4cGVjdCB0byBzZWUgdGhpcyBlcnJvciB3aGVuIHBhc3NpbmcgaW4gYSBjdXN0b20gY2hhbmdlQWRkcmVzcyB3aXRoIG5vIGNoYWluIG9yIGluZGV4XG4gICAgcmV0dXJuIHsgZXh0ZXJuYWw6IGZhbHNlIH07XG4gIH1cblxuICBjb25zb2xlLmVycm9yKCdBZGRyZXNzIGNsYXNzaWZpY2F0aW9uIGZhaWxlZCBmb3IgYWRkcmVzcycsIGN1cnJlbnRBZGRyZXNzKTtcbiAgY29uc29sZS50cmFjZShlKTtcbiAgLyoqXG4gICAqIEl0IG1pZ2h0IGJlIGEgY29tcGxldGVseSBpbnZhbGlkIGFkZHJlc3Mgb3IgYSBiYWQgdmFsaWRhdGlvbiBhdHRlbXB0IG9yIHNvbWV0aGluZyBlbHNlIGNvbXBsZXRlbHksIGluXG4gICAqIHdoaWNoIGNhc2Ugd2UgZG8gbm90IHByb2NlZWQgYW5kIHJhdGhlciByZXRocm93IHRoZSBlcnJvciwgd2hpY2ggaXMgc2FmZXIgdGhhbiBhc3N1bWluZyB0aGF0IHRoZSBhZGRyZXNzXG4gICAqIHZhbGlkYXRpb24gZmFpbGVkIHNpbXBseSBiZWNhdXNlIGl0J3MgZXh0ZXJuYWwgdG8gdGhlIHdhbGxldC5cbiAgICovXG4gIHRocm93IGU7XG59XG5cbmludGVyZmFjZSBGZXRjaEFkZHJlc3NEZXRhaWxzT3B0aW9ucyB7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbiAgZGlzYWJsZU5ldHdvcmtpbmc6IGJvb2xlYW47XG4gIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQ6IGFueTtcbiAgYWRkcmVzc0RldGFpbHNWZXJpZmljYXRpb246IGFueTtcbiAgY3VycmVudEFkZHJlc3M6IHN0cmluZztcbiAgd2FsbGV0OiBXYWxsZXQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQWRkcmVzc0RldGFpbHMoe1xuICByZXFJZCxcbiAgZGlzYWJsZU5ldHdvcmtpbmcsXG4gIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQsXG4gIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uLFxuICBjdXJyZW50QWRkcmVzcyxcbiAgd2FsbGV0LFxufTogRmV0Y2hBZGRyZXNzRGV0YWlsc09wdGlvbnMpIHtcbiAgbGV0IGFkZHJlc3NEZXRhaWxzID0gXy5leHRlbmQoe30sIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQsIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uKTtcbiAgZGVidWcoJ0xvY2FsbHkgYXZhaWxhYmxlIGFkZHJlc3MgJXMgZGV0YWlsczogJU8nLCBjdXJyZW50QWRkcmVzcywgYWRkcmVzc0RldGFpbHMpO1xuICBpZiAoXy5pc0VtcHR5KGFkZHJlc3NEZXRhaWxzKSAmJiAhZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICBhZGRyZXNzRGV0YWlscyA9IGF3YWl0IHdhbGxldC5nZXRBZGRyZXNzKHsgYWRkcmVzczogY3VycmVudEFkZHJlc3MsIHJlcUlkIH0pO1xuICAgIGRlYnVnKCdEb3dubG9hZGVkIGFkZHJlc3MgJXMgZGV0YWlsczogJU8nLCBjdXJyZW50QWRkcmVzcywgYWRkcmVzc0RldGFpbHMpO1xuICB9XG4gIHJldHVybiBhZGRyZXNzRGV0YWlscztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21DaGFuZ2VPcHRpb25zIHtcbiAga2V5czogW0tleWNoYWluLCBLZXljaGFpbiwgS2V5Y2hhaW5dO1xuICBzaWduYXR1cmVzOiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VPdXRwdXRPcHRpb25zIHtcbiAgY3VycmVudE91dHB1dDogT3V0cHV0O1xuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luO1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICB2ZXJpZmljYXRpb246IFZlcmlmaWNhdGlvbk9wdGlvbnM7XG4gIGtleWNoYWluQXJyYXk6IFtLZXljaGFpbiwgS2V5Y2hhaW4sIEtleWNoYWluXTtcbiAgd2FsbGV0OiBXYWxsZXQ7XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbiAgY3VzdG9tQ2hhbmdlPzogQ3VzdG9tQ2hhbmdlT3B0aW9ucztcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VPdXRwdXQoe1xuICBjdXJyZW50T3V0cHV0LFxuICBjb2luLFxuICB0eFByZWJ1aWxkLFxuICB2ZXJpZmljYXRpb24sXG4gIGtleWNoYWluQXJyYXksXG4gIHdhbGxldCxcbiAgdHhQYXJhbXMsXG4gIGN1c3RvbUNoYW5nZSxcbiAgcmVxSWQsXG59OiBQYXJzZU91dHB1dE9wdGlvbnMpOiBQcm9taXNlPE91dHB1dD4ge1xuICBjb25zdCBkaXNhYmxlTmV0d29ya2luZyA9ICEhdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IGN1cnJlbnRPdXRwdXQuYWRkcmVzcztcblxuICAvLyBhdHRlbXB0IHRvIGdyYWIgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGVpdGhlciB0aGUgcHJlYnVpbHQgdHgsIG9yIHRoZSB2ZXJpZmljYXRpb24gcGFyYW1zLlxuICAvLyBJZiBib3RoIG9mIHRoZXNlIGFyZSBlbXB0eSwgdGhlbiB3ZSB3aWxsIHRyeSB0byBnZXQgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGJpdGdvIGluc3RlYWRcbiAgY29uc3QgYWRkcmVzc0RldGFpbHNQcmVidWlsZCA9IF8uZ2V0KHR4UHJlYnVpbGQsIGB0eEluZm8ud2FsbGV0QWRkcmVzc0RldGFpbHMuJHtjdXJyZW50QWRkcmVzc31gLCB7fSk7XG4gIGNvbnN0IGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uOiBBZGRyZXNzVmVyaWZpY2F0aW9uRGF0YSA9IF8uZ2V0KHZlcmlmaWNhdGlvbiwgYGFkZHJlc3Nlcy4ke2N1cnJlbnRBZGRyZXNzfWAsIHt9KTtcbiAgZGVidWcoJ1BhcnNpbmcgYWRkcmVzcyBkZXRhaWxzIGZvciAlcycsIGN1cnJlbnRBZGRyZXNzKTtcbiAgbGV0IGN1cnJlbnRBZGRyZXNzRGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRBZGRyZXNzVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICB0cnkge1xuICAgIC8qKlxuICAgICAqIFRoZSBvbmx5IHdheSB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBhZGRyZXNzIGlzIGtub3duIG9uIHRoZSB3YWxsZXQgaXMgdG8gaW5pdGlhdGUgYSBuZXR3b3JrIHJlcXVlc3QgYW5kXG4gICAgICogZmV0Y2ggaXQuIFNob3VsZCB0aGUgcmVxdWVzdCBmYWlsIGFuZCByZXR1cm4gYSA0MDQsIGl0IHdpbGwgdGhyb3cgYW5kIHRoZXJlZm9yZSBoYXMgdG8gYmUgY2F1Z2h0LiBGb3IgdGhhdFxuICAgICAqIHJlYXNvbiwgYWRkcmVzcyB3YWxsZXQgb3duZXJzaGlwIGRldGVjdGlvbiBpcyB3cmFwcGVkIGluIGEgdHJ5L2NhdGNoLiBBZGRpdGlvbmFsbHksIG9uY2UgdGhlIGFkZHJlc3NcbiAgICAgKiBkZXRhaWxzIGFyZSBmZXRjaGVkIG9uIHRoZSB3YWxsZXQsIGEgbG9jYWwgYWRkcmVzcyB2YWxpZGF0aW9uIGlzIHJ1biwgd2hvc2UgZXJyb3JzIGhvd2V2ZXIgYXJlIGdlbmVyYXRlZFxuICAgICAqIGNsaWVudC1zaWRlIGFuZCBjYW4gdGhlcmVmb3JlIGJlIGFuYWx5emVkIHdpdGggbW9yZSBncmFudWxhcml0eSBhbmQgdHlwZSBjaGVja2luZy5cbiAgICAgKi9cbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IGF3YWl0IGZldGNoQWRkcmVzc0RldGFpbHMoe1xuICAgICAgcmVxSWQsXG4gICAgICBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbixcbiAgICAgIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQsXG4gICAgICBjdXJyZW50QWRkcmVzcyxcbiAgICAgIGRpc2FibGVOZXR3b3JraW5nLFxuICAgICAgd2FsbGV0LFxuICAgIH0pO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBhZGRyZXNzIGlzIG9uIHRoZSB3YWxsZXQuIHZlcmlmeUFkZHJlc3MgdGhyb3dzIGlmXG4gICAgLy8gaXQgZmFpbHMgdG8gY29ycmVjdGx5IHJlZGVyaXZlIHRoZSBhZGRyZXNzLCBtZWFuaW5nIGl0J3MgZXh0ZXJuYWxcbiAgICBjdXJyZW50QWRkcmVzc1R5cGUgPSBBYnN0cmFjdFV0eG9Db2luLmluZmVyQWRkcmVzc1R5cGUoYWRkcmVzc0RldGFpbHMpIHx8IHVuZGVmaW5lZDtcbiAgICBjdXJyZW50QWRkcmVzc0RldGFpbHMgPSBhZGRyZXNzRGV0YWlscztcbiAgICBjb2luLnZlcmlmeUFkZHJlc3MoXG4gICAgICBfLmV4dGVuZCh7IGFkZHJlc3NUeXBlOiBjdXJyZW50QWRkcmVzc1R5cGUgfSwgYWRkcmVzc0RldGFpbHMsIHtcbiAgICAgICAga2V5Y2hhaW5zOiBrZXljaGFpbkFycmF5LFxuICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgIH0pXG4gICAgKTtcbiAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gcGFzc2VkJywgY3VycmVudEFkZHJlc3MpO1xuXG4gICAgLy8gdmVyaWZ5IGFkZHJlc3Mgc3VjY2VlZGVkIHdpdGhvdXQgdGhyb3dpbmcsIHNvIHRoZSBhZGRyZXNzIHdhc1xuICAgIC8vIGNvcnJlY3RseSByZWRlcml2ZWQgZnJvbSB0aGUgd2FsbGV0IGtleWNoYWlucywgbWFraW5nIGl0IG5vdCBleHRlcm5hbFxuICAgIHJldHVybiBfLmV4dGVuZCh7fSwgY3VycmVudE91dHB1dCwgYWRkcmVzc0RldGFpbHMsIHsgZXh0ZXJuYWw6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ0FkZHJlc3MgJXMgdmVyaWZpY2F0aW9uIHRocmV3IGFuIGVycm9yOicsIGN1cnJlbnRBZGRyZXNzLCBlKTtcbiAgICByZXR1cm4gXy5leHRlbmQoXG4gICAgICB7fSxcbiAgICAgIGN1cnJlbnRPdXRwdXQsXG4gICAgICBoYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3Ioe1xuICAgICAgICBlLFxuICAgICAgICBjb2luLFxuICAgICAgICBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgd2FsbGV0LFxuICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgY3VzdG9tQ2hhbmdlS2V5czogY3VzdG9tQ2hhbmdlICYmIGN1c3RvbUNoYW5nZS5rZXlzLFxuICAgICAgICBhZGRyZXNzRGV0YWlsczogY3VycmVudEFkZHJlc3NEZXRhaWxzLFxuICAgICAgICBhZGRyZXNzVHlwZTogY3VycmVudEFkZHJlc3NUeXBlLFxuICAgICAgICBjb25zaWRlck1pZ3JhdGVkRnJvbUFkZHJlc3NJbnRlcm5hbDogdmVyaWZpY2F0aW9uLmNvbnNpZGVyTWlncmF0ZWRGcm9tQWRkcmVzc0ludGVybmFsLFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iXX0=