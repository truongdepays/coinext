"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encryptText = exports.getBitgoGpgPubKey = void 0;
const openpgp_1 = require("openpgp");
/**
 * Fetches BitGo's pubic gpg key used in MPC flows
 * @param {BitGo} bitgo BitGo object
 * @return {Key} public gpg key
 */
async function getBitgoGpgPubKey(bitgo) {
    const constants = await bitgo.fetchConstants();
    if (!constants.mpc || !constants.mpc.bitgoPublicKey) {
        throw new Error('Unable to create MPC keys - bitgoPublicKey is missing from constants');
    }
    const bitgoPublicKeyStr = constants.mpc.bitgoPublicKey;
    return await openpgp_1.readKey({ armoredKey: bitgoPublicKeyStr });
}
exports.getBitgoGpgPubKey = getBitgoGpgPubKey;
/**
 * Encrypts string using gpg key
 * @param text string to encrypt
 * @param key encryption key
 * @return {string} encrypted string
 */
async function encryptText(text, key) {
    const messageToEncrypt = await openpgp_1.createMessage({
        text,
    });
    return await openpgp_1.encrypt({
        message: messageToEncrypt,
        encryptionKeys: [key],
        format: 'armored',
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
}
exports.encryptText = encryptText;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BlbmdwZ1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2ludGVybmFsL29wZW5ncGdVdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBK0Q7QUFHL0Q7Ozs7R0FJRztBQUNJLEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxLQUFZO0lBQ2xELE1BQU0sU0FBUyxHQUFHLE1BQU0sS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQy9DLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUU7UUFDbkQsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRUFBc0UsQ0FBQyxDQUFDO0tBQ3pGO0lBRUQsTUFBTSxpQkFBaUIsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLGNBQXdCLENBQUM7SUFDakUsT0FBTyxNQUFNLGlCQUFPLENBQUMsRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO0FBQzFELENBQUM7QUFSRCw4Q0FRQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLFdBQVcsQ0FBQyxJQUFZLEVBQUUsR0FBUTtJQUN0RCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sdUJBQWEsQ0FBQztRQUMzQyxJQUFJO0tBQ0wsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxNQUFNLGlCQUFPLENBQUM7UUFDbkIsT0FBTyxFQUFFLGdCQUFnQjtRQUN6QixjQUFjLEVBQUUsQ0FBQyxHQUFHLENBQUM7UUFDckIsTUFBTSxFQUFFLFNBQVM7UUFDakIsTUFBTSxFQUFFO1lBQ04sWUFBWSxFQUFFLElBQUksR0FBRyxFQUFFO1lBQ3ZCLFdBQVcsRUFBRSxLQUFLO1lBQ2xCLFdBQVcsRUFBRSxLQUFLO1NBQ25CO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWRELGtDQWNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlTWVzc2FnZSwgZW5jcnlwdCwgS2V5LCByZWFkS2V5IH0gZnJvbSAnb3BlbnBncCc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcblxuLyoqXG4gKiBGZXRjaGVzIEJpdEdvJ3MgcHViaWMgZ3BnIGtleSB1c2VkIGluIE1QQyBmbG93c1xuICogQHBhcmFtIHtCaXRHb30gYml0Z28gQml0R28gb2JqZWN0XG4gKiBAcmV0dXJuIHtLZXl9IHB1YmxpYyBncGcga2V5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCaXRnb0dwZ1B1YktleShiaXRnbzogQml0R28pOiBQcm9taXNlPEtleT4ge1xuICBjb25zdCBjb25zdGFudHMgPSBhd2FpdCBiaXRnby5mZXRjaENvbnN0YW50cygpO1xuICBpZiAoIWNvbnN0YW50cy5tcGMgfHwgIWNvbnN0YW50cy5tcGMuYml0Z29QdWJsaWNLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgTVBDIGtleXMgLSBiaXRnb1B1YmxpY0tleSBpcyBtaXNzaW5nIGZyb20gY29uc3RhbnRzJyk7XG4gIH1cblxuICBjb25zdCBiaXRnb1B1YmxpY0tleVN0ciA9IGNvbnN0YW50cy5tcGMuYml0Z29QdWJsaWNLZXkgYXMgc3RyaW5nO1xuICByZXR1cm4gYXdhaXQgcmVhZEtleSh7IGFybW9yZWRLZXk6IGJpdGdvUHVibGljS2V5U3RyIH0pO1xufVxuXG4vKipcbiAqIEVuY3J5cHRzIHN0cmluZyB1c2luZyBncGcga2V5XG4gKiBAcGFyYW0gdGV4dCBzdHJpbmcgdG8gZW5jcnlwdFxuICogQHBhcmFtIGtleSBlbmNyeXB0aW9uIGtleVxuICogQHJldHVybiB7c3RyaW5nfSBlbmNyeXB0ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0VGV4dCh0ZXh0OiBzdHJpbmcsIGtleTogS2V5KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgbWVzc2FnZVRvRW5jcnlwdCA9IGF3YWl0IGNyZWF0ZU1lc3NhZ2Uoe1xuICAgIHRleHQsXG4gIH0pO1xuICByZXR1cm4gYXdhaXQgZW5jcnlwdCh7XG4gICAgbWVzc2FnZTogbWVzc2FnZVRvRW5jcnlwdCxcbiAgICBlbmNyeXB0aW9uS2V5czogW2tleV0sXG4gICAgZm9ybWF0OiAnYXJtb3JlZCcsXG4gICAgY29uZmlnOiB7XG4gICAgICByZWplY3RDdXJ2ZXM6IG5ldyBTZXQoKSxcbiAgICAgIHNob3dWZXJzaW9uOiBmYWxzZSxcbiAgICAgIHNob3dDb21tZW50OiBmYWxzZSxcbiAgICB9LFxuICB9KTtcbn1cbiJdfQ==