"use strict";
/**
 * @prettier
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = exports.RequestTracer = void 0;
/**
 */
const bip32 = require("bip32");
const Big = require("big.js");
const _ = require("lodash");
const crypto_1 = require("crypto");
const debugLib = require("debug");
const errors_1 = require("../../errors");
const debug = debugLib('bitgo:v2:util');
let ethUtil;
let isEthAvailable = false;
const ethImport = 'ethereumjs-util';
Promise.resolve().then(() => require('ethereumjs-util')).then((eth) => {
    ethUtil = eth;
    isEthAvailable = true;
})
    .catch((e) => {
    // ethereum currently not supported
    debug('unable to load ethereumjs-util:');
    debug(e.stack);
});
/**
 * Create a request tracer for tracing workflows which involve multiple round trips to the server
 */
class RequestTracer {
    constructor() {
        this._seq = 0;
        this._seed = crypto_1.randomBytes(10);
    }
    inc() {
        this._seq++;
    }
    toString() {
        return `${this._seed.toString('hex')}-${_.padStart(this._seq.toString(16), 4, '0')}`;
    }
}
exports.RequestTracer = RequestTracer;
class Util {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() { }
    /**
     * @deprecated
     */
    static isEthAvailable() {
        return isEthAvailable;
    }
    /**
     * Convert a big.js big number to an array of unsigned bytes
     * @param bn
     * @deprecated
     */
    static bnToByteArrayUnsigned(bn) {
        let ba = bn.abs().toByteArray();
        if (ba.length) {
            if (ba[0] === 0) {
                ba = ba.slice(1);
            }
            return ba.map(function (v) {
                return v < 0 ? v + 256 : v;
            });
        }
        else {
            // Empty array, nothing to do
            return ba;
        }
    }
    /**
     * Utility method for handling arguments of pageable queries
     * @param params
     * @deprecated
     */
    static preparePageableQuery(params = {}) {
        const query = {};
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.skip) {
            if (!_.isNumber(params.skip)) {
                throw new Error('invalid skip argument, expecting number');
            }
            query.skip = params.skip;
        }
        return query;
    }
    /**
     * Create a request identifier for tracing multi-request workflows
     */
    static createRequestId() {
        return new RequestTracer();
    }
    /**
     * Convert a BTC xpub to an Ethereum address (with 0x prefix)
     * @param xpub
     * @deprecated
     */
    static xpubToEthAddress(xpub) {
        if (!isEthAvailable) {
            throw new errors_1.EthereumLibraryUnavailableError(ethImport);
        }
        return ethUtil.bufferToHex(ethUtil.publicToAddress(bip32.fromBase58(xpub).publicKey, true /* sanitize */));
    }
    /**
     * Convert a BTC xpriv to an Ethereum private key (without 0x prefix)
     * @param xprv
     * @deprecated
     */
    static xprvToEthPrivateKey(xprv) {
        const node = bip32.fromBase58(xprv);
        if (!node.privateKey) {
            throw new Error(`no privateKey`);
        }
        return node.privateKey.toString('hex');
    }
    /**
     * Sign a message using Ethereum's ECsign method and return the signature string
     * @param msgHash
     * @param privKey
     * @deprecated
     */
    static ethSignMsgHash(msgHash, privKey) {
        if (!isEthAvailable) {
            throw new errors_1.EthereumLibraryUnavailableError(ethImport);
        }
        const signatureInParts = ethUtil.ecsign(Buffer.from(ethUtil.stripHexPrefix(msgHash), 'hex'), Buffer.from(privKey, 'hex'));
        // Assemble strings from r, s and v
        const r = ethUtil.setLengthLeft(signatureInParts.r, 32).toString('hex');
        const s = ethUtil.setLengthLeft(signatureInParts.s, 32).toString('hex');
        const v = ethUtil.stripHexPrefix(ethUtil.intToHex(signatureInParts.v));
        // Concatenate the r, s and v parts to make the signature string
        return ethUtil.addHexPrefix(r.concat(s, v));
    }
    /**
     * Convert from wei string (or BN) to Ether (multiply by 1e18)
     * @param wei
     * @deprecated
     */
    static weiToEtherString(wei) {
        if (!isEthAvailable) {
            throw new errors_1.EthereumLibraryUnavailableError(ethImport);
        }
        let bn = wei;
        if (!(wei instanceof ethUtil.BN)) {
            bn = new ethUtil.BN(wei);
        }
        Big.E_POS = 256;
        Big.E_NEG = -18;
        const weiString = bn.toString(10);
        const big = new Big(weiString);
        // 10^18
        const ether = big.div('1000000000000000000');
        return ether.toPrecision();
    }
    /**
     * Recover an ethereum address from a signature and message hash
     * @param msgHash
     * @param signature
     * @deprecated
     */
    static ecRecoverEthAddress(msgHash, signature) {
        msgHash = ethUtil.stripHexPrefix(msgHash);
        signature = ethUtil.stripHexPrefix(signature);
        const v = parseInt(signature.slice(128, 130), 16);
        const r = Buffer.from(signature.slice(0, 64), 'hex');
        const s = Buffer.from(signature.slice(64, 128), 'hex');
        const pubKey = ethUtil.ecrecover(Buffer.from(msgHash, 'hex'), v, r, s);
        return ethUtil.bufferToHex(ethUtil.pubToAddress(pubKey));
    }
}
exports.Util = Util;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9pbnRlcm5hbC91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7OztBQUVIO0dBQ0c7QUFDSCwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QixtQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDLHlDQUErRDtBQUcvRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7QUFFeEMsSUFBSSxPQUFPLENBQUM7QUFDWixJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUM7QUFFM0IsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQUM7QUFDcEMscUNBQU8saUJBQWlCLEdBQ3JCLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO0lBQ1osT0FBTyxHQUFHLEdBQUcsQ0FBQztJQUNkLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFDeEIsQ0FBQyxDQUFDO0tBQ0QsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7SUFDWCxtQ0FBbUM7SUFDbkMsS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7SUFDekMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQixDQUFDLENBQUMsQ0FBQztBQUVMOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBR3hCO1FBRlEsU0FBSSxHQUFHLENBQUMsQ0FBQztRQUdmLElBQUksQ0FBQyxLQUFLLEdBQUcsb0JBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsR0FBRztRQUNELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENB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QU0sQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztDQUNGO0FBcEpELG9CQW9KQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbmltcG9ydCAqIGFzIGJpcDMyIGZyb20gJ2JpcDMyJztcbmltcG9ydCAqIGFzIEJpZyBmcm9tICdiaWcuanMnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgRXRoZXJldW1MaWJyYXJ5VW5hdmFpbGFibGVFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBJUmVxdWVzdFRyYWNlciB9IGZyb20gJ0BiaXRnby9zZGstYXBpJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djI6dXRpbCcpO1xuXG5sZXQgZXRoVXRpbDtcbmxldCBpc0V0aEF2YWlsYWJsZSA9IGZhbHNlO1xuXG5jb25zdCBldGhJbXBvcnQgPSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCgnZXRoZXJldW1qcy11dGlsJylcbiAgLnRoZW4oKGV0aCkgPT4ge1xuICAgIGV0aFV0aWwgPSBldGg7XG4gICAgaXNFdGhBdmFpbGFibGUgPSB0cnVlO1xuICB9KVxuICAuY2F0Y2goKGUpID0+IHtcbiAgICAvLyBldGhlcmV1bSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLXV0aWw6Jyk7XG4gICAgZGVidWcoZS5zdGFjayk7XG4gIH0pO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlcXVlc3QgdHJhY2VyIGZvciB0cmFjaW5nIHdvcmtmbG93cyB3aGljaCBpbnZvbHZlIG11bHRpcGxlIHJvdW5kIHRyaXBzIHRvIHRoZSBzZXJ2ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFJlcXVlc3RUcmFjZXIgaW1wbGVtZW50cyBJUmVxdWVzdFRyYWNlciB7XG4gIHByaXZhdGUgX3NlcSA9IDA7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3NlZWQ6IEJ1ZmZlcjtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc2VlZCA9IHJhbmRvbUJ5dGVzKDEwKTtcbiAgfVxuXG4gIGluYygpIHtcbiAgICB0aGlzLl9zZXErKztcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9zZWVkLnRvU3RyaW5nKCdoZXgnKX0tJHtfLnBhZFN0YXJ0KHRoaXMuX3NlcS50b1N0cmluZygxNiksIDQsICcwJyl9YDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXRpbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgaXNFdGhBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIGlzRXRoQXZhaWxhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBiaWcuanMgYmlnIG51bWJlciB0byBhbiBhcnJheSBvZiB1bnNpZ25lZCBieXRlc1xuICAgKiBAcGFyYW0gYm5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBiblRvQnl0ZUFycmF5VW5zaWduZWQoYm46IGFueSk6IGFueSB7XG4gICAgbGV0IGJhID0gYm4uYWJzKCkudG9CeXRlQXJyYXkoKTtcbiAgICBpZiAoYmEubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFbMF0gPT09IDApIHtcbiAgICAgICAgYmEgPSBiYS5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPCAwID8gdiArIDI1NiA6IHY7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW1wdHkgYXJyYXksIG5vdGhpbmcgdG8gZG9cbiAgICAgIHJldHVybiBiYTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIGhhbmRsaW5nIGFyZ3VtZW50cyBvZiBwYWdlYWJsZSBxdWVyaWVzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBwcmVwYXJlUGFnZWFibGVRdWVyeShwYXJhbXM6IHsgbGltaXQ/OiBudW1iZXI7IHNraXA/OiBudW1iZXIgfSA9IHt9KTogeyBsaW1pdD86IG51bWJlcjsgc2tpcD86IG51bWJlciB9IHtcbiAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5za2lwKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnNraXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBza2lwIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5za2lwID0gcGFyYW1zLnNraXA7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZXF1ZXN0IGlkZW50aWZpZXIgZm9yIHRyYWNpbmcgbXVsdGktcmVxdWVzdCB3b3JrZmxvd3NcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVSZXF1ZXN0SWQoKTogUmVxdWVzdFRyYWNlciB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIEJUQyB4cHViIHRvIGFuIEV0aGVyZXVtIGFkZHJlc3MgKHdpdGggMHggcHJlZml4KVxuICAgKiBAcGFyYW0geHB1YlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIHhwdWJUb0V0aEFkZHJlc3MoeHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIWlzRXRoQXZhaWxhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXRoZXJldW1MaWJyYXJ5VW5hdmFpbGFibGVFcnJvcihldGhJbXBvcnQpO1xuICAgIH1cbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhiaXAzMi5mcm9tQmFzZTU4KHhwdWIpLnB1YmxpY0tleSwgdHJ1ZSAvKiBzYW5pdGl6ZSAqLykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBCVEMgeHByaXYgdG8gYW4gRXRoZXJldW0gcHJpdmF0ZSBrZXkgKHdpdGhvdXQgMHggcHJlZml4KVxuICAgKiBAcGFyYW0geHBydlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIHhwcnZUb0V0aFByaXZhdGVLZXkoeHBydjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBub2RlID0gYmlwMzIuZnJvbUJhc2U1OCh4cHJ2KTtcbiAgICBpZiAoIW5vZGUucHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBwcml2YXRlS2V5YCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSBtZXNzYWdlIHVzaW5nIEV0aGVyZXVtJ3MgRUNzaWduIG1ldGhvZCBhbmQgcmV0dXJuIHRoZSBzaWduYXR1cmUgc3RyaW5nXG4gICAqIEBwYXJhbSBtc2dIYXNoXG4gICAqIEBwYXJhbSBwcml2S2V5XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgZXRoU2lnbk1zZ0hhc2gobXNnSGFzaDogc3RyaW5nLCBwcml2S2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghaXNFdGhBdmFpbGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGV0aEltcG9ydCk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZUluUGFydHMgPSBldGhVdGlsLmVjc2lnbihcbiAgICAgIEJ1ZmZlci5mcm9tKGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgobXNnSGFzaCksICdoZXgnKSxcbiAgICAgIEJ1ZmZlci5mcm9tKHByaXZLZXksICdoZXgnKVxuICAgICk7XG5cbiAgICAvLyBBc3NlbWJsZSBzdHJpbmdzIGZyb20gciwgcyBhbmQgdlxuICAgIGNvbnN0IHIgPSBldGhVdGlsLnNldExlbmd0aExlZnQoc2lnbmF0dXJlSW5QYXJ0cy5yLCAzMikudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IHMgPSBldGhVdGlsLnNldExlbmd0aExlZnQoc2lnbmF0dXJlSW5QYXJ0cy5zLCAzMikudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IHYgPSBldGhVdGlsLnN0cmlwSGV4UHJlZml4KGV0aFV0aWwuaW50VG9IZXgoc2lnbmF0dXJlSW5QYXJ0cy52KSk7XG5cbiAgICAvLyBDb25jYXRlbmF0ZSB0aGUgciwgcyBhbmQgdiBwYXJ0cyB0byBtYWtlIHRoZSBzaWduYXR1cmUgc3RyaW5nXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KHIuY29uY2F0KHMsIHYpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gd2VpIHN0cmluZyAob3IgQk4pIHRvIEV0aGVyIChtdWx0aXBseSBieSAxZTE4KVxuICAgKiBAcGFyYW0gd2VpXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgd2VpVG9FdGhlclN0cmluZyh3ZWk6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKCFpc0V0aEF2YWlsYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEV0aGVyZXVtTGlicmFyeVVuYXZhaWxhYmxlRXJyb3IoZXRoSW1wb3J0KTtcbiAgICB9XG4gICAgbGV0IGJuID0gd2VpO1xuICAgIGlmICghKHdlaSBpbnN0YW5jZW9mIGV0aFV0aWwuQk4pKSB7XG4gICAgICBibiA9IG5ldyBldGhVdGlsLkJOKHdlaSk7XG4gICAgfVxuICAgIEJpZy5FX1BPUyA9IDI1NjtcbiAgICBCaWcuRV9ORUcgPSAtMTg7XG4gICAgY29uc3Qgd2VpU3RyaW5nID0gYm4udG9TdHJpbmcoMTApO1xuICAgIGNvbnN0IGJpZyA9IG5ldyBCaWcod2VpU3RyaW5nKTtcbiAgICAvLyAxMF4xOFxuICAgIGNvbnN0IGV0aGVyID0gYmlnLmRpdignMTAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuICAgIHJldHVybiBldGhlci50b1ByZWNpc2lvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXIgYW4gZXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2lnbmF0dXJlIGFuZCBtZXNzYWdlIGhhc2hcbiAgICogQHBhcmFtIG1zZ0hhc2hcbiAgICogQHBhcmFtIHNpZ25hdHVyZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIGVjUmVjb3ZlckV0aEFkZHJlc3MobXNnSGFzaDogc3RyaW5nLCBzaWduYXR1cmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbXNnSGFzaCA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgobXNnSGFzaCk7XG4gICAgc2lnbmF0dXJlID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChzaWduYXR1cmUpO1xuXG4gICAgY29uc3QgdiA9IHBhcnNlSW50KHNpZ25hdHVyZS5zbGljZSgxMjgsIDEzMCksIDE2KTtcbiAgICBjb25zdCByID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNsaWNlKDAsIDY0KSwgJ2hleCcpO1xuICAgIGNvbnN0IHMgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUuc2xpY2UoNjQsIDEyOCksICdoZXgnKTtcblxuICAgIGNvbnN0IHB1YktleSA9IGV0aFV0aWwuZWNyZWNvdmVyKEJ1ZmZlci5mcm9tKG1zZ0hhc2gsICdoZXgnKSwgdiwgciwgcyk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoZXRoVXRpbC5wdWJUb0FkZHJlc3MocHViS2V5KSk7XG4gIH1cbn1cbiJdfQ==