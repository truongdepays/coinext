"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlsUtils = void 0;
const crypto_1 = require("crypto");
const openpgp_1 = require("openpgp");
const account_lib_1 = require("@bitgo/account-lib");
const mpcUtils_1 = require("./mpcUtils");
/**
 * Utility functions for BLS-DKG work flows.
 */
class BlsUtils extends mpcUtils_1.MpcUtils {
    constructor(bitgo, baseCoin) {
        super(bitgo, baseCoin);
    }
    /**
     * Creates a Keychain containing the User's BLS-DKG signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's BLS-DKG key share
     * @param backupKeyShare - backup's BLS-DKG key share
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param passphrase - wallet passphrase used to encrypt user's signing materials
     */
    async createUserKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode) {
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        const bitGoToUserShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'user');
        if (!bitGoToUserShare) {
            throw new Error('Missing BitGo to User key share');
        }
        if (!userKeyShare.secretShares || !userKeyShare.pub) {
            throw new Error('Invalid user key shares');
        }
        if (!backupKeyShare.secretShares || !backupKeyShare.pub) {
            throw new Error('Invalid backup key shares');
        }
        const bitGoToUserPrivateShare = await this.decryptPrivateShare(bitGoToUserShare.privateShare, userGpgKey);
        const userPrivateKey = account_lib_1.BaseCoin.BlsKeyPair.aggregatePrvkeys([
            userKeyShare.secretShares[0],
            backupKeyShare.secretShares[0],
            bitGoToUserPrivateShare,
        ]);
        const commonPub = account_lib_1.BaseCoin.BlsKeyPair.aggregatePubkeys([
            userKeyShare.pub,
            backupKeyShare.pub,
            bitGoToUserShare.publicShare,
        ]);
        if (commonPub !== bitgoKeychain.commonPub) {
            throw new Error('Failed to create user keychain - commonPubs do not match.');
        }
        const userKeychainParams = {
            source: 'user',
            type: 'blsdkg',
            commonPub: commonPub,
            encryptedPrv: this.bitgo.encrypt({ input: userPrivateKey, password: passphrase }),
            originalPasscodeEncryptionCode: originalPasscodeEncryptionCode,
        };
        return await this.baseCoin.keychains().add(userKeychainParams);
    }
    /**
     * Creates a Keychain containing the Backup party's BLS-DKG signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - User's BLS-DKG Keyshare
     * @param backupKeyShare - Backup's BLS-DKG Keyshare
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param passphrase - wallet passphrase used to encrypt user's signing materials
     */
    async createBackupKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase) {
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Invalid bitgo keyshares');
        }
        const bitGoToBackupShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'backup');
        if (!bitGoToBackupShare) {
            throw new Error('Missing BitGo to User key share');
        }
        if (!userKeyShare.secretShares || !userKeyShare.pub) {
            throw new Error('Invalid user key shares');
        }
        if (!backupKeyShare.secretShares || !backupKeyShare.pub) {
            throw new Error('Invalid backup key shares');
        }
        const bitGoToBackupPrivateShare = await this.decryptPrivateShare(bitGoToBackupShare.privateShare, userGpgKey);
        const backupPrivateKey = account_lib_1.BaseCoin.BlsKeyPair.aggregatePrvkeys([
            userKeyShare.secretShares[1],
            backupKeyShare.secretShares[1],
            bitGoToBackupPrivateShare,
        ]);
        const commonPub = account_lib_1.BaseCoin.BlsKeyPair.aggregatePubkeys([
            userKeyShare.pub,
            backupKeyShare.pub,
            bitGoToBackupShare.publicShare,
        ]);
        if (commonPub !== bitgoKeychain.commonPub) {
            throw new Error('Failed to create backup keychain - commonPubs do not match.');
        }
        return await this.baseCoin.keychains().createBackup({
            source: 'backup',
            type: 'blsdkg',
            commonPub: commonPub,
            prv: backupPrivateKey,
            encryptedPrv: this.bitgo.encrypt({ input: backupPrivateKey, password: passphrase }),
        });
    }
    /**
     * Creates a Keychain containing BitGo's BLS-DKG signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's BLS-DKG key share
     * @param backupKeyShare - backup's BLS-DKG key share
     */
    async createBitgoKeychain(userGpgKey, userKeyShare, backupKeyShare, enterprise) {
        if (!userKeyShare.secretShares || !userKeyShare.pub) {
            throw new Error('Invalid user key shares');
        }
        if (!backupKeyShare.secretShares || !backupKeyShare.pub) {
            throw new Error('Invalid backup key shares');
        }
        const userToBitgoKeyShare = {
            publicShare: userKeyShare.pub,
            privateShare: userKeyShare.secretShares[2],
        };
        const backupToBitgoKeyShare = {
            publicShare: backupKeyShare.pub,
            privateShare: backupKeyShare.secretShares[2],
        };
        return await this.createBitgoKeychainInWP(userGpgKey, userToBitgoKeyShare, backupToBitgoKeyShare, 'blsdkg', enterprise);
    }
    /**
     * Creates User, Backup, and BitGo BLS-DKG Keychains.
     *
     * @param params.passphrase - passphrase used to encrypt signing materials created for User and Backup
     */
    async createKeychains(params) {
        const userKeyShare = this.baseCoin.generateKeyPair();
        const backupKeyShare = this.baseCoin.generateKeyPair();
        const randomHexString = crypto_1.randomBytes(12).toString('hex');
        const userGpgKey = await openpgp_1.generateKey({
            userIDs: [
                {
                    name: randomHexString,
                    email: `${randomHexString}@${randomHexString}.com`,
                },
            ],
        });
        const bitgoKeychain = await this.createBitgoKeychain(userGpgKey, userKeyShare, backupKeyShare, params.enterprise);
        const userKeychainPromise = this.createUserKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, params.passphrase, params.originalPasscodeEncryptionCode);
        const backupKeychainPromise = this.createBackupKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, params.passphrase);
        const [userKeychain, backupKeychain] = await Promise.all([userKeychainPromise, backupKeychainPromise]);
        // create wallet
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        return keychains;
    }
}
exports.BlsUtils = BlsUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxzVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvaW50ZXJuYWwvYmxzVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxtQ0FBcUM7QUFDckMscUNBQXlEO0FBRXpELG9EQUFvRTtBQUtwRSx5Q0FBc0M7QUFFdEM7O0dBRUc7QUFDSCxNQUFhLFFBQVMsU0FBUSxtQkFBUTtJQUNwQyxZQUFZLEtBQVksRUFBRSxRQUFrQjtRQUMxQyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILEtBQUssQ0FBQyxrQkFBa0IsQ0FDdEIsVUFBcUMsRUFDckMsWUFBd0IsRUFDeEIsY0FBMEIsRUFDMUIsYUFBdUIsRUFDdkIsVUFBa0IsRUFDbEIsOEJBQXVDO1FBRXZDLE1BQU0sY0FBYyxHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUM7UUFDL0MsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDN0M7UUFFRCxNQUFNLGdCQUFnQixHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssT0FBTyxJQUFJLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFBTSxDQUFDLENBQUM7UUFDaEgsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRDtRQUVELElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRTtZQUNuRCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDNUM7UUFDRCxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksSUFBSSxDQUFDLGNBQWMs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QUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsbUJBQW1CLEVBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUFDO1FBRXZHLGdCQUFnQjtRQUNoQixNQUFNLFNBQVMsR0FBRztZQUNoQixZQUFZO1lBQ1osY0FBYztZQUNkLGFBQWE7U0FDZCxDQUFDO1FBRUYsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztDQUNGO0FBdE5ELDRCQXNOQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cblxuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgU2VyaWFsaXplZEtleVBhaXIsIGdlbmVyYXRlS2V5IH0gZnJvbSAnb3BlbnBncCc7XG5cbmltcG9ydCB7IEJhc2VDb2luIGFzIEJhc2VDb2luQWNjb3VudExpYiB9IGZyb20gJ0BiaXRnby9hY2NvdW50LWxpYic7XG5cbmltcG9ydCB7IEJhc2VDb2luLCBLZXljaGFpbnNUcmlwbGV0LCBCbHNLZXlQYWlyIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgS2V5Y2hhaW4gfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBNcGNVdGlscyB9IGZyb20gJy4vbXBjVXRpbHMnO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBCTFMtREtHIHdvcmsgZmxvd3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCbHNVdGlscyBleHRlbmRzIE1wY1V0aWxzIHtcbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4pIHtcbiAgICBzdXBlcihiaXRnbywgYmFzZUNvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBLZXljaGFpbiBjb250YWluaW5nIHRoZSBVc2VyJ3MgQkxTLURLRyBzaWduaW5nIG1hdGVyaWFscy5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJHcGdLZXkgLSBlcGhlbWVyYWwgR1BHIGtleSB0byBlbmNyeXB0IC8gZGVjcnlwdCBzZW5zaXR2ZSBkYXRhIGV4Y2hhbmdlZCBiZXR3ZWVuIHVzZXIgYW5kIHNlcnZlclxuICAgKiBAcGFyYW0gdXNlcktleVNoYXJlIC0gdXNlcidzIEJMUy1ES0cga2V5IHNoYXJlXG4gICAqIEBwYXJhbSBiYWNrdXBLZXlTaGFyZSAtIGJhY2t1cCdzIEJMUy1ES0cga2V5IHNoYXJlXG4gICAqIEBwYXJhbSBiaXRnb0tleWNoYWluIC0gcHJldmlvdXNseSBjcmVhdGVkIEJpdEdvIGtleWNoYWluOyBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB1c2VyIGFuZCBiYWNrdXAga2V5IHNoYXJlc1xuICAgKiBAcGFyYW0gcGFzc3BocmFzZSAtIHdhbGxldCBwYXNzcGhyYXNlIHVzZWQgdG8gZW5jcnlwdCB1c2VyJ3Mgc2lnbmluZyBtYXRlcmlhbHNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXJLZXljaGFpbihcbiAgICB1c2VyR3BnS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIHVzZXJLZXlTaGFyZTogQmxzS2V5UGFpcixcbiAgICBiYWNrdXBLZXlTaGFyZTogQmxzS2V5UGFpcixcbiAgICBiaXRnb0tleWNoYWluOiBLZXljaGFpbixcbiAgICBwYXNzcGhyYXNlOiBzdHJpbmcsXG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nXG4gICk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBjb25zdCBiaXRnb0tleVNoYXJlcyA9IGJpdGdvS2V5Y2hhaW4ua2V5U2hhcmVzO1xuICAgIGlmICghYml0Z29LZXlTaGFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCaXRHbyBrZXkgc2hhcmVzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0R29Ub1VzZXJTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAndXNlcicpO1xuICAgIGlmICghYml0R29Ub1VzZXJTaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIHRvIFVzZXIga2V5IHNoYXJlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VyS2V5U2hhcmUuc2VjcmV0U2hhcmVzIHx8ICF1c2VyS2V5U2hhcmUucHViKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgc2hhcmVzJyk7XG4gICAgfVxuICAgIGlmICghYmFja3VwS2V5U2hhcmUuc2VjcmV0U2hhcmVzIHx8ICFiYWNrdXBLZXlTaGFyZS5wdWIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAga2V5IHNoYXJlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9Vc2VyUHJpdmF0ZVNoYXJlID0gYXdhaXQgdGhpcy5kZWNyeXB0UHJpdmF0ZVNoYXJlKGJpdEdvVG9Vc2VyU2hhcmUucHJpdmF0ZVNoYXJlLCB1c2VyR3BnS2V5KTtcblxuICAgIGNvbnN0IHVzZXJQcml2YXRlS2V5ID0gQmFzZUNvaW5BY2NvdW50TGliLkJsc0tleVBhaXIuYWdncmVnYXRlUHJ2a2V5cyhbXG4gICAgICB1c2VyS2V5U2hhcmUuc2VjcmV0U2hhcmVzWzBdLFxuICAgICAgYmFja3VwS2V5U2hhcmUuc2VjcmV0U2hhcmVzWzBdLFxuICAgICAgYml0R29Ub1VzZXJQcml2YXRlU2hhcmUsXG4gICAgXSk7XG4gICAgY29uc3QgY29tbW9uUHViID0gQmFzZUNvaW5BY2NvdW50TGliLkJsc0tleVBhaXIuYWdncmVnYXRlUHVia2V5cyhbXG4gICAgICB1c2VyS2V5U2hhcmUucHViLFxuICAgICAgYmFja3VwS2V5U2hhcmUucHViLFxuICAgICAgYml0R29Ub1VzZXJTaGFyZS5wdWJsaWNTaGFyZSxcbiAgICBdKTtcbiAgICBpZiAoY29tbW9uUHViICE9PSBiaXRnb0tleWNoYWluLmNvbW1vblB1Yikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHVzZXIga2V5Y2hhaW4gLSBjb21tb25QdWJzIGRvIG5vdCBtYXRjaC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyS2V5Y2hhaW5QYXJhbXM6IGFueSA9IHtcbiAgICAgIHNvdXJjZTogJ3VzZXInLFxuICAgICAgdHlwZTogJ2Jsc2RrZycsXG4gICAgICBjb21tb25QdWI6IGNvbW1vblB1YixcbiAgICAgIGVuY3J5cHRlZFBydjogdGhpcy5iaXRnby5lbmNyeXB0KHsgaW5wdXQ6IHVzZXJQcml2YXRlS2V5LCBwYXNzd29yZDogcGFzc3BocmFzZSB9KSxcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQodXNlcktleWNoYWluUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgS2V5Y2hhaW4gY29udGFpbmluZyB0aGUgQmFja3VwIHBhcnR5J3MgQkxTLURLRyBzaWduaW5nIG1hdGVyaWFscy5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJHcGdLZXkgLSBlcGhlbWVyYWwgR1BHIGtleSB0byBlbmNyeXB0IC8gZGVjcnlwdCBzZW5zaXR2ZSBkYXRhIGV4Y2hhbmdlZCBiZXR3ZWVuIHVzZXIgYW5kIHNlcnZlclxuICAgKiBAcGFyYW0gdXNlcktleVNoYXJlIC0gVXNlcidzIEJMUy1ES0cgS2V5c2hhcmVcbiAgICogQHBhcmFtIGJhY2t1cEtleVNoYXJlIC0gQmFja3VwJ3MgQkxTLURLRyBLZXlzaGFyZVxuICAgKiBAcGFyYW0gYml0Z29LZXljaGFpbiAtIHByZXZpb3VzbHkgY3JlYXRlZCBCaXRHbyBrZXljaGFpbjsgbXVzdCBiZSBjb21wYXRpYmxlIHdpdGggdXNlciBhbmQgYmFja3VwIGtleSBzaGFyZXNcbiAgICogQHBhcmFtIHBhc3NwaHJhc2UgLSB3YWxsZXQgcGFzc3BocmFzZSB1c2VkIHRvIGVuY3J5cHQgdXNlcidzIHNpZ25pbmcgbWF0ZXJpYWxzXG4gICAqL1xuICBhc3luYyBjcmVhdGVCYWNrdXBLZXljaGFpbihcbiAgICB1c2VyR3BnS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIHVzZXJLZXlTaGFyZTogQmxzS2V5UGFpcixcbiAgICBiYWNrdXBLZXlTaGFyZTogQmxzS2V5UGFpcixcbiAgICBiaXRnb0tleWNoYWluOiBLZXljaGFpbixcbiAgICBwYXNzcGhyYXNlOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbnN0IGJpdGdvS2V5U2hhcmVzID0gYml0Z29LZXljaGFpbi5rZXlTaGFyZXM7XG4gICAgaWYgKCFiaXRnb0tleVNoYXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJpdGdvIGtleXNoYXJlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9CYWNrdXBTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAnYmFja3VwJyk7XG4gICAgaWYgKCFiaXRHb1RvQmFja3VwU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCaXRHbyB0byBVc2VyIGtleSBzaGFyZScpO1xuICAgIH1cblxuICAgIGlmICghdXNlcktleVNoYXJlLnNlY3JldFNoYXJlcyB8fCAhdXNlcktleVNoYXJlLnB1Yikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIga2V5IHNoYXJlcycpO1xuICAgIH1cbiAgICBpZiAoIWJhY2t1cEtleVNoYXJlLnNlY3JldFNoYXJlcyB8fCAhYmFja3VwS2V5U2hhcmUucHViKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFja3VwIGtleSBzaGFyZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRHb1RvQmFja3VwUHJpdmF0ZVNoYXJlID0gYXdhaXQgdGhpcy5kZWNyeXB0UHJpdmF0ZVNoYXJlKGJpdEdvVG9CYWNrdXBTaGFyZS5wcml2YXRlU2hhcmUsIHVzZXJHcGdLZXkpO1xuXG4gICAgY29uc3QgYmFja3VwUHJpdmF0ZUtleSA9IEJhc2VDb2luQWNjb3VudExpYi5CbHNLZXlQYWlyLmFnZ3JlZ2F0ZVBydmtleXMoW1xuICAgICAgdXNlcktleVNoYXJlLnNlY3JldFNoYXJlc1sxXSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLnNlY3JldFNoYXJlc1sxXSxcbiAgICAgIGJpdEdvVG9CYWNrdXBQcml2YXRlU2hhcmUsXG4gICAgXSk7XG4gICAgY29uc3QgY29tbW9uUHViID0gQmFzZUNvaW5BY2NvdW50TGliLkJsc0tleVBhaXIuYWdncmVnYXRlUHVia2V5cyhbXG4gICAgICB1c2VyS2V5U2hhcmUucHViLFxuICAgICAgYmFja3VwS2V5U2hhcmUucHViLFxuICAgICAgYml0R29Ub0JhY2t1cFNoYXJlLnB1YmxpY1NoYXJlLFxuICAgIF0pO1xuICAgIGlmIChjb21tb25QdWIgIT09IGJpdGdvS2V5Y2hhaW4uY29tbW9uUHViKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYmFja3VwIGtleWNoYWluIC0gY29tbW9uUHVicyBkbyBub3QgbWF0Y2guJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQmFja3VwKHtcbiAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICB0eXBlOiAnYmxzZGtnJyxcbiAgICAgIGNvbW1vblB1YjogY29tbW9uUHViLFxuICAgICAgcHJ2OiBiYWNrdXBQcml2YXRlS2V5LFxuICAgICAgZW5jcnlwdGVkUHJ2OiB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogYmFja3VwUHJpdmF0ZUtleSwgcGFzc3dvcmQ6IHBhc3NwaHJhc2UgfSksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEtleWNoYWluIGNvbnRhaW5pbmcgQml0R28ncyBCTFMtREtHIHNpZ25pbmcgbWF0ZXJpYWxzLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckdwZ0tleSAtIGVwaGVtZXJhbCBHUEcga2V5IHRvIGVuY3J5cHQgLyBkZWNyeXB0IHNlbnNpdHZlIGRhdGEgZXhjaGFuZ2VkIGJldHdlZW4gdXNlciBhbmQgc2VydmVyXG4gICAqIEBwYXJhbSB1c2VyS2V5U2hhcmUgLSB1c2VyJ3MgQkxTLURLRyBrZXkgc2hhcmVcbiAgICogQHBhcmFtIGJhY2t1cEtleVNoYXJlIC0gYmFja3VwJ3MgQkxTLURLRyBrZXkgc2hhcmVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJpdGdvS2V5Y2hhaW4oXG4gICAgdXNlckdwZ0tleTogU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICB1c2VyS2V5U2hhcmU6IEJsc0tleVBhaXIsXG4gICAgYmFja3VwS2V5U2hhcmU6IEJsc0tleVBhaXIsXG4gICAgZW50ZXJwcmlzZT86IHN0cmluZ1xuICApOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgaWYgKCF1c2VyS2V5U2hhcmUuc2VjcmV0U2hhcmVzIHx8ICF1c2VyS2V5U2hhcmUucHViKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgc2hhcmVzJyk7XG4gICAgfVxuICAgIGlmICghYmFja3VwS2V5U2hhcmUuc2VjcmV0U2hhcmVzIHx8ICFiYWNrdXBLZXlTaGFyZS5wdWIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAga2V5IHNoYXJlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJUb0JpdGdvS2V5U2hhcmUgPSB7XG4gICAgICBwdWJsaWNTaGFyZTogdXNlcktleVNoYXJlLnB1YixcbiAgICAgIHByaXZhdGVTaGFyZTogdXNlcktleVNoYXJlLnNlY3JldFNoYXJlc1syXSxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwVG9CaXRnb0tleVNoYXJlID0ge1xuICAgICAgcHVibGljU2hhcmU6IGJhY2t1cEtleVNoYXJlLnB1YixcbiAgICAgIHByaXZhdGVTaGFyZTogYmFja3VwS2V5U2hhcmUuc2VjcmV0U2hhcmVzWzJdLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVCaXRnb0tleWNoYWluSW5XUChcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICB1c2VyVG9CaXRnb0tleVNoYXJlLFxuICAgICAgYmFja3VwVG9CaXRnb0tleVNoYXJlLFxuICAgICAgJ2Jsc2RrZycsXG4gICAgICBlbnRlcnByaXNlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFVzZXIsIEJhY2t1cCwgYW5kIEJpdEdvIEJMUy1ES0cgS2V5Y2hhaW5zLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnBhc3NwaHJhc2UgLSBwYXNzcGhyYXNlIHVzZWQgdG8gZW5jcnlwdCBzaWduaW5nIG1hdGVyaWFscyBjcmVhdGVkIGZvciBVc2VyIGFuZCBCYWNrdXBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUtleWNoYWlucyhwYXJhbXM6IHtcbiAgICBwYXNzcGhyYXNlOiBzdHJpbmc7XG4gICAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPEtleWNoYWluc1RyaXBsZXQ+IHtcbiAgICBjb25zdCB1c2VyS2V5U2hhcmUgPSB0aGlzLmJhc2VDb2luLmdlbmVyYXRlS2V5UGFpcigpO1xuICAgIGNvbnN0IGJhY2t1cEtleVNoYXJlID0gdGhpcy5iYXNlQ29pbi5nZW5lcmF0ZUtleVBhaXIoKTtcblxuICAgIGNvbnN0IHJhbmRvbUhleFN0cmluZyA9IHJhbmRvbUJ5dGVzKDEyKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVLZXkoe1xuICAgICAgdXNlcklEczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogcmFuZG9tSGV4U3RyaW5nLFxuICAgICAgICAgIGVtYWlsOiBgJHtyYW5kb21IZXhTdHJpbmd9QCR7cmFuZG9tSGV4U3RyaW5nfS5jb21gLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJpdGdvS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmNyZWF0ZUJpdGdvS2V5Y2hhaW4odXNlckdwZ0tleSwgdXNlcktleVNoYXJlLCBiYWNrdXBLZXlTaGFyZSwgcGFyYW1zLmVudGVycHJpc2UpO1xuICAgIGNvbnN0IHVzZXJLZXljaGFpblByb21pc2UgPSB0aGlzLmNyZWF0ZVVzZXJLZXljaGFpbihcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBwYXJhbXMucGFzc3BocmFzZSxcbiAgICAgIHBhcmFtcy5vcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGVcbiAgICApO1xuICAgIGNvbnN0IGJhY2t1cEtleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlQmFja3VwS2V5Y2hhaW4oXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgdXNlcktleVNoYXJlLFxuICAgICAgYmFja3VwS2V5U2hhcmUsXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgcGFyYW1zLnBhc3NwaHJhc2VcbiAgICApO1xuICAgIGNvbnN0IFt1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluXSA9IGF3YWl0IFByb21pc2UuYWxsKFt1c2VyS2V5Y2hhaW5Qcm9taXNlLCBiYWNrdXBLZXljaGFpblByb21pc2VdKTtcblxuICAgIC8vIGNyZWF0ZSB3YWxsZXRcbiAgICBjb25zdCBrZXljaGFpbnMgPSB7XG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgfTtcblxuICAgIHJldHVybiBrZXljaGFpbnM7XG4gIH1cbn1cbiJdfQ==