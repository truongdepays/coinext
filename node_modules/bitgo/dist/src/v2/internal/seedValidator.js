"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedValidator = void 0;
const stellar = require("stellar-sdk");
const _ = require("lodash");
const statics_1 = require("@bitgo/statics");
const account_lib_1 = require("@bitgo/account-lib");
/**
 * This classes intention is to guess/verify what seeds come from where.
 */
class SeedValidator {
    /**
     * Try to guess what kind of seed this could be
     * @param seed
     * @returns {string} - returns undefined if the coin type is undetectable. returns
     * the coin family otherwise.
     */
    static getCoinFamilyFromSeed(seed) {
        let coin = undefined;
        // if this can be implemented in more than one competing seed format, that could be an issue
        if (!SeedValidator.hasCompetingSeedFormats(seed)) {
            // ordering generally matters here - hbar is the least permissive for seed checking, algo and
            // stellar have checksums. coin is guaranteed to be mutually exclusive by the
            // competing seed format check
            if (account_lib_1.Algo.algoUtils.isValidSeed(seed))
                coin = statics_1.CoinFamily.ALGO;
            if (stellar.StrKey.isValidEd25519SecretSeed(seed))
                coin = statics_1.CoinFamily.XLM;
            if (SeedValidator.isValidHbarSeedFormat(seed))
                coin = statics_1.CoinFamily.HBAR;
        }
        return coin;
    }
    /**
     * Checks whether this is a valid seed for this coin family type.
     * @param seed - seed
     * @param coinFamily - the coinFamily of the coin we're working with
     */
    static isValidEd25519SeedForCoin(seed, coinFamily) {
        const guessedCoin = SeedValidator.getCoinFamilyFromSeed(seed);
        return coinFamily === guessedCoin;
    }
    /**
     * We need to ensure there is no overlap for any two seeds we put into this function. This functions
     * intention is for gating whether this seed could possibly match two formats or is invalid itself.
     * @param seed
     */
    static hasCompetingSeedFormats(seed) {
        const isAlgoSeed = account_lib_1.Algo.algoUtils.isValidSeed(seed);
        const isStellarSeed = stellar.StrKey.isValidEd25519SecretSeed(seed);
        const isHbarSeed = SeedValidator.isValidHbarSeedFormat(seed);
        return _.sum([isAlgoSeed, isStellarSeed, isHbarSeed]) !== 1;
    }
    /**
     * Checks if this is a valid Hbar prv. These can be encoded differently.
     * @param seed
     */
    static isValidHbarSeedFormat(seed) {
        try {
            account_lib_1.Hbar.Utils.createRawKey(seed);
        }
        catch {
            return false;
        }
        return true;
    }
}
exports.SeedValidator = SeedValidator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VlZFZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9pbnRlcm5hbC9zZWVkVmFsaWRhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHVDQUF1QztBQUN2Qyw0QkFBNEI7QUFDNUIsNENBQTRDO0FBQzVDLG9EQUFnRDtBQUVoRDs7R0FFRztBQUNILE1BQWEsYUFBYTtJQUV4Qjs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxJQUFZO1FBQ3ZDLElBQUksSUFBSSxHQUEyQixTQUFTLENBQUM7UUFFN0MsNEZBQTRGO1FBQzVGLElBQUksQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEQsNkZBQTZGO1lBQzdGLDZFQUE2RTtZQUM3RSw4QkFBOEI7WUFFOUIsSUFBSSxrQkFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO2dCQUFFLElBQUksR0FBRyxvQkFBVSxDQUFDLElBQUksQ0FBQztZQUM3RCxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDO2dCQUFFLElBQUksR0FBRyxvQkFBVSxDQUFDLEdBQUcsQ0FBQztZQUN6RSxJQUFJLGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUM7Z0JBQUUsSUFBSSxHQUFHLG9CQUFVLENBQUMsSUFBSSxDQUFDO1NBQ3ZFO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxJQUFZLEVBQUUsVUFBc0I7UUFDbkUsTUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlELE9BQU8sVUFBVSxLQUFLLFdBQVcsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxJQUFZO1FBQ3pDLE1BQU0sVUFBVSxHQUFHLGtCQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU3RCxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsYUFBYSxFQUFFLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMscUJBQXFCLENBQUMsSUFBWTtRQUN2QyxJQUFJO1lBQ0Ysa0JBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQy9CO1FBQUMsTUFBTTtZQUNOLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Q0FFRjtBQTdERCxzQ0E2REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IENvaW5GYW1pbHkgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBIYmFyLCBBbGdvIH0gZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcblxuLyoqXG4gKiBUaGlzIGNsYXNzZXMgaW50ZW50aW9uIGlzIHRvIGd1ZXNzL3ZlcmlmeSB3aGF0IHNlZWRzIGNvbWUgZnJvbSB3aGVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlZWRWYWxpZGF0b3Ige1xuXG4gIC8qKlxuICAgKiBUcnkgdG8gZ3Vlc3Mgd2hhdCBraW5kIG9mIHNlZWQgdGhpcyBjb3VsZCBiZVxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBjb2luIHR5cGUgaXMgdW5kZXRlY3RhYmxlLiByZXR1cm5zXG4gICAqIHRoZSBjb2luIGZhbWlseSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgZ2V0Q29pbkZhbWlseUZyb21TZWVkKHNlZWQ6IHN0cmluZyk6IENvaW5GYW1pbHkgfCB1bmRlZmluZWQge1xuICAgIGxldCBjb2luOiBDb2luRmFtaWx5IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gaWYgdGhpcyBjYW4gYmUgaW1wbGVtZW50ZWQgaW4gbW9yZSB0aGFuIG9uZSBjb21wZXRpbmcgc2VlZCBmb3JtYXQsIHRoYXQgY291bGQgYmUgYW4gaXNzdWVcbiAgICBpZiAoIVNlZWRWYWxpZGF0b3IuaGFzQ29tcGV0aW5nU2VlZEZvcm1hdHMoc2VlZCkpIHtcbiAgICAgIC8vIG9yZGVyaW5nIGdlbmVyYWxseSBtYXR0ZXJzIGhlcmUgLSBoYmFyIGlzIHRoZSBsZWFzdCBwZXJtaXNzaXZlIGZvciBzZWVkIGNoZWNraW5nLCBhbGdvIGFuZFxuICAgICAgLy8gc3RlbGxhciBoYXZlIGNoZWNrc3Vtcy4gY29pbiBpcyBndWFyYW50ZWVkIHRvIGJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBieSB0aGVcbiAgICAgIC8vIGNvbXBldGluZyBzZWVkIGZvcm1hdCBjaGVja1xuXG4gICAgICBpZiAoQWxnby5hbGdvVXRpbHMuaXNWYWxpZFNlZWQoc2VlZCkpIGNvaW4gPSBDb2luRmFtaWx5LkFMR087XG4gICAgICBpZiAoc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlTZWNyZXRTZWVkKHNlZWQpKSBjb2luID0gQ29pbkZhbWlseS5YTE07XG4gICAgICBpZiAoU2VlZFZhbGlkYXRvci5pc1ZhbGlkSGJhclNlZWRGb3JtYXQoc2VlZCkpIGNvaW4gPSBDb2luRmFtaWx5LkhCQVI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvaW47XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBpcyBhIHZhbGlkIHNlZWQgZm9yIHRoaXMgY29pbiBmYW1pbHkgdHlwZS5cbiAgICogQHBhcmFtIHNlZWQgLSBzZWVkXG4gICAqIEBwYXJhbSBjb2luRmFtaWx5IC0gdGhlIGNvaW5GYW1pbHkgb2YgdGhlIGNvaW4gd2UncmUgd29ya2luZyB3aXRoXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEVkMjU1MTlTZWVkRm9yQ29pbihzZWVkOiBzdHJpbmcsIGNvaW5GYW1pbHk6IENvaW5GYW1pbHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBndWVzc2VkQ29pbiA9IFNlZWRWYWxpZGF0b3IuZ2V0Q29pbkZhbWlseUZyb21TZWVkKHNlZWQpO1xuICAgIHJldHVybiBjb2luRmFtaWx5ID09PSBndWVzc2VkQ29pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRvIGVuc3VyZSB0aGVyZSBpcyBubyBvdmVybGFwIGZvciBhbnkgdHdvIHNlZWRzIHdlIHB1dCBpbnRvIHRoaXMgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb25zXG4gICAqIGludGVudGlvbiBpcyBmb3IgZ2F0aW5nIHdoZXRoZXIgdGhpcyBzZWVkIGNvdWxkIHBvc3NpYmx5IG1hdGNoIHR3byBmb3JtYXRzIG9yIGlzIGludmFsaWQgaXRzZWxmLlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKi9cbiAgc3RhdGljIGhhc0NvbXBldGluZ1NlZWRGb3JtYXRzKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzQWxnb1NlZWQgPSBBbGdvLmFsZ29VdGlscy5pc1ZhbGlkU2VlZChzZWVkKTtcbiAgICBjb25zdCBpc1N0ZWxsYXJTZWVkID0gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlTZWNyZXRTZWVkKHNlZWQpO1xuICAgIGNvbnN0IGlzSGJhclNlZWQgPSBTZWVkVmFsaWRhdG9yLmlzVmFsaWRIYmFyU2VlZEZvcm1hdChzZWVkKTtcblxuICAgIHJldHVybiBfLnN1bShbaXNBbGdvU2VlZCwgaXNTdGVsbGFyU2VlZCwgaXNIYmFyU2VlZF0pICE9PSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGlzIGEgdmFsaWQgSGJhciBwcnYuIFRoZXNlIGNhbiBiZSBlbmNvZGVkIGRpZmZlcmVudGx5LlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRIYmFyU2VlZEZvcm1hdChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgSGJhci5VdGlscy5jcmVhdGVSYXdLZXkoc2VlZCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbiJdfQ==