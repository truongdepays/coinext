"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TssUtils = exports.SignatureShareType = void 0;
const crypto = require("crypto");
const openpgp = require("openpgp");
const _ = require("lodash");
const hdTree_1 = require("@bitgo/account-lib/dist/src/mpc/hdTree");
const tss_1 = require("@bitgo/account-lib/dist/src/mpc/tss");
const opengpgUtils_1 = require("./opengpgUtils");
const mpcUtils_1 = require("./mpcUtils");
const bs58 = require("bs58");
var ShareKeyPosition;
(function (ShareKeyPosition) {
    ShareKeyPosition[ShareKeyPosition["USER"] = 1] = "USER";
    ShareKeyPosition[ShareKeyPosition["BACKUP"] = 2] = "BACKUP";
    ShareKeyPosition[ShareKeyPosition["BITGO"] = 3] = "BITGO";
})(ShareKeyPosition || (ShareKeyPosition = {}));
var SignatureShareType;
(function (SignatureShareType) {
    SignatureShareType["USER"] = "user";
    SignatureShareType["BACKUP"] = "backup";
    SignatureShareType["BITGO"] = "bitgo";
})(SignatureShareType = exports.SignatureShareType || (exports.SignatureShareType = {}));
// #endregion
/**
 * Utility functions for TSS work flows.
 */
class TssUtils extends mpcUtils_1.MpcUtils {
    constructor(bitgo, baseCoin, wallet) {
        super(bitgo, baseCoin);
        this._wallet = wallet;
    }
    get wallet() {
        if (_.isNil(this._wallet)) {
            throw new Error('Wallet not defined');
        }
        return this._wallet;
    }
    /**
     * Creates a Keychain containing the User's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param passphrase - wallet passphrase used to encrypt user's signing materials
     * @param [originalPasscodeEncryptionCode] - optional encryption code needed for wallet password reset for hot wallets
     */
    async createUserKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode) {
        await tss_1.default.initialize();
        const MPC = new tss_1.default();
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        const bitGoToUserShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'user');
        if (!bitGoToUserShare) {
            throw new Error('Missing BitGo to User key share');
        }
        const bitGoToUserPrivateShare = await this.decryptPrivateShare(bitGoToUserShare.privateShare, userGpgKey);
        const bitgoToUser = {
            i: 1,
            j: 3,
            y: bitGoToUserShare.publicShare.slice(0, 64),
            u: bitGoToUserPrivateShare.slice(0, 64),
            chaincode: bitGoToUserPrivateShare.slice(64),
        };
        const userCombined = MPC.keyCombine(userKeyShare.uShare, [backupKeyShare.yShares[1], bitgoToUser]);
        const commonKeychain = userCombined.pShare.y + userCombined.pShare.chaincode;
        if (commonKeychain !== bitgoKeychain.commonKeychain) {
            throw new Error('Failed to create user keychain - commonKeychains do not match.');
        }
        const userSigningMaterial = {
            uShare: userKeyShare.uShare,
            bitgoYShare: bitgoToUser,
            backupYShare: backupKeyShare.yShares[1],
        };
        const userKeychainParams = {
            source: 'user',
            type: 'tss',
            commonKeychain: bitgoKeychain.commonKeychain,
            encryptedPrv: this.bitgo.encrypt({ input: JSON.stringify(userSigningMaterial), password: passphrase }),
            originalPasscodeEncryptionCode,
        };
        return await this.baseCoin.keychains().add(userKeychainParams);
    }
    /**
     * Creates a Keychain containing the Backup party's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - User's TSS Keyshare
     * @param backupKeyShare - Backup's TSS Keyshare
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param passphrase - wallet passphrase used to encrypt user's signing materials
     */
    async createBackupKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase) {
        await tss_1.default.initialize();
        const MPC = new tss_1.default();
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Invalid bitgo keyshares');
        }
        const bitGoToBackupShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'backup');
        if (!bitGoToBackupShare) {
            throw new Error('Missing BitGo to User key share');
        }
        const bitGoToBackupPrivateShare = await this.decryptPrivateShare(bitGoToBackupShare.privateShare, userGpgKey);
        const bitgoToBackup = {
            i: 2,
            j: 3,
            y: bitGoToBackupShare.publicShare.slice(0, 64),
            u: bitGoToBackupPrivateShare.slice(0, 64),
            chaincode: bitGoToBackupPrivateShare.slice(64),
        };
        const backupCombined = MPC.keyCombine(backupKeyShare.uShare, [userKeyShare.yShares[2], bitgoToBackup]);
        const commonKeychain = backupCombined.pShare.y + backupCombined.pShare.chaincode;
        if (commonKeychain !== bitgoKeychain.commonKeychain) {
            throw new Error('Failed to create backup keychain - commonKeychains do not match.');
        }
        const backupSigningMaterial = {
            uShare: backupKeyShare.uShare,
            bitgoYShare: bitgoToBackup,
            userYShare: userKeyShare.yShares[2],
        };
        const prv = JSON.stringify(backupSigningMaterial);
        return await this.baseCoin.keychains().createBackup({
            source: 'backup',
            type: 'tss',
            commonKeychain: bitgoKeychain.commonKeychain,
            prv: prv,
            encryptedPrv: this.bitgo.encrypt({ input: prv, password: passphrase }),
        });
    }
    /**
     * Creates a Keychain containing BitGo's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     */
    async createBitgoKeychain(userGpgKey, userKeyShare, backupKeyShare, enterprise) {
        const userToBitgoPublicShare = Buffer.concat([
            Buffer.from(userKeyShare.uShare.y, 'hex'),
            Buffer.from(userKeyShare.uShare.chaincode, 'hex'),
        ]).toString('hex');
        const userToBitgoPrivateShare = Buffer.concat([
            Buffer.from(userKeyShare.yShares[3].u, 'hex'),
            Buffer.from(userKeyShare.yShares[3].chaincode, 'hex'),
        ]).toString('hex');
        const userToBitgoKeyShare = {
            publicShare: userToBitgoPublicShare,
            privateShare: userToBitgoPrivateShare,
        };
        const backupToBitgoPublicShare = Buffer.concat([
            Buffer.from(backupKeyShare.uShare.y, 'hex'),
            Buffer.from(backupKeyShare.uShare.chaincode, 'hex'),
        ]).toString('hex');
        const backupToBitgoPrivateShare = Buffer.concat([
            Buffer.from(backupKeyShare.yShares[3].u, 'hex'),
            Buffer.from(backupKeyShare.yShares[3].chaincode, 'hex'),
        ]).toString('hex');
        const backupToBitgoKeyShare = {
            publicShare: backupToBitgoPublicShare,
            privateShare: backupToBitgoPrivateShare,
        };
        return await this.createBitgoKeychainInWP(userGpgKey, userToBitgoKeyShare, backupToBitgoKeyShare, 'tss', enterprise);
    }
    /**
     * Creates User, Backup, and BitGo TSS Keychains.
     *
     * @param params.passphrase - passphrase used to encrypt signing materials created for User and Backup
     */
    async createKeychains(params) {
        await tss_1.default.initialize();
        const MPC = new tss_1.default();
        const m = 2;
        const n = 3;
        const userKeyShare = MPC.keyShare(1, m, n);
        const backupKeyShare = MPC.keyShare(2, m, n);
        const randomHexString = crypto.randomBytes(12).toString('hex');
        const userGpgKey = await openpgp.generateKey({
            userIDs: [
                {
                    name: randomHexString,
                    email: `${randomHexString}@${randomHexString}.com`,
                },
            ],
        });
        const bitgoKeychain = await this.createBitgoKeychain(userGpgKey, userKeyShare, backupKeyShare, params.enterprise);
        const userKeychainPromise = this.createUserKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, params.passphrase, params.originalPasscodeEncryptionCode);
        const backupKeychainPromise = this.createBackupKeychain(userGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, params.passphrase);
        const [userKeychain, backupKeychain] = await Promise.all([userKeychainPromise, backupKeychainPromise]);
        // create wallet
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        return keychains;
    }
    /**
     * Signs the transaction associated to the transaction request.
     *
     * @param txRequest - transaction request object or id
     * @param prv - decrypted private key
     * @param reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequest(params) {
        let txRequestResolved;
        let txRequestId;
        const { txRequest, prv } = params;
        if (typeof txRequest === 'string') {
            txRequestResolved = await this.getTxRequest(txRequest);
            txRequestId = txRequestResolved.txRequestId;
        }
        else {
            txRequestResolved = txRequest;
            txRequestId = txRequest.txRequestId;
        }
        await tss_1.default.initialize();
        await hdTree_1.Ed25519BIP32.initialize();
        const MPC = new tss_1.default(new hdTree_1.Ed25519BIP32());
        const userSigningMaterial = JSON.parse(prv);
        const signingKey = MPC.keyDerive(userSigningMaterial.uShare, [userSigningMaterial.bitgoYShare, userSigningMaterial.backupYShare], txRequestResolved.unsignedTxs[0].derivationPath);
        const signablePayload = Buffer.from(txRequestResolved.unsignedTxs[0].signableHex, 'hex');
        const userSignShare = await this.createUserSignShare({ signablePayload, pShare: signingKey.pShare });
        const signerShare = signingKey.yShares[3].u + signingKey.yShares[3].chaincode;
        const bitgoGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(this.bitgo);
        const encryptedSignerShare = await opengpgUtils_1.encryptText(signerShare, bitgoGpgKey);
        await this.offerUserToBitgoRShare({
            txRequestId,
            userSignShare,
            encryptedSignerShare,
        });
        const bitgoToUserRShare = await this.getBitgoToUserRShare(txRequestId);
        const userToBitGoGShare = await this.createUserToBitGoGShare(userSignShare, bitgoToUserRShare, userSigningMaterial.backupYShare, userSigningMaterial.bitgoYShare, signablePayload);
        await this.sendUserToBitgoGShare(txRequestId, userToBitGoGShare);
        return await this.getTxRequest(txRequestId);
    }
    /**
     * Builds a tx request from params and verify it
     *
     * @param {PrebuildTransactionWithIntentOptions} params - parameters to build the tx
     * @returns {Promise<TxRequest>} - a built tx request
     */
    async prebuildTxWithIntent(params) {
        var _a;
        const chain = this.baseCoin.getChain();
        const intentRecipients = params.recipients.map((recipient) => ({
            address: { address: recipient.address },
            amount: { value: `${recipient.amount}`, symbol: chain },
        }));
        const whitelistedParams = {
            intent: {
                intentType: params.intentType,
                sequenceId: params.sequenceId,
                comment: params.comment,
                recipients: intentRecipients,
                memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
                token: params.tokenName,
                nonce: params.nonce,
            },
        };
        const unsignedTx = (await this.bitgo
            .post(this.bitgo.url('/wallet/' + this.wallet.id() + '/txrequests', 2))
            .send(whitelistedParams)
            .result());
        return unsignedTx;
    }
    /**
     * Creates the User Sign Share containing the User XShare and the User to Bitgo RShare
     *
     * @param {Buffer} signablePayload - the signablePayload as a buffer
     * @param {PShare} pShare - User's signing material
     * @returns {Promise<SignShare>} - User Sign Share
     */
    async createUserSignShare(params) {
        const { signablePayload, pShare } = params;
        await tss_1.default.initialize();
        const MPC = new tss_1.default();
        if (pShare.i !== ShareKeyPosition.USER) {
            throw new Error('Invalid PShare, PShare doesnt belong to the User');
        }
        const jShare = { i: ShareKeyPosition.BITGO, j: ShareKeyPosition.USER };
        return MPC.signShare(signablePayload, pShare, [jShare]);
    }
    /**
     * Sends a Signature Share
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {SignatureShareRecord} signatureShare - a Signature Share
     * @returns {Promise<SignatureShareRecord>} - a Signature Share
     */
    async sendSignatureShare(params) {
        const { txRequestId, signatureShare, signerShare } = params;
        return this.bitgo
            .post(this.bitgo.url('/wallet/' + this.wallet.id() + '/txrequests/' + txRequestId + '/signatureshares', 2))
            .send({
            signatureShare,
            signerShare,
        })
            .result();
    }
    /**
     * Sends the User to Bitgo RShare to Bitgo
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {SignShare} userSignShare - the user Sign Share
     * @param {String} encryptedSignerShare - signer share encrypted to bitgo key
     * @returns {Promise<void>}
     */
    async offerUserToBitgoRShare(params) {
        const { txRequestId, userSignShare, encryptedSignerShare } = params;
        const rShare = userSignShare.rShares[ShareKeyPosition.BITGO];
        if (_.isNil(rShare)) {
            throw new Error('userToBitgo RShare not found');
        }
        if (rShare.i !== ShareKeyPosition.BITGO || rShare.j !== ShareKeyPosition.USER) {
            throw new Error('Invalid RShare, is not from User to Bitgo');
        }
        const signatureShare = {
            from: SignatureShareType.USER,
            to: SignatureShareType.BITGO,
            share: rShare.r + rShare.R,
        };
        await this.sendSignatureShare({ txRequestId, signatureShare, signerShare: encryptedSignerShare });
    }
    /**
     * Gets the Bitgo to User RShare from Bitgo
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<SignatureShareRecord>} - a Signature Share
     */
    async getBitgoToUserRShare(txRequestId) {
        const txRequest = await this.getTxRequest(txRequestId);
        const signatureShares = txRequest.signatureShares;
        if (_.isNil(signatureShares) || _.isEmpty(signatureShares)) {
            throw new Error(`No signatures shares found for id: ${txRequestId}`);
        }
        // at this point we expect the only share to be the RShare
        const bitgoToUserRShare = signatureShares.find((sigShare) => sigShare.from === SignatureShareType.BITGO && sigShare.to === SignatureShareType.USER);
        if (_.isNil(bitgoToUserRShare)) {
            throw new Error(`Bitgo to User RShare not found for id: ${txRequestId}`);
        }
        return bitgoToUserRShare;
    }
    /**
     * Gets the latest Tx Request by id
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<TxRequest>}
     */
    async getTxRequest(txRequestId) {
        const txRequestRes = await this.bitgo
            .get(this.bitgo.url('/wallet/' + this.wallet.id() + '/txrequests', 2))
            .query({ txRequestIds: txRequestId, latest: 'true' })
            .result();
        if (txRequestRes.txRequests.length <= 0) {
            throw new Error(`Unable to find TxRequest with id ${txRequestId}`);
        }
        return txRequestRes.txRequests[0];
    }
    /**
     * Call delete signature shares for a txRequest, the endpoint delete the signatures and return them
     *
     * @param {string} txRequestId tx id reference to delete signature shares
     * @returns {SignatureShareRecord[]}
     */
    async deleteSignatureShares(txRequestId) {
        return this.bitgo
            .del(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests/${txRequestId}/signatureshares`, 2))
            .send()
            .result();
    }
    /**
     * Creates the User to Bitgo GShare
     *
     * @param {SignShare} userSignShare - the User Sign Share
     * @param {SignatureShareRecord} bitgoToUserRShare - the Bitgo to User RShare
     * @param {YShare} backupToUserYShare - the backup key Y share received during wallet creation
     * @param {Buffer} signablePayload - the signable payload from a tx
     * @returns {Promise<GShare>} - the User to Bitgo GShare
     */
    async createUserToBitGoGShare(userSignShare, bitgoToUserRShare, backupToUserYShare, bitgoToUserYShare, signablePayload) {
        if (userSignShare.xShare.i !== ShareKeyPosition.USER) {
            throw new Error('Invalid XShare, doesnt belong to the User');
        }
        if (bitgoToUserRShare.from !== SignatureShareType.BITGO || bitgoToUserRShare.to !== SignatureShareType.USER) {
            throw new Error('Invalid RShare, is not from Bitgo to User');
        }
        if (backupToUserYShare.i !== ShareKeyPosition.USER) {
            throw new Error('Invalid YShare, doesnt belong to the User');
        }
        if (backupToUserYShare.j !== ShareKeyPosition.BACKUP) {
            throw new Error('Invalid YShare, is not backup key');
        }
        const RShare = {
            i: ShareKeyPosition.USER,
            j: ShareKeyPosition.BITGO,
            u: bitgoToUserYShare.u,
            r: bitgoToUserRShare.share.substring(0, 64),
            R: bitgoToUserRShare.share.substring(64, 128),
        };
        await tss_1.default.initialize();
        const MPC = new tss_1.default();
        return MPC.sign(signablePayload, userSignShare.xShare, [RShare], [backupToUserYShare]);
    }
    /**
     * Sends the User to Bitgo GShare to Bitgo
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {GShare} userToBitgoGShare - the User to Bitgo GShare
     * @returns {Promise<void>}
     */
    async sendUserToBitgoGShare(txRequestId, userToBitgoGShare) {
        if (userToBitgoGShare.i !== ShareKeyPosition.USER) {
            throw new Error('Invalid GShare, doesnt belong to the User');
        }
        const signatureShare = {
            from: SignatureShareType.USER,
            to: SignatureShareType.BITGO,
            share: userToBitgoGShare.R + userToBitgoGShare.gamma,
        };
        await this.sendSignatureShare({ txRequestId, signatureShare });
    }
    /**
     * Initialize the send procedure once Bitgo has the User To Bitgo GShare
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<any>}
     */
    async sendTxRequest(txRequestId) {
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.wallet.id() + '/tx/send'))
            .send({ txRequestId })
            .result();
    }
    /**
     * Delete signature shares, get the tx request without them from the db and sign it to finally send it.
     *
     * Note : This can be performed in order to reach latest network conditions required on pending approval flow.
     *
     * @param {String} txRequestId - the txRequest Id to make the requests.
     * @param {String} decryptedPrv - decrypted prv to sign the tx request.
     * @param {RequestTracer} reqId id tracer.
     * @returns {Promise<any>}
     */
    async recreateTxRequest(txRequestId, decryptedPrv, reqId) {
        await this.deleteSignatureShares(txRequestId);
        // after delete signatures shares get the tx without them
        const txRequest = await this.getTxRequest(txRequestId);
        return await this.signTxRequest({ txRequest, prv: decryptedPrv, reqId });
    }
    /**
     * Get the commonPub portion of the commonKeychain.
     *
     * @param {String} commonKeychain
     * @returns {string}
     */
    static getPublicKeyFromCommonKeychain(commonKeychain) {
        if (commonKeychain.length !== 128) {
            throw new Error(`Invalid commonKeychain length, expected 128, got ${commonKeychain.length}`);
        }
        const commonPubHexStr = commonKeychain.slice(0, 64);
        return bs58.encode(Buffer.from(commonPubHexStr, 'hex'));
    }
}
exports.TssUtils = TssUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHNzVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvaW50ZXJuYWwvdHNzVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLDRCQUE2QjtBQUU3QixtRUFBc0U7QUFDdEUsNkRBUzZDO0FBSzdDLGlEQUFnRTtBQUNoRSx5Q0FBc0M7QUFHdEMsNkJBQTZCO0FBaUI3QixJQUFLLGdCQUlKO0FBSkQsV0FBSyxnQkFBZ0I7SUFDbkIsdURBQVEsQ0FBQTtJQUNSLDJEQUFVLENBQUE7SUFDVix5REFBUyxDQUFBO0FBQ1gsQ0FBQyxFQUpJLGdCQUFnQixLQUFoQixnQkFBZ0IsUUFJcEI7QUFpQkQsSUFBWSxrQkFJWDtBQUpELFdBQVksa0JBQWtCO0lBQzVCLG1DQUFhLENBQUE7SUFDYix1Q0FBaUIsQ0FBQTtJQUNqQixxQ0FBZSxDQUFBO0FBQ2pCLENBQUMsRUFKVyxrQkFBa0IsR0FBbEIsMEJBQWtCLEtBQWxCLDBCQUFrQixRQUk3QjtBQXFCRCxhQUFhO0FBRWI7O0dBRUc7QUFFSCxNQUFhLFFBQVMsU0FBUSxtQkFBUTtJQUdwQyxZQUFZLEtBQVksRUFBRSxRQUFrQixFQUFFLE1BQWU7UUFDM0QsS0FBSyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztJQUN4QixDQUFDO0lBRUQsSUFBWSxNQUFNO1FBQ2hCLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDekIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3ZDO1FBQ0QsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxLQUFLLENBQUMsa0JBQWtCLENBQ3RCLFVBQTZDLEVBQzdD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RCxPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLDhCQUE4QixDQUFDLGNBQXNCO1FBQzFELElBQUksY0FBYyxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7WUFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDOUY7UUFDRCxNQUFNLGVBQWUsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNwRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0NBQ0Y7QUE3akJELDRCQTZqQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgb3BlbnBncCBmcm9tICdvcGVucGdwJztcbmltcG9ydCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmltcG9ydCB7IEVkMjU1MTlCSVAzMiB9IGZyb20gJ0BiaXRnby9hY2NvdW50LWxpYi9kaXN0L3NyYy9tcGMvaGRUcmVlJztcbmltcG9ydCBFZGRzYSwge1xuICBLZXlTaGFyZSxcbiAgSlNoYXJlLFxuICBTaWduU2hhcmUsXG4gIFlTaGFyZSxcbiAgUlNoYXJlLFxuICBHU2hhcmUsXG4gIFVTaGFyZSxcbiAgUFNoYXJlLFxufSBmcm9tICdAYml0Z28vYWNjb3VudC1saWIvZGlzdC9zcmMvbXBjL3Rzcyc7XG5cbmltcG9ydCB7IEJhc2VDb2luLCBLZXljaGFpbnNUcmlwbGV0IH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgS2V5Y2hhaW4gfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBlbmNyeXB0VGV4dCwgZ2V0Qml0Z29HcGdQdWJLZXkgfSBmcm9tICcuL29wZW5ncGdVdGlscyc7XG5pbXBvcnQgeyBNcGNVdGlscyB9IGZyb20gJy4vbXBjVXRpbHMnO1xuaW1wb3J0IHsgTWVtbywgV2FsbGV0IH0gZnJvbSAnLi4nO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uL2ludGVybmFsL3V0aWwnO1xuaW1wb3J0ICogYXMgYnM1OCBmcm9tICdiczU4JztcblxuLy8gI3JlZ2lvbiBJbnRlcmZhY2VzXG5pbnRlcmZhY2UgUHJlYnVpbGRUcmFuc2FjdGlvbldpdGhJbnRlbnRPcHRpb25zIHtcbiAgcmVxSWQ6IFJlcXVlc3RUcmFjZXI7XG4gIGludGVudFR5cGU6IHN0cmluZztcbiAgc2VxdWVuY2VJZD86IHN0cmluZztcbiAgcmVjaXBpZW50czoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgfVtdO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBtZW1vPzogTWVtbztcbiAgdG9rZW5OYW1lPzogc3RyaW5nO1xuICBub25jZT86IHN0cmluZztcbn1cblxuZW51bSBTaGFyZUtleVBvc2l0aW9uIHtcbiAgVVNFUiA9IDEsXG4gIEJBQ0tVUCA9IDIsXG4gIEJJVEdPID0gMyxcbn1cblxuLy8gY29tcGxldGUgd2l0aCBtb3JlIHByb3BzIGlmIG5lY2Nlc2FyeVxuZXhwb3J0IGludGVyZmFjZSBUeFJlcXVlc3Qge1xuICB0eFJlcXVlc3RJZDogc3RyaW5nO1xuICB1bnNpZ25lZFR4czoge1xuICAgIHNlcmlhbGl6ZWRUeEhleDogc3RyaW5nO1xuICAgIHNpZ25hYmxlSGV4OiBzdHJpbmc7XG4gICAgZmVlSW5mbz86IHtcbiAgICAgIGZlZTogbnVtYmVyO1xuICAgICAgZmVlU3RyaW5nOiBzdHJpbmc7XG4gICAgfTtcbiAgICBkZXJpdmF0aW9uUGF0aDogc3RyaW5nO1xuICB9W107XG4gIHNpZ25hdHVyZVNoYXJlcz86IFNpZ25hdHVyZVNoYXJlUmVjb3JkW107XG59XG5cbmV4cG9ydCBlbnVtIFNpZ25hdHVyZVNoYXJlVHlwZSB7XG4gIFVTRVIgPSAndXNlcicsXG4gIEJBQ0tVUCA9ICdiYWNrdXAnLFxuICBCSVRHTyA9ICdiaXRnbycsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmF0dXJlU2hhcmVSZWNvcmQge1xuICBmcm9tOiBTaWduYXR1cmVTaGFyZVR5cGU7XG4gIHRvOiBTaWduYXR1cmVTaGFyZVR5cGU7XG4gIHNoYXJlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduaW5nTWF0ZXJpYWwge1xuICB1U2hhcmU6IFVTaGFyZTtcbiAgYml0Z29ZU2hhcmU6IFlTaGFyZTtcbn1cblxuaW50ZXJmYWNlIFVzZXJTaWduaW5nTWF0ZXJpYWwgZXh0ZW5kcyBTaWduaW5nTWF0ZXJpYWwge1xuICBiYWNrdXBZU2hhcmU6IFlTaGFyZTtcbn1cblxuaW50ZXJmYWNlIEJhY2t1cFNpZ25pbmdNYXRlcmlhbCBleHRlbmRzIFNpZ25pbmdNYXRlcmlhbCB7XG4gIHVzZXJZU2hhcmU6IFlTaGFyZTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBUU1Mgd29yayBmbG93cy5cbiAqL1xuXG5leHBvcnQgY2xhc3MgVHNzVXRpbHMgZXh0ZW5kcyBNcGNVdGlscyB7XG4gIHByaXZhdGUgX3dhbGxldD86IFdhbGxldDtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbiwgd2FsbGV0PzogV2FsbGV0KSB7XG4gICAgc3VwZXIoYml0Z28sIGJhc2VDb2luKTtcbiAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gIH1cblxuICBwcml2YXRlIGdldCB3YWxsZXQoKTogV2FsbGV0IHtcbiAgICBpZiAoXy5pc05pbCh0aGlzLl93YWxsZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBLZXljaGFpbiBjb250YWluaW5nIHRoZSBVc2VyJ3MgVFNTIHNpZ25pbmcgbWF0ZXJpYWxzLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckdwZ0tleSAtIGVwaGVtZXJhbCBHUEcga2V5IHRvIGVuY3J5cHQgLyBkZWNyeXB0IHNlbnNpdHZlIGRhdGEgZXhjaGFuZ2VkIGJldHdlZW4gdXNlciBhbmQgc2VydmVyXG4gICAqIEBwYXJhbSB1c2VyS2V5U2hhcmUgLSB1c2VyJ3MgVFNTIGtleSBzaGFyZVxuICAgKiBAcGFyYW0gYmFja3VwS2V5U2hhcmUgLSBiYWNrdXAncyBUU1Mga2V5IHNoYXJlXG4gICAqIEBwYXJhbSBiaXRnb0tleWNoYWluIC0gcHJldmlvdXNseSBjcmVhdGVkIEJpdEdvIGtleWNoYWluOyBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB1c2VyIGFuZCBiYWNrdXAga2V5IHNoYXJlc1xuICAgKiBAcGFyYW0gcGFzc3BocmFzZSAtIHdhbGxldCBwYXNzcGhyYXNlIHVzZWQgdG8gZW5jcnlwdCB1c2VyJ3Mgc2lnbmluZyBtYXRlcmlhbHNcbiAgICogQHBhcmFtIFtvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGVdIC0gb3B0aW9uYWwgZW5jcnlwdGlvbiBjb2RlIG5lZWRlZCBmb3Igd2FsbGV0IHBhc3N3b3JkIHJlc2V0IGZvciBob3Qgd2FsbGV0c1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlVXNlcktleWNoYWluKFxuICAgIHVzZXJHcGdLZXk6IG9wZW5wZ3AuU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICB1c2VyS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIGJhY2t1cEtleVNoYXJlOiBLZXlTaGFyZSxcbiAgICBiaXRnb0tleWNoYWluOiBLZXljaGFpbixcbiAgICBwYXNzcGhyYXNlOiBzdHJpbmcsXG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nXG4gICk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBhd2FpdCBFZGRzYS5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgTVBDID0gbmV3IEVkZHNhKCk7XG4gICAgY29uc3QgYml0Z29LZXlTaGFyZXMgPSBiaXRnb0tleWNoYWluLmtleVNoYXJlcztcbiAgICBpZiAoIWJpdGdvS2V5U2hhcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgQml0R28ga2V5IHNoYXJlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9Vc2VyU2hhcmUgPSBiaXRnb0tleVNoYXJlcy5maW5kKChrZXlTaGFyZSkgPT4ga2V5U2hhcmUuZnJvbSA9PT0gJ2JpdGdvJyAmJiBrZXlTaGFyZS50byA9PT0gJ3VzZXInKTtcbiAgICBpZiAoIWJpdEdvVG9Vc2VyU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCaXRHbyB0byBVc2VyIGtleSBzaGFyZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9Vc2VyUHJpdmF0ZVNoYXJlID0gYXdhaXQgdGhpcy5kZWNyeXB0UHJpdmF0ZVNoYXJlKGJpdEdvVG9Vc2VyU2hhcmUucHJpdmF0ZVNoYXJlLCB1c2VyR3BnS2V5KTtcblxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyOiBZU2hhcmUgPSB7XG4gICAgICBpOiAxLFxuICAgICAgajogMyxcbiAgICAgIHk6IGJpdEdvVG9Vc2VyU2hhcmUucHVibGljU2hhcmUuc2xpY2UoMCwgNjQpLFxuICAgICAgdTogYml0R29Ub1VzZXJQcml2YXRlU2hhcmUuc2xpY2UoMCwgNjQpLFxuICAgICAgY2hhaW5jb2RlOiBiaXRHb1RvVXNlclByaXZhdGVTaGFyZS5zbGljZSg2NCksXG4gICAgfTtcblxuICAgIGNvbnN0IHVzZXJDb21iaW5lZCA9IE1QQy5rZXlDb21iaW5lKHVzZXJLZXlTaGFyZS51U2hhcmUsIFtiYWNrdXBLZXlTaGFyZS55U2hhcmVzWzFdLCBiaXRnb1RvVXNlcl0pO1xuICAgIGNvbnN0IGNvbW1vbktleWNoYWluID0gdXNlckNvbWJpbmVkLnBTaGFyZS55ICsgdXNlckNvbWJpbmVkLnBTaGFyZS5jaGFpbmNvZGU7XG4gICAgaWYgKGNvbW1vbktleWNoYWluICE9PSBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdXNlciBrZXljaGFpbiAtIGNvbW1vbktleWNoYWlucyBkbyBub3QgbWF0Y2guJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlclNpZ25pbmdNYXRlcmlhbDogVXNlclNpZ25pbmdNYXRlcmlhbCA9IHtcbiAgICAgIHVTaGFyZTogdXNlcktleVNoYXJlLnVTaGFyZSxcbiAgICAgIGJpdGdvWVNoYXJlOiBiaXRnb1RvVXNlcixcbiAgICAgIGJhY2t1cFlTaGFyZTogYmFja3VwS2V5U2hhcmUueVNoYXJlc1sxXSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXNlcktleWNoYWluUGFyYW1zID0ge1xuICAgICAgc291cmNlOiAndXNlcicsXG4gICAgICB0eXBlOiAndHNzJyxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluLFxuICAgICAgZW5jcnlwdGVkUHJ2OiB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogSlNPTi5zdHJpbmdpZnkodXNlclNpZ25pbmdNYXRlcmlhbCksIHBhc3N3b3JkOiBwYXNzcGhyYXNlIH0pLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQodXNlcktleWNoYWluUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgS2V5Y2hhaW4gY29udGFpbmluZyB0aGUgQmFja3VwIHBhcnR5J3MgVFNTIHNpZ25pbmcgbWF0ZXJpYWxzLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckdwZ0tleSAtIGVwaGVtZXJhbCBHUEcga2V5IHRvIGVuY3J5cHQgLyBkZWNyeXB0IHNlbnNpdHZlIGRhdGEgZXhjaGFuZ2VkIGJldHdlZW4gdXNlciBhbmQgc2VydmVyXG4gICAqIEBwYXJhbSB1c2VyS2V5U2hhcmUgLSBVc2VyJ3MgVFNTIEtleXNoYXJlXG4gICAqIEBwYXJhbSBiYWNrdXBLZXlTaGFyZSAtIEJhY2t1cCdzIFRTUyBLZXlzaGFyZVxuICAgKiBAcGFyYW0gYml0Z29LZXljaGFpbiAtIHByZXZpb3VzbHkgY3JlYXRlZCBCaXRHbyBrZXljaGFpbjsgbXVzdCBiZSBjb21wYXRpYmxlIHdpdGggdXNlciBhbmQgYmFja3VwIGtleSBzaGFyZXNcbiAgICogQHBhcmFtIHBhc3NwaHJhc2UgLSB3YWxsZXQgcGFzc3BocmFzZSB1c2VkIHRvIGVuY3J5cHQgdXNlcidzIHNpZ25pbmcgbWF0ZXJpYWxzXG4gICAqL1xuICBhc3luYyBjcmVhdGVCYWNrdXBLZXljaGFpbihcbiAgICB1c2VyR3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgdXNlcktleVNoYXJlOiBLZXlTaGFyZSxcbiAgICBiYWNrdXBLZXlTaGFyZTogS2V5U2hhcmUsXG4gICAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW4sXG4gICAgcGFzc3BocmFzZTogc3RyaW5nXG4gICk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBhd2FpdCBFZGRzYS5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgTVBDID0gbmV3IEVkZHNhKCk7XG4gICAgY29uc3QgYml0Z29LZXlTaGFyZXMgPSBiaXRnb0tleWNoYWluLmtleVNoYXJlcztcbiAgICBpZiAoIWJpdGdvS2V5U2hhcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYml0Z28ga2V5c2hhcmVzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0R29Ub0JhY2t1cFNoYXJlID0gYml0Z29LZXlTaGFyZXMuZmluZCgoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiaXRnbycgJiYga2V5U2hhcmUudG8gPT09ICdiYWNrdXAnKTtcbiAgICBpZiAoIWJpdEdvVG9CYWNrdXBTaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIHRvIFVzZXIga2V5IHNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0R29Ub0JhY2t1cFByaXZhdGVTaGFyZSA9IGF3YWl0IHRoaXMuZGVjcnlwdFByaXZhdGVTaGFyZShiaXRHb1RvQmFja3VwU2hhcmUucHJpdmF0ZVNoYXJlLCB1c2VyR3BnS2V5KTtcblxuICAgIGNvbnN0IGJpdGdvVG9CYWNrdXA6IFlTaGFyZSA9IHtcbiAgICAgIGk6IDIsXG4gICAgICBqOiAzLFxuICAgICAgeTogYml0R29Ub0JhY2t1cFNoYXJlLnB1YmxpY1NoYXJlLnNsaWNlKDAsIDY0KSxcbiAgICAgIHU6IGJpdEdvVG9CYWNrdXBQcml2YXRlU2hhcmUuc2xpY2UoMCwgNjQpLFxuICAgICAgY2hhaW5jb2RlOiBiaXRHb1RvQmFja3VwUHJpdmF0ZVNoYXJlLnNsaWNlKDY0KSxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwQ29tYmluZWQgPSBNUEMua2V5Q29tYmluZShiYWNrdXBLZXlTaGFyZS51U2hhcmUsIFt1c2VyS2V5U2hhcmUueVNoYXJlc1syXSwgYml0Z29Ub0JhY2t1cF0pO1xuICAgIGNvbnN0IGNvbW1vbktleWNoYWluID0gYmFja3VwQ29tYmluZWQucFNoYXJlLnkgKyBiYWNrdXBDb21iaW5lZC5wU2hhcmUuY2hhaW5jb2RlO1xuICAgIGlmIChjb21tb25LZXljaGFpbiAhPT0gYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGJhY2t1cCBrZXljaGFpbiAtIGNvbW1vbktleWNoYWlucyBkbyBub3QgbWF0Y2guJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFja3VwU2lnbmluZ01hdGVyaWFsOiBCYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSB7XG4gICAgICB1U2hhcmU6IGJhY2t1cEtleVNoYXJlLnVTaGFyZSxcbiAgICAgIGJpdGdvWVNoYXJlOiBiaXRnb1RvQmFja3VwLFxuICAgICAgdXNlcllTaGFyZTogdXNlcktleVNoYXJlLnlTaGFyZXNbMl0sXG4gICAgfTtcbiAgICBjb25zdCBwcnYgPSBKU09OLnN0cmluZ2lmeShiYWNrdXBTaWduaW5nTWF0ZXJpYWwpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQmFja3VwKHtcbiAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICB0eXBlOiAndHNzJyxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluLFxuICAgICAgcHJ2OiBwcnYsXG4gICAgICBlbmNyeXB0ZWRQcnY6IHRoaXMuYml0Z28uZW5jcnlwdCh7IGlucHV0OiBwcnYsIHBhc3N3b3JkOiBwYXNzcGhyYXNlIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBLZXljaGFpbiBjb250YWluaW5nIEJpdEdvJ3MgVFNTIHNpZ25pbmcgbWF0ZXJpYWxzLlxuICAgKlxuICAgKiBAcGFyYW0gdXNlckdwZ0tleSAtIGVwaGVtZXJhbCBHUEcga2V5IHRvIGVuY3J5cHQgLyBkZWNyeXB0IHNlbnNpdHZlIGRhdGEgZXhjaGFuZ2VkIGJldHdlZW4gdXNlciBhbmQgc2VydmVyXG4gICAqIEBwYXJhbSB1c2VyS2V5U2hhcmUgLSB1c2VyJ3MgVFNTIGtleSBzaGFyZVxuICAgKiBAcGFyYW0gYmFja3VwS2V5U2hhcmUgLSBiYWNrdXAncyBUU1Mga2V5IHNoYXJlXG4gICAqL1xuICBhc3luYyBjcmVhdGVCaXRnb0tleWNoYWluKFxuICAgIHVzZXJHcGdLZXk6IG9wZW5wZ3AuU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICB1c2VyS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIGJhY2t1cEtleVNoYXJlOiBLZXlTaGFyZSxcbiAgICBlbnRlcnByaXNlPzogc3RyaW5nXG4gICk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBjb25zdCB1c2VyVG9CaXRnb1B1YmxpY1NoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUudVNoYXJlLnksICdoZXgnKSxcbiAgICAgIEJ1ZmZlci5mcm9tKHVzZXJLZXlTaGFyZS51U2hhcmUuY2hhaW5jb2RlLCAnaGV4JyksXG4gICAgXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IHVzZXJUb0JpdGdvUHJpdmF0ZVNoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUueVNoYXJlc1szXS51LCAnaGV4JyksXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUueVNoYXJlc1szXS5jaGFpbmNvZGUsICdoZXgnKSxcbiAgICBdKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgdXNlclRvQml0Z29LZXlTaGFyZSA9IHtcbiAgICAgIHB1YmxpY1NoYXJlOiB1c2VyVG9CaXRnb1B1YmxpY1NoYXJlLFxuICAgICAgcHJpdmF0ZVNoYXJlOiB1c2VyVG9CaXRnb1ByaXZhdGVTaGFyZSxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwVG9CaXRnb1B1YmxpY1NoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShiYWNrdXBLZXlTaGFyZS51U2hhcmUueSwgJ2hleCcpLFxuICAgICAgQnVmZmVyLmZyb20oYmFja3VwS2V5U2hhcmUudVNoYXJlLmNoYWluY29kZSwgJ2hleCcpLFxuICAgIF0pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBiYWNrdXBUb0JpdGdvUHJpdmF0ZVNoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShiYWNrdXBLZXlTaGFyZS55U2hhcmVzWzNdLnUsICdoZXgnKSxcbiAgICAgIEJ1ZmZlci5mcm9tKGJhY2t1cEtleVNoYXJlLnlTaGFyZXNbM10uY2hhaW5jb2RlLCAnaGV4JyksXG4gICAgXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGJhY2t1cFRvQml0Z29LZXlTaGFyZSA9IHtcbiAgICAgIHB1YmxpY1NoYXJlOiBiYWNrdXBUb0JpdGdvUHVibGljU2hhcmUsXG4gICAgICBwcml2YXRlU2hhcmU6IGJhY2t1cFRvQml0Z29Qcml2YXRlU2hhcmUsXG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUJpdGdvS2V5Y2hhaW5JbldQKFxuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIHVzZXJUb0JpdGdvS2V5U2hhcmUsXG4gICAgICBiYWNrdXBUb0JpdGdvS2V5U2hhcmUsXG4gICAgICAndHNzJyxcbiAgICAgIGVudGVycHJpc2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgVXNlciwgQmFja3VwLCBhbmQgQml0R28gVFNTIEtleWNoYWlucy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5wYXNzcGhyYXNlIC0gcGFzc3BocmFzZSB1c2VkIHRvIGVuY3J5cHQgc2lnbmluZyBtYXRlcmlhbHMgY3JlYXRlZCBmb3IgVXNlciBhbmQgQmFja3VwXG4gICAqL1xuICBhc3luYyBjcmVhdGVLZXljaGFpbnMocGFyYW1zOiB7XG4gICAgcGFzc3BocmFzZTogc3RyaW5nO1xuICAgIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxLZXljaGFpbnNUcmlwbGV0PiB7XG4gICAgYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IE1QQyA9IG5ldyBFZGRzYSgpO1xuICAgIGNvbnN0IG0gPSAyO1xuICAgIGNvbnN0IG4gPSAzO1xuXG4gICAgY29uc3QgdXNlcktleVNoYXJlID0gTVBDLmtleVNoYXJlKDEsIG0sIG4pO1xuICAgIGNvbnN0IGJhY2t1cEtleVNoYXJlID0gTVBDLmtleVNoYXJlKDIsIG0sIG4pO1xuXG4gICAgY29uc3QgcmFuZG9tSGV4U3RyaW5nID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDEyKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgb3BlbnBncC5nZW5lcmF0ZUtleSh7XG4gICAgICB1c2VySURzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiByYW5kb21IZXhTdHJpbmcsXG4gICAgICAgICAgZW1haWw6IGAke3JhbmRvbUhleFN0cmluZ31AJHtyYW5kb21IZXhTdHJpbmd9LmNvbWAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgYml0Z29LZXljaGFpbiA9IGF3YWl0IHRoaXMuY3JlYXRlQml0Z29LZXljaGFpbih1c2VyR3BnS2V5LCB1c2VyS2V5U2hhcmUsIGJhY2t1cEtleVNoYXJlLCBwYXJhbXMuZW50ZXJwcmlzZSk7XG4gICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlVXNlcktleWNoYWluKFxuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwS2V5Y2hhaW5Qcm9taXNlID0gdGhpcy5jcmVhdGVCYWNrdXBLZXljaGFpbihcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBwYXJhbXMucGFzc3BocmFzZVxuICAgICk7XG4gICAgY29uc3QgW3VzZXJLZXljaGFpbiwgYmFja3VwS2V5Y2hhaW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW3VzZXJLZXljaGFpblByb21pc2UsIGJhY2t1cEtleWNoYWluUHJvbWlzZV0pO1xuXG4gICAgLy8gY3JlYXRlIHdhbGxldFxuICAgIGNvbnN0IGtleWNoYWlucyA9IHtcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuXG4gICAgcmV0dXJuIGtleWNoYWlucztcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyB0aGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB0byB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHR4UmVxdWVzdCAtIHRyYW5zYWN0aW9uIHJlcXVlc3Qgb2JqZWN0IG9yIGlkXG4gICAqIEBwYXJhbSBwcnYgLSBkZWNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHJlcUlkIC0gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSBmdWxseSBzaWduZWQgVHhSZXF1ZXN0IG9iamVjdFxuICAgKi9cbiAgYXN5bmMgc2lnblR4UmVxdWVzdChwYXJhbXM6IHtcbiAgICB0eFJlcXVlc3Q6IHN0cmluZyB8IFR4UmVxdWVzdDtcbiAgICBwcnY6IHN0cmluZztcbiAgICByZXFJZDogUmVxdWVzdFRyYWNlcjtcbiAgfSk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgbGV0IHR4UmVxdWVzdFJlc29sdmVkOiBUeFJlcXVlc3Q7XG4gICAgbGV0IHR4UmVxdWVzdElkOiBzdHJpbmc7XG5cbiAgICBjb25zdCB7IHR4UmVxdWVzdCwgcHJ2IH0gPSBwYXJhbXM7XG5cbiAgICBpZiAodHlwZW9mIHR4UmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkID0gYXdhaXQgdGhpcy5nZXRUeFJlcXVlc3QodHhSZXF1ZXN0KTtcbiAgICAgIHR4UmVxdWVzdElkID0gdHhSZXF1ZXN0UmVzb2x2ZWQudHhSZXF1ZXN0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkID0gdHhSZXF1ZXN0O1xuICAgICAgdHhSZXF1ZXN0SWQgPSB0eFJlcXVlc3QudHhSZXF1ZXN0SWQ7XG4gICAgfVxuXG4gICAgYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuICAgIGF3YWl0IEVkMjU1MTlCSVAzMi5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgTVBDID0gbmV3IEVkZHNhKG5ldyBFZDI1NTE5QklQMzIoKSk7XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsOiBVc2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShwcnYpO1xuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBNUEMua2V5RGVyaXZlKFxuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC51U2hhcmUsXG4gICAgICBbdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSwgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmVdLFxuICAgICAgdHhSZXF1ZXN0UmVzb2x2ZWQudW5zaWduZWRUeHNbMF0uZGVyaXZhdGlvblBhdGhcbiAgICApO1xuXG4gICAgY29uc3Qgc2lnbmFibGVQYXlsb2FkID0gQnVmZmVyLmZyb20odHhSZXF1ZXN0UmVzb2x2ZWQudW5zaWduZWRUeHNbMF0uc2lnbmFibGVIZXgsICdoZXgnKTtcblxuICAgIGNvbnN0IHVzZXJTaWduU2hhcmUgPSBhd2FpdCB0aGlzLmNyZWF0ZVVzZXJTaWduU2hhcmUoeyBzaWduYWJsZVBheWxvYWQsIHBTaGFyZTogc2lnbmluZ0tleS5wU2hhcmUgfSk7XG5cbiAgICBjb25zdCBzaWduZXJTaGFyZSA9IHNpZ25pbmdLZXkueVNoYXJlc1szXS51ICsgc2lnbmluZ0tleS55U2hhcmVzWzNdLmNoYWluY29kZTtcbiAgICBjb25zdCBiaXRnb0dwZ0tleSA9IGF3YWl0IGdldEJpdGdvR3BnUHViS2V5KHRoaXMuYml0Z28pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFNpZ25lclNoYXJlID0gYXdhaXQgZW5jcnlwdFRleHQoc2lnbmVyU2hhcmUsIGJpdGdvR3BnS2V5KTtcblxuICAgIGF3YWl0IHRoaXMub2ZmZXJVc2VyVG9CaXRnb1JTaGFyZSh7XG4gICAgICB0eFJlcXVlc3RJZCxcbiAgICAgIHVzZXJTaWduU2hhcmUsXG4gICAgICBlbmNyeXB0ZWRTaWduZXJTaGFyZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyUlNoYXJlID0gYXdhaXQgdGhpcy5nZXRCaXRnb1RvVXNlclJTaGFyZSh0eFJlcXVlc3RJZCk7XG5cbiAgICBjb25zdCB1c2VyVG9CaXRHb0dTaGFyZSA9IGF3YWl0IHRoaXMuY3JlYXRlVXNlclRvQml0R29HU2hhcmUoXG4gICAgICB1c2VyU2lnblNoYXJlLFxuICAgICAgYml0Z29Ub1VzZXJSU2hhcmUsXG4gICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cFlTaGFyZSxcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29ZU2hhcmUsXG4gICAgICBzaWduYWJsZVBheWxvYWRcbiAgICApO1xuXG4gICAgYXdhaXQgdGhpcy5zZW5kVXNlclRvQml0Z29HU2hhcmUodHhSZXF1ZXN0SWQsIHVzZXJUb0JpdEdvR1NoYXJlKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFR4UmVxdWVzdCh0eFJlcXVlc3RJZCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgdHggcmVxdWVzdCBmcm9tIHBhcmFtcyBhbmQgdmVyaWZ5IGl0XG4gICAqXG4gICAqIEBwYXJhbSB7UHJlYnVpbGRUcmFuc2FjdGlvbldpdGhJbnRlbnRPcHRpb25zfSBwYXJhbXMgLSBwYXJhbWV0ZXJzIHRvIGJ1aWxkIHRoZSB0eFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSAtIGEgYnVpbHQgdHggcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcHJlYnVpbGRUeFdpdGhJbnRlbnQocGFyYW1zOiBQcmVidWlsZFRyYW5zYWN0aW9uV2l0aEludGVudE9wdGlvbnMpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IGNoYWluID0gdGhpcy5iYXNlQ29pbi5nZXRDaGFpbigpO1xuICAgIGNvbnN0IGludGVudFJlY2lwaWVudHMgPSBwYXJhbXMucmVjaXBpZW50cy5tYXAoKHJlY2lwaWVudCkgPT4gKHtcbiAgICAgIGFkZHJlc3M6IHsgYWRkcmVzczogcmVjaXBpZW50LmFkZHJlc3MgfSxcbiAgICAgIGFtb3VudDogeyB2YWx1ZTogYCR7cmVjaXBpZW50LmFtb3VudH1gLCBzeW1ib2w6IGNoYWluIH0sXG4gICAgfSkpO1xuXG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSB7XG4gICAgICBpbnRlbnQ6IHtcbiAgICAgICAgaW50ZW50VHlwZTogcGFyYW1zLmludGVudFR5cGUsXG4gICAgICAgIHNlcXVlbmNlSWQ6IHBhcmFtcy5zZXF1ZW5jZUlkLFxuICAgICAgICBjb21tZW50OiBwYXJhbXMuY29tbWVudCxcbiAgICAgICAgcmVjaXBpZW50czogaW50ZW50UmVjaXBpZW50cyxcbiAgICAgICAgbWVtbzogcGFyYW1zLm1lbW8/LnZhbHVlLFxuICAgICAgICB0b2tlbjogcGFyYW1zLnRva2VuTmFtZSxcbiAgICAgICAgbm9uY2U6IHBhcmFtcy5ub25jZSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHVuc2lnbmVkVHggPSAoYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iaXRnby51cmwoJy93YWxsZXQvJyArIHRoaXMud2FsbGV0LmlkKCkgKyAnL3R4cmVxdWVzdHMnLCAyKSlcbiAgICAgIC5zZW5kKHdoaXRlbGlzdGVkUGFyYW1zKVxuICAgICAgLnJlc3VsdCgpKSBhcyBUeFJlcXVlc3Q7XG5cbiAgICByZXR1cm4gdW5zaWduZWRUeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBVc2VyIFNpZ24gU2hhcmUgY29udGFpbmluZyB0aGUgVXNlciBYU2hhcmUgYW5kIHRoZSBVc2VyIHRvIEJpdGdvIFJTaGFyZVxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmFibGVQYXlsb2FkIC0gdGhlIHNpZ25hYmxlUGF5bG9hZCBhcyBhIGJ1ZmZlclxuICAgKiBAcGFyYW0ge1BTaGFyZX0gcFNoYXJlIC0gVXNlcidzIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICogQHJldHVybnMge1Byb21pc2U8U2lnblNoYXJlPn0gLSBVc2VyIFNpZ24gU2hhcmVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXJTaWduU2hhcmUocGFyYW1zOiB7IHNpZ25hYmxlUGF5bG9hZDogQnVmZmVyOyBwU2hhcmU6IFBTaGFyZSB9KTogUHJvbWlzZTxTaWduU2hhcmU+IHtcbiAgICBjb25zdCB7IHNpZ25hYmxlUGF5bG9hZCwgcFNoYXJlIH0gPSBwYXJhbXM7XG5cbiAgICBhd2FpdCBFZGRzYS5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgTVBDID0gbmV3IEVkZHNhKCk7XG5cbiAgICBpZiAocFNoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBTaGFyZSwgUFNoYXJlIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgICB9XG4gICAgY29uc3QgalNoYXJlOiBKU2hhcmUgPSB7IGk6IFNoYXJlS2V5UG9zaXRpb24uQklUR08sIGo6IFNoYXJlS2V5UG9zaXRpb24uVVNFUiB9O1xuICAgIHJldHVybiBNUEMuc2lnblNoYXJlKHNpZ25hYmxlUGF5bG9hZCwgcFNoYXJlLCBbalNoYXJlXSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBTaWduYXR1cmUgU2hhcmVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcGFyYW0ge1NpZ25hdHVyZVNoYXJlUmVjb3JkfSBzaWduYXR1cmVTaGFyZSAtIGEgU2lnbmF0dXJlIFNoYXJlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkPn0gLSBhIFNpZ25hdHVyZSBTaGFyZVxuICAgKi9cbiAgYXN5bmMgc2VuZFNpZ25hdHVyZVNoYXJlKHBhcmFtczoge1xuICAgIHR4UmVxdWVzdElkOiBzdHJpbmc7XG4gICAgc2lnbmF0dXJlU2hhcmU6IFNpZ25hdHVyZVNoYXJlUmVjb3JkO1xuICAgIHNpZ25lclNoYXJlPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxTaWduYXR1cmVTaGFyZVJlY29yZD4ge1xuICAgIGNvbnN0IHsgdHhSZXF1ZXN0SWQsIHNpZ25hdHVyZVNoYXJlLCBzaWduZXJTaGFyZSB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldC8nICsgdGhpcy53YWxsZXQuaWQoKSArICcvdHhyZXF1ZXN0cy8nICsgdHhSZXF1ZXN0SWQgKyAnL3NpZ25hdHVyZXNoYXJlcycsIDIpKVxuICAgICAgLnNlbmQoe1xuICAgICAgICBzaWduYXR1cmVTaGFyZSxcbiAgICAgICAgc2lnbmVyU2hhcmUsXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBVc2VyIHRvIEJpdGdvIFJTaGFyZSB0byBCaXRnb1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkXG4gICAqIEBwYXJhbSB7U2lnblNoYXJlfSB1c2VyU2lnblNoYXJlIC0gdGhlIHVzZXIgU2lnbiBTaGFyZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jcnlwdGVkU2lnbmVyU2hhcmUgLSBzaWduZXIgc2hhcmUgZW5jcnlwdGVkIHRvIGJpdGdvIGtleVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIG9mZmVyVXNlclRvQml0Z29SU2hhcmUocGFyYW1zOiB7XG4gICAgdHhSZXF1ZXN0SWQ6IHN0cmluZztcbiAgICB1c2VyU2lnblNoYXJlOiBTaWduU2hhcmU7XG4gICAgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IHN0cmluZztcbiAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgdHhSZXF1ZXN0SWQsIHVzZXJTaWduU2hhcmUsIGVuY3J5cHRlZFNpZ25lclNoYXJlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgclNoYXJlOiBSU2hhcmUgPSB1c2VyU2lnblNoYXJlLnJTaGFyZXNbU2hhcmVLZXlQb3NpdGlvbi5CSVRHT107XG4gICAgaWYgKF8uaXNOaWwoclNoYXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyVG9CaXRnbyBSU2hhcmUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGlmIChyU2hhcmUuaSAhPT0gU2hhcmVLZXlQb3NpdGlvbi5CSVRHTyB8fCByU2hhcmUuaiAhPT0gU2hhcmVLZXlQb3NpdGlvbi5VU0VSKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUlNoYXJlLCBpcyBub3QgZnJvbSBVc2VyIHRvIEJpdGdvJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZVNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZCA9IHtcbiAgICAgIGZyb206IFNpZ25hdHVyZVNoYXJlVHlwZS5VU0VSLFxuICAgICAgdG86IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyxcbiAgICAgIHNoYXJlOiByU2hhcmUuciArIHJTaGFyZS5SLFxuICAgIH07XG5cbiAgICBhd2FpdCB0aGlzLnNlbmRTaWduYXR1cmVTaGFyZSh7IHR4UmVxdWVzdElkLCBzaWduYXR1cmVTaGFyZSwgc2lnbmVyU2hhcmU6IGVuY3J5cHRlZFNpZ25lclNoYXJlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIEJpdGdvIHRvIFVzZXIgUlNoYXJlIGZyb20gQml0Z29cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduYXR1cmVTaGFyZVJlY29yZD59IC0gYSBTaWduYXR1cmUgU2hhcmVcbiAgICovXG4gIGFzeW5jIGdldEJpdGdvVG9Vc2VyUlNoYXJlKHR4UmVxdWVzdElkOiBzdHJpbmcpOiBQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkPiB7XG4gICAgY29uc3QgdHhSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRUeFJlcXVlc3QodHhSZXF1ZXN0SWQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZVNoYXJlcyA9IHR4UmVxdWVzdC5zaWduYXR1cmVTaGFyZXM7XG4gICAgaWYgKF8uaXNOaWwoc2lnbmF0dXJlU2hhcmVzKSB8fCBfLmlzRW1wdHkoc2lnbmF0dXJlU2hhcmVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzaWduYXR1cmVzIHNoYXJlcyBmb3VuZCBmb3IgaWQ6ICR7dHhSZXF1ZXN0SWR9YCk7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBleHBlY3QgdGhlIG9ubHkgc2hhcmUgdG8gYmUgdGhlIFJTaGFyZVxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyUlNoYXJlID0gc2lnbmF0dXJlU2hhcmVzLmZpbmQoXG4gICAgICAoc2lnU2hhcmUpID0+IHNpZ1NoYXJlLmZyb20gPT09IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyAmJiBzaWdTaGFyZS50byA9PT0gU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVJcbiAgICApO1xuICAgIGlmIChfLmlzTmlsKGJpdGdvVG9Vc2VyUlNoYXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRnbyB0byBVc2VyIFJTaGFyZSBub3QgZm91bmQgZm9yIGlkOiAke3R4UmVxdWVzdElkfWApO1xuICAgIH1cbiAgICByZXR1cm4gYml0Z29Ub1VzZXJSU2hhcmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbGF0ZXN0IFR4IFJlcXVlc3QgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IHR4UmVxdWVzdFJlczogeyB0eFJlcXVlc3RzOiBUeFJlcXVlc3RbXSB9ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldC8nICsgdGhpcy53YWxsZXQuaWQoKSArICcvdHhyZXF1ZXN0cycsIDIpKVxuICAgICAgLnF1ZXJ5KHsgdHhSZXF1ZXN0SWRzOiB0eFJlcXVlc3RJZCwgbGF0ZXN0OiAndHJ1ZScgfSlcbiAgICAgIC5yZXN1bHQoKTtcblxuICAgIGlmICh0eFJlcXVlc3RSZXMudHhSZXF1ZXN0cy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBUeFJlcXVlc3Qgd2l0aCBpZCAke3R4UmVxdWVzdElkfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0eFJlcXVlc3RSZXMudHhSZXF1ZXN0c1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGRlbGV0ZSBzaWduYXR1cmUgc2hhcmVzIGZvciBhIHR4UmVxdWVzdCwgdGhlIGVuZHBvaW50IGRlbGV0ZSB0aGUgc2lnbmF0dXJlcyBhbmQgcmV0dXJuIHRoZW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR4UmVxdWVzdElkIHR4IGlkIHJlZmVyZW5jZSB0byBkZWxldGUgc2lnbmF0dXJlIHNoYXJlc1xuICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlU2hhcmVSZWNvcmRbXX1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVNpZ25hdHVyZVNoYXJlcyh0eFJlcXVlc3RJZDogc3RyaW5nKTogUHJvbWlzZTxTaWduYXR1cmVTaGFyZVJlY29yZFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5kZWwodGhpcy5iaXRnby51cmwoYC93YWxsZXQvJHt0aGlzLndhbGxldC5pZCgpfS90eHJlcXVlc3RzLyR7dHhSZXF1ZXN0SWR9L3NpZ25hdHVyZXNoYXJlc2AsIDIpKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFVzZXIgdG8gQml0Z28gR1NoYXJlXG4gICAqXG4gICAqIEBwYXJhbSB7U2lnblNoYXJlfSB1c2VyU2lnblNoYXJlIC0gdGhlIFVzZXIgU2lnbiBTaGFyZVxuICAgKiBAcGFyYW0ge1NpZ25hdHVyZVNoYXJlUmVjb3JkfSBiaXRnb1RvVXNlclJTaGFyZSAtIHRoZSBCaXRnbyB0byBVc2VyIFJTaGFyZVxuICAgKiBAcGFyYW0ge1lTaGFyZX0gYmFja3VwVG9Vc2VyWVNoYXJlIC0gdGhlIGJhY2t1cCBrZXkgWSBzaGFyZSByZWNlaXZlZCBkdXJpbmcgd2FsbGV0IGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYWJsZVBheWxvYWQgLSB0aGUgc2lnbmFibGUgcGF5bG9hZCBmcm9tIGEgdHhcbiAgICogQHJldHVybnMge1Byb21pc2U8R1NoYXJlPn0gLSB0aGUgVXNlciB0byBCaXRnbyBHU2hhcmVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXJUb0JpdEdvR1NoYXJlKFxuICAgIHVzZXJTaWduU2hhcmU6IFNpZ25TaGFyZSxcbiAgICBiaXRnb1RvVXNlclJTaGFyZTogU2lnbmF0dXJlU2hhcmVSZWNvcmQsXG4gICAgYmFja3VwVG9Vc2VyWVNoYXJlOiBZU2hhcmUsXG4gICAgYml0Z29Ub1VzZXJZU2hhcmU6IFlTaGFyZSxcbiAgICBzaWduYWJsZVBheWxvYWQ6IEJ1ZmZlclxuICApOiBQcm9taXNlPEdTaGFyZT4ge1xuICAgIGlmICh1c2VyU2lnblNoYXJlLnhTaGFyZS5pICE9PSBTaGFyZUtleVBvc2l0aW9uLlVTRVIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgICB9XG4gICAgaWYgKGJpdGdvVG9Vc2VyUlNoYXJlLmZyb20gIT09IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyB8fCBiaXRnb1RvVXNlclJTaGFyZS50byAhPT0gU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU2hhcmUsIGlzIG5vdCBmcm9tIEJpdGdvIHRvIFVzZXInKTtcbiAgICB9XG4gICAgaWYgKGJhY2t1cFRvVXNlcllTaGFyZS5pICE9PSBTaGFyZUtleVBvc2l0aW9uLlVTRVIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBZU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgICB9XG4gICAgaWYgKGJhY2t1cFRvVXNlcllTaGFyZS5qICE9PSBTaGFyZUtleVBvc2l0aW9uLkJBQ0tVUCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFlTaGFyZSwgaXMgbm90IGJhY2t1cCBrZXknKTtcbiAgICB9XG5cbiAgICBjb25zdCBSU2hhcmU6IFJTaGFyZSA9IHtcbiAgICAgIGk6IFNoYXJlS2V5UG9zaXRpb24uVVNFUixcbiAgICAgIGo6IFNoYXJlS2V5UG9zaXRpb24uQklUR08sXG4gICAgICB1OiBiaXRnb1RvVXNlcllTaGFyZS51LFxuICAgICAgcjogYml0Z29Ub1VzZXJSU2hhcmUuc2hhcmUuc3Vic3RyaW5nKDAsIDY0KSxcbiAgICAgIFI6IGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLnN1YnN0cmluZyg2NCwgMTI4KSxcbiAgICB9O1xuICAgIGF3YWl0IEVkZHNhLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBNUEMgPSBuZXcgRWRkc2EoKTtcbiAgICByZXR1cm4gTVBDLnNpZ24oc2lnbmFibGVQYXlsb2FkLCB1c2VyU2lnblNoYXJlLnhTaGFyZSwgW1JTaGFyZV0sIFtiYWNrdXBUb1VzZXJZU2hhcmVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgVXNlciB0byBCaXRnbyBHU2hhcmUgdG8gQml0Z29cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcGFyYW0ge0dTaGFyZX0gdXNlclRvQml0Z29HU2hhcmUgLSB0aGUgVXNlciB0byBCaXRnbyBHU2hhcmVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzZW5kVXNlclRvQml0Z29HU2hhcmUodHhSZXF1ZXN0SWQ6IHN0cmluZywgdXNlclRvQml0Z29HU2hhcmU6IEdTaGFyZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh1c2VyVG9CaXRnb0dTaGFyZS5pICE9PSBTaGFyZUtleVBvc2l0aW9uLlVTRVIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlU2hhcmU6IFNpZ25hdHVyZVNoYXJlUmVjb3JkID0ge1xuICAgICAgZnJvbTogU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVIsXG4gICAgICB0bzogU2lnbmF0dXJlU2hhcmVUeXBlLkJJVEdPLFxuICAgICAgc2hhcmU6IHVzZXJUb0JpdGdvR1NoYXJlLlIgKyB1c2VyVG9CaXRnb0dTaGFyZS5nYW1tYSxcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy5zZW5kU2lnbmF0dXJlU2hhcmUoeyB0eFJlcXVlc3RJZCwgc2lnbmF0dXJlU2hhcmUgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgc2VuZCBwcm9jZWR1cmUgb25jZSBCaXRnbyBoYXMgdGhlIFVzZXIgVG8gQml0Z28gR1NoYXJlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWRcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICovXG4gIGFzeW5jIHNlbmRUeFJlcXVlc3QodHhSZXF1ZXN0SWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLndhbGxldC5pZCgpICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZCh7IHR4UmVxdWVzdElkIH0pXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHNpZ25hdHVyZSBzaGFyZXMsIGdldCB0aGUgdHggcmVxdWVzdCB3aXRob3V0IHRoZW0gZnJvbSB0aGUgZGIgYW5kIHNpZ24gaXQgdG8gZmluYWxseSBzZW5kIGl0LlxuICAgKlxuICAgKiBOb3RlIDogVGhpcyBjYW4gYmUgcGVyZm9ybWVkIGluIG9yZGVyIHRvIHJlYWNoIGxhdGVzdCBuZXR3b3JrIGNvbmRpdGlvbnMgcmVxdWlyZWQgb24gcGVuZGluZyBhcHByb3ZhbCBmbG93LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkIHRvIG1ha2UgdGhlIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjcnlwdGVkUHJ2IC0gZGVjcnlwdGVkIHBydiB0byBzaWduIHRoZSB0eCByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge1JlcXVlc3RUcmFjZXJ9IHJlcUlkIGlkIHRyYWNlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICovXG4gIGFzeW5jIHJlY3JlYXRlVHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcsIGRlY3J5cHRlZFBydjogc3RyaW5nLCByZXFJZDogUmVxdWVzdFRyYWNlcik6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxldGVTaWduYXR1cmVTaGFyZXModHhSZXF1ZXN0SWQpO1xuICAgIC8vIGFmdGVyIGRlbGV0ZSBzaWduYXR1cmVzIHNoYXJlcyBnZXQgdGhlIHR4IHdpdGhvdXQgdGhlbVxuICAgIGNvbnN0IHR4UmVxdWVzdCA9IGF3YWl0IHRoaXMuZ2V0VHhSZXF1ZXN0KHR4UmVxdWVzdElkKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduVHhSZXF1ZXN0KHsgdHhSZXF1ZXN0LCBwcnY6IGRlY3J5cHRlZFBydiwgcmVxSWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb21tb25QdWIgcG9ydGlvbiBvZiB0aGUgY29tbW9uS2V5Y2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tb25LZXljaGFpblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldFB1YmxpY0tleUZyb21Db21tb25LZXljaGFpbihjb21tb25LZXljaGFpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoY29tbW9uS2V5Y2hhaW4ubGVuZ3RoICE9PSAxMjgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21tb25LZXljaGFpbiBsZW5ndGgsIGV4cGVjdGVkIDEyOCwgZ290ICR7Y29tbW9uS2V5Y2hhaW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25QdWJIZXhTdHIgPSBjb21tb25LZXljaGFpbi5zbGljZSgwLCA2NCk7XG4gICAgcmV0dXJuIGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKGNvbW1vblB1YkhleFN0ciwgJ2hleCcpKTtcbiAgfVxufVxuIl19