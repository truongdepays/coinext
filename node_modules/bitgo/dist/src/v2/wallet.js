"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const bignumber_js_1 = require("bignumber.js");
const _ = require("lodash");
const debugLib = require("debug");
const bitcoin_1 = require("../bitcoin");
const sdk_core_1 = require("@bitgo/sdk-core");
const errors_1 = require("../errors");
const internal = require("./internal/internal");
const keycard_1 = require("./internal/keycard");
const tradingAccount_1 = require("./trading/tradingAccount");
const pendingApproval_1 = require("./pendingApproval");
const util_1 = require("./internal/util");
const ecdh_1 = require("../ecdh");
const tssUtils_1 = require("./internal/tssUtils");
const debug = debugLib('bitgo:v2:wallet');
// #endregion
class Wallet {
    constructor(bitgo, baseCoin, walletData) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this._wallet = walletData;
        const userId = _.get(bitgo, '_user.id');
        if (_.isString(userId)) {
            const userDetails = _.find(walletData.users, { user: userId });
            this._permissions = _.get(userDetails, 'permissions');
        }
        this.tssUtils = new tssUtils_1.TssUtils(bitgo, baseCoin, this);
    }
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    url(extra = '') {
        return this.baseCoin.url('/wallet/' + this.id() + extra);
    }
    /**
     * Get this wallet's id
     */
    id() {
        return this._wallet.id;
    }
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    approvalsRequired() {
        return this._wallet.approvalsRequired;
    }
    /**
     * Get the current balance of this wallet
     */
    balance() {
        return this._wallet.balance;
    }
    prebuildWhitelistedParams() {
        return [
            'addressType',
            'changeAddress',
            'consolidateAddresses',
            'cpfpFeeRate',
            'cpfpTxIds',
            'enforceMinConfirmsForChange',
            'feeRate',
            'gasLimit',
            'gasPrice',
            'idfSignedTimestamp',
            'idfUserId',
            'idfVersion',
            'instant',
            'lastLedgerSequence',
            'ledgerSequenceDelta',
            'maxFee',
            'maxFeeRate',
            'maxValue',
            'memo',
            'transferId',
            'message',
            'minConfirms',
            'minValue',
            'noSplitChange',
            'numBlocks',
            'nonce',
            'recipients',
            'reservation',
            'sequenceId',
            'strategy',
            'targetWalletUnspents',
            'trustlines',
            'type',
            'unspents',
            'nonParticipation',
            'validFromBlock',
            'validToBlock',
            'messageKey',
            'stakingOptions',
            'eip1559',
            'keyregTxBase64',
            'closeRemainderTo',
            'tokenName',
            // param to set emergency flag on a custodial transaction.
            // This transaction should be performed in less than 1 hour or it will fail.
            'emergency',
        ];
    }
    /**
     * This is a strict sub-set of prebuildWhitelistedParams
     */
    prebuildConsolidateAccountParams() {
        return ['consolidateAddresses', 'feeRate', 'maxFeeRate', 'memo', 'validFromBlock', 'validToBlock'];
    }
    /**
     * Get the confirmed balance of this wallet
     */
    confirmedBalance() {
        return this._wallet.confirmedBalance;
    }
    /**
     * Get the spendable balance of this wallet
     */
    spendableBalance() {
        return this._wallet.spendableBalance;
    }
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    balanceString() {
        return this._wallet.balanceString;
    }
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    confirmedBalanceString() {
        return this._wallet.confirmedBalanceString;
    }
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    spendableBalanceString() {
        return this._wallet.spendableBalanceString;
    }
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    coin() {
        return this._wallet.coin;
    }
    /**
     * Get the label (name) for this wallet
     */
    label() {
        return this._wallet.label;
    }
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    keyIds() {
        return this._wallet.keys;
    }
    /**
     * Get a receive address for this wallet
     */
    receiveAddress() {
        return this._wallet.receiveAddress.address;
    }
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    migratedFrom() {
        return this._wallet.migratedFrom;
    }
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    tokenFlushThresholds() {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('not supported for this wallet');
        }
        return this._wallet.coinSpecific.tokenFlushThresholds;
    }
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    coinSpecific() {
        return this._wallet.coinSpecific;
    }
    /**
     * Get all pending approvals on this wallet
     */
    pendingApprovals() {
        return this._wallet.pendingApprovals.map((currentApproval) => {
            return new pendingApproval_1.PendingApproval(this.bitgo, this.baseCoin, currentApproval, this);
        });
    }
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @returns {Wallet}
     */
    async refresh(params = {}) {
        this._wallet = await this.bitgo.get(this.url()).result();
        return this;
    }
    /**
     * List the transactions for a given wallet
     * @param params
     * @returns {*}
     */
    async transactions(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return await this.bitgo
            .get(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx'))
            .query(query)
            .result();
    }
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @returns {*}
     */
    async getTransaction(params = {}) {
        sdk_core_1.common.validateParams(params, ['txHash'], []);
        const query = {};
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (!_.isUndefined(params.limit)) {
            if (!_.isInteger(params.limit) || params.limit < 1) {
                throw new Error('invalid limit argument, expecting positive integer');
            }
            query.limit = params.limit;
        }
        return await this.bitgo
            .get(this.url('/tx/' + params.txHash))
            .query(query)
            .result();
    }
    /**
     * List the transfers for a given wallet
     * @param params
     * @returns {*}
     */
    async transfers(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        if (params.searchLabel) {
            if (!_.isString(params.searchLabel)) {
                throw new Error('invalid searchLabel argument, expecting string');
            }
            query.searchLabel = params.searchLabel;
        }
        if (params.address) {
            if (!_.isArray(params.address) && !_.isString(params.address)) {
                throw new Error('invalid address argument, expecting string or array');
            }
            if (_.isArray(params.address)) {
                params.address.forEach((address) => {
                    if (!_.isString(address)) {
                        throw new Error('invalid address argument, expecting array of address strings');
                    }
                });
            }
            query.address = params.address;
        }
        if (params.dateGte) {
            if (!_.isString(params.dateGte)) {
                throw new Error('invalid dateGte argument, expecting string');
            }
            query.dateGte = params.dateGte;
        }
        if (params.dateLt) {
            if (!_.isString(params.dateLt)) {
                throw new Error('invalid dateLt argument, expecting string');
            }
            query.dateLt = params.dateLt;
        }
        if (!_.isNil(params.valueGte)) {
            if (!_.isNumber(params.valueGte)) {
                throw new Error('invalid valueGte argument, expecting number');
            }
            query.valueGte = params.valueGte;
        }
        if (!_.isNil(params.valueLt)) {
            if (!_.isNumber(params.valueLt)) {
                throw new Error('invalid valueLt argument, expecting number');
            }
            query.valueLt = params.valueLt;
        }
        if (!_.isNil(params.includeHex)) {
            if (!_.isBoolean(params.includeHex)) {
                throw new Error('invalid includeHex argument, expecting boolean');
            }
            query.includeHex = params.includeHex;
        }
        if (!_.isNil(params.state)) {
            if (!Array.isArray(params.state) && !_.isString(params.state)) {
                throw new Error('invalid state argument, expecting string or array');
            }
            if (Array.isArray(params.state)) {
                params.state.forEach((state) => {
                    if (!_.isString(state)) {
                        throw new Error('invalid state argument, expecting array of state strings');
                    }
                });
            }
            query.state = params.state;
        }
        if (!_.isNil(params.type)) {
            if (!_.isString(params.type)) {
                throw new Error('invalid type argument, expecting string');
            }
            query.type = params.type;
        }
        return await this.bitgo.get(this.url('/transfer')).query(query).result();
    }
    /**
     * Get transfers on this wallet
     * @param params
     */
    async getTransfer(params = {}) {
        sdk_core_1.common.validateParams(params, ['id'], []);
        return await this.bitgo.get(this.url('/transfer/' + params.id)).result();
    }
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     */
    async transferBySequenceId(params = {}) {
        sdk_core_1.common.validateParams(params, ['sequenceId'], []);
        return await this.bitgo.get(this.url('/transfer/sequenceId/' + params.sequenceId)).result();
    }
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    async maximumSpendable(params = {}) {
        const filteredParams = _.pick(params, [
            'enforceMinConfirmsForChange',
            'feeRate',
            'limit',
            'maxFeeRate',
            'maxValue',
            'minConfirms',
            'minHeight',
            'minValue',
            'plainTarget',
            'recipientAddress',
            'target',
        ]);
        return await this.bitgo.get(this.url('/maximumSpendable')).query(filteredParams).result();
    }
    /**
     * List the unspents for a given wallet
     * @param params
     * @returns {*}
     */
    async unspents(params = {}) {
        const query = _.pick(params, [
            'chains',
            'limit',
            'maxValue',
            'minConfirms',
            'minHeight',
            'minValue',
            'prevId',
            'segwit',
            'target',
        ]);
        return this.bitgo.get(this.url('/unspents')).query(query).result();
    }
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    async manageUnspents(routeName, params = {}) {
        sdk_core_1.common.validateParams(params, [], ['walletPassphrase', 'xprv']);
        const reqId = new util_1.RequestTracer();
        const filteredParams = _.pick(params, [
            'feeRate',
            'maxFeeRate',
            'maxFeePercentage',
            'feeTxConfirmTarget',
            'minValue',
            'maxValue',
            'minHeight',
            'minConfirms',
            'enforceMinConfirmsForChange',
            'targetAddress',
            routeName === 'consolidate' ? 'limit' : 'maxNumInputsToUse',
            'numUnspentsToMake',
        ]);
        this.bitgo.setRequestTracer(reqId);
        const response = await this.bitgo
            .post(this.url(`/${routeName}Unspents`))
            .send(filteredParams)
            .result();
        const keychains = (await this.baseCoin
            .keychains()
            .getKeysForSigning({ wallet: this, reqId }));
        const transactionParams = {
            ...params,
            txPrebuild: response,
            keychain: keychains[0],
            pubs: keychains.map((k) => k.pub),
        };
        const signedTransaction = await this.signTransaction(transactionParams);
        const selectParams = _.pick(params, ['comment', 'otp']);
        const finalTxParams = _.extend({}, signedTransaction, selectParams, { type: routeName });
        this.bitgo.setRequestTracer(reqId);
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx/send'))
            .send(finalTxParams)
            .result();
    }
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    async consolidateUnspents(params = {}) {
        return this.manageUnspents('consolidate', params);
    }
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.minValue - the minimum value of unspents to use
     * @param {Number} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    async fanoutUnspents(params = {}) {
        return this.manageUnspents('fanout', params);
    }
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     */
    async updateTokenFlushThresholds(thresholds = {}) {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('not supported for this wallet');
        }
        this._wallet = await this.bitgo
            .put(this.url())
            .send({
            tokenFlushThresholds: thresholds,
        })
            .result();
    }
    /**
       * Updates the wallet. Sets flags for deployForwardersManually and flushForwardersManually of the wallet.
       * @param forwarderFlags {Object} - {
         "coinSpecific": {
           [coinName]: {
             "deployForwardersManually": {Boolean},
             "flushForwardersManually": {Boolean}
           }
         }
       }
       */
    async updateForwarders(forwarderFlags = {}) {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('not supported for this wallet');
        }
        this._wallet = await this.bitgo.put(this.url()).send(forwarderFlags).result();
    }
    /**
     * To manually deploy an ETH address
     *
     * @param {Object} params - parameters object
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @returns {Object} Http response
     */
    async deployForwarders(params) {
        if (_.isUndefined(params.address) && _.isUndefined(params.id)) {
            throw new Error('address or id of address required');
        }
        let query;
        if (params.address) {
            query = params.address;
        }
        else {
            query = params.id;
        }
        const url = this.url(`/address/${encodeURIComponent(query)}/deployment`);
        this._wallet = await this.bitgo.post(url).send(params).result();
        return this._wallet;
    }
    /**
     * To manually forward tokens from an ETH or CELO address
     *
     * @param {Object} params - parameters object
     * @param {String} params.tokenName - Name of token that needs to be forwarded from the address
     * @param {String} [params.address] -
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @param {String} [params.gasPrice] - Explicit gas price to use when forwarding token from the forwarder contract (ETH and Celo only). If not given, defaults to the current estimated network gas price.
     * @param {String} [params.eip1559] - Specify eip1559 fee parameters in token forwarding transaction.
     * @returns {Object} Http response
     */
    async flushForwarderToken(params) {
        if (_.isUndefined(params.address) && _.isUndefined(params.id)) {
            throw new Error('address or id of address required');
        }
        let query;
        if (params.address) {
            query = params.address;
        }
        else {
            query = params.id;
        }
        const url = this.url(`/address/${encodeURIComponent(query)}/tokenforward`);
        this._wallet = await this.bitgo.post(url).send(params).result();
        return this._wallet;
    }
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @returns txHex {String} the txHex of the signed transaction
     */
    async sweep(params = {}) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['address'], ['walletPassphrase', 'xprv', 'otp']);
        // The sweep API endpoint is only available to utxo-based coins
        if (!this.baseCoin.sweepWithSendMany()) {
            if (this.confirmedBalanceString() !== this.balanceString()) {
                throw new Error('cannot sweep when unconfirmed funds exist on the wallet, please wait until all inbound transactions confirm');
            }
            const value = this.spendableBalanceString();
            if (_.isUndefined(value) || value === '0') {
                throw new Error('no funds to sweep');
            }
            params.recipients = [
                {
                    address: params.address,
                    amount: value,
                },
            ];
            return this.sendMany(params);
        }
        // the following flow works for all UTXO coins
        const reqId = new util_1.RequestTracer();
        const filteredParams = _.pick(params, [
            'address',
            'feeRate',
            'maxFeeRate',
            'feeTxConfirmTarget',
            'allowPartialSweep',
        ]);
        this.bitgo.setRequestTracer(reqId);
        const response = await this.bitgo.post(this.url('/sweepWallet')).send(filteredParams).result();
        // TODO(BG-3588): add txHex validation to protect man in the middle attacks replacing the txHex
        const keychains = (await this.baseCoin.keychains().getKeysForSigning({ wallet: this, reqId }));
        const transactionParams = {
            ...params,
            txPrebuild: response,
            keychain: keychains[0],
            userKeychain: keychains[0],
            backupKeychain: keychains.length > 1 ? keychains[1] : null,
            bitgoKeychain: keychains.length > 2 ? keychains[2] : null,
            prv: params.xprv,
        };
        const signedTransaction = await this.signTransaction(transactionParams);
        const selectParams = _.pick(params, ['otp']);
        const finalTxParams = _.extend({}, signedTransaction, selectParams);
        this.bitgo.setRequestTracer(reqId);
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx/send'))
            .send(finalTxParams)
            .result();
    }
    /**
     * Freeze a given wallet
     * @param params
     * @returns {*}
     */
    async freeze(params = {}) {
        sdk_core_1.common.validateParams(params, [], []);
        if (params.duration) {
            if (!_.isNumber(params.duration)) {
                throw new Error('invalid duration: should be number of seconds');
            }
        }
        return await this.bitgo.post(this.url('/freeze')).send(params).result();
    }
    /**
     * Update comment of a transfer
     * @param params
     * @returns {*}
     */
    async transferComment(params = {}) {
        sdk_core_1.common.validateParams(params, ['id'], ['comment']);
        return await this.bitgo
            .post(this.baseCoin.url('/wallet/' + this._wallet.id + '/transfer/' + params.id + '/comment'))
            .send(params)
            .result();
    }
    /**
     * List the addresses for a given wallet
     * @param params
     * @returns {*}
     */
    async addresses(params = {}) {
        sdk_core_1.common.validateParams(params, [], []);
        const query = {};
        if (params.mine) {
            query.mine = !!params.mine;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.sort) {
            if (!_.isNumber(params.sort)) {
                throw new Error('invalid sort argument, expecting number');
            }
            query.sort = params.sort;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.labelContains) {
            if (!_.isString(params.labelContains)) {
                throw new Error('invalid labelContains argument, expecting string');
            }
            query.labelContains = params.labelContains;
        }
        if (!_.isUndefined(params.segwit)) {
            if (!_.isBoolean(params.segwit)) {
                throw new Error('invalid segwit argument, expecting boolean');
            }
            query.segwit = params.segwit;
        }
        if (!_.isUndefined(params.chains)) {
            if (!_.isArray(params.chains)) {
                throw new Error('invalid chains argument, expecting array of numbers');
            }
            query.chains = params.chains;
        }
        return this.bitgo
            .get(this.baseCoin.url('/wallet/' + this._wallet.id + '/addresses'))
            .query(query)
            .result();
    }
    /**
     * Get a single wallet address by its id
     * @param params
     * @returns {*}
     */
    async getAddress(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['address', 'id']);
        let query;
        if (_.isUndefined(params.address) && _.isUndefined(params.id)) {
            throw new Error('address or id of address required');
        }
        if (params.address) {
            query = params.address;
        }
        else {
            query = params.id;
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return this.bitgo
            .get(this.baseCoin.url(`/wallet/${this._wallet.id}/address/${encodeURIComponent(query)}`))
            .result();
    }
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Number} params.forwarderVersion The version of address to create, if applicable
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param {String} params.baseAddress base address of the wallet(optional parameter)
     * @param {Boolean} params.allowSkipVerifyAddress When set to false, it throws error if address verification is skipped for any reason. Default is true.
     * @param {String} [params.derivedAddress]  Derived address
     * @param {Number} [params.index] Index of the derived address
     * @param {String} [params.passphrase] passphrase
     * Address verification can be skipped when forwarderVersion is 0 and pendingChainInitialization is true OR
     * if 'coinSpecific' is not part of the response from api call to create address
     */
    async createAddress(params = {}) {
        const addressParams = {};
        const reqId = new util_1.RequestTracer();
        const { chain, gasPrice, label, lowPriority, forwarderVersion, format, count = 1, baseAddress, allowSkipVerifyAddress = true, } = params;
        if (!_.isUndefined(chain)) {
            if (!_.isInteger(chain)) {
                throw new Error('chain has to be an integer');
            }
            addressParams.chain = chain;
        }
        if (!_.isUndefined(gasPrice)) {
            if (!_.isInteger(gasPrice) && (isNaN(Number(gasPrice)) || !_.isString(gasPrice))) {
                throw new Error('gasPrice has to be an integer or numeric string');
            }
            addressParams.gasPrice = gasPrice;
        }
        if (!_.isUndefined(forwarderVersion)) {
            if (!_.isInteger(forwarderVersion) || forwarderVersion < 0 || forwarderVersion > 1) {
                throw new Error('forwarderVersion has to be an integer between 0 and 1');
            }
            addressParams.forwarderVersion = forwarderVersion;
        }
        if (!_.isUndefined(label)) {
            if (!_.isString(label)) {
                throw new Error('label has to be a string');
            }
            addressParams.label = label;
        }
        if (!_.isUndefined(baseAddress)) {
            if (!_.isString(baseAddress)) {
                throw new Error('baseAddress has to be a string');
            }
        }
        if (!_.isUndefined(allowSkipVerifyAddress)) {
            if (!_.isBoolean(allowSkipVerifyAddress)) {
                throw new Error('allowSkipVerifyAddress has to be a boolean');
            }
        }
        if (!_.isInteger(count) || count <= 0 || count > 250) {
            throw new Error('count has to be a number between 1 and 250');
        }
        if (!_.isUndefined(lowPriority)) {
            if (!_.isBoolean(lowPriority)) {
                throw new Error('lowPriority has to be a boolean');
            }
            addressParams.lowPriority = lowPriority;
        }
        if (!_.isUndefined(format)) {
            if (!_.isString(format)) {
                throw new Error('format has to be a string');
            }
            addressParams.format = format;
        }
        // get keychains for address verification
        const keychains = await Promise.all(this._wallet.keys.map((k) => this.baseCoin.keychains().get({ id: k, reqId })));
        const rootAddress = _.get(this._wallet, 'receiveAddress.address');
        const newAddresses = _.times(count, async () => {
            var _a;
            this.bitgo.setRequestTracer(reqId);
            const newAddress = (await this.bitgo
                .post(this.baseCoin.url('/wallet/' + this._wallet.id + '/address'))
                .send(addressParams)
                .result());
            // infer its address type
            if (_.isObject(newAddress.coinSpecific)) {
                // need dynamic import to break circular dependency, this is ugly
                const { AbstractUtxoCoin } = require('./coins/abstractUtxoCoin');
                newAddress.addressType = AbstractUtxoCoin.inferAddressType(newAddress);
            }
            newAddress.keychains = keychains;
            newAddress.baseAddress = baseAddress !== null && baseAddress !== void 0 ? baseAddress : _.get(this._wallet, 'coinSpecific.baseAddress');
            const verificationData = _.merge({}, newAddress, { rootAddress });
            if (verificationData.error) {
                throw new errors_1.AddressGenerationError(verificationData.error);
            }
            verificationData.impliedForwarderVersion = forwarderVersion !== null && forwarderVersion !== void 0 ? forwarderVersion : (_a = verificationData.coinSpecific) === null || _a === void 0 ? void 0 : _a.forwarderVersion;
            // This condition was added in first place because in celo, when verifyAddress method was called on addresses which were having pendingChainInitialization as true, it used to throw some error
            // In case of forwarder version 1 eth addresses, addresses need to be verified even if the pendingChainInitialization flag is true
            if (verificationData.coinSpecific &&
                (!verificationData.coinSpecific.pendingChainInitialization || verificationData.impliedForwarderVersion === 1)) {
                // can't verify addresses which are pending chain initialization, as the address is hidden
                let isWalletAddress = false;
                try {
                    isWalletAddress = this.baseCoin.isWalletAddress(verificationData);
                }
                catch (e) {
                    if (!(e instanceof errors_1.MethodNotImplementedError)) {
                        throw e;
                    }
                    // FIXME(BG-43225): implement this correctly
                    isWalletAddress = true;
                }
                if (!isWalletAddress) {
                    throw new Error(`not a wallet address`);
                }
            }
            else if (!allowSkipVerifyAddress) {
                throw new Error(`address verification skipped for count = ${count}`);
            }
            return newAddress;
        });
        if (newAddresses.length === 1) {
            return newAddresses[0];
        }
        return {
            addresses: await Promise.all(newAddresses),
        };
    }
    /**
     * Update properties on an address
     * @param params
     * @returns {*}
     */
    async updateAddress(params = {}) {
        const address = params.address;
        if (!_.isString(address)) {
            throw new Error('missing required string parameter address');
        }
        const putParams = _.pick(params, ['label']);
        const url = this.url('/address/' + encodeURIComponent(address));
        return this.bitgo.put(url).send(putParams).result();
    }
    /**
     * List webhooks on this wallet
     * @param params
     */
    async listWebhooks(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/webhooks')).query(query).result();
    }
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @returns {*}
     */
    async simulateWebhook(params = {}) {
        sdk_core_1.common.validateParams(params, ['webhookId'], ['transferId', 'pendingApprovalId']);
        const hasTransferId = !!params.transferId;
        const hasPendingApprovalId = !!params.pendingApprovalId;
        if (!hasTransferId && !hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId');
        }
        if (hasTransferId && hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId, but not both');
        }
        // depending on the coin type of the wallet, the txHash has to adhere to its respective format
        // but the server takes care of that
        // only take the transferId and pendingApprovalId properties
        const filteredParams = _.pick(params, ['transferId', 'pendingApprovalId']);
        const webhookId = params.webhookId;
        return this.bitgo
            .post(this.url('/webhooks/' + webhookId + '/simulate'))
            .send(filteredParams)
            .result();
    }
    /**
     * Add a webhook to this wallet
     * @param params
     */
    async addWebhook(params = {}) {
        sdk_core_1.common.validateParams(params, ['url', 'type'], []);
        return this.bitgo.post(this.url('/webhooks')).send(params).result();
    }
    /**
     * Remove a webhook from this wallet
     * @param params
     */
    async removeWebhook(params = {}) {
        sdk_core_1.common.validateParams(params, ['url', 'type'], []);
        return this.bitgo.del(this.url('/webhooks')).send(params).result();
    }
    /**
     * Gets the user key chain for this wallet
     *
     * The user key chain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     * @param params
     */
    async getEncryptedUserKeychain(params = {}) {
        const tryKeyChain = async (index) => {
            if (!this._wallet.keys || index >= this._wallet.keys.length) {
                throw new Error('No encrypted keychains on this wallet.');
            }
            const params = { id: this._wallet.keys[index] };
            const keychain = await this.baseCoin.keychains().get(params);
            // If we find the prv, then this is probably the user keychain we're looking for
            if (keychain.encryptedPrv) {
                return keychain;
            }
            return tryKeyChain(index + 1);
        };
        return tryKeyChain(0);
    }
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     */
    async getPrv(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['walletPassphrase', 'prv']);
        // Prepare signing key
        if (_.isUndefined(params.prv) && _.isUndefined(params.walletPassphrase)) {
            throw new Error('must either provide prv or wallet passphrase');
        }
        if (!_.isUndefined(params.prv) && !_.isString(params.prv)) {
            throw new Error('prv must be a string');
        }
        if (!_.isUndefined(params.walletPassphrase) && !_.isString(params.walletPassphrase)) {
            throw new Error('walletPassphrase must be a string');
        }
        if (params.prv) {
            return params.prv;
        }
        const userKeychain = (await this.getEncryptedUserKeychain());
        const userEncryptedPrv = userKeychain.encryptedPrv;
        let userPrv;
        try {
            userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
        }
        catch (e) {
            throw new Error('error decrypting wallet passphrase');
        }
        return userPrv;
    }
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     */
    async createShare(params = {}) {
        sdk_core_1.common.validateParams(params, ['user', 'permissions'], []);
        if (params.keychain && !_.isEmpty(params.keychain)) {
            if (!params.keychain.pub ||
                !params.keychain.encryptedPrv ||
                !params.keychain.fromPubKey ||
                !params.keychain.toPubKey ||
                !params.keychain.path) {
                throw new Error('requires keychain parameters - pub, encryptedPrv, fromPubKey, toPubKey, path');
            }
        }
        return this.bitgo.post(this.url('/share')).send(params).result();
    }
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @returns {*}
     */
    async shareWallet(params = {}) {
        var _a;
        sdk_core_1.common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message']);
        if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
            throw new Error('Expected reshare to be a boolean.');
        }
        if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
            throw new Error('Expected skipKeychain to be a boolean. ');
        }
        const needsKeychain = !params.skipKeychain && params.permissions && params.permissions.indexOf('spend') !== -1;
        if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
            throw new Error('Expected disableEmail to be a boolean.');
        }
        if (!_.isString(params.email)) {
            throw new Error('missing required string parameter email');
        }
        const sharing = (await this.bitgo.getSharingKey({ email: params.email.toLowerCase() }));
        let sharedKeychain;
        if (needsKeychain) {
            try {
                const keychain = (await this.getEncryptedUserKeychain({}));
                // Decrypt the user key with a passphrase
                if (keychain.encryptedPrv) {
                    if (!params.walletPassphrase) {
                        throw new Error('Missing walletPassphrase argument');
                    }
                    try {
                        keychain.prv = this.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedPrv });
                    }
                    catch (e) {
                        throw new Error('Unable to decrypt user keychain');
                    }
                    const eckey = bitcoin_1.makeRandomKey();
                    const secret = ecdh_1.getSharedSecret(eckey, Buffer.from(sharing.pubkey, 'hex')).toString('hex');
                    const newEncryptedPrv = this.bitgo.encrypt({ password: secret, input: keychain.prv });
                    // Only one of pub/commonPub/commonKeychain should be present in the keychain
                    let pub = (_a = keychain.pub) !== null && _a !== void 0 ? _a : keychain.commonPub;
                    if (keychain.commonKeychain) {
                        pub = tssUtils_1.TssUtils.getPublicKeyFromCommonKeychain(keychain.commonKeychain);
                    }
                    sharedKeychain = {
                        pub,
                        encryptedPrv: newEncryptedPrv,
                        fromPubKey: eckey.publicKey.toString('hex'),
                        toPubKey: sharing.pubkey,
                        path: sharing.path,
                    };
                }
            }
            catch (e) {
                if (e.message === 'No encrypted keychains on this wallet.') {
                    sharedKeychain = {};
                    // ignore this error because this looks like a cold wallet
                }
                else {
                    throw e;
                }
            }
        }
        const options = {
            user: sharing.userId,
            permissions: params.permissions,
            reshare: params.reshare,
            message: params.message,
            disableEmail: params.disableEmail,
        };
        if (sharedKeychain) {
            options.keychain = sharedKeychain;
        }
        else if (params.skipKeychain) {
            options.keychain = {};
        }
        return await this.createShare(options);
    }
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @return {*}
     */
    async removeUser(params = {}) {
        sdk_core_1.common.validateParams(params, ['userId'], []);
        const userId = params.userId;
        return await this.bitgo.del(this.url('/user/' + userId)).result();
    }
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the walletâ€™s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.nonParticipation - (Algorand) Non participating key reg transaction
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} param.transferId - transfer Id to use in transaction (supported by casper)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param {String} params.walletContractAddress - The contract address used as the "to" field of a transaction
     * @returns {*}
     */
    async prebuildTransaction(params = {}) {
        if (this._wallet.multisigType === 'tss') {
            return this.prebuildTransactionTss(params);
        }
        // Whitelist params to build tx
        const whitelistedParams = _.pick(params, this.prebuildWhitelistedParams());
        debug('prebuilding transaction: %O', whitelistedParams);
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        const extraParams = await this.baseCoin.getExtraPrebuildParams(Object.assign(params, { wallet: this }));
        Object.assign(whitelistedParams, extraParams);
        const queryParams = {
            offlineVerification: params.offlineVerification ? true : undefined,
        };
        const buildQuery = this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.id() + '/tx/build'))
            .query(queryParams)
            .send(whitelistedParams)
            .result();
        const blockHeightQuery = _.isFunction(this.baseCoin.getLatestBlockHeight)
            ? this.baseCoin.getLatestBlockHeight(params.reqId)
            : Promise.resolve(undefined);
        const queries = [buildQuery, blockHeightQuery];
        const [buildResponse, blockHeight] = (await Promise.all(queries));
        debug('postprocessing transaction prebuild: %O', buildResponse);
        if (!_.isUndefined(blockHeight)) {
            buildResponse.blockHeight = blockHeight;
        }
        let prebuild = (await this.baseCoin.postProcessPrebuild(Object.assign(buildResponse, { wallet: this, buildParams: whitelistedParams })));
        delete prebuild.wallet;
        delete prebuild.buildParams;
        prebuild = _.extend({}, prebuild, { walletId: this.id() });
        if (this._wallet && this._wallet.coinSpecific && !params.walletContractAddress) {
            prebuild = _.extend({}, prebuild, { walletContractAddress: this._wallet.coinSpecific.baseAddress });
        }
        debug('final transaction prebuild: %O', prebuild);
        return prebuild;
    }
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @return {*}
     */
    async signTransaction(params = {}) {
        const { txPrebuild } = params;
        if (!txPrebuild || typeof txPrebuild !== 'object') {
            throw new Error('txPrebuild must be an object');
        }
        const presign = await this.baseCoin.presignTransaction({
            ...params,
            walletData: this._wallet,
            tssUtils: this.tssUtils,
        });
        if (this._wallet.multisigType === 'tss') {
            return this.signTransactionTss({ ...presign, prv: this.getUserPrv(presign) });
        }
        let { pubs } = params;
        if (!pubs && this.baseCoin.keyIdsForSigning().length > 1) {
            const keychains = await this.baseCoin.keychains().getKeysForSigning({ wallet: this });
            pubs = keychains.map((k) => k.pub);
        }
        const signTransactionParams = {
            ...presign,
            txPrebuild,
            pubs,
            coin: this.baseCoin,
        };
        if (_.isFunction(params.customSigningFunction)) {
            return params.customSigningFunction(signTransactionParams);
        }
        return this.baseCoin.signTransaction({
            ...signTransactionParams,
            prv: this.getUserPrv(presign),
        });
    }
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    getUserPrv(params = {}) {
        const userKeychain = params.keychain || params.key;
        let userPrv = params.prv;
        if (userPrv && typeof userPrv !== 'string') {
            throw new Error('prv must be a string');
        }
        // use the `derivedFromParentWithSeed` property from the user keychain as the `coldDerivationSeed`
        // if no other `coldDerivationSeed` was explicitly provided
        if (params.coldDerivationSeed === undefined &&
            params.keychain !== undefined &&
            params.keychain.derivedFromParentWithSeed !== undefined) {
            params.coldDerivationSeed = params.keychain.derivedFromParentWithSeed;
        }
        if (userPrv && params.coldDerivationSeed) {
            // the derivation only makes sense when a key already exists
            const derivation = this.baseCoin.deriveKeyWithSeed({ key: userPrv, seed: params.coldDerivationSeed });
            userPrv = derivation.key;
        }
        else if (!userPrv) {
            if (!userKeychain || typeof userKeychain !== 'object') {
                throw new Error('keychain must be an object');
            }
            const userEncryptedPrv = userKeychain.encryptedPrv;
            if (!userEncryptedPrv) {
                throw new Error('keychain does not have property encryptedPrv');
            }
            if (!params.walletPassphrase) {
                throw new Error('walletPassphrase property missing');
            }
            userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
        }
        return userPrv;
    }
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     */
    async prebuildAndSignTransaction(params = {}) {
        var _a;
        if (params.eip1559 && params.gasPrice) {
            const error = new Error('Only one of params.eip1559 and params.gasPrice may be specified');
            error.code = 'both_gasPrice_and_eip1559gasModel_specified';
            throw error;
        }
        if (params.prebuildTx && params.recipients) {
            const error = new Error('Only one of prebuildTx and recipients may be specified');
            error.code = 'both_prebuildtx_and_recipients_specified';
            throw error;
        }
        if (params.recipients && !Array.isArray(params.recipients)) {
            const error = new Error('expecting recipients array');
            error.code = 'recipients_not_array';
            throw error;
        }
        if (_.isArray(this._permissions) && !this._permissions.includes('spend')) {
            const error = new Error('no spend permission on this wallet');
            error.code = 'user_not_allowed_to_spend_from_wallet';
            throw error;
        }
        // call prebuildTransaction and keychains-get in parallel
        // the prebuild can be overridden by providing an explicit tx
        const txPrebuildQuery = params.prebuildTx ? Promise.resolve(params.prebuildTx) : this.prebuildTransaction(params);
        const keychains = await this.baseCoin.keychains().getKeysForSigning({ wallet: this, reqId: params.reqId });
        const txPrebuild = (await txPrebuildQuery);
        try {
            await this.baseCoin.verifyTransaction({
                txParams: txPrebuild.buildParams || params,
                txPrebuild,
                wallet: this,
                verification: (_a = params.verification) !== null && _a !== void 0 ? _a : {},
                reqId: params.reqId,
            });
        }
        catch (e) {
            console.error('transaction prebuild failed local validation:', e.message);
            console.error('transaction params:', _.omit(params, ['keychain', 'prv', 'passphrase', 'walletPassphrase', 'key', 'wallet']));
            console.error('transaction prebuild:', txPrebuild);
            console.trace(e);
            throw e;
        }
        // pass our three keys
        const signingParams = {
            ...params,
            txPrebuild: txPrebuild,
            wallet: {
                // this is the version of the multisig address at wallet creation time
                addressVersion: this._wallet.coinSpecific.addressVersion,
            },
            keychain: keychains[0],
            backupKeychain: keychains.length > 1 ? keychains[1] : null,
            bitgoKeychain: keychains.length > 2 ? keychains[2] : null,
            pubs: keychains.map((k) => k.pub),
            reqId: params.reqId,
        };
        try {
            return await this.signTransaction(signingParams);
        }
        catch (error) {
            if (error.message.includes('insufficient funds')) {
                error.code = 'insufficient_funds';
                error.walletBalances = {
                    balanceString: this.balanceString(),
                    confirmedBalanceString: this.confirmedBalanceString(),
                    spendableBalanceString: this.spendableBalanceString(),
                    balance: this.balance(),
                    confirmedBalance: this.confirmedBalance(),
                    spendableBalance: this.spendableBalance(),
                };
                error.txParams = _.omit(params, ['keychain', 'prv', 'passphrase', 'walletPassphrase', 'key']);
            }
            throw error;
        }
    }
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     */
    async accelerateTransaction(params = {}) {
        // TODO(BG-9349): change the last check to > 0 and the error message once platform allows multiple transactions to
        //                be bumped in the same CPFP transaction
        if (_.isUndefined(params.cpfpTxIds) || !Array.isArray(params.cpfpTxIds) || params.cpfpTxIds.length !== 1) {
            const error = new Error('expecting cpfpTxIds to be an array of length 1');
            error.code = 'cpfptxids_not_array';
            throw error;
        }
        if (_.isUndefined(params.cpfpFeeRate)) {
            if (params.noCpfpFeeRate !== true) {
                const error = new Error('cpfpFeeRate must be set unless noCpfpFeeRate is set');
                error.code = 'cpfpfeerate_not_set';
                throw error;
            }
        }
        else {
            if (!_.isInteger(params.cpfpFeeRate) || params.cpfpFeeRate < 0) {
                const error = new Error('cpfpFeeRate must be a non-negative integer');
                error.code = 'cpfpfeerate_not_nonnegative_integer';
                throw error;
            }
        }
        if (_.isUndefined(params.maxFee)) {
            if (params.noMaxFee !== true) {
                const error = new Error('maxFee must be set unless noMaxFee is set');
                error.code = 'maxfee_not_set';
                throw error;
            }
        }
        else {
            if (!_.isInteger(params.maxFee) || params.maxFee < 0) {
                const error = new Error('maxFee must be a non-negative integer');
                error.code = 'maxfee_not_nonnegative_integer';
                throw error;
            }
        }
        if (params.recipients !== undefined) {
            if (!Array.isArray(params.recipients) || params.recipients.length !== 0) {
                throw new Error(`invalid value for 'recipients': must be empty array when set`);
            }
        }
        params.recipients = [];
        // We must pass the build params through to submit in case the CPFP tx ever has to be rebuilt.
        const submitParams = Object.assign(params, await this.prebuildAndSignTransaction(params));
        delete submitParams.wallet;
        return await this.submitTransaction(submitParams);
    }
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     */
    async submitTransaction(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['otp', 'txHex', 'txRequestId']);
        const hasTxHex = !!params.txHex;
        const hasHalfSigned = !!params.halfSigned;
        if (params.txRequestId && (hasTxHex || hasHalfSigned)) {
            throw new Error('must supply exactly one of txRequestId, txHex, or halfSigned');
        }
        else if (!params.txRequestId && ((hasTxHex && hasHalfSigned) || (!hasTxHex && !hasHalfSigned))) {
            throw new Error('must supply either txHex or halfSigned, but not both');
        }
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.id() + '/tx/send'))
            .send(params)
            .result();
    }
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.custodianTransactionId - [Ethereum/MMI Specific] id of transaction created via metamask
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @returns {*}
     */
    async send(params = {}) {
        sdk_core_1.common.validateParams(params, ['address'], ['message', 'data']);
        if (_.isUndefined(params.amount)) {
            throw new Error('missing required parameter amount');
        }
        if (_.isUndefined(params.address)) {
            throw new Error('missing required parameter address');
        }
        const coin = this.baseCoin;
        const amount = new bignumber_js_1.BigNumber(params.amount);
        if (amount.isNegative()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        if (!coin.valuelessTransferAllowed() && amount.isZero()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        const recipients = [
            {
                address: params.address,
                amount: params.amount,
                tokenName: params.tokenName,
            },
        ];
        if (params.data && coin.transactionDataAllowed()) {
            recipients[0].data = params.data;
        }
        const sendManyOptions = Object.assign({}, params, { recipients });
        return this.sendMany(sendManyOptions);
    }
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @returns {*}
     */
    async sendMany(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['comment', 'otp']);
        debug('sendMany called');
        const reqId = params.reqId || new util_1.RequestTracer();
        params.reqId = reqId;
        this.bitgo.setRequestTracer(reqId);
        const coin = this.baseCoin;
        if (_.isObject(params.recipients)) {
            params.recipients.map(function (recipient) {
                const amount = new bignumber_js_1.BigNumber(recipient.amount);
                if (amount.isNegative()) {
                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                }
                if (!coin.valuelessTransferAllowed() && amount.isZero()) {
                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                }
            });
        }
        if (this._wallet.multisigType === 'tss') {
            return this.sendManyTss(params);
        }
        const halfSignedTransaction = await this.prebuildAndSignTransaction(params);
        const selectParams = _.pick(params, [
            'recipients',
            'numBlocks',
            'feeRate',
            'maxFeeRate',
            'minConfirms',
            'enforceMinConfirmsForChange',
            'targetWalletUnspents',
            'message',
            'minValue',
            'maxValue',
            'sequenceId',
            'lastLedgerSequence',
            'ledgerSequenceDelta',
            'gasPrice',
            'noSplitChange',
            'unspents',
            'comment',
            'otp',
            'changeAddress',
            'instant',
            'memo',
            'type',
            'trustlines',
            'transferId',
            'stakingOptions',
        ]);
        const finalTxParams = _.extend({}, halfSignedTransaction, selectParams);
        return this.bitgo.post(this.url('/tx/send')).send(finalTxParams).result();
    }
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     */
    async recoverToken(params = {}) {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('token recovery only supported for eth wallets');
        }
        const { tokenContractAddress, recipient } = params;
        if (_.isUndefined(tokenContractAddress)) {
            throw new Error('missing required string parameter tokenContractAddress');
        }
        if (_.isUndefined(recipient)) {
            throw new Error('missing required string parameter recipient');
        }
        const recoverTokenOptions = Object.assign({ tokenContractAddress, recipient }, params, { wallet: this });
        return this.baseCoin.recoverToken(recoverTokenOptions);
    }
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    async getFirstPendingTransaction(params = {}) {
        return internal.getFirstPendingTransaction({ walletId: this.id() }, this.baseCoin, this.bitgo);
    }
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} params.fee The new fee to apply to the denoted transaction
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    async changeFee(params = {}) {
        sdk_core_1.common.validateParams(params, ['txid', 'fee'], []);
        return await this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.id() + '/tx/changeFee'))
            .send(params)
            .result();
    }
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    async getPaymentInfo(params = {}) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['url'], []);
        return await this.bitgo.get(this.url('/paymentInfo')).query(params).result();
    }
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    async sendPaymentResponse(params = {}) {
        return await this.bitgo.post(this.url('/sendPayment')).send(params).result();
    }
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    async createPolicyRule(params = {}) {
        sdk_core_1.common.validateParams(params, ['id', 'type'], ['message']);
        if (!_.isObject(params.condition)) {
            throw new Error('missing parameter: conditions object');
        }
        if (!_.isObject(params.action)) {
            throw new Error('missing parameter: action object');
        }
        return await this.bitgo.post(this.url('/policy/rule')).send(params).result();
    }
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    async setPolicyRule(params = {}) {
        sdk_core_1.common.validateParams(params, ['id', 'type'], ['message']);
        if (!_.isObject(params.condition)) {
            throw new Error('missing parameter: conditions object');
        }
        if (!_.isObject(params.action)) {
            throw new Error('missing parameter: action object');
        }
        return await this.bitgo.put(this.url('/policy/rule')).send(params).result();
    }
    /**
     * Remove Policy Rule
     * @param params
     * @returns {*}
     */
    async removePolicyRule(params = {}) {
        sdk_core_1.common.validateParams(params, ['id'], ['message']);
        return await this.bitgo.del(this.url('/policy/rule')).send(params).result();
    }
    /**
     * Remove this wallet
     * @param params
     * @returns {*}
     */
    async remove(params = {}) {
        return this.bitgo.del(this.url()).result();
    }
    /**
     * Extract a JSON representable version of this wallet
     */
    toJSON() {
        return this._wallet;
    }
    /**
     * Create a trading account from this wallet
     */
    toTradingAccount() {
        if (this.baseCoin.getFamily() !== 'ofc') {
            throw new Error('Can only convert an Offchain (OFC) wallet to a trading account');
        }
        return new tradingAccount_1.TradingAccount(this._wallet.enterprise, this, this.bitgo);
    }
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    downloadKeycard(params = {}) {
        if (!window || !window.location) {
            throw new Error('The downloadKeycard function is only callable within a browser.');
        }
        // Grab parameters with default for activationCode
        const { jsPDF, QRCode, userKeychain, backupKeychain, bitgoKeychain, passphrase, passcodeEncryptionCode, walletKeyID, backupKeyID, activationCode = Math.floor(Math.random() * 900000 + 100000).toString(), } = params;
        if (!jsPDF || typeof jsPDF !== 'function') {
            throw new Error('Please pass in a valid jsPDF instance');
        }
        // Validate keychains
        if (!userKeychain || typeof userKeychain !== 'object') {
            throw new Error(`Wallet keychain must have a 'user' property`);
        }
        if (!backupKeychain || typeof backupKeychain !== 'object') {
            throw new Error('Backup keychain is required and must be an object');
        }
        if (!bitgoKeychain || typeof bitgoKeychain !== 'object') {
            throw new Error('Bitgo keychain is required and must be an object');
        }
        if (walletKeyID && typeof walletKeyID !== 'string') {
            throw new Error('walletKeyID must be a string');
        }
        if (backupKeyID && typeof backupKeyID !== 'string') {
            throw new Error('backupKeyID must be a string');
        }
        // Validate activation code if provided
        if (typeof activationCode !== 'string') {
            throw new Error('Activation Code must be a string');
        }
        if (activationCode.length !== 6) {
            throw new Error('Activation code must be six characters');
        }
        const coinShortName = this.baseCoin.type;
        const coinName = this.baseCoin.getFullName();
        const walletLabel = this._wallet.label;
        const doc = keycard_1.drawKeycard({
            jsPDF,
            QRCode,
            encrypt: this.bitgo.encrypt,
            coinShortName,
            coinName,
            activationCode,
            walletLabel,
            passphrase,
            passcodeEncryptionCode,
            userKeychain,
            backupKeychain,
            bitgoKeychain,
            walletKeyID,
            backupKeyID,
        });
        // Save the PDF on the user's browser
        doc.save(`BitGo Keycard for ${walletLabel}.pdf`);
    }
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    async buildAccountConsolidations(params = {}) {
        if (!this.baseCoin.allowsAccountConsolidations()) {
            throw new Error(`${this.baseCoin.getFullName()} does not allow account consolidations.`);
        }
        // Whitelist params to build tx
        const whitelistedParams = _.pick(params, this.prebuildConsolidateAccountParams());
        debug('prebuilding consolidation transaction: %O', whitelistedParams);
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        // this could return 100 build transactions
        const buildResponse = (await this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.id() + '/consolidateAccount/build'))
            .send(whitelistedParams)
            .result());
        // we need to step over each prebuild now - should be in an array in the body
        const consolidations = [];
        for (const consolidateAccountBuild of buildResponse) {
            let prebuild = (await this.baseCoin.postProcessPrebuild(Object.assign(consolidateAccountBuild, { wallet: this, buildParams: whitelistedParams })));
            delete prebuild.wallet;
            delete prebuild.buildParams;
            prebuild = _.extend({}, prebuild, { walletId: this.id() });
            debug('final consolidation transaction prebuild: %O', prebuild);
            consolidations.push(prebuild);
        }
        return consolidations;
    }
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     prebuildTx   - this is the pre-build consolidation tx. this is a normally built tx with
     *                    an additional parameter of consolidateId.
     *     verification - normal keychains, etc. for verification
     */
    async sendAccountConsolidation(params = {}) {
        if (!this.baseCoin.allowsAccountConsolidations()) {
            throw new Error(`${this.baseCoin.getFullName()} does not allow account consolidations.`);
        }
        // one of a set of consolidation transactions
        if (typeof params.prebuildTx === 'string' || params.prebuildTx === undefined) {
            throw new Error('Invalid build of account consolidation.');
        }
        if (!params.prebuildTx.consolidateId) {
            throw new Error('Failed to find consolidation id on consolidation transaction.');
        }
        if (this._wallet.multisigType === 'tss') {
            if (!params.prebuildTx.txRequestId) {
                throw new Error('Consolidation request missing txRequestId.');
            }
            return await this.sendManyTss(params);
        }
        const signedPrebuild = (await this.prebuildAndSignTransaction(params));
        // decorate with our consolidation id
        signedPrebuild.consolidateId = params.prebuildTx.consolidateId;
        delete signedPrebuild.wallet;
        return await this.submitTransaction(signedPrebuild);
    }
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params -
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    async sendAccountConsolidations(params = {}) {
        if (!this.baseCoin.allowsAccountConsolidations()) {
            throw new Error(`${this.baseCoin.getFullName()} does not allow account consolidations.`);
        }
        // this gives us a set of account consolidation transactions
        const unsignedBuilds = (await this.buildAccountConsolidations(params));
        if (unsignedBuilds && unsignedBuilds.length > 0) {
            const successfulTxs = [];
            const failedTxs = new Array();
            for (const unsignedBuild of unsignedBuilds) {
                // fold any of the parameters we used to build this transaction into the unsignedBuild
                const unsignedBuildWithOptions = Object.assign({}, params);
                unsignedBuildWithOptions.prebuildTx = unsignedBuild;
                try {
                    const sendTx = await this.sendAccountConsolidation(unsignedBuildWithOptions);
                    successfulTxs.push(sendTx);
                }
                catch (e) {
                    console.dir(e);
                    failedTxs.push(e);
                }
            }
            return {
                success: successfulTxs,
                failure: failedTxs,
            };
        }
    }
    /* MARK: TSS Helpers */
    /**
     * Prebuilds a transaction for a TSS wallet.
     *
     * @param params prebuild transaction options
     */
    async prebuildTransactionTss(params = {}) {
        const reqId = params.reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        let unsignedTxRequest;
        switch (params.type) {
            case 'transfer':
                unsignedTxRequest = await this.tssUtils.prebuildTxWithIntent({
                    reqId,
                    intentType: 'payment',
                    sequenceId: params.sequenceId,
                    comment: params.comment,
                    recipients: params.recipients || [],
                    memo: params.memo,
                    nonce: params.nonce,
                });
                break;
            case 'enabletoken':
                unsignedTxRequest = await this.tssUtils.prebuildTxWithIntent({
                    reqId,
                    intentType: 'createAccount',
                    recipients: params.recipients || [],
                    tokenName: params.tokenName,
                    memo: params.memo,
                });
                break;
            default:
                throw new Error(`transaction type not supported: ${params.type}`);
        }
        const unsignedTxs = unsignedTxRequest.unsignedTxs;
        if (unsignedTxs.length !== 1) {
            throw new Error(`Expected a single unsigned tx for tx request with id: ${unsignedTxRequest.txRequestId}`);
        }
        const whitelistedParams = _.pick(params, this.prebuildWhitelistedParams());
        return {
            walletId: this.id(),
            wallet: this,
            txRequestId: unsignedTxRequest.txRequestId,
            txHex: unsignedTxs[0].serializedTxHex,
            buildParams: whitelistedParams,
            feeInfo: unsignedTxs[0].feeInfo,
        };
    }
    /**
     * Signs a transaction from a TSS wallet.
     *
     * @param params signing options
     */
    async signTransactionTss(params = {}) {
        if (!params.txPrebuild) {
            throw new Error('txPrebuild required to sign transactions with TSS');
        }
        if (!params.txPrebuild.txRequestId) {
            throw new Error('txRequestId required to sign transactions with TSS');
        }
        if (!params.prv) {
            throw new Error('prv required to sign transactions with TSS');
        }
        try {
            const signedTxRequest = await this.tssUtils.signTxRequest({
                txRequest: params.txPrebuild.txRequestId,
                prv: params.prv,
                reqId: params.reqId || new util_1.RequestTracer(),
            });
            return {
                txRequestId: signedTxRequest.txRequestId,
            };
        }
        catch (e) {
            throw new Error('failed to sign transaction ' + e);
        }
    }
    /**
     * Builds, signs, and sends a transaction from a TSS wallet.
     *
     * @param params send options
     */
    async sendManyTss(params = {}) {
        const signedTransaction = (await this.prebuildAndSignTransaction(params));
        if (!signedTransaction.txRequestId) {
            throw new Error('txRequestId missing from signed transaction');
        }
        return this.tssUtils.sendTxRequest(signedTransaction.txRequestId);
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7OztBQUVILCtDQUF5QztBQUN6Qyw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBRWxDLHdDQUEyQztBQUUzQyw4Q0FBeUM7QUFDekMsc0NBQThFO0FBVTlFLGdEQUFnRDtBQUNoRCxnREFBaUQ7QUFFakQsNkRBQTBEO0FBQzFELHVEQUF5RTtBQUN6RSwwQ0FBZ0Q7QUFDaEQsa0NBQTBDO0FBQzFDLGtEQUEwRDtBQUUxRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQXNlMUMsYUFBYTtBQUViLE1BQWEsTUFBTTtJQU9qQixZQUFZLEtBQVksRUFBRSxRQUFrQixFQUFFLFVBQWU7UUFDM0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUM7UUFDMUIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3RCLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQy9ELElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsYUFBYSxDQUFDLENBQUM7U0FDdkQ7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksbUJBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7O09BR0c7SUFD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SUFBSSxLQUFLLENBQUMsNkJBQTZCLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDcEQ7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBMEIsRUFBRTtRQUNwRCxNQUFNLGlCQUFpQixHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLENBQTZCLENBQUM7UUFDdEcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsRUFBRTtZQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7U0FDaEU7UUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7Q0FDRjtBQS9zRUQsd0JBK3NFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cblxuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcblxuaW1wb3J0IHsgbWFrZVJhbmRvbUtleSB9IGZyb20gJy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgeyBjb21tb24gfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQWRkcmVzc0dlbmVyYXRpb25FcnJvciwgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFNpZ25lZFRyYW5zYWN0aW9uUmVxdWVzdCxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVmVyaWZpY2F0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG59IGZyb20gJy4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgRXRoIH0gZnJvbSAnLi9jb2lucyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2ludGVybmFsJztcbmltcG9ydCB7IGRyYXdLZXljYXJkIH0gZnJvbSAnLi9pbnRlcm5hbC9rZXljYXJkJztcbmltcG9ydCB7IEtleWNoYWluIH0gZnJvbSAnLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgVHJhZGluZ0FjY291bnQgfSBmcm9tICcuL3RyYWRpbmcvdHJhZGluZ0FjY291bnQnO1xuaW1wb3J0IHsgUGVuZGluZ0FwcHJvdmFsLCBQZW5kaW5nQXBwcm92YWxEYXRhIH0gZnJvbSAnLi9wZW5kaW5nQXBwcm92YWwnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbCc7XG5pbXBvcnQgeyBnZXRTaGFyZWRTZWNyZXQgfSBmcm9tICcuLi9lY2RoJztcbmltcG9ydCB7IFRzc1V0aWxzLCBUeFJlcXVlc3QgfSBmcm9tICcuL2ludGVybmFsL3Rzc1V0aWxzJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djI6d2FsbGV0Jyk7XG5cbnR5cGUgTWFuYWdlVW5zcGVudHMgPSAnY29uc29saWRhdGUnIHwgJ2Zhbm91dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF4aW11bVNwZW5kYWJsZU9wdGlvbnMge1xuICBtaW5WYWx1ZT86IG51bWJlciB8IHN0cmluZztcbiAgbWF4VmFsdWU/OiBudW1iZXIgfCBzdHJpbmc7XG4gIG1pbkhlaWdodD86IG51bWJlcjtcbiAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IGJvb2xlYW47XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gIHJlY2lwaWVudEFkZHJlc3M/OiBzdHJpbmc7XG4gIGxpbWl0PzogbnVtYmVyO1xuICB0YXJnZXQ/OiBudW1iZXI7XG4gIHBsYWluVGFyZ2V0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1heGltdW1TcGVuZGFibGUge1xuICBtYXhpbXVtU3BlbmRhYmxlOiBudW1iZXI7XG4gIGNvaW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vIHtcbiAgdmFsdWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIGEgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbjpcbiAqIC0gd2FsbGV0UGFzc3BocmFzZSAtIG5lY2Vzc2FyeSBmb3Igc2lnbmluZ1xuICogLSBmZWVSYXRlXG4gKiAtIG1heEZlZVJhdGVcbiAqIC0gdmFsaWRGcm9tQmxvY2tcbiAqIC0gdmFsaWRUb0Jsb2NrXG4gKlxuICogV2hhdCBzaG91bGRuJ3QgYmUgcGFzc2VkICh0aGVzZSB3aWxsIGJlIGlnbm9yZWQpOlxuICogLSByZWNpcGllbnRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRDb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgUHJlYnVpbGRUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBjb25zb2xpZGF0ZUFkZHJlc3Nlcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWJ1aWxkVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xuICByZWNpcGllbnRzPzoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgfVtdO1xuICBudW1CbG9ja3M/OiBudW1iZXI7XG4gIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBib29sZWFuO1xuICB0YXJnZXRXYWxsZXRVbnNwZW50cz86IG51bWJlcjtcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBzZXF1ZW5jZUlkPzogc3RyaW5nO1xuICBsYXN0TGVkZ2VyU2VxdWVuY2U/OiBudW1iZXI7XG4gIGxlZGdlclNlcXVlbmNlRGVsdGE/OiBudW1iZXI7XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBub1NwbGl0Q2hhbmdlPzogYm9vbGVhbjtcbiAgdW5zcGVudHM/OiBhbnlbXTtcbiAgY2hhbmdlQWRkcmVzcz86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgY2xvc2VSZW1haW5kZXJUbz86IHN0cmluZztcbiAgbm9uUGFydGljaXBhdGlvbj86IGJvb2xlYW47XG4gIHZhbGlkRnJvbUJsb2NrPzogbnVtYmVyO1xuICB2YWxpZFRvQmxvY2s/OiBudW1iZXI7XG4gIGluc3RhbnQ/OiBib29sZWFuO1xuICBtZW1vPzogTWVtbztcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG4gIGhvcD86IGJvb2xlYW47XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHJlc2VydmF0aW9uPzoge1xuICAgIGV4cGlyZVRpbWU/OiBzdHJpbmc7XG4gICAgcGVuZGluZ0FwcHJvdmFsSWQ/OiBzdHJpbmc7XG4gIH07XG4gIG9mZmxpbmVWZXJpZmljYXRpb24/OiBib29sZWFuO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG4gIGlkZlNpZ25lZFRpbWVzdGFtcD86IHN0cmluZztcbiAgaWRmVXNlcklkPzogc3RyaW5nO1xuICBpZGZWZXJzaW9uPzogbnVtYmVyO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBbaW5kZXg6IHN0cmluZ106IHVua25vd247XG4gIHRva2VuTmFtZT86IHN0cmluZztcbiAgbm9uY2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgUHJlYnVpbGRUcmFuc2FjdGlvbk9wdGlvbnMsIFdhbGxldFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICBwcmVidWlsZFR4Pzogc3RyaW5nIHwgUHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdDtcbiAgdmVyaWZpY2F0aW9uPzogVmVyaWZpY2F0aW9uT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0IGV4dGVuZHMgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHdhbGxldElkOiBzdHJpbmc7XG4gIC8vIENvbnNvbGlkYXRlIElEIGlzIHVzZWQgZm9yIGNvbnNvbGlkYXRlIGFjY291bnQgdHJhbnNhY3Rpb25zIGFuZCBpbmRpY2F0ZXMgaWYgdGhpcyBpc1xuICAvLyBhIGNvbnNvbGlkYXRpb24gYW5kIHdoYXQgY29uc29saWRhdGUgZ3JvdXAgaXQgc2hvdWxkIGJlIHJlZmVyZW5jZWQgYnkuXG4gIGNvbnNvbGlkYXRlSWQ/OiBzdHJpbmc7XG4gIGNvbnNvbGlkYXRpb25EZXRhaWxzPzoge1xuICAgIHNlbmRlckFkZHJlc3NJbmRleDogbnVtYmVyO1xuICB9O1xuICBmZWVJbmZvPzoge1xuICAgIGZlZT86IG51bWJlcjtcbiAgICBmZWVTdHJpbmc/OiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tU2lnbmluZ0Z1bmN0aW9uIHtcbiAgKHBhcmFtczogeyBjb2luOiBCYXNlQ29pbjsgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDsgcHVicz86IHN0cmluZ1tdIH0pOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xuICB0eFByZWJ1aWxkPzogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2Pzogc3RyaW5nO1xuICBwdWJzPzogc3RyaW5nW107XG4gIGNvc2lnbmVyUHViPzogc3RyaW5nO1xuICBpc0xhc3RTaWduYXR1cmU/OiBib29sZWFuO1xuICBjdXN0b21TaWduaW5nRnVuY3Rpb24/OiBDdXN0b21TaWduaW5nRnVuY3Rpb247XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRVc2VyUHJ2T3B0aW9ucyB7XG4gIGtleWNoYWluPzogS2V5Y2hhaW47XG4gIGtleT86IEtleWNoYWluO1xuICBwcnY/OiBzdHJpbmc7XG4gIGNvbGREZXJpdmF0aW9uU2VlZD86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRDb2luU3BlY2lmaWMge1xuICB0b2tlbkZsdXNoVGhyZXNob2xkcz86IGFueTtcbiAgYWRkcmVzc1ZlcnNpb24/OiBudW1iZXI7XG4gIGJhc2VBZGRyZXNzPzogc3RyaW5nO1xuICByb290QWRkcmVzcz86IHN0cmluZztcbiAgY3VzdG9tQ2hhbmdlV2FsbGV0SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIHByZXZJZD86IHN0cmluZztcbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0VHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgUGFnaW5hdGlvbk9wdGlvbnMge1xuICB0eEhhc2g/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJzT3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgdHhIYXNoPzogc3RyaW5nO1xuICBhbGxUb2tlbnM/OiBib29sZWFuO1xuICBzZWFyY2hMYWJlbD86IHN0cmluZztcbiAgYWRkcmVzcz86IHN0cmluZ1tdIHwgc3RyaW5nO1xuICBkYXRlR3RlPzogc3RyaW5nO1xuICBkYXRlTHQ/OiBzdHJpbmc7XG4gIHZhbHVlR3RlPzogbnVtYmVyO1xuICB2YWx1ZUx0PzogbnVtYmVyO1xuICBpbmNsdWRlSGV4PzogYm9vbGVhbjtcbiAgc3RhdGU/OiBzdHJpbmdbXSB8IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRUcmFuc2Zlck9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2ZlckJ5U2VxdWVuY2VJZE9wdGlvbnMge1xuICBzZXF1ZW5jZUlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVuc3BlbnRzT3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICB0YXJnZXQ/OiBudW1iZXI7XG4gIHNlZ3dpdD86IGJvb2xlYW47XG4gIGNoYWlucz86IG51bWJlcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zIGV4dGVuZHMgV2FsbGV0U2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHhwcnY/OiBzdHJpbmc7XG4gIG1pblZhbHVlPzogbnVtYmVyO1xuICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgbWluSGVpZ2h0PzogbnVtYmVyO1xuICBudW1VbnNwZW50c1RvTWFrZT86IG51bWJlcjtcbiAgZmVlVHhDb25maXJtVGFyZ2V0PzogbnVtYmVyO1xuICBsaW1pdD86IG51bWJlcjtcbiAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IGJvb2xlYW47XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVBlcmNlbnRhZ2U/OiBudW1iZXI7XG4gIGNvbW1lbnQ/OiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgdGFyZ2V0QWRkcmVzcz86IHN0cmluZztcbiAgW2luZGV4OiBzdHJpbmddOiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZhbm91dFVuc3BlbnRzT3B0aW9ucyBleHRlbmRzIFdhbGxldFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB4cHJ2Pzogc3RyaW5nO1xuICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgbWF4VmFsdWU/OiBudW1iZXI7XG4gIG1pbkhlaWdodD86IG51bWJlcjtcbiAgbWF4TnVtSW5wdXRzVG9Vc2U/OiBudW1iZXI7XG4gIG51bVVuc3BlbnRzVG9NYWtlPzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUGVyY2VudGFnZT86IG51bWJlcjtcbiAgZmVlVHhDb25maXJtVGFyZ2V0PzogbnVtYmVyO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIHRhcmdldEFkZHJlc3M/OiBzdHJpbmc7XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTd2VlcE9wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB4cHJ2Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gIGZlZVR4Q29uZmlybVRhcmdldD86IG51bWJlcjtcbiAgYWxsb3dQYXJ0aWFsU3dlZXA/OiBib29sZWFuO1xuICBbaW5kZXg6IHN0cmluZ106IHVua25vd247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJlZXplT3B0aW9ucyB7XG4gIGR1cmF0aW9uPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVyQ29tbWVudE9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgY29tbWVudD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRyZXNzZXNPcHRpb25zIGV4dGVuZHMgUGFnaW5hdGlvbk9wdGlvbnMge1xuICBtaW5lPzogYm9vbGVhbjtcbiAgc29ydD86IG51bWJlcjtcbiAgbGFiZWxDb250YWlucz86IHN0cmluZztcbiAgc2Vnd2l0PzogYm9vbGVhbjtcbiAgY2hhaW5zPzogbnVtYmVyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0QWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveUZvcndhcmRlcnNPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmx1c2hGb3J3YXJkZXJUb2tlbk9wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgdG9rZW5OYW1lOiBzdHJpbmc7XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBlaXAxNTU5Pzoge1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBudW1iZXI7XG4gICAgbWF4RmVlUGVyR2FzOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQWRkcmVzc09wdGlvbnMge1xuICBjaGFpbj86IG51bWJlcjtcbiAgZ2FzUHJpY2U/OiBudW1iZXIgfCBzdHJpbmc7XG4gIGNvdW50PzogbnVtYmVyO1xuICBsYWJlbD86IHN0cmluZztcbiAgbG93UHJpb3JpdHk/OiBib29sZWFuO1xuICBmb3J3YXJkZXJWZXJzaW9uPzogbnVtYmVyO1xuICBmb3JtYXQ/OiAnYmFzZTU4JyB8ICdjYXNoYWRkcic7XG4gIGJhc2VBZGRyZXNzPzogc3RyaW5nO1xuICBhbGxvd1NraXBWZXJpZnlBZGRyZXNzPzogYm9vbGVhbjtcbiAgZGVyaXZlZEFkZHJlc3M/OiBzdHJpbmc7XG4gIGluZGV4PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUFkZHJlc3NPcHRpb25zIHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltdWxhdGVXZWJob29rT3B0aW9ucyB7XG4gIHdlYmhvb2tJZD86IHN0cmluZztcbiAgdHJhbnNmZXJJZD86IHN0cmluZztcbiAgcGVuZGluZ0FwcHJvdmFsSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kaWZ5V2ViaG9va09wdGlvbnMge1xuICB1cmw/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0UHJ2T3B0aW9ucyB7XG4gIHBydj86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTaGFyZU9wdGlvbnMge1xuICB1c2VyPzogc3RyaW5nO1xuICBwZXJtaXNzaW9ucz86IHN0cmluZztcbiAga2V5Y2hhaW4/OiB7XG4gICAgLy8gSW4gdGhlIGNvbnRleHQgb2Ygd2FsbGV0IHNoYXJpbmcsIHB1YiBjYW4gcmVwcmVzZW50IG9uZSBvZjpcbiAgICAvLyBwdWIgKGluZGVwZW5kYW50IG11bHRpIHNpZyksIGNvbW1vblB1YiAoYmxzKSwgb3IgY29tbW9uUHViIHBvcnRpb24gb2YgY29tbW9uS2V5Y2hhaW4gKFRTUylcbiAgICBwdWI/OiBzdHJpbmc7XG4gICAgZW5jcnlwdGVkUHJ2Pzogc3RyaW5nO1xuICAgIGZyb21QdWJLZXk/OiBzdHJpbmc7XG4gICAgdG9QdWJLZXk/OiBzdHJpbmc7XG4gICAgcGF0aD86IHN0cmluZztcbiAgfTtcbiAgcmVzaGFyZT86IGJvb2xlYW47XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGRpc2FibGVFbWFpbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhcmVXYWxsZXRPcHRpb25zIHtcbiAgZW1haWw/OiBzdHJpbmc7XG4gIHBlcm1pc3Npb25zPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICByZXNoYXJlPzogYm9vbGVhbjtcbiAgc2tpcEtleWNoYWluPzogYm9vbGVhbjtcbiAgZGlzYWJsZUVtYWlsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdmVVc2VyT3B0aW9ucyB7XG4gIHVzZXJJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY2NlbGVyYXRlVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgY3BmcFR4SWRzPzogc3RyaW5nW107XG4gIGNwZnBGZWVSYXRlPzogbnVtYmVyO1xuICBub0NwZnBGZWVSYXRlPzogYm9vbGVhbjtcbiAgbWF4RmVlPzogbnVtYmVyO1xuICBub01heEZlZT86IGJvb2xlYW47XG4gIHJlY2lwaWVudHM/OiB7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICAgIGFtb3VudDogc3RyaW5nO1xuICB9W107XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJtaXRUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBvdHA/OiBzdHJpbmc7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4Pzogc3RyaW5nOyAvLyBUcmFuc2FjdGlvbiBpbiBhbnkgZm9ybWF0IHJlcXVpcmVkIGJ5IGVhY2ggY29pbiwgaS5lLiBpbiBUcm9uIGl0IGlzIGEgc3RyaW5naWZ5ZWQgSlNPTlxuICAgIHBheWxvYWQ/OiBzdHJpbmc7XG4gICAgdHhCYXNlNjQ/OiBzdHJpbmc7XG4gIH07XG4gIGNvbW1lbnQ/OiBzdHJpbmc7XG4gIHR4UmVxdWVzdElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbmRPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgYW1vdW50PzogbnVtYmVyIHwgc3RyaW5nO1xuICBkYXRhPzogc3RyaW5nO1xuICBmZWVMaW1pdD86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgcHJ2Pzogc3RyaW5nO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgY3VzdG9kaWFuVHJhbnNhY3Rpb25JZD86IHN0cmluZztcbiAgW2luZGV4OiBzdHJpbmddOiB1bmtub3duO1xuICB0b2tlbk5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZE1hbnlPcHRpb25zIGV4dGVuZHMgUHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xuICByZWNpcGllbnRzPzoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgICBmZWVMaW1pdD86IHN0cmluZztcbiAgICBkYXRhPzogc3RyaW5nO1xuICAgIHRva2VuTmFtZT86IHN0cmluZztcbiAgfVtdO1xuICBudW1CbG9ja3M/OiBudW1iZXI7XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBib29sZWFuO1xuICB0YXJnZXRXYWxsZXRVbnNwZW50cz86IG51bWJlcjtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBzZXF1ZW5jZUlkPzogc3RyaW5nO1xuICBsYXN0TGVkZ2VyU2VxdWVuY2U/OiBudW1iZXI7XG4gIGxlZGdlclNlcXVlbmNlRGVsdGE/OiBudW1iZXI7XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBub1NwbGl0Q2hhbmdlPzogYm9vbGVhbjtcbiAgdW5zcGVudHM/OiBzdHJpbmdbXTtcbiAgY29tbWVudD86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICBjaGFuZ2VBZGRyZXNzPzogc3RyaW5nO1xuICBpbnN0YW50PzogYm9vbGVhbjtcbiAgbWVtbz86IE1lbW87XG4gIHRyYW5zZmVySWQ/OiBudW1iZXI7XG4gIFtpbmRleDogc3RyaW5nXTogdW5rbm93bjtcbn1cblxudHlwZSBXYWxsZXRUeXBlID0gJ2JhY2tpbmcnIHwgJ2NvbGQnIHwgJ2N1c3RvZGlhbCcgfCAnY3VzdG9kaWFsUGFpcmVkJyB8ICdob3QnIHwgJ3RyYWRpbmcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldERhdGEge1xuICBpZDogc3RyaW5nO1xuICBhcHByb3ZhbHNSZXF1aXJlZDogbnVtYmVyO1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIGNvbmZpcm1lZEJhbGFuY2U6IG51bWJlcjtcbiAgc3BlbmRhYmxlQmFsYW5jZTogbnVtYmVyO1xuICBiYWxhbmNlU3RyaW5nOiBzdHJpbmc7XG4gIGNvbmZpcm1lZEJhbGFuY2VTdHJpbmc6IHN0cmluZztcbiAgc3BlbmRhYmxlQmFsYW5jZVN0cmluZzogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGtleXM6IHN0cmluZ1tdO1xuICByZWNlaXZlQWRkcmVzczoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgfTtcbiAgbWlncmF0ZWRGcm9tPzogc3RyaW5nO1xuICBjb2luU3BlY2lmaWM6IFdhbGxldENvaW5TcGVjaWZpYztcbiAgcGVuZGluZ0FwcHJvdmFsczogUGVuZGluZ0FwcHJvdmFsRGF0YVtdO1xuICBlbnRlcnByaXNlOiBzdHJpbmc7XG4gIGN1c3RvbUNoYW5nZUtleVNpZ25hdHVyZXM/OiB7XG4gICAgdXNlcj86IHN0cmluZztcbiAgICBiYWNrdXA/OiBzdHJpbmc7XG4gICAgYml0Z28/OiBzdHJpbmc7XG4gIH07XG4gIG11bHRpc2lnVHlwZTogJ29uY2hhaW4nIHwgJ3Rzcyc7XG4gIHR5cGU/OiBXYWxsZXRUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJUb2tlbk9wdGlvbnMge1xuICB0b2tlbkNvbnRyYWN0QWRkcmVzcz86IHN0cmluZztcbiAgcmVjaXBpZW50Pzogc3RyaW5nO1xuICBicm9hZGNhc3Q/OiBib29sZWFuO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBwcnY/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhbmdlRmVlT3B0aW9ucyB7XG4gIHR4aWQ/OiBzdHJpbmc7XG4gIGZlZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVQb2xpY3lSdWxlT3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBjb25kaXRpb24/OiB1bmtub3duO1xuICBhY3Rpb24/OiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldFBvbGljeVJ1bGVPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGNvbmRpdGlvbj86IHVua25vd247XG4gIGFjdGlvbj86IHVua25vd247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZlUG9saWN5UnVsZU9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb3dubG9hZEtleWNhcmRPcHRpb25zIHtcbiAganNQREY/OiBhbnk7XG4gIFFSQ29kZT86IGFueTtcbiAgdXNlcktleWNoYWluPzogS2V5Y2hhaW47XG4gIGJhY2t1cEtleWNoYWluPzogS2V5Y2hhaW47XG4gIGJpdGdvS2V5Y2hhaW4/OiBLZXljaGFpbjtcbiAgcGFzc3BocmFzZT86IHN0cmluZztcbiAgcGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZztcbiAgYWN0aXZhdGlvbkNvZGU/OiBzdHJpbmc7XG4gIHdhbGxldEtleUlEPzogc3RyaW5nO1xuICBiYWNrdXBLZXlJRD86IHN0cmluZztcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG5leHBvcnQgY2xhc3MgV2FsbGV0IHtcbiAgcHVibGljIHJlYWRvbmx5IGJpdGdvOiBCaXRHbztcbiAgcHVibGljIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcbiAgcHJpdmF0ZSBfd2FsbGV0OiBXYWxsZXREYXRhO1xuICBwcml2YXRlIHJlYWRvbmx5IHRzc1V0aWxzOiBUc3NVdGlscztcbiAgcHJpdmF0ZSByZWFkb25seSBfcGVybWlzc2lvbnM/OiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbiwgd2FsbGV0RGF0YTogYW55KSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuYmFzZUNvaW4gPSBiYXNlQ29pbjtcbiAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXREYXRhO1xuICAgIGNvbnN0IHVzZXJJZCA9IF8uZ2V0KGJpdGdvLCAnX3VzZXIuaWQnKTtcbiAgICBpZiAoXy5pc1N0cmluZyh1c2VySWQpKSB7XG4gICAgICBjb25zdCB1c2VyRGV0YWlscyA9IF8uZmluZCh3YWxsZXREYXRhLnVzZXJzLCB7IHVzZXI6IHVzZXJJZCB9KTtcbiAgICAgIHRoaXMuX3Blcm1pc3Npb25zID0gXy5nZXQodXNlckRldGFpbHMsICdwZXJtaXNzaW9ucycpO1xuICAgIH1cbiAgICB0aGlzLnRzc1V0aWxzID0gbmV3IFRzc1V0aWxzKGJpdGdvLCBiYXNlQ29pbiwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBVUkwgdXNpbmcgdGhpcyB3YWxsZXQncyBpZCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgQml0R28gQVBJIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIGV4dHJhIEFQSSBzcGVjaWZpYyBzdHJpbmcgdG8gYXBwZW5kIHRvIHRoZSB3YWxsZXQgaWRcbiAgICovXG4gIHVybChleHRyYSA9ICcnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuaWQoKSArIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhpcyB3YWxsZXQncyBpZFxuICAgKi9cbiAgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyByZXF1aXJlZCBmb3Igc3BlbmRpbmcgZnVuZHMgZnJvbSB0aGlzIHdhbGxldFxuICAgKi9cbiAgYXBwcm92YWxzUmVxdWlyZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmFwcHJvdmFsc1JlcXVpcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBiYWxhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5iYWxhbmNlO1xuICB9XG5cbiAgcHJlYnVpbGRXaGl0ZWxpc3RlZFBhcmFtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdhZGRyZXNzVHlwZScsXG4gICAgICAnY2hhbmdlQWRkcmVzcycsXG4gICAgICAnY29uc29saWRhdGVBZGRyZXNzZXMnLFxuICAgICAgJ2NwZnBGZWVSYXRlJyxcbiAgICAgICdjcGZwVHhJZHMnLFxuICAgICAgJ2VuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZScsXG4gICAgICAnZmVlUmF0ZScsXG4gICAgICAnZ2FzTGltaXQnLFxuICAgICAgJ2dhc1ByaWNlJyxcbiAgICAgICdpZGZTaWduZWRUaW1lc3RhbXAnLFxuICAgICAgJ2lkZlVzZXJJZCcsXG4gICAgICAnaWRmVmVyc2lvbicsXG4gICAgICAnaW5zdGFudCcsXG4gICAgICAnbGFzdExlZGdlclNlcXVlbmNlJyxcbiAgICAgICdsZWRnZXJTZXF1ZW5jZURlbHRhJyxcbiAgICAgICdtYXhGZWUnLFxuICAgICAgJ21heEZlZVJhdGUnLFxuICAgICAgJ21heFZhbHVlJyxcbiAgICAgICdtZW1vJyxcbiAgICAgICd0cmFuc2ZlcklkJyxcbiAgICAgICdtZXNzYWdlJyxcbiAgICAgICdtaW5Db25maXJtcycsXG4gICAgICAnbWluVmFsdWUnLFxuICAgICAgJ25vU3BsaXRDaGFuZ2UnLFxuICAgICAgJ251bUJsb2NrcycsXG4gICAgICAnbm9uY2UnLFxuICAgICAgJ3JlY2lwaWVudHMnLFxuICAgICAgJ3Jlc2VydmF0aW9uJyxcbiAgICAgICdzZXF1ZW5jZUlkJyxcbiAgICAgICdzdHJhdGVneScsXG4gICAgICAndGFyZ2V0V2FsbGV0VW5zcGVudHMnLFxuICAgICAgJ3RydXN0bGluZXMnLFxuICAgICAgJ3R5cGUnLFxuICAgICAgJ3Vuc3BlbnRzJyxcbiAgICAgICdub25QYXJ0aWNpcGF0aW9uJyxcbiAgICAgICd2YWxpZEZyb21CbG9jaycsXG4gICAgICAndmFsaWRUb0Jsb2NrJyxcbiAgICAgICdtZXNzYWdlS2V5JyxcbiAgICAgICdzdGFraW5nT3B0aW9ucycsXG4gICAgICAnZWlwMTU1OScsXG4gICAgICAna2V5cmVnVHhCYXNlNjQnLFxuICAgICAgJ2Nsb3NlUmVtYWluZGVyVG8nLFxuICAgICAgJ3Rva2VuTmFtZScsXG4gICAgICAvLyBwYXJhbSB0byBzZXQgZW1lcmdlbmN5IGZsYWcgb24gYSBjdXN0b2RpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBwZXJmb3JtZWQgaW4gbGVzcyB0aGFuIDEgaG91ciBvciBpdCB3aWxsIGZhaWwuXG4gICAgICAnZW1lcmdlbmN5JyxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBzdHJpY3Qgc3ViLXNldCBvZiBwcmVidWlsZFdoaXRlbGlzdGVkUGFyYW1zXG4gICAqL1xuICBwcmVidWlsZENvbnNvbGlkYXRlQWNjb3VudFBhcmFtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsnY29uc29saWRhdGVBZGRyZXNzZXMnLCAnZmVlUmF0ZScsICdtYXhGZWVSYXRlJywgJ21lbW8nLCAndmFsaWRGcm9tQmxvY2snLCAndmFsaWRUb0Jsb2NrJ107XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb25maXJtZWQgYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKi9cbiAgY29uZmlybWVkQmFsYW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29uZmlybWVkQmFsYW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNwZW5kYWJsZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBzcGVuZGFibGVCYWxhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5zcGVuZGFibGVCYWxhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJhbGFuY2VzIGhhdmUgdGhlIHBvdGVudGlhbCB0byBvdmVyZmxvdyBzdGFuZGFyZCBqYXZhc2NyaXB0IG51bWJlcnNcbiAgICovXG4gIGJhbGFuY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmJhbGFuY2VTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25maXJtZWQgYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJhbGFuY2VzIGhhdmUgdGhlIHBvdGVudGlhbCB0byBvdmVyZmxvdyBzdGFuZGFyZCBqYXZhc2NyaXB0IG51bWJlcnNcbiAgICovXG4gIGNvbmZpcm1lZEJhbGFuY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmNvbmZpcm1lZEJhbGFuY2VTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGVuZGFibGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJhbGFuY2VzIGhhdmUgdGhlIHBvdGVudGlhbCB0byBvdmVyZmxvdyBzdGFuZGFyZCBqYXZhc2NyaXB0IG51bWJlcnNcbiAgICovXG4gIHNwZW5kYWJsZUJhbGFuY2VTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LnNwZW5kYWJsZUJhbGFuY2VTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb2luIGlkZW50aWZpZXIgZm9yIHRoZSB0eXBlIG9mIGNvaW4gdGhpcyB3YWxsZXQgaG9sZHNcbiAgICovXG4gIGNvaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYWJlbCAobmFtZSkgZm9yIHRoaXMgd2FsbGV0XG4gICAqL1xuICBwdWJsaWMgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmxhYmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljIG9iamVjdCBpZHMgZm9yIHRoZSBrZXljaGFpbnMgb24gdGhpcyB3YWxsZXQuXG4gICAqL1xuICBwdWJsaWMga2V5SWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmtleXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVjZWl2ZSBhZGRyZXNzIGZvciB0aGlzIHdhbGxldFxuICAgKi9cbiAgcHVibGljIHJlY2VpdmVBZGRyZXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5yZWNlaXZlQWRkcmVzcy5hZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2FsbGV0IGlkIG9mIHRoZSB3YWxsZXQgdGhhdCB0aGlzIHdhbGxldCB3YXMgbWlncmF0ZWQgZnJvbS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoaXMgaXMgYSBCQ0ggd2FsbGV0IHRoYXQgd2FzIGNyZWF0ZWQgZnJvbSBhIEJUQyB3YWxsZXQsXG4gICAqIHRoZSBCQ0ggd2FsbGV0IG1pZ3JhdGVkIGZyb20gZmllbGQgd291bGQgaGF2ZSB0aGUgQlRDIHdhbGxldCBpZC5cbiAgICovXG4gIHB1YmxpYyBtaWdyYXRlZEZyb20oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0Lm1pZ3JhdGVkRnJvbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRva2VuIGZsdXNoIHRocmVzaG9sZHMgZm9yIHRoaXMgd2FsbGV0XG4gICAqIEByZXR1cm4geyp8T2JqZWN0fSBwYWlycyBvZiB7IFt0b2tlbk5hbWVdOiB0aHJlc2hvbGRzIH0gYmFzZSB1bml0c1xuICAgKi9cbiAgdG9rZW5GbHVzaFRocmVzaG9sZHMoKTogYW55IHtcbiAgICBpZiAodGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSAhPT0gJ2V0aCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBmb3IgdGhpcyB3YWxsZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5jb2luU3BlY2lmaWMudG9rZW5GbHVzaFRocmVzaG9sZHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdhbGxldCBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBzcGVjaWZpYyB0byBjZXJ0YWluIGNvaW4gaW1wbGVtZW50YXRpb25zXG4gICAqL1xuICBjb2luU3BlY2lmaWMoKTogV2FsbGV0Q29pblNwZWNpZmljIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmNvaW5TcGVjaWZpYztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHBlbmRpbmcgYXBwcm92YWxzIG9uIHRoaXMgd2FsbGV0XG4gICAqL1xuICBwZW5kaW5nQXBwcm92YWxzKCk6IFBlbmRpbmdBcHByb3ZhbFtdIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LnBlbmRpbmdBcHByb3ZhbHMubWFwKChjdXJyZW50QXBwcm92YWwpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUGVuZGluZ0FwcHJvdmFsKHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIGN1cnJlbnRBcHByb3ZhbCwgdGhpcyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgd2FsbGV0IG9iamVjdCBieSBzeW5jaW5nIHdpdGggdGhlIGJhY2stZW5kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMge1dhbGxldH1cbiAgICovXG4gIGFzeW5jIHJlZnJlc2gocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8V2FsbGV0PiB7XG4gICAgdGhpcy5fd2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy51cmwoKSkucmVzdWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgdHJhbnNhY3Rpb25zIGZvciBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgdHJhbnNhY3Rpb25zKHBhcmFtczogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IFBhZ2luYXRpb25PcHRpb25zID0ge307XG5cbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5fd2FsbGV0LmlkICsgJy90eCcpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHRyYW5zYWN0aW9ucyBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgLSB0eEhhc2ggdGhlIHRyYW5zYWN0aW9uIGhhc2ggdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHBhcmFtczogR2V0VHJhbnNhY3Rpb25PcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHhIYXNoJ10sIFtdKTtcblxuICAgIGNvbnN0IHF1ZXJ5OiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucHJldklkKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLmxpbWl0KSB8fCBwYXJhbXMubGltaXQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMudXJsKCcvdHgvJyArIHBhcmFtcy50eEhhc2gpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHRyYW5zZmVycyBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIHRyYW5zZmVycyhwYXJhbXM6IFRyYW5zZmVyc09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IFRyYW5zZmVyc09wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNlYXJjaExhYmVsKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnNlYXJjaExhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VhcmNoTGFiZWwgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnNlYXJjaExhYmVsID0gcGFyYW1zLnNlYXJjaExhYmVsO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYWRkcmVzcykge1xuICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmFkZHJlc3MpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZyBvciBhcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNBcnJheShwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgICAgcGFyYW1zLmFkZHJlc3MuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MgYXJndW1lbnQsIGV4cGVjdGluZyBhcnJheSBvZiBhZGRyZXNzIHN0cmluZ3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGF0ZUd0ZSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5kYXRlR3RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0ZUd0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkuZGF0ZUd0ZSA9IHBhcmFtcy5kYXRlR3RlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGF0ZUx0KSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmRhdGVMdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGVMdCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkuZGF0ZUx0ID0gcGFyYW1zLmRhdGVMdDtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOaWwocGFyYW1zLnZhbHVlR3RlKSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy52YWx1ZUd0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbHVlR3RlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS52YWx1ZUd0ZSA9IHBhcmFtcy52YWx1ZUd0ZTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOaWwocGFyYW1zLnZhbHVlTHQpKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnZhbHVlTHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWx1ZUx0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS52YWx1ZUx0ID0gcGFyYW1zLnZhbHVlTHQ7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy5pbmNsdWRlSGV4KSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuaW5jbHVkZUhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY2x1ZGVIZXggYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5pbmNsdWRlSGV4ID0gcGFyYW1zLmluY2x1ZGVIZXg7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy5zdGF0ZSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuc3RhdGUpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5zdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nIG9yIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5zdGF0ZSkpIHtcbiAgICAgICAgcGFyYW1zLnN0YXRlLmZvckVhY2goKHN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHN0YXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlIGFyZ3VtZW50LCBleHBlY3RpbmcgYXJyYXkgb2Ygc3RhdGUgc3RyaW5ncycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBxdWVyeS5zdGF0ZSA9IHBhcmFtcy5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOaWwocGFyYW1zLnR5cGUpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS50eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvdHJhbnNmZXInKSkucXVlcnkocXVlcnkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2ZlcnMgb24gdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNmZXIocGFyYW1zOiBHZXRUcmFuc2Zlck9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvdHJhbnNmZXIvJyArIHBhcmFtcy5pZCkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRyYW5zYWN0aW9uIGJ5IHNlcXVlbmNlIGlkIGZvciBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyB0cmFuc2ZlckJ5U2VxdWVuY2VJZChwYXJhbXM6IFRyYW5zZmVyQnlTZXF1ZW5jZUlkT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3NlcXVlbmNlSWQnXSwgW10pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3RyYW5zZmVyL3NlcXVlbmNlSWQvJyArIHBhcmFtcy5zZXF1ZW5jZUlkKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIGFtb3VudCB5b3UgY2FuIHNwZW5kIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmxpbWl0IC0gbWF4aW11bSBudW1iZXIgb2Ygc2VsZWN0YWJsZSB1bnNwZW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gdGhlIG1pbmltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSB0aGUgbWF4aW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2UgaW4gc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5IZWlnaHQgLSB0aGUgbWluaW11bSBoZWlnaHQgb2YgdW5zcGVudHMgb24gdGhlIGJsb2NrIGNoYWluIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gYWxsIHNlbGVjdGVkIHVuc3BlbnRzIHdpbGwgaGF2ZSBhdCBsZWFzdCB0aGlzIG1hbnkgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgLSBFbmZvcmNlcyBtaW5Db25maXJtcyBvbiBjaGFuZ2UgaW5wdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIGZlZSByYXRlIHRvIHVzZSBpbiBjYWxjdWxhdGlvbiBvZiBtYXhpbXVtIHNwZW5kYWJsZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnJlY2lwaWVudEFkZHJlc3MgLSByZWNpcGllbnQgYWRkcmVzc2VzIGZvciBhIG1vcmUgYWNjdXJhdGUgY2FsY3VsYXRpb24gb2YgdGhlIG1heGltdW0gYXZhaWxhYmxlIHRvIHNlbmRcbiAgICogQHJldHVybnMge3ttYXhpbXVtU3BlbmRhYmxlOiBOdW1iZXIsIGNvaW46IFN0cmluZ319XG4gICAqIE5PVEUgOiBmZWVUeENvbmZpcm1UYXJnZXQgb21pdHRlZCBvbiBwdXJwb3NlIGJlY2F1c2UgZ2F1Z2luZyB0aGUgbWF4aW11bSBzcGVuZGFibGUgYW1vdW50IHdpdGggZHluYW1pYyBmZWVzIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICovXG4gIGFzeW5jIG1heGltdW1TcGVuZGFibGUocGFyYW1zOiBNYXhpbXVtU3BlbmRhYmxlT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxNYXhpbXVtU3BlbmRhYmxlPiB7XG4gICAgY29uc3QgZmlsdGVyZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAnZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlJyxcbiAgICAgICdmZWVSYXRlJyxcbiAgICAgICdsaW1pdCcsXG4gICAgICAnbWF4RmVlUmF0ZScsXG4gICAgICAnbWF4VmFsdWUnLFxuICAgICAgJ21pbkNvbmZpcm1zJyxcbiAgICAgICdtaW5IZWlnaHQnLFxuICAgICAgJ21pblZhbHVlJyxcbiAgICAgICdwbGFpblRhcmdldCcsXG4gICAgICAncmVjaXBpZW50QWRkcmVzcycsXG4gICAgICAndGFyZ2V0JyxcbiAgICBdKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL21heGltdW1TcGVuZGFibGUnKSkucXVlcnkoZmlsdGVyZWRQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHVuc3BlbnRzIGZvciBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgdW5zcGVudHMocGFyYW1zOiBVbnNwZW50c09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcXVlcnkgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAnY2hhaW5zJyxcbiAgICAgICdsaW1pdCcsXG4gICAgICAnbWF4VmFsdWUnLFxuICAgICAgJ21pbkNvbmZpcm1zJyxcbiAgICAgICdtaW5IZWlnaHQnLFxuICAgICAgJ21pblZhbHVlJyxcbiAgICAgICdwcmV2SWQnLFxuICAgICAgJ3NlZ3dpdCcsXG4gICAgICAndGFyZ2V0JyxcbiAgICBdKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3Vuc3BlbnRzJykpLnF1ZXJ5KHF1ZXJ5KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZSBvciBmYW5vdXQgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJvdXRlTmFtZSAtIGVpdGhlciBgY29uc29saWRhdGVgIG9yIGBmYW5vdXRgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKlxuICAgKiBXYWxsZXQgcGFyYW1ldGVyczpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqXG4gICAqIEZlZSBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZmVlIHJhdGUgdG8gdXNlIGZvciB0aGUgY29uc29saWRhdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSByZWxhdGl2ZSBwb3J0aW9uIHRoYXQgeW91J3JlIHdpbGxpbmcgdG8gc3BlbmQgdG93YXJkcyBmZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gZXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aCB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICpcbiAgICogSW5wdXQgcGFyYW1ldGVyczpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gaWYgdHJ1ZSwgbWluQ29uZmlybXMgYWxzbyBhcHBsaWVzIHRvIGNoYW5nZSBvdXRwdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgICAgICAgICAgICAgICAgZm9yIHJvdXRlTmFtZSA9PT0gJ2NvbnNvbGlkYXRlJ1xuICAgKiAgICAgICAgICAgICAgICAgcGFyYW1zLm1heE51bUlucHV0c1RvVXNlICAgIGZvciByb3V0ZU5hbWUgPT09ICdmYW5vdXQnXG4gICAqICAgICAgICAgICAgICAgICAgLSBtYXhpbXVtIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIE91dHB1dCBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bVVuc3BlbnRzVG9NYWtlIC0gdGhlIG51bWJlciBvZiBuZXcgdW5zcGVudHMgdG8gbWFrZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtYW5hZ2VVbnNwZW50cyhcbiAgICByb3V0ZU5hbWU6IE1hbmFnZVVuc3BlbnRzLFxuICAgIHBhcmFtczogQ29uc29saWRhdGVVbnNwZW50c09wdGlvbnMgfCBGYW5vdXRVbnNwZW50c09wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddKTtcblxuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICBjb25zdCBmaWx0ZXJlZFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFtcbiAgICAgICdmZWVSYXRlJyxcbiAgICAgICdtYXhGZWVSYXRlJyxcbiAgICAgICdtYXhGZWVQZXJjZW50YWdlJyxcbiAgICAgICdmZWVUeENvbmZpcm1UYXJnZXQnLFxuXG4gICAgICAnbWluVmFsdWUnLFxuICAgICAgJ21heFZhbHVlJyxcbiAgICAgICdtaW5IZWlnaHQnLFxuICAgICAgJ21pbkNvbmZpcm1zJyxcbiAgICAgICdlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UnLFxuICAgICAgJ3RhcmdldEFkZHJlc3MnLFxuXG4gICAgICByb3V0ZU5hbWUgPT09ICdjb25zb2xpZGF0ZScgPyAnbGltaXQnIDogJ21heE51bUlucHV0c1RvVXNlJyxcbiAgICAgICdudW1VbnNwZW50c1RvTWFrZScsXG4gICAgXSk7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMudXJsKGAvJHtyb3V0ZU5hbWV9VW5zcGVudHNgKSlcbiAgICAgIC5zZW5kKGZpbHRlcmVkUGFyYW1zKVxuICAgICAgLnJlc3VsdCgpO1xuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0gKGF3YWl0IHRoaXMuYmFzZUNvaW5cbiAgICAgIC5rZXljaGFpbnMoKVxuICAgICAgLmdldEtleXNGb3JTaWduaW5nKHsgd2FsbGV0OiB0aGlzLCByZXFJZCB9KSkgYXMgdW5rbm93biBhcyBLZXljaGFpbltdO1xuXG4gICAgY29uc3QgdHJhbnNhY3Rpb25QYXJhbXMgPSB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICB0eFByZWJ1aWxkOiByZXNwb25zZSxcbiAgICAgIGtleWNoYWluOiBrZXljaGFpbnNbMF0sXG4gICAgICBwdWJzOiBrZXljaGFpbnMubWFwKChrKSA9PiBrLnB1YiksXG4gICAgfTtcbiAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uUGFyYW1zKTtcbiAgICBjb25zdCBzZWxlY3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ2NvbW1lbnQnLCAnb3RwJ10pO1xuICAgIGNvbnN0IGZpbmFsVHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgc2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcywgeyB0eXBlOiByb3V0ZU5hbWUgfSk7XG5cbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5fd2FsbGV0LmlkICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZChmaW5hbFR4UGFyYW1zKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnNvbGlkYXRlIHVuc3BlbnRzIG9uIGEgd2FsbGV0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgLSB0aGUgdXNlcnMgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy54cHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtIGlmIHRoZSB3YWxsZXRQYXNzcGhyYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gVGhlIGZlZSByYXRlIHRvIHVzZSBmb3IgdGhlIGNvbnNvbGlkYXRpb24gaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVQZXJjZW50YWdlIC0gdGhlIG1heGltdW0gcmVsYXRpdmUgcG9ydGlvbiB0aGF0IHlvdSdyZSB3aWxsaW5nIHRvIHNwZW5kIHRvd2FyZHMgZmVlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCAtIGVzdGltYXRlIHRoZSBmZWVzIHRvIGFpbSBmb3IgZmlyc3QgY29uZmlybWF0aW9uIHdpdGggdGhpcyBudW1iZXIgb2YgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSB0aGUgbWluaW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2UgaW4gc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkhlaWdodCAtIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB1bnNwZW50cyBvbiB0aGUgYmxvY2sgY2hhaW4gdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluQ29uZmlybXMgLSBhbGwgc2VsZWN0ZWQgdW5zcGVudHMgd2lsbCBoYXZlIGF0IGxlYXN0IHRoaXMgbWFueSBjb25maXJtYXRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIGlmIHRydWUsIG1pbkNvbmZpcm1zIGFsc28gYXBwbGllcyB0byBjaGFuZ2Ugb3V0cHV0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmxpbWl0ICAgICAgICAgICAgICAgIGZvciByb3V0ZU5hbWUgPT09ICdjb25zb2xpZGF0ZSdcbiAgICogICAgICAgICAgICAgICAgIHBhcmFtcy5tYXhOdW1JbnB1dHNUb1VzZSAgICBmb3Igcm91dGVOYW1lID09PSAnZmFub3V0J1xuICAgKiAgICAgICAgICAgICAgICAgIC0gbWF4aW11bSBudW1iZXIgb2YgdW5zcGVudHMgeW91IHdhbnQgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bVVuc3BlbnRzVG9NYWtlIC0gdGhlIG51bWJlciBvZiBuZXcgdW5zcGVudHMgdG8gbWFrZVxuICAgKi9cbiAgYXN5bmMgY29uc29saWRhdGVVbnNwZW50cyhwYXJhbXM6IENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZVVuc3BlbnRzKCdjb25zb2xpZGF0ZScsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogRmFub3V0IHVuc3BlbnRzIG9uIGEgd2FsbGV0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgLSB0aGUgdXNlcnMgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy54cHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtIGlmIHRoZSB3YWxsZXRQYXNzcGhyYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVQZXJjZW50YWdlIC0gdGhlIG1heGltdW0gcHJvcG9ydGlvbiBvZiBhbiB1bnNwZW50IHlvdSBhcmUgd2lsbGluZyB0byBsb3NlIHRvIGZlZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQgLSBlc3RpbWF0ZSB0aGUgZmVlcyB0byBhaW0gZm9yIGZpcnN0IGNvbmZpcm1hdGlvbiB3aXRoIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZGVzaXJlZCBmZWUgcmF0ZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIFRoZSBtYXggbGltaXQgZm9yIGEgZmVlIHJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhOdW1JbnB1dHNUb1VzZSAtIHRoZSBudW1iZXIgb2YgdW5zcGVudHMgeW91IHdhbnQgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bVVuc3BlbnRzVG9NYWtlIC0gdGhlIG51bWJlciBvZiBuZXcgdW5zcGVudHMgdG8gbWFrZVxuICAgKi9cbiAgYXN5bmMgZmFub3V0VW5zcGVudHMocGFyYW1zOiBGYW5vdXRVbnNwZW50c09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMubWFuYWdlVW5zcGVudHMoJ2Zhbm91dCcsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0b2tlbiBmbHVzaCB0aHJlc2hvbGRzIGZvciB0aGUgd2FsbGV0LiBVcGRhdGVzIHRoZSB3YWxsZXQuXG4gICAqIFRva2VucyB3aWxsIG9ubHkgYmUgZmx1c2hlZCBmcm9tIGZvcndhcmRlciBjb250cmFjdHMgaWYgdGhlIGJhbGFuY2UgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQgZGVmaW5lZCBoZXJlLlxuICAgKiBAcGFyYW0gdGhyZXNob2xkcyB7T2JqZWN0fSAtIHBhaXJzIG9mIHsgW3Rva2VuTmFtZV06IHRocmVzaG9sZCB9IChiYXNlIHVuaXRzKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVG9rZW5GbHVzaFRocmVzaG9sZHModGhyZXNob2xkczogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICh0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnZXRoJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHdhbGxldCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wdXQodGhpcy51cmwoKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgdG9rZW5GbHVzaFRocmVzaG9sZHM6IHRocmVzaG9sZHMsXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG4gIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHdhbGxldC4gU2V0cyBmbGFncyBmb3IgZGVwbG95Rm9yd2FyZGVyc01hbnVhbGx5IGFuZCBmbHVzaEZvcndhcmRlcnNNYW51YWxseSBvZiB0aGUgd2FsbGV0LlxuICAgICAqIEBwYXJhbSBmb3J3YXJkZXJGbGFncyB7T2JqZWN0fSAtIHtcbiAgICAgICBcImNvaW5TcGVjaWZpY1wiOiB7XG4gICAgICAgICBbY29pbk5hbWVdOiB7XG4gICAgICAgICAgIFwiZGVwbG95Rm9yd2FyZGVyc01hbnVhbGx5XCI6IHtCb29sZWFufSxcbiAgICAgICAgICAgXCJmbHVzaEZvcndhcmRlcnNNYW51YWxseVwiOiB7Qm9vbGVhbn1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cbiAgICAgKi9cbiAgYXN5bmMgdXBkYXRlRm9yd2FyZGVycyhmb3J3YXJkZXJGbGFnczogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICh0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnZXRoJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHdhbGxldCcpO1xuICAgIH1cbiAgICB0aGlzLl93YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnB1dCh0aGlzLnVybCgpKS5zZW5kKGZvcndhcmRlckZsYWdzKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBtYW51YWxseSBkZXBsb3kgYW4gRVRIIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmFkZHJlc3NdIC0gYWRkcmVzc0lkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmlkXSAtIGFkZHJlc3NJZCBjb3VsZCBiZSByZWNlaXZlZCBhbHNvIGFzIGlkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEh0dHAgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIGRlcGxveUZvcndhcmRlcnMocGFyYW1zOiBEZXBsb3lGb3J3YXJkZXJzT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmFkZHJlc3MpICYmIF8uaXNVbmRlZmluZWQocGFyYW1zLmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyZXNzIG9yIGlkIG9mIGFkZHJlc3MgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChwYXJhbXMuYWRkcmVzcykge1xuICAgICAgcXVlcnkgPSBwYXJhbXMuYWRkcmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBwYXJhbXMuaWQ7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMudXJsKGAvYWRkcmVzcy8ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9L2RlcGxveW1lbnRgKTtcbiAgICB0aGlzLl93YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodXJsKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBtYW51YWxseSBmb3J3YXJkIHRva2VucyBmcm9tIGFuIEVUSCBvciBDRUxPIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudG9rZW5OYW1lIC0gTmFtZSBvZiB0b2tlbiB0aGF0IG5lZWRzIHRvIGJlIGZvcndhcmRlZCBmcm9tIHRoZSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmFkZHJlc3NdIC1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuYWRkcmVzc10gLSBhZGRyZXNzSWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuaWRdIC0gYWRkcmVzc0lkIGNvdWxkIGJlIHJlY2VpdmVkIGFsc28gYXMgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZ2FzUHJpY2VdIC0gRXhwbGljaXQgZ2FzIHByaWNlIHRvIHVzZSB3aGVuIGZvcndhcmRpbmcgdG9rZW4gZnJvbSB0aGUgZm9yd2FyZGVyIGNvbnRyYWN0IChFVEggYW5kIENlbG8gb25seSkuIElmIG5vdCBnaXZlbiwgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZXN0aW1hdGVkIG5ldHdvcmsgZ2FzIHByaWNlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5laXAxNTU5XSAtIFNwZWNpZnkgZWlwMTU1OSBmZWUgcGFyYW1ldGVycyBpbiB0b2tlbiBmb3J3YXJkaW5nIHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIdHRwIHJlc3BvbnNlXG4gICAqL1xuICBhc3luYyBmbHVzaEZvcndhcmRlclRva2VuKHBhcmFtczogRmx1c2hGb3J3YXJkZXJUb2tlbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hZGRyZXNzKSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkcmVzcyBvciBpZCBvZiBhZGRyZXNzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGxldCBxdWVyeTtcbiAgICBpZiAocGFyYW1zLmFkZHJlc3MpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLmFkZHJlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLmlkO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLnVybChgL2FkZHJlc3MvJHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfS90b2tlbmZvcndhcmRgKTtcbiAgICB0aGlzLl93YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodXJsKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2VlcCBmdW5kcyBmb3IgYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHNlbmQgYWxsIHRoZSBmdW5kcyBpbiB0aGUgd2FsbGV0IHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSB1c2VycyB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0gaWYgdGhlIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm90cCAtIFR3byBmYWN0b3IgYXV0aCBjb2RlIHRvIGVuYWJsZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCAtIEVzdGltYXRlIHRoZSBmZWVzIHRvIGFpbSBmb3IgZmlyc3QgY29uZmlybWF0aW9uIHdpdGhpbiB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gVGhlIGRlc2lyZWQgZmVlIHJhdGUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhGZWVSYXRlXSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5hbGxvd1BhcnRpYWxTd2VlcF0gLSBhbGxvd3Mgc3dlZXBpbmcgMjAwIHVuc3BlbnRzIHdoZW4gdGhlIHdhbGxldCBoYXMgbW9yZSB0aGFuIHRoYXRcbiAgICogQHJldHVybnMgdHhIZXgge1N0cmluZ30gdGhlIHR4SGV4IG9mIHRoZSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIHN3ZWVwKHBhcmFtczogU3dlZXBPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnLCAnb3RwJ10pO1xuXG4gICAgLy8gVGhlIHN3ZWVwIEFQSSBlbmRwb2ludCBpcyBvbmx5IGF2YWlsYWJsZSB0byB1dHhvLWJhc2VkIGNvaW5zXG5cbiAgICBpZiAoIXRoaXMuYmFzZUNvaW4uc3dlZXBXaXRoU2VuZE1hbnkoKSkge1xuICAgICAgaWYgKHRoaXMuY29uZmlybWVkQmFsYW5jZVN0cmluZygpICE9PSB0aGlzLmJhbGFuY2VTdHJpbmcoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBzd2VlcCB3aGVuIHVuY29uZmlybWVkIGZ1bmRzIGV4aXN0IG9uIHRoZSB3YWxsZXQsIHBsZWFzZSB3YWl0IHVudGlsIGFsbCBpbmJvdW5kIHRyYW5zYWN0aW9ucyBjb25maXJtJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3BlbmRhYmxlQmFsYW5jZVN0cmluZygpO1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBmdW5kcyB0byBzd2VlcCcpO1xuICAgICAgfVxuICAgICAgKHBhcmFtcyBhcyBhbnkpLnJlY2lwaWVudHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IHZhbHVlLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2VuZE1hbnkocGFyYW1zKTtcbiAgICB9XG4gICAgLy8gdGhlIGZvbGxvd2luZyBmbG93IHdvcmtzIGZvciBhbGwgVVRYTyBjb2luc1xuXG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgW1xuICAgICAgJ2FkZHJlc3MnLFxuICAgICAgJ2ZlZVJhdGUnLFxuICAgICAgJ21heEZlZVJhdGUnLFxuICAgICAgJ2ZlZVR4Q29uZmlybVRhcmdldCcsXG4gICAgICAnYWxsb3dQYXJ0aWFsU3dlZXAnLFxuICAgIF0pO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy9zd2VlcFdhbGxldCcpKS5zZW5kKGZpbHRlcmVkUGFyYW1zKS5yZXN1bHQoKTtcblxuICAgIC8vIFRPRE8oQkctMzU4OCk6IGFkZCB0eEhleCB2YWxpZGF0aW9uIHRvIHByb3RlY3QgbWFuIGluIHRoZSBtaWRkbGUgYXR0YWNrcyByZXBsYWNpbmcgdGhlIHR4SGV4XG5cbiAgICBjb25zdCBrZXljaGFpbnMgPSAoYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXRLZXlzRm9yU2lnbmluZyh7IHdhbGxldDogdGhpcywgcmVxSWQgfSkpIGFzIGFueTtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uUGFyYW1zID0ge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgdHhQcmVidWlsZDogcmVzcG9uc2UsXG4gICAgICBrZXljaGFpbjoga2V5Y2hhaW5zWzBdLFxuICAgICAgdXNlcktleWNoYWluOiBrZXljaGFpbnNbMF0sXG4gICAgICBiYWNrdXBLZXljaGFpbjoga2V5Y2hhaW5zLmxlbmd0aCA+IDEgPyBrZXljaGFpbnNbMV0gOiBudWxsLFxuICAgICAgYml0Z29LZXljaGFpbjoga2V5Y2hhaW5zLmxlbmd0aCA+IDIgPyBrZXljaGFpbnNbMl0gOiBudWxsLFxuICAgICAgcHJ2OiBwYXJhbXMueHBydixcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25QYXJhbXMpO1xuXG4gICAgY29uc3Qgc2VsZWN0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydvdHAnXSk7XG4gICAgY29uc3QgZmluYWxUeFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBzaWduZWRUcmFuc2FjdGlvbiwgc2VsZWN0UGFyYW1zKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5fd2FsbGV0LmlkICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZChmaW5hbFR4UGFyYW1zKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyZWV6ZSBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZnJlZXplKHBhcmFtczogRnJlZXplT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10pO1xuXG4gICAgaWYgKHBhcmFtcy5kdXJhdGlvbikge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGR1cmF0aW9uOiBzaG91bGQgYmUgbnVtYmVyIG9mIHNlY29uZHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvZnJlZXplJykpLnNlbmQocGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY29tbWVudCBvZiBhIHRyYW5zZmVyXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyB0cmFuc2ZlckNvbW1lbnQocGFyYW1zOiBUcmFuc2ZlckNvbW1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgWydjb21tZW50J10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLl93YWxsZXQuaWQgKyAnL3RyYW5zZmVyLycgKyBwYXJhbXMuaWQgKyAnL2NvbW1lbnQnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSBhZGRyZXNzZXMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBhZGRyZXNzZXMocGFyYW1zOiBBZGRyZXNzZXNPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSk7XG5cbiAgICBjb25zdCBxdWVyeTogQWRkcmVzc2VzT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5taW5lKSB7XG4gICAgICBxdWVyeS5taW5lID0gISFwYXJhbXMubWluZTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc29ydCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5zb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc29ydCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuc29ydCA9IHBhcmFtcy5zb3J0O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5sYWJlbENvbnRhaW5zKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmxhYmVsQ29udGFpbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsYWJlbENvbnRhaW5zIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5sYWJlbENvbnRhaW5zID0gcGFyYW1zLmxhYmVsQ29udGFpbnM7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zZWd3aXQpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5zZWd3aXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZWd3aXQgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5zZWd3aXQgPSBwYXJhbXMuc2Vnd2l0O1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuY2hhaW5zKSkge1xuICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmNoYWlucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNoYWlucyBhcmd1bWVudCwgZXhwZWN0aW5nIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmNoYWlucyA9IHBhcmFtcy5jaGFpbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuX3dhbGxldC5pZCArICcvYWRkcmVzc2VzJykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIHdhbGxldCBhZGRyZXNzIGJ5IGl0cyBpZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzcyhwYXJhbXM6IEdldEFkZHJlc3NPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ2FkZHJlc3MnLCAnaWQnXSk7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hZGRyZXNzKSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkcmVzcyBvciBpZCBvZiBhZGRyZXNzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuYWRkcmVzcykge1xuICAgICAgcXVlcnkgPSBwYXJhbXMuYWRkcmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBwYXJhbXMuaWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5nZXQodGhpcy5iYXNlQ29pbi51cmwoYC93YWxsZXQvJHt0aGlzLl93YWxsZXQuaWR9L2FkZHJlc3MvJHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfWApKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBvbmUgb3IgbW9yZSBuZXcgYWRkcmVzcyhlcykgZm9yIHVzZSB3aXRoIHRoaXMgd2FsbGV0LlxuICAgKlxuICAgKiBJZiB0aGUgYGNvdW50YCBmaWVsZCBpcyBkZWZpbmVkIGFuZCBncmVhdGVyIHRoYW4gMSwgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICogYXJyYXkgcHJvcGVydHkgbmFtZWQgYGFkZHJlc3Nlc2AgY29udGFpbmluZyBgY291bnRgIGFkZHJlc3Mgb2JqZWN0c1xuICAgKiB3aWxsIGJlIHJldHVybmVkLiBPdGhlcndpc2UsIGEgc2luZ2xlIGFkZHJlc3Mgb2JqZWN0IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuY2hhaW4gb24gd2hpY2ggdGhlIG5ldyBhZGRyZXNzIHNob3VsZCBiZSBjcmVhdGVkXG4gICAqIEBwYXJhbSB7KE51bWJlcnxTdHJpbmcpfSBwYXJhbXMuZ2FzUHJpY2UgZ2FzIHByaWNlIGZvciBuZXcgYWRkcmVzcyBjcmVhdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmxhYmVsIGxhYmVsIGZvciB0aGUgbmV3IGFkZHJlc3MoZXMpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubGFiZWwgbGFiZWwgZm9yIHRoZSBuZXcgYWRkcmVzcyhlcylcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5jb3VudD0xIG51bWJlciBvZiBuZXcgYWRkcmVzc2VzIHdoaWNoIHNob3VsZCBiZSBjcmVhdGVkIChtYXhpbXVtIDI1MClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mb3J3YXJkZXJWZXJzaW9uIFRoZSB2ZXJzaW9uIG9mIGFkZHJlc3MgdG8gY3JlYXRlLCBpZiBhcHBsaWNhYmxlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmxvd1ByaW9yaXR5IEV0aGVyZXVtLXNwZWNpZmljIHBhcmFtIHRvIGNyZWF0ZSBhZGRyZXNzIHVzaW5nIGxvdyBwcmlvcml0eSBmZWUgYWRkcmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmJhc2VBZGRyZXNzIGJhc2UgYWRkcmVzcyBvZiB0aGUgd2FsbGV0KG9wdGlvbmFsIHBhcmFtZXRlcilcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuYWxsb3dTa2lwVmVyaWZ5QWRkcmVzcyBXaGVuIHNldCB0byBmYWxzZSwgaXQgdGhyb3dzIGVycm9yIGlmIGFkZHJlc3MgdmVyaWZpY2F0aW9uIGlzIHNraXBwZWQgZm9yIGFueSByZWFzb24uIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZGVyaXZlZEFkZHJlc3NdICBEZXJpdmVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuaW5kZXhdIEluZGV4IG9mIHRoZSBkZXJpdmVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucGFzc3BocmFzZV0gcGFzc3BocmFzZVxuICAgKiBBZGRyZXNzIHZlcmlmaWNhdGlvbiBjYW4gYmUgc2tpcHBlZCB3aGVuIGZvcndhcmRlclZlcnNpb24gaXMgMCBhbmQgcGVuZGluZ0NoYWluSW5pdGlhbGl6YXRpb24gaXMgdHJ1ZSBPUlxuICAgKiBpZiAnY29pblNwZWNpZmljJyBpcyBub3QgcGFydCBvZiB0aGUgcmVzcG9uc2UgZnJvbSBhcGkgY2FsbCB0byBjcmVhdGUgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWRkcmVzcyhwYXJhbXM6IENyZWF0ZUFkZHJlc3NPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGFkZHJlc3NQYXJhbXM6IENyZWF0ZUFkZHJlc3NPcHRpb25zID0ge307XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuXG4gICAgY29uc3Qge1xuICAgICAgY2hhaW4sXG4gICAgICBnYXNQcmljZSxcbiAgICAgIGxhYmVsLFxuICAgICAgbG93UHJpb3JpdHksXG4gICAgICBmb3J3YXJkZXJWZXJzaW9uLFxuICAgICAgZm9ybWF0LFxuICAgICAgY291bnQgPSAxLFxuICAgICAgYmFzZUFkZHJlc3MsXG4gICAgICBhbGxvd1NraXBWZXJpZnlBZGRyZXNzID0gdHJ1ZSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNoYWluKSkge1xuICAgICAgaWYgKCFfLmlzSW50ZWdlcihjaGFpbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFpbiBoYXMgdG8gYmUgYW4gaW50ZWdlcicpO1xuICAgICAgfVxuICAgICAgYWRkcmVzc1BhcmFtcy5jaGFpbiA9IGNoYWluO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChnYXNQcmljZSkpIHtcbiAgICAgIGlmICghXy5pc0ludGVnZXIoZ2FzUHJpY2UpICYmIChpc05hTihOdW1iZXIoZ2FzUHJpY2UpKSB8fCAhXy5pc1N0cmluZyhnYXNQcmljZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2FzUHJpY2UgaGFzIHRvIGJlIGFuIGludGVnZXIgb3IgbnVtZXJpYyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGFkZHJlc3NQYXJhbXMuZ2FzUHJpY2UgPSBnYXNQcmljZTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZm9yd2FyZGVyVmVyc2lvbikpIHtcbiAgICAgIGlmICghXy5pc0ludGVnZXIoZm9yd2FyZGVyVmVyc2lvbikgfHwgZm9yd2FyZGVyVmVyc2lvbiA8IDAgfHwgZm9yd2FyZGVyVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3J3YXJkZXJWZXJzaW9uIGhhcyB0byBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgfVxuICAgICAgYWRkcmVzc1BhcmFtcy5mb3J3YXJkZXJWZXJzaW9uID0gZm9yd2FyZGVyVmVyc2lvbjtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQobGFiZWwpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcobGFiZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWwgaGFzIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBhZGRyZXNzUGFyYW1zLmxhYmVsID0gbGFiZWw7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGJhc2VBZGRyZXNzKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKGJhc2VBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2VBZGRyZXNzIGhhcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChhbGxvd1NraXBWZXJpZnlBZGRyZXNzKSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihhbGxvd1NraXBWZXJpZnlBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FsbG93U2tpcFZlcmlmeUFkZHJlc3MgaGFzIHRvIGJlIGEgYm9vbGVhbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc0ludGVnZXIoY291bnQpIHx8IGNvdW50IDw9IDAgfHwgY291bnQgPiAyNTApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bnQgaGFzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMjUwJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGxvd1ByaW9yaXR5KSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihsb3dQcmlvcml0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb3dQcmlvcml0eSBoYXMgdG8gYmUgYSBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBhZGRyZXNzUGFyYW1zLmxvd1ByaW9yaXR5ID0gbG93UHJpb3JpdHk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGZvcm1hdCkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhmb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IGhhcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgYWRkcmVzc1BhcmFtcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGtleWNoYWlucyBmb3IgYWRkcmVzcyB2ZXJpZmljYXRpb25cbiAgICBjb25zdCBrZXljaGFpbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl93YWxsZXQua2V5cy5tYXAoKGspID0+IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IGssIHJlcUlkIH0pKSk7XG4gICAgY29uc3Qgcm9vdEFkZHJlc3MgPSBfLmdldCh0aGlzLl93YWxsZXQsICdyZWNlaXZlQWRkcmVzcy5hZGRyZXNzJyk7XG5cbiAgICBjb25zdCBuZXdBZGRyZXNzZXMgPSBfLnRpbWVzKGNvdW50LCBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgY29uc3QgbmV3QWRkcmVzcyA9IChhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLl93YWxsZXQuaWQgKyAnL2FkZHJlc3MnKSlcbiAgICAgICAgLnNlbmQoYWRkcmVzc1BhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpKSBhcyBhbnk7XG5cbiAgICAgIC8vIGluZmVyIGl0cyBhZGRyZXNzIHR5cGVcbiAgICAgIGlmIChfLmlzT2JqZWN0KG5ld0FkZHJlc3MuY29pblNwZWNpZmljKSkge1xuICAgICAgICAvLyBuZWVkIGR5bmFtaWMgaW1wb3J0IHRvIGJyZWFrIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHRoaXMgaXMgdWdseVxuICAgICAgICBjb25zdCB7IEFic3RyYWN0VXR4b0NvaW4gfSA9IHJlcXVpcmUoJy4vY29pbnMvYWJzdHJhY3RVdHhvQ29pbicpO1xuICAgICAgICBuZXdBZGRyZXNzLmFkZHJlc3NUeXBlID0gQWJzdHJhY3RVdHhvQ29pbi5pbmZlckFkZHJlc3NUeXBlKG5ld0FkZHJlc3MpO1xuICAgICAgfVxuXG4gICAgICBuZXdBZGRyZXNzLmtleWNoYWlucyA9IGtleWNoYWlucztcbiAgICAgIG5ld0FkZHJlc3MuYmFzZUFkZHJlc3MgPSBiYXNlQWRkcmVzcyA/PyBfLmdldCh0aGlzLl93YWxsZXQsICdjb2luU3BlY2lmaWMuYmFzZUFkZHJlc3MnKTtcblxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uRGF0YTogVmVyaWZ5QWRkcmVzc09wdGlvbnMgPSBfLm1lcmdlKHt9LCBuZXdBZGRyZXNzLCB7IHJvb3RBZGRyZXNzIH0pO1xuXG4gICAgICBpZiAodmVyaWZpY2F0aW9uRGF0YS5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQWRkcmVzc0dlbmVyYXRpb25FcnJvcih2ZXJpZmljYXRpb25EYXRhLmVycm9yKTtcbiAgICAgIH1cblxuICAgICAgdmVyaWZpY2F0aW9uRGF0YS5pbXBsaWVkRm9yd2FyZGVyVmVyc2lvbiA9IGZvcndhcmRlclZlcnNpb24gPz8gdmVyaWZpY2F0aW9uRGF0YS5jb2luU3BlY2lmaWM/LmZvcndhcmRlclZlcnNpb247XG4gICAgICAvLyBUaGlzIGNvbmRpdGlvbiB3YXMgYWRkZWQgaW4gZmlyc3QgcGxhY2UgYmVjYXVzZSBpbiBjZWxvLCB3aGVuIHZlcmlmeUFkZHJlc3MgbWV0aG9kIHdhcyBjYWxsZWQgb24gYWRkcmVzc2VzIHdoaWNoIHdlcmUgaGF2aW5nIHBlbmRpbmdDaGFpbkluaXRpYWxpemF0aW9uIGFzIHRydWUsIGl0IHVzZWQgdG8gdGhyb3cgc29tZSBlcnJvclxuICAgICAgLy8gSW4gY2FzZSBvZiBmb3J3YXJkZXIgdmVyc2lvbiAxIGV0aCBhZGRyZXNzZXMsIGFkZHJlc3NlcyBuZWVkIHRvIGJlIHZlcmlmaWVkIGV2ZW4gaWYgdGhlIHBlbmRpbmdDaGFpbkluaXRpYWxpemF0aW9uIGZsYWcgaXMgdHJ1ZVxuICAgICAgaWYgKFxuICAgICAgICB2ZXJpZmljYXRpb25EYXRhLmNvaW5TcGVjaWZpYyAmJlxuICAgICAgICAoIXZlcmlmaWNhdGlvbkRhdGEuY29pblNwZWNpZmljLnBlbmRpbmdDaGFpbkluaXRpYWxpemF0aW9uIHx8IHZlcmlmaWNhdGlvbkRhdGEuaW1wbGllZEZvcndhcmRlclZlcnNpb24gPT09IDEpXG4gICAgICApIHtcbiAgICAgICAgLy8gY2FuJ3QgdmVyaWZ5IGFkZHJlc3NlcyB3aGljaCBhcmUgcGVuZGluZyBjaGFpbiBpbml0aWFsaXphdGlvbiwgYXMgdGhlIGFkZHJlc3MgaXMgaGlkZGVuXG4gICAgICAgIGxldCBpc1dhbGxldEFkZHJlc3MgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpc1dhbGxldEFkZHJlc3MgPSB0aGlzLmJhc2VDb2luLmlzV2FsbGV0QWRkcmVzcyh2ZXJpZmljYXRpb25EYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRklYTUUoQkctNDMyMjUpOiBpbXBsZW1lbnQgdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgICBpc1dhbGxldEFkZHJlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNXYWxsZXRBZGRyZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgYSB3YWxsZXQgYWRkcmVzc2ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd1NraXBWZXJpZnlBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWRkcmVzcyB2ZXJpZmljYXRpb24gc2tpcHBlZCBmb3IgY291bnQgPSAke2NvdW50fWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3QWRkcmVzcztcbiAgICB9KTtcblxuICAgIGlmIChuZXdBZGRyZXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3QWRkcmVzc2VzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzZXM6IGF3YWl0IFByb21pc2UuYWxsKG5ld0FkZHJlc3NlcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcHJvcGVydGllcyBvbiBhbiBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyB1cGRhdGVBZGRyZXNzKHBhcmFtczogVXBkYXRlQWRkcmVzc09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuXG4gICAgaWYgKCFfLmlzU3RyaW5nKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHV0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydsYWJlbCddKTtcbiAgICBjb25zdCB1cmwgPSB0aGlzLnVybCgnL2FkZHJlc3MvJyArIGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzKSk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wdXQodXJsKS5zZW5kKHB1dFBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB3ZWJob29rcyBvbiB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBsaXN0V2ViaG9va3MocGFyYW1zOiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy93ZWJob29rcycpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgd2FsbGV0IHdlYmhvb2ssIGN1cnJlbnRseSBmb3Igd2ViaG9va3Mgb2YgdHlwZSB0cmFuc2ZlciBhbmQgcGVuZGluZyBhcHByb3ZhbFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gd2ViaG9va0lkIChyZXF1aXJlZCkgaWQgb2YgdGhlIHdlYmhvb2sgdG8gYmUgc2ltdWxhdGVkXG4gICAqIC0gdHJhbnNmZXJJZCAob3B0aW9uYWwgYnV0IHJlcXVpcmVkIGZvciB0cmFuc2ZlciB3ZWJob29rcykgaWQgb2YgdGhlIHNpbXVsYXRlZCB0cmFuc2ZlclxuICAgKiAtIHBlbmRpbmdBcHByb3ZhbElkIChvcHRpb25hbCBidXQgcmVxdWlyZWQgZm9yIHBlbmRpbmcgYXBwcm92YWwgd2ViaG9va3MpIGlkIG9mIHRoZSBzaW11bGF0ZWQgcGVuZGluZyBhcHByb3ZhbFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlV2ViaG9vayhwYXJhbXM6IFNpbXVsYXRlV2ViaG9va09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3ZWJob29rSWQnXSwgWyd0cmFuc2ZlcklkJywgJ3BlbmRpbmdBcHByb3ZhbElkJ10pO1xuXG4gICAgY29uc3QgaGFzVHJhbnNmZXJJZCA9ICEhcGFyYW1zLnRyYW5zZmVySWQ7XG4gICAgY29uc3QgaGFzUGVuZGluZ0FwcHJvdmFsSWQgPSAhIXBhcmFtcy5wZW5kaW5nQXBwcm92YWxJZDtcbiAgICBpZiAoIWhhc1RyYW5zZmVySWQgJiYgIWhhc1BlbmRpbmdBcHByb3ZhbElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGVpdGhlciB0cmFuc2ZlcklkIG9yIHBlbmRpbmdBcHByb3ZhbElkJyk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1RyYW5zZmVySWQgJiYgaGFzUGVuZGluZ0FwcHJvdmFsSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgZWl0aGVyIHRyYW5zZmVySWQgb3IgcGVuZGluZ0FwcHJvdmFsSWQsIGJ1dCBub3QgYm90aCcpO1xuICAgIH1cblxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgY29pbiB0eXBlIG9mIHRoZSB3YWxsZXQsIHRoZSB0eEhhc2ggaGFzIHRvIGFkaGVyZSB0byBpdHMgcmVzcGVjdGl2ZSBmb3JtYXRcbiAgICAvLyBidXQgdGhlIHNlcnZlciB0YWtlcyBjYXJlIG9mIHRoYXRcblxuICAgIC8vIG9ubHkgdGFrZSB0aGUgdHJhbnNmZXJJZCBhbmQgcGVuZGluZ0FwcHJvdmFsSWQgcHJvcGVydGllc1xuICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgWyd0cmFuc2ZlcklkJywgJ3BlbmRpbmdBcHByb3ZhbElkJ10pO1xuXG4gICAgY29uc3Qgd2ViaG9va0lkID0gcGFyYW1zLndlYmhvb2tJZDtcbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy51cmwoJy93ZWJob29rcy8nICsgd2ViaG9va0lkICsgJy9zaW11bGF0ZScpKVxuICAgICAgLnNlbmQoZmlsdGVyZWRQYXJhbXMpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgd2ViaG9vayB0byB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBhZGRXZWJob29rKHBhcmFtczogTW9kaWZ5V2ViaG9va09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnLCAndHlwZSddLCBbXSk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHdlYmhvb2sgZnJvbSB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZW1vdmVXZWJob29rKHBhcmFtczogTW9kaWZ5V2ViaG9va09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnLCAndHlwZSddLCBbXSk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy93ZWJob29rcycpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlciBrZXkgY2hhaW4gZm9yIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoZSB1c2VyIGtleSBjaGFpbiBpcyB0aGUgZmlyc3Qga2V5Y2hhaW4gb2YgdGhlIHdhbGxldCBhbmQgdXN1YWxseSBoYXMgdGhlIGVuY3J5cHRlZCBwcnYgc3RvcmVkIG9uIEJpdEdvLlxuICAgKiBVc2VmdWwgd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSB1c2Vycycga2V5Y2hhaW4gZnJvbSB0aGUgc2VydmVyIGJlZm9yZSBkZWNyeXB0aW5nIHRvIHNpZ24gYSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluKHBhcmFtczogUmVjb3JkPHN0cmluZywgbmV2ZXI+ID0ge30pOiBQcm9taXNlPHsgZW5jcnlwdGVkUHJ2OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IHRyeUtleUNoYWluID0gYXN5bmMgKGluZGV4OiBudW1iZXIpOiBQcm9taXNlPHsgZW5jcnlwdGVkUHJ2OiBzdHJpbmcgfT4gPT4ge1xuICAgICAgaWYgKCF0aGlzLl93YWxsZXQua2V5cyB8fCBpbmRleCA+PSB0aGlzLl93YWxsZXQua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbmNyeXB0ZWQga2V5Y2hhaW5zIG9uIHRoaXMgd2FsbGV0LicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXMgPSB7IGlkOiB0aGlzLl93YWxsZXQua2V5c1tpbmRleF0gfTtcblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmdldChwYXJhbXMpO1xuICAgICAgLy8gSWYgd2UgZmluZCB0aGUgcHJ2LCB0aGVuIHRoaXMgaXMgcHJvYmFibHkgdGhlIHVzZXIga2V5Y2hhaW4gd2UncmUgbG9va2luZyBmb3JcbiAgICAgIGlmIChrZXljaGFpbi5lbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgcmV0dXJuIGtleWNoYWluIGFzIHsgZW5jcnlwdGVkUHJ2OiBzdHJpbmcgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnlLZXlDaGFpbihpbmRleCArIDEpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdHJ5S2V5Q2hhaW4oMCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW5lbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZm9yIHRoaXMgd2FsbGV0IChiZSBjYXJlZnVsISlcbiAgICogUmVxdWlyZXMgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZ2V0UHJ2KHBhcmFtczogR2V0UHJ2T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3BydiddKTtcblxuICAgIC8vIFByZXBhcmUgc2lnbmluZyBrZXlcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucHJ2KSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGVpdGhlciBwcm92aWRlIHBydiBvciB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucHJ2KSAmJiAhXy5pc1N0cmluZyhwYXJhbXMucHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcnYgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkgJiYgIV8uaXNTdHJpbmcocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldFBhc3NwaHJhc2UgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucHJ2KSB7XG4gICAgICByZXR1cm4gcGFyYW1zLnBydjtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSAoYXdhaXQgdGhpcy5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4oKSkgYXMgYW55O1xuICAgIGNvbnN0IHVzZXJFbmNyeXB0ZWRQcnYgPSB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuXG4gICAgbGV0IHVzZXJQcnY7XG4gICAgdHJ5IHtcbiAgICAgIHVzZXJQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogdXNlckVuY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgZGVjcnlwdGluZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VyUHJ2O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYW4gZW5jcnlwdGVkIHdhbGxldCBzaGFyZSB0byBCaXRHby5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2hhcmUocGFyYW1zOiBDcmVhdGVTaGFyZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1c2VyJywgJ3Blcm1pc3Npb25zJ10sIFtdKTtcblxuICAgIGlmIChwYXJhbXMua2V5Y2hhaW4gJiYgIV8uaXNFbXB0eShwYXJhbXMua2V5Y2hhaW4pKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFwYXJhbXMua2V5Y2hhaW4ucHViIHx8XG4gICAgICAgICFwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2IHx8XG4gICAgICAgICFwYXJhbXMua2V5Y2hhaW4uZnJvbVB1YktleSB8fFxuICAgICAgICAhcGFyYW1zLmtleWNoYWluLnRvUHViS2V5IHx8XG4gICAgICAgICFwYXJhbXMua2V5Y2hhaW4ucGF0aFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMga2V5Y2hhaW4gcGFyYW1ldGVycyAtIHB1YiwgZW5jcnlwdGVkUHJ2LCBmcm9tUHViS2V5LCB0b1B1YktleSwgcGF0aCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy9zaGFyZScpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2hhcmUgdGhpcyB3YWxsZXQgd2l0aCBhbm90aGVyIEJpdEdvIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBzaGFyZVdhbGxldChwYXJhbXM6IFNoYXJlV2FsbGV0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2VtYWlsJywgJ3Blcm1pc3Npb25zJ10sIFsnd2FsbGV0UGFzc3BocmFzZScsICdtZXNzYWdlJ10pO1xuXG4gICAgaWYgKHBhcmFtcy5yZXNoYXJlICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5yZXNoYXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNoYXJlIHRvIGJlIGEgYm9vbGVhbi4nKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNraXBLZXljaGFpbiAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuc2tpcEtleWNoYWluKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwS2V5Y2hhaW4gdG8gYmUgYSBib29sZWFuLiAnKTtcbiAgICB9XG4gICAgY29uc3QgbmVlZHNLZXljaGFpbiA9ICFwYXJhbXMuc2tpcEtleWNoYWluICYmIHBhcmFtcy5wZXJtaXNzaW9ucyAmJiBwYXJhbXMucGVybWlzc2lvbnMuaW5kZXhPZignc3BlbmQnKSAhPT0gLTE7XG5cbiAgICBpZiAocGFyYW1zLmRpc2FibGVFbWFpbCAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZUVtYWlsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkaXNhYmxlRW1haWwgdG8gYmUgYSBib29sZWFuLicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuZW1haWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBlbWFpbCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYXJpbmcgPSAoYXdhaXQgdGhpcy5iaXRnby5nZXRTaGFyaW5nS2V5KHsgZW1haWw6IHBhcmFtcy5lbWFpbC50b0xvd2VyQ2FzZSgpIH0pKSBhcyBhbnk7XG4gICAgbGV0IHNoYXJlZEtleWNoYWluO1xuICAgIGlmIChuZWVkc0tleWNoYWluKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXljaGFpbiA9IChhd2FpdCB0aGlzLmdldEVuY3J5cHRlZFVzZXJLZXljaGFpbih7fSkpIGFzIGFueTtcbiAgICAgICAgLy8gRGVjcnlwdCB0aGUgdXNlciBrZXkgd2l0aCBhIHBhc3NwaHJhc2VcbiAgICAgICAgaWYgKGtleWNoYWluLmVuY3J5cHRlZFBydikge1xuICAgICAgICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB3YWxsZXRQYXNzcGhyYXNlIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXljaGFpbi5wcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsIGlucHV0OiBrZXljaGFpbi5lbmNyeXB0ZWRQcnYgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCB1c2VyIGtleWNoYWluJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZWNrZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gICAgICAgICAgY29uc3Qgc2VjcmV0ID0gZ2V0U2hhcmVkU2VjcmV0KGVja2V5LCBCdWZmZXIuZnJvbShzaGFyaW5nLnB1YmtleSwgJ2hleCcpKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgY29uc3QgbmV3RW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHsgcGFzc3dvcmQ6IHNlY3JldCwgaW5wdXQ6IGtleWNoYWluLnBydiB9KTtcbiAgICAgICAgICAvLyBPbmx5IG9uZSBvZiBwdWIvY29tbW9uUHViL2NvbW1vbktleWNoYWluIHNob3VsZCBiZSBwcmVzZW50IGluIHRoZSBrZXljaGFpblxuICAgICAgICAgIGxldCBwdWIgPSBrZXljaGFpbi5wdWIgPz8ga2V5Y2hhaW4uY29tbW9uUHViO1xuICAgICAgICAgIGlmIChrZXljaGFpbi5jb21tb25LZXljaGFpbikge1xuICAgICAgICAgICAgcHViID0gVHNzVXRpbHMuZ2V0UHVibGljS2V5RnJvbUNvbW1vbktleWNoYWluKGtleWNoYWluLmNvbW1vbktleWNoYWluKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2hhcmVkS2V5Y2hhaW4gPSB7XG4gICAgICAgICAgICBwdWIsXG4gICAgICAgICAgICBlbmNyeXB0ZWRQcnY6IG5ld0VuY3J5cHRlZFBydixcbiAgICAgICAgICAgIGZyb21QdWJLZXk6IGVja2V5LnB1YmxpY0tleS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICB0b1B1YktleTogc2hhcmluZy5wdWJrZXksXG4gICAgICAgICAgICBwYXRoOiBzaGFyaW5nLnBhdGgsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5tZXNzYWdlID09PSAnTm8gZW5jcnlwdGVkIGtleWNoYWlucyBvbiB0aGlzIHdhbGxldC4nKSB7XG4gICAgICAgICAgc2hhcmVkS2V5Y2hhaW4gPSB7fTtcbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHRoaXMgbG9va3MgbGlrZSBhIGNvbGQgd2FsbGV0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnM6IENyZWF0ZVNoYXJlT3B0aW9ucyA9IHtcbiAgICAgIHVzZXI6IHNoYXJpbmcudXNlcklkLFxuICAgICAgcGVybWlzc2lvbnM6IHBhcmFtcy5wZXJtaXNzaW9ucyxcbiAgICAgIHJlc2hhcmU6IHBhcmFtcy5yZXNoYXJlLFxuICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG4gICAgICBkaXNhYmxlRW1haWw6IHBhcmFtcy5kaXNhYmxlRW1haWwsXG4gICAgfTtcblxuICAgIGlmIChzaGFyZWRLZXljaGFpbikge1xuICAgICAgb3B0aW9ucy5rZXljaGFpbiA9IHNoYXJlZEtleWNoYWluO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnNraXBLZXljaGFpbikge1xuICAgICAgb3B0aW9ucy5rZXljaGFpbiA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZVNoYXJlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1c2VyIGZyb20gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB1c2VySWQgSWQgb2YgdGhlIHVzZXIgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBhc3luYyByZW1vdmVVc2VyKHBhcmFtczogUmVtb3ZlVXNlck9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1c2VySWQnXSwgW10pO1xuXG4gICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy91c2VyLycgKyB1c2VySWQpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkICh1bnNpZ25lZCB0cmFuc2FjdGlvbikgZnJvbSBCaXRHb1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7e2FkZHJlc3M6IHN0cmluZywgYW1vdW50OiBzdHJpbmd9fSBwYXJhbXMucmVjaXBpZW50cyAtIGxpc3Qgb2YgcmVjaXBpZW50cyBhbmQgbmVjZXNzYXJ5IHJlY2lwaWVudCBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bUJsb2NrcyAtIEVzdGltYXRlcyB0aGUgYXBwcm94aW1hdGUgZmVlIHBlciBraWxvYnl0ZSBuZWNlc3NhcnkgZm9yIGEgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHdpdGhpbiBudW1CbG9ja3MgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIHRoZSBkZXNpcmVkIGZlZVJhdGUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBiYXNlIHVuaXRzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIGJhc2UgdW5pdHMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIE1pbmltdW0gbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdW5zcGVudHMgZ29pbmcgaW50byB0aGlzIHRyYW5zYWN0aW9uIHNob3VsZCBoYXZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIEVuZm9yY2UgbWluaW11bSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyBvbiBjaGFuZ2UgKGludGVybmFsKSBpbnB1dHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMgLSBUaGUgZGVzaXJlZCBjb3VudCBvZiB1bnNwZW50cyBpbiB0aGUgd2FsbGV0LiBJZiB0aGUgd2FsbGV04oCZcyBjdXJyZW50IHVuc3BlbnQgY291bnQgaXMgbG93ZXIgdGhhbiB0aGUgdGFyZ2V0LCB1cCB0byBmb3VyIGFkZGl0aW9uYWwgY2hhbmdlIG91dHB1dHMgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSBJZ25vcmUgdW5zcGVudHMgc21hbGxlciB0aGFuIHRoaXMgYW1vdW50IG9mIGJhc2UgdW5pdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIElnbm9yZSB1bnNwZW50cyBsYXJnZXIgdGhhbiB0aGlzIGFtb3VudCBvZiBiYXNlIHVuaXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuc2VxdWVuY2VJZCAtIFRoZSBzZXF1ZW5jZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5sYXN0TGVkZ2VyU2VxdWVuY2UgLSBBYnNvbHV0ZSBtYXggbGVkZ2VyIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5sZWRnZXJTZXF1ZW5jZURlbHRhIC0gUmVsYXRpdmUgbGVkZ2VyIGhlaWdodCAoaW4gcmVsYXRpb24gdG8gdGhlIGN1cnJlbnQgbGVkZ2VyKSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5nYXNQcmljZSAtIEN1c3RvbSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5nYXNMaW1pdCAtIEN1c3RvbSBnYXMgbGltaXQgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMubm9TcGxpdENoYW5nZSAtIFNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0b21hdGljIGNoYW5nZSBzcGxpdHRpbmcgZm9yIHB1cnBvc2VzIG9mIHVuc3BlbnQgbWFuYWdlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMudW5zcGVudHMgLSBUaGUgdW5zcGVudHMgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCB1bnNwZW50IHNob3VsZCBiZSBpbiB0aGUgZm9ybSBwcmV2VHhJZDpuT3V0cHV0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY2hhbmdlQWRkcmVzcyAtIFNwZWNpZmllcyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIGNoYW5nZSBvdXRwdXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMubm9uUGFydGljaXBhdGlvbiAtIChBbGdvcmFuZCkgTm9uIHBhcnRpY2lwYXRpbmcga2V5IHJlZyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnZhbGlkRnJvbUJsb2NrIC0gKEFsZ29yYW5kKSBUaGUgbWluaW11bSByb3VuZCB0aGlzIHdpbGwgcnVuIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMudmFsaWRUb0Jsb2NrIC0gKEFsZ29yYW5kKSBUaGUgbWF4aW11bSByb3VuZCB0aGlzIHdpbGwgcnVuIG9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmluc3RhbnQgLSBCdWlsZCB0aGlzIHRyYW5zYWN0aW9uIHRvIGNvbmZvcm0gd2l0aCBpbnN0YW50IHNlbmRpbmcgY29pbi1zcGVjaWZpYyBtZXRob2QgKGlmIGF2YWlsYWJsZSlcbiAgICogQHBhcmFtIHt7dmFsdWU6IFN0cmluZywgdHlwZTogU3RyaW5nfX0gcGFyYW1zLm1lbW8gLSBNZW1vIHRvIHVzZSBpbiB0cmFuc2FjdGlvbiAoc3VwcG9ydGVkIGJ5IFN0ZWxsYXIpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbS50cmFuc2ZlcklkIC0gdHJhbnNmZXIgSWQgdG8gdXNlIGluIHRyYW5zYWN0aW9uIChzdXBwb3J0ZWQgYnkgY2FzcGVyKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmFkZHJlc3NUeXBlIC0gVGhlIHR5cGUgb2YgYWRkcmVzcyB0byBjcmVhdGUgZm9yIGNoYW5nZS4gT25lIG9mIGBwMnNoYCwgYHAyc2hQMndzaGAsIGFuZCBgcDJ3c2hgLiBDYXNlLXNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuaG9wIC0gQnVpbGQgdGhpcyBhcyBhbiBFdGhlcmV1bSBob3AgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5yZXNlcnZhdGlvbiAtIE9iamVjdCB0byByZXNlcnZlIHRoZSB1bnNwZW50cyB0aGF0IHRoaXMgdHggYnVpbGQgdXNlcy4gRm9ybWF0IGlzIHJlc2VydmF0aW9uID0geyBleHBpcmVUaW1lOiBJU09EYXRlU3RyaW5nLCBwZW5kaW5nQXBwcm92YWxJZDogU3RyaW5nIH1cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIFRoZSBwYXNzcGhyYXNlIHRvIHRoZSB3YWxsZXQgdXNlciBrZXksIHRvIHNpZ24gY29tbWl0bWVudCBkYXRhIGZvciBFdGhlcmV1bSBob3AgdHJhbnNhY3Rpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MgdXNlZCBhcyB0aGUgXCJ0b1wiIGZpZWxkIG9mIGEgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBwcmVidWlsZFRyYW5zYWN0aW9uKHBhcmFtczogUHJlYnVpbGRUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdD4ge1xuICAgIGlmICh0aGlzLl93YWxsZXQubXVsdGlzaWdUeXBlID09PSAndHNzJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJlYnVpbGRUcmFuc2FjdGlvblRzcyhwYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIFdoaXRlbGlzdCBwYXJhbXMgdG8gYnVpbGQgdHhcbiAgICBjb25zdCB3aGl0ZWxpc3RlZFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIHRoaXMucHJlYnVpbGRXaGl0ZWxpc3RlZFBhcmFtcygpKTtcbiAgICBkZWJ1ZygncHJlYnVpbGRpbmcgdHJhbnNhY3Rpb246ICVPJywgd2hpdGVsaXN0ZWRQYXJhbXMpO1xuXG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5nZXRFeHRyYVByZWJ1aWxkUGFyYW1zKE9iamVjdC5hc3NpZ24ocGFyYW1zLCB7IHdhbGxldDogdGhpcyB9KSk7XG4gICAgT2JqZWN0LmFzc2lnbih3aGl0ZWxpc3RlZFBhcmFtcywgZXh0cmFQYXJhbXMpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgb2ZmbGluZVZlcmlmaWNhdGlvbjogcGFyYW1zLm9mZmxpbmVWZXJpZmljYXRpb24gPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICBjb25zdCBidWlsZFF1ZXJ5ID0gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuaWQoKSArICcvdHgvYnVpbGQnKSlcbiAgICAgIC5xdWVyeShxdWVyeVBhcmFtcylcbiAgICAgIC5zZW5kKHdoaXRlbGlzdGVkUGFyYW1zKVxuICAgICAgLnJlc3VsdCgpO1xuXG4gICAgY29uc3QgYmxvY2tIZWlnaHRRdWVyeSA9IF8uaXNGdW5jdGlvbigodGhpcy5iYXNlQ29pbiBhcyBhbnkpLmdldExhdGVzdEJsb2NrSGVpZ2h0KVxuICAgICAgPyAodGhpcy5iYXNlQ29pbiBhcyBhbnkpLmdldExhdGVzdEJsb2NrSGVpZ2h0KHBhcmFtcy5yZXFJZClcbiAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcXVlcmllcyA9IFtidWlsZFF1ZXJ5LCBibG9ja0hlaWdodFF1ZXJ5XTtcbiAgICBjb25zdCBbYnVpbGRSZXNwb25zZSwgYmxvY2tIZWlnaHRdID0gKGF3YWl0IFByb21pc2UuYWxsKHF1ZXJpZXMpKSBhcyBhbnk7XG4gICAgZGVidWcoJ3Bvc3Rwcm9jZXNzaW5nIHRyYW5zYWN0aW9uIHByZWJ1aWxkOiAlTycsIGJ1aWxkUmVzcG9uc2UpO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChibG9ja0hlaWdodCkpIHtcbiAgICAgIGJ1aWxkUmVzcG9uc2UuYmxvY2tIZWlnaHQgPSBibG9ja0hlaWdodDtcbiAgICB9XG4gICAgbGV0IHByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkID0gKGF3YWl0IHRoaXMuYmFzZUNvaW4ucG9zdFByb2Nlc3NQcmVidWlsZChcbiAgICAgIE9iamVjdC5hc3NpZ24oYnVpbGRSZXNwb25zZSwgeyB3YWxsZXQ6IHRoaXMsIGJ1aWxkUGFyYW1zOiB3aGl0ZWxpc3RlZFBhcmFtcyB9KVxuICAgICkpIGFzIGFueTtcbiAgICBkZWxldGUgcHJlYnVpbGQud2FsbGV0O1xuICAgIGRlbGV0ZSBwcmVidWlsZC5idWlsZFBhcmFtcztcbiAgICBwcmVidWlsZCA9IF8uZXh0ZW5kKHt9LCBwcmVidWlsZCwgeyB3YWxsZXRJZDogdGhpcy5pZCgpIH0pO1xuICAgIGlmICh0aGlzLl93YWxsZXQgJiYgdGhpcy5fd2FsbGV0LmNvaW5TcGVjaWZpYyAmJiAhcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcykge1xuICAgICAgcHJlYnVpbGQgPSBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiB0aGlzLl93YWxsZXQuY29pblNwZWNpZmljLmJhc2VBZGRyZXNzIH0pO1xuICAgIH1cbiAgICBkZWJ1ZygnZmluYWwgdHJhbnNhY3Rpb24gcHJlYnVpbGQ6ICVPJywgcHJlYnVpbGQpO1xuICAgIHJldHVybiBwcmVidWlsZCBhcyBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIFtrZXljaGFpbiAvIGtleV0gKG9iamVjdCkgb3IgcHJ2IChzdHJpbmcpXG4gICAqIC0gd2FsbGV0UGFzc3BocmFzZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogV2FsbGV0U2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHsgdHhQcmVidWlsZCB9ID0gcGFyYW1zO1xuICAgIGlmICghdHhQcmVidWlsZCB8fCB0eXBlb2YgdHhQcmVidWlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXNpZ24gPSBhd2FpdCB0aGlzLmJhc2VDb2luLnByZXNpZ25UcmFuc2FjdGlvbih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICB3YWxsZXREYXRhOiB0aGlzLl93YWxsZXQsXG4gICAgICB0c3NVdGlsczogdGhpcy50c3NVdGlscyxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl93YWxsZXQubXVsdGlzaWdUeXBlID09PSAndHNzJykge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnblRyYW5zYWN0aW9uVHNzKHsgLi4ucHJlc2lnbiwgcHJ2OiB0aGlzLmdldFVzZXJQcnYocHJlc2lnbiBhcyBHZXRVc2VyUHJ2T3B0aW9ucykgfSk7XG4gICAgfVxuXG4gICAgbGV0IHsgcHVicyB9ID0gcGFyYW1zO1xuICAgIGlmICghcHVicyAmJiB0aGlzLmJhc2VDb2luLmtleUlkc0ZvclNpZ25pbmcoKS5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBrZXljaGFpbnMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmdldEtleXNGb3JTaWduaW5nKHsgd2FsbGV0OiB0aGlzIH0pO1xuICAgICAgcHVicyA9IGtleWNoYWlucy5tYXAoKGspID0+IGsucHViKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduVHJhbnNhY3Rpb25QYXJhbXMgPSB7XG4gICAgICAuLi5wcmVzaWduLFxuICAgICAgdHhQcmVidWlsZCxcbiAgICAgIHB1YnMsXG4gICAgICBjb2luOiB0aGlzLmJhc2VDb2luLFxuICAgIH07XG5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhcmFtcy5jdXN0b21TaWduaW5nRnVuY3Rpb24pKSB7XG4gICAgICByZXR1cm4gcGFyYW1zLmN1c3RvbVNpZ25pbmdGdW5jdGlvbihzaWduVHJhbnNhY3Rpb25QYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5zaWduVHJhbnNhY3Rpb24oe1xuICAgICAgLi4uc2lnblRyYW5zYWN0aW9uUGFyYW1zLFxuICAgICAgcHJ2OiB0aGlzLmdldFVzZXJQcnYocHJlc2lnbiBhcyBHZXRVc2VyUHJ2T3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyIHByaXZhdGUga2V5IGZyb20gZWl0aGVyIGEgZGVyaXZhdGlvbiBvciBhbiBlbmNyeXB0ZWQga2V5Y2hhaW5cbiAgICogQHBhcmFtIFtwYXJhbXMua2V5Y2hhaW4gLyBwYXJhbXMua2V5XSAob2JqZWN0KSBvciBwYXJhbXMucHJ2IChzdHJpbmcpXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAoc3RyaW5nKVxuICAgKi9cbiAgZ2V0VXNlclBydihwYXJhbXM6IEdldFVzZXJQcnZPcHRpb25zID0ge30pOiBzdHJpbmcge1xuICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IHBhcmFtcy5rZXljaGFpbiB8fCBwYXJhbXMua2V5O1xuICAgIGxldCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcbiAgICBpZiAodXNlclBydiAmJiB0eXBlb2YgdXNlclBydiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJ2IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvLyB1c2UgdGhlIGBkZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkYCBwcm9wZXJ0eSBmcm9tIHRoZSB1c2VyIGtleWNoYWluIGFzIHRoZSBgY29sZERlcml2YXRpb25TZWVkYFxuICAgIC8vIGlmIG5vIG90aGVyIGBjb2xkRGVyaXZhdGlvblNlZWRgIHdhcyBleHBsaWNpdGx5IHByb3ZpZGVkXG4gICAgaWYgKFxuICAgICAgcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBwYXJhbXMua2V5Y2hhaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgcGFyYW1zLmtleWNoYWluLmRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQgIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCA9IHBhcmFtcy5rZXljaGFpbi5kZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkO1xuICAgIH1cblxuICAgIGlmICh1c2VyUHJ2ICYmIHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQpIHtcbiAgICAgIC8vIHRoZSBkZXJpdmF0aW9uIG9ubHkgbWFrZXMgc2Vuc2Ugd2hlbiBhIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgY29uc3QgZGVyaXZhdGlvbiA9IHRoaXMuYmFzZUNvaW4uZGVyaXZlS2V5V2l0aFNlZWQoeyBrZXk6IHVzZXJQcnYsIHNlZWQ6IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQgfSk7XG4gICAgICB1c2VyUHJ2ID0gZGVyaXZhdGlvbi5rZXk7XG4gICAgfSBlbHNlIGlmICghdXNlclBydikge1xuICAgICAgaWYgKCF1c2VyS2V5Y2hhaW4gfHwgdHlwZW9mIHVzZXJLZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXNlckVuY3J5cHRlZFBydiA9IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgICBpZiAoIXVzZXJFbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbiBkb2VzIG5vdCBoYXZlIHByb3BlcnR5IGVuY3J5cHRlZFBydicpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldFBhc3NwaHJhc2UgcHJvcGVydHkgbWlzc2luZycpO1xuICAgICAgfVxuXG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IHVzZXJFbmNyeXB0ZWRQcnYsIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXJQcnY7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgZnJvbSBCaXRHbywgdmFsaWRhdGUgaXQsIGFuZCB0aGVuIGRlY3J5cHQgdGhlIHVzZXIga2V5IGFuZCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBwcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGlmIChwYXJhbXMuZWlwMTU1OSAmJiBwYXJhbXMuZ2FzUHJpY2UpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHBhcmFtcy5laXAxNTU5IGFuZCBwYXJhbXMuZ2FzUHJpY2UgbWF5IGJlIHNwZWNpZmllZCcpO1xuICAgICAgZXJyb3IuY29kZSA9ICdib3RoX2dhc1ByaWNlX2FuZF9laXAxNTU5Z2FzTW9kZWxfc3BlY2lmaWVkJztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucHJlYnVpbGRUeCAmJiBwYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignT25seSBvbmUgb2YgcHJlYnVpbGRUeCBhbmQgcmVjaXBpZW50cyBtYXkgYmUgc3BlY2lmaWVkJyk7XG4gICAgICBlcnJvci5jb2RlID0gJ2JvdGhfcHJlYnVpbGR0eF9hbmRfcmVjaXBpZW50c19zcGVjaWZpZWQnO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZWNpcGllbnRzICYmICFBcnJheS5pc0FycmF5KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignZXhwZWN0aW5nIHJlY2lwaWVudHMgYXJyYXknKTtcbiAgICAgIGVycm9yLmNvZGUgPSAncmVjaXBpZW50c19ub3RfYXJyYXknO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNBcnJheSh0aGlzLl9wZXJtaXNzaW9ucykgJiYgIXRoaXMuX3Blcm1pc3Npb25zLmluY2x1ZGVzKCdzcGVuZCcpKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdubyBzcGVuZCBwZXJtaXNzaW9uIG9uIHRoaXMgd2FsbGV0Jyk7XG4gICAgICBlcnJvci5jb2RlID0gJ3VzZXJfbm90X2FsbG93ZWRfdG9fc3BlbmRfZnJvbV93YWxsZXQnO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gY2FsbCBwcmVidWlsZFRyYW5zYWN0aW9uIGFuZCBrZXljaGFpbnMtZ2V0IGluIHBhcmFsbGVsXG4gICAgLy8gdGhlIHByZWJ1aWxkIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHByb3ZpZGluZyBhbiBleHBsaWNpdCB0eFxuICAgIGNvbnN0IHR4UHJlYnVpbGRRdWVyeSA9IHBhcmFtcy5wcmVidWlsZFR4ID8gUHJvbWlzZS5yZXNvbHZlKHBhcmFtcy5wcmVidWlsZFR4KSA6IHRoaXMucHJlYnVpbGRUcmFuc2FjdGlvbihwYXJhbXMpO1xuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXRLZXlzRm9yU2lnbmluZyh7IHdhbGxldDogdGhpcywgcmVxSWQ6IHBhcmFtcy5yZXFJZCB9KTtcblxuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSAoYXdhaXQgdHhQcmVidWlsZFF1ZXJ5KSBhcyBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYmFzZUNvaW4udmVyaWZ5VHJhbnNhY3Rpb24oe1xuICAgICAgICB0eFBhcmFtczogdHhQcmVidWlsZC5idWlsZFBhcmFtcyB8fCBwYXJhbXMsXG4gICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgIHdhbGxldDogdGhpcyxcbiAgICAgICAgdmVyaWZpY2F0aW9uOiBwYXJhbXMudmVyaWZpY2F0aW9uID8/IHt9LFxuICAgICAgICByZXFJZDogcGFyYW1zLnJlcUlkLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZmFpbGVkIGxvY2FsIHZhbGlkYXRpb246JywgZS5tZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICd0cmFuc2FjdGlvbiBwYXJhbXM6JyxcbiAgICAgICAgXy5vbWl0KHBhcmFtcywgWydrZXljaGFpbicsICdwcnYnLCAncGFzc3BocmFzZScsICd3YWxsZXRQYXNzcGhyYXNlJywgJ2tleScsICd3YWxsZXQnXSlcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZDonLCB0eFByZWJ1aWxkKTtcbiAgICAgIGNvbnNvbGUudHJhY2UoZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICAvLyBwYXNzIG91ciB0aHJlZSBrZXlzXG4gICAgY29uc3Qgc2lnbmluZ1BhcmFtcyA9IHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIHR4UHJlYnVpbGQ6IHR4UHJlYnVpbGQsXG4gICAgICB3YWxsZXQ6IHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgbXVsdGlzaWcgYWRkcmVzcyBhdCB3YWxsZXQgY3JlYXRpb24gdGltZVxuICAgICAgICBhZGRyZXNzVmVyc2lvbjogdGhpcy5fd2FsbGV0LmNvaW5TcGVjaWZpYy5hZGRyZXNzVmVyc2lvbixcbiAgICAgIH0sXG4gICAgICBrZXljaGFpbjoga2V5Y2hhaW5zWzBdLFxuICAgICAgYmFja3VwS2V5Y2hhaW46IGtleWNoYWlucy5sZW5ndGggPiAxID8ga2V5Y2hhaW5zWzFdIDogbnVsbCxcbiAgICAgIGJpdGdvS2V5Y2hhaW46IGtleWNoYWlucy5sZW5ndGggPiAyID8ga2V5Y2hhaW5zWzJdIDogbnVsbCxcbiAgICAgIHB1YnM6IGtleWNoYWlucy5tYXAoKGspID0+IGsucHViKSxcbiAgICAgIHJlcUlkOiBwYXJhbXMucmVxSWQsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24oc2lnbmluZ1BhcmFtcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQgZnVuZHMnKSkge1xuICAgICAgICBlcnJvci5jb2RlID0gJ2luc3VmZmljaWVudF9mdW5kcyc7XG4gICAgICAgIGVycm9yLndhbGxldEJhbGFuY2VzID0ge1xuICAgICAgICAgIGJhbGFuY2VTdHJpbmc6IHRoaXMuYmFsYW5jZVN0cmluZygpLFxuICAgICAgICAgIGNvbmZpcm1lZEJhbGFuY2VTdHJpbmc6IHRoaXMuY29uZmlybWVkQmFsYW5jZVN0cmluZygpLFxuICAgICAgICAgIHNwZW5kYWJsZUJhbGFuY2VTdHJpbmc6IHRoaXMuc3BlbmRhYmxlQmFsYW5jZVN0cmluZygpLFxuICAgICAgICAgIGJhbGFuY2U6IHRoaXMuYmFsYW5jZSgpLFxuICAgICAgICAgIGNvbmZpcm1lZEJhbGFuY2U6IHRoaXMuY29uZmlybWVkQmFsYW5jZSgpLFxuICAgICAgICAgIHNwZW5kYWJsZUJhbGFuY2U6IHRoaXMuc3BlbmRhYmxlQmFsYW5jZSgpLFxuICAgICAgICB9O1xuICAgICAgICBlcnJvci50eFBhcmFtcyA9IF8ub21pdChwYXJhbXMsIFsna2V5Y2hhaW4nLCAncHJ2JywgJ3Bhc3NwaHJhc2UnLCAnd2FsbGV0UGFzc3BocmFzZScsICdrZXknXSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZWxlcmF0ZSBhIHRyYW5zYWN0aW9uJ3MgY29uZmlybWF0aW9uIHVzaW5nIENoaWxkLVBheXMtRm9yLVBhcmVudCAoQ1BGUClcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgYWNjZWxlcmF0ZVRyYW5zYWN0aW9uKHBhcmFtczogQWNjZWxlcmF0ZVRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBUT0RPKEJHLTkzNDkpOiBjaGFuZ2UgdGhlIGxhc3QgY2hlY2sgdG8gPiAwIGFuZCB0aGUgZXJyb3IgbWVzc2FnZSBvbmNlIHBsYXRmb3JtIGFsbG93cyBtdWx0aXBsZSB0cmFuc2FjdGlvbnMgdG9cbiAgICAvLyAgICAgICAgICAgICAgICBiZSBidW1wZWQgaW4gdGhlIHNhbWUgQ1BGUCB0cmFuc2FjdGlvblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5jcGZwVHhJZHMpIHx8ICFBcnJheS5pc0FycmF5KHBhcmFtcy5jcGZwVHhJZHMpIHx8IHBhcmFtcy5jcGZwVHhJZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdleHBlY3RpbmcgY3BmcFR4SWRzIHRvIGJlIGFuIGFycmF5IG9mIGxlbmd0aCAxJyk7XG4gICAgICBlcnJvci5jb2RlID0gJ2NwZnB0eGlkc19ub3RfYXJyYXknO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmNwZnBGZWVSYXRlKSkge1xuICAgICAgaWYgKHBhcmFtcy5ub0NwZnBGZWVSYXRlICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ2NwZnBGZWVSYXRlIG11c3QgYmUgc2V0IHVubGVzcyBub0NwZnBGZWVSYXRlIGlzIHNldCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ2NwZnBmZWVyYXRlX25vdF9zZXQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMuY3BmcEZlZVJhdGUpIHx8IHBhcmFtcy5jcGZwRmVlUmF0ZSA8IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignY3BmcEZlZVJhdGUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnY3BmcGZlZXJhdGVfbm90X25vbm5lZ2F0aXZlX2ludGVnZXInO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMubWF4RmVlKSkge1xuICAgICAgaWYgKHBhcmFtcy5ub01heEZlZSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdtYXhGZWUgbXVzdCBiZSBzZXQgdW5sZXNzIG5vTWF4RmVlIGlzIHNldCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ21heGZlZV9ub3Rfc2V0JztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm1heEZlZSkgfHwgcGFyYW1zLm1heEZlZSA8IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignbWF4RmVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ21heGZlZV9ub3Rfbm9ubmVnYXRpdmVfaW50ZWdlcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMucmVjaXBpZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnJlY2lwaWVudHMpIHx8IHBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yICdyZWNpcGllbnRzJzogbXVzdCBiZSBlbXB0eSBhcnJheSB3aGVuIHNldGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmFtcy5yZWNpcGllbnRzID0gW107XG5cbiAgICAvLyBXZSBtdXN0IHBhc3MgdGhlIGJ1aWxkIHBhcmFtcyB0aHJvdWdoIHRvIHN1Ym1pdCBpbiBjYXNlIHRoZSBDUEZQIHR4IGV2ZXIgaGFzIHRvIGJlIHJlYnVpbHQuXG4gICAgY29uc3Qgc3VibWl0UGFyYW1zID0gT2JqZWN0LmFzc2lnbihwYXJhbXMsIGF3YWl0IHRoaXMucHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSk7XG4gICAgZGVsZXRlIChzdWJtaXRQYXJhbXMgYXMgYW55KS53YWxsZXQ7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3VibWl0VHJhbnNhY3Rpb24oc3VibWl0UGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgYSBoYWxmLXNpZ25lZCB0cmFuc2FjdGlvbiB0byBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhIZXg6IHRyYW5zYWN0aW9uIGhleCB0byBzdWJtaXRcbiAgICogLSBoYWxmU2lnbmVkOiBvYmplY3QgY29udGFpbmluZyB0cmFuc2FjdGlvbiAodHhIZXggb3IgdHhCYXNlNjQpIHRvIHN1Ym1pdFxuICAgKi9cbiAgYXN5bmMgc3VibWl0VHJhbnNhY3Rpb24ocGFyYW1zOiBTdWJtaXRUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnb3RwJywgJ3R4SGV4JywgJ3R4UmVxdWVzdElkJ10pO1xuICAgIGNvbnN0IGhhc1R4SGV4ID0gISFwYXJhbXMudHhIZXg7XG4gICAgY29uc3QgaGFzSGFsZlNpZ25lZCA9ICEhcGFyYW1zLmhhbGZTaWduZWQ7XG5cbiAgICBpZiAocGFyYW1zLnR4UmVxdWVzdElkICYmIChoYXNUeEhleCB8fCBoYXNIYWxmU2lnbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHN1cHBseSBleGFjdGx5IG9uZSBvZiB0eFJlcXVlc3RJZCwgdHhIZXgsIG9yIGhhbGZTaWduZWQnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXJhbXMudHhSZXF1ZXN0SWQgJiYgKChoYXNUeEhleCAmJiBoYXNIYWxmU2lnbmVkKSB8fCAoIWhhc1R4SGV4ICYmICFoYXNIYWxmU2lnbmVkKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgZWl0aGVyIHR4SGV4IG9yIGhhbGZTaWduZWQsIGJ1dCBub3QgYm90aCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5pZCgpICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBjb2lucyB0byBhIHJlY2lwaWVudFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyAtIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50IC0gdGhlIGFtb3VudCBpbiBzYXRvc2hpcy93ZWkvYmFzZSB2YWx1ZSB0byBiZSBzZW50XG4gICAqIEBwYXJhbSBwYXJhbXMubWVzc2FnZSAtIG9wdGlvbmFsIG1lc3NhZ2UgdG8gYXR0YWNoIHRvIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YSAtIFtFdGhlcmV1bSBTcGVjaWZpY10gb3B0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMuY3VzdG9kaWFuVHJhbnNhY3Rpb25JZCAtIFtFdGhlcmV1bS9NTUkgU3BlY2lmaWNdIGlkIG9mIHRyYW5zYWN0aW9uIGNyZWF0ZWQgdmlhIG1ldGFtYXNrXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSBwYXNzcGhyYXNlIHRvIGJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgdXNlciBrZXkgb24gdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtcy5wcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0sIGlmIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gdGhlIG1pbmltdW0gY29uZmlybWF0aW9uIHRocmVzaG9sZCBmb3IgaW5wdXRzXG4gICAqIEBwYXJhbSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gd2hldGhlciB0byBlbmZvcmNlIG1pbkNvbmZpcm1zIGZvciBjaGFuZ2UgaW5wdXRzXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgc2VuZChwYXJhbXM6IFNlbmRPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbJ21lc3NhZ2UnLCAnZGF0YSddKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGFtb3VudCcpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29pbiA9IHRoaXMuYmFzZUNvaW47XG5cbiAgICBjb25zdCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHBhcmFtcy5hbW91bnQpO1xuICAgIGlmIChhbW91bnQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFtb3VudCAtIHBvc2l0aXZlIG51bWJlciBncmVhdGVyIHRoYW4gemVybyBvciBudW1lcmljIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmICghY29pbi52YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKSAmJiBhbW91bnQuaXNaZXJvKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYW1vdW50IC0gcG9zaXRpdmUgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvIG9yIG51bWVyaWMgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudHM6IFNlbmRNYW55T3B0aW9uc1sncmVjaXBpZW50cyddID0gW1xuICAgICAge1xuICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBwYXJhbXMuYW1vdW50LFxuICAgICAgICB0b2tlbk5hbWU6IHBhcmFtcy50b2tlbk5hbWUsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBpZiAocGFyYW1zLmRhdGEgJiYgY29pbi50cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCkpIHtcbiAgICAgIHJlY2lwaWVudHNbMF0uZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgIH1cbiAgICBjb25zdCBzZW5kTWFueU9wdGlvbnM6IFNlbmRNYW55T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywgeyByZWNpcGllbnRzIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRNYW55KHNlbmRNYW55T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBtb25leSB0byBtdWx0aXBsZSByZWNpcGllbnRzXG4gICAqIDEuIEdldHMgdGhlIHVzZXIga2V5Y2hhaW4gYnkgY2hlY2tpbmcgdGhlIHdhbGxldCBmb3IgYSBrZXkgd2hpY2ggaGFzIGFuIGVuY3J5cHRlZCBwcnZcbiAgICogMi4gRGVjcnlwdHMgdXNlciBrZXlcbiAgICogMy4gQ3JlYXRlcyB0aGUgdHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IGZlZVxuICAgKiA0LiBTaWducyB0cmFuc2FjdGlvbiB3aXRoIGRlY3J5cHRlZCB1c2VyIGtleVxuICAgKiA1LiBTZW5kcyB0aGUgdHJhbnNhY3Rpb24gdG8gQml0R29cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge3thZGRyZXNzOiBzdHJpbmcsIGFtb3VudDogc3RyaW5nfX0gcGFyYW1zLnJlY2lwaWVudHMgLSBsaXN0IG9mIHJlY2lwaWVudHMgYW5kIG5lY2Vzc2FyeSByZWNpcGllbnQgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5udW1CbG9ja3MgLSBFc3RpbWF0ZXMgdGhlIGFwcHJveGltYXRlIGZlZSBwZXIga2lsb2J5dGUgbmVjZXNzYXJ5IGZvciBhIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiB3aXRoaW4gbnVtQmxvY2tzIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSB0aGUgZGVzaXJlZCBmZWVSYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2F0b3RoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gRW5mb3JjZXMgbWluQ29uZmlybXMgb24gY2hhbmdlIGlucHV0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzIC0gVGhlIGRlc2lyZWQgY291bnQgb2YgdW5zcGVudHMgaW4gdGhlIHdhbGxldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBvcHRpb25hbCBtZXNzYWdlIHRvIGF0dGFjaCB0byB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gSWdub3JlIHVuc3BlbnRzIHNtYWxsZXIgdGhhbiB0aGlzIGFtb3VudCBvZiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gSWdub3JlIHVuc3BlbnRzIGxhcmdlciB0aGFuIHRoaXMgYW1vdW50IG9mIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuc2VxdWVuY2VJZCAtIFRoZSBzZXF1ZW5jZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5sYXN0TGVkZ2VyU2VxdWVuY2UgLSBBYnNvbHV0ZSBtYXggbGVkZ2VyIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5sZWRnZXJTZXF1ZW5jZURlbHRhIC0gUmVsYXRpdmUgbGVkZ2VyIGhlaWdodCAoaW4gcmVsYXRpb24gdG8gdGhlIGN1cnJlbnQgbGVkZ2VyKSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5nYXNQcmljZSAtIEN1c3RvbSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMubm9TcGxpdENoYW5nZSAtIFNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0b21hdGljIGNoYW5nZSBzcGxpdHRpbmcgZm9yIHB1cnBvc2VzIG9mIHVuc3BlbnQgbWFuYWdlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMudW5zcGVudHMgLSBUaGUgdW5zcGVudHMgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCB1bnNwZW50IHNob3VsZCBiZSBpbiB0aGUgZm9ybSBwcmV2VHhJZDpuT3V0cHV0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY29tbWVudCAtIEFueSBhZGRpdGlvbmFsIGNvbW1lbnQgdG8gYXR0YWNoIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm90cCAtIFR3byBmYWN0b3IgYXV0aCBjb2RlIHRvIGVuYWJsZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNoYW5nZUFkZHJlc3MgLSBTcGVjaWZpZXMgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSBjaGFuZ2Ugb3V0cHV0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmluc3RhbnQgLSBTZW5kIHRoaXMgdHJhbnNhY3Rpb24gdXNpbmcgY29pbi1zcGVjaWZpYyBpbnN0YW50IHNlbmRpbmcgbWV0aG9kIChpZiBhdmFpbGFibGUpXG4gICAqIEBwYXJhbSB7e3ZhbHVlOiBTdHJpbmcsIHR5cGU6IFN0cmluZ319IHBhcmFtcy5tZW1vIC0gTWVtbyB0byB1c2UgaW4gdHJhbnNhY3Rpb24gKHN1cHBvcnRlZCBieSBTdGVsbGFyKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnR5cGUgLSBUeXBlIG9mIHRoZSB0cmFuc2FjdGlvbiAoZS5nLiB0cnVzdGxpbmUpXG4gICAqIEBwYXJhbSB7e3Rva2VuOiBwYXJhbXMsIGFjdGlvbjogU3RyaW5nLCBsaW1pdDogU3RyaW5nfVtdfSBvcHRpb25zLnRydXN0bGluZXMgLSBBcnJheSBvZiB0cnVzdGxpbmVzIHRvIG1hbmFnZSAoc3VwcG9ydGVkIGJ5IFN0ZWxsYXIpXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgc2VuZE1hbnkocGFyYW1zOiBTZW5kTWFueU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnY29tbWVudCcsICdvdHAnXSk7XG4gICAgZGVidWcoJ3NlbmRNYW55IGNhbGxlZCcpO1xuICAgIGNvbnN0IHJlcUlkID0gcGFyYW1zLnJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gICAgcGFyYW1zLnJlcUlkID0gcmVxSWQ7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICBjb25zdCBjb2luID0gdGhpcy5iYXNlQ29pbjtcbiAgICBpZiAoXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICAgIHBhcmFtcy5yZWNpcGllbnRzLm1hcChmdW5jdGlvbiAocmVjaXBpZW50KSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50LmFtb3VudCk7XG4gICAgICAgIGlmIChhbW91bnQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhbW91bnQgLSBwb3NpdGl2ZSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gb3IgbnVtZXJpYyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvaW4udmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkgJiYgYW1vdW50LmlzWmVybygpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhbW91bnQgLSBwb3NpdGl2ZSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gb3IgbnVtZXJpYyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3dhbGxldC5tdWx0aXNpZ1R5cGUgPT09ICd0c3MnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5kTWFueVRzcyhwYXJhbXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbGZTaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMucHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICBjb25zdCBzZWxlY3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAncmVjaXBpZW50cycsXG4gICAgICAnbnVtQmxvY2tzJyxcbiAgICAgICdmZWVSYXRlJyxcbiAgICAgICdtYXhGZWVSYXRlJyxcbiAgICAgICdtaW5Db25maXJtcycsXG4gICAgICAnZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlJyxcbiAgICAgICd0YXJnZXRXYWxsZXRVbnNwZW50cycsXG4gICAgICAnbWVzc2FnZScsXG4gICAgICAnbWluVmFsdWUnLFxuICAgICAgJ21heFZhbHVlJyxcbiAgICAgICdzZXF1ZW5jZUlkJyxcbiAgICAgICdsYXN0TGVkZ2VyU2VxdWVuY2UnLFxuICAgICAgJ2xlZGdlclNlcXVlbmNlRGVsdGEnLFxuICAgICAgJ2dhc1ByaWNlJyxcbiAgICAgICdub1NwbGl0Q2hhbmdlJyxcbiAgICAgICd1bnNwZW50cycsXG4gICAgICAnY29tbWVudCcsXG4gICAgICAnb3RwJyxcbiAgICAgICdjaGFuZ2VBZGRyZXNzJyxcbiAgICAgICdpbnN0YW50JyxcbiAgICAgICdtZW1vJyxcbiAgICAgICd0eXBlJyxcbiAgICAgICd0cnVzdGxpbmVzJyxcbiAgICAgICd0cmFuc2ZlcklkJyxcbiAgICAgICdzdGFraW5nT3B0aW9ucycsXG4gICAgXSk7XG4gICAgY29uc3QgZmluYWxUeFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBoYWxmU2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcyk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvdHgvc2VuZCcpKS5zZW5kKGZpbmFsVHhQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXIgYW4gdW5zdXBwb3J0ZWQgdG9rZW4gZnJvbSBhIEJpdEdvIG11bHRpc2lnIHdhbGxldFxuICAgKiBwYXJhbXMgYXJlIHZhbGlkYXRlZCBpbiBFdGgucHJvdG90eXBlLnJlY292ZXJUb2tlblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MgdGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHVuc3VwcG9ydGVkIHRva2VuXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjaXBpZW50IHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIHJlY292ZXJlZCB0b2tlbnMgc2hvdWxkIGJlIHNlbnQgdG9cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB0aGUgeHBydlxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlclRva2VuKHBhcmFtczogUmVjb3ZlclRva2VuT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAodGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSAhPT0gJ2V0aCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gcmVjb3Zlcnkgb25seSBzdXBwb3J0ZWQgZm9yIGV0aCB3YWxsZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0b2tlbkNvbnRyYWN0QWRkcmVzcywgcmVjaXBpZW50IH0gPSBwYXJhbXM7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0b2tlbkNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIHRva2VuQ29udHJhY3RBZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocmVjaXBpZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgcmVjaXBpZW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb3ZlclRva2VuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB0b2tlbkNvbnRyYWN0QWRkcmVzcywgcmVjaXBpZW50IH0sIHBhcmFtcywgeyB3YWxsZXQ6IHRoaXMgfSk7XG4gICAgcmV0dXJuICh0aGlzLmJhc2VDb2luIGFzIEV0aCkucmVjb3ZlclRva2VuKHJlY292ZXJUb2tlbk9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2FjdGlvbiBtZXRhZGF0YSBmb3IgdGhlIG9sZGVzdCB0cmFuc2FjdGlvbiB0aGF0IGlzIHN0aWxsIHBlbmRpbmcgb3IgYXR0ZW1wdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggdHhpZCwgd2FsbGV0SWQsIHR4LCBhbmQgZmVlIChpZiBzdXBwb3J0ZWQgZm9yIGNvaW4pXG4gICAqL1xuICBhc3luYyBnZXRGaXJzdFBlbmRpbmdUcmFuc2FjdGlvbihwYXJhbXM6IFJlY29yZDxzdHJpbmcsIG5ldmVyPiA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0Rmlyc3RQZW5kaW5nVHJhbnNhY3Rpb24oeyB3YWxsZXRJZDogdGhpcy5pZCgpIH0sIHRoaXMuYmFzZUNvaW4sIHRoaXMuYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZmVlIG9uIHRoZSBwZW5kaW5nIHRyYW5zYWN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIHR4aWQgdG8gdGhlIGdpdmVuIG5ldyBmZWVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnR4aWQgVGhlIHRyYW5zYWN0aW9uIElkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRyYW5zYWN0aW9uIHdob3NlIGZlZSBpcyB0byBiZSBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuZmVlIFRoZSBuZXcgZmVlIHRvIGFwcGx5IHRvIHRoZSBkZW5vdGVkIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0cmFuc2FjdGlvbiBJRCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIHRoYXQgY29udGFpbnMgdGhlIG5ldyBmZWUgcmF0ZVxuICAgKi9cbiAgYXN5bmMgY2hhbmdlRmVlKHBhcmFtczogQ2hhbmdlRmVlT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4aWQnLCAnZmVlJ10sIFtdKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5pZCgpICsgJy90eC9jaGFuZ2VGZWUnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvIGZyb20gbWVyY2hhbnQgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy51cmwgVGhlIFVybCB0byByZXRyaWV2ZSBpbmZvIGZyb21cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgbWVyY2hhbnQgc2VydmVyXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBnZXRQYXltZW50SW5mbyhwYXJhbXM6IHsgdXJsPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXJsJ10sIFtdKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3BheW1lbnRJbmZvJykpLnF1ZXJ5KHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBqc29uIHBheW1lbnQgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1zIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnBheW1lbnRVcmwgLSBUaGUgdXJsIHRvIHNlbmQgdGhlIGZ1bGx5IHNpZ25lZCB0cmFuc2FjdGlvbiB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnR4SGV4IC0gVGhlIHRyYW5zYWN0aW9uIGhleCBvZiB0aGUgcGF5bWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1lbW8ge1N0cmluZ30gLSBBIG1lbW8gc3VwcGxpZWQgYnkgdGhlIG1lcmNoYW50LCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB0cmFuc2ZlciBhcyB0aGUgY29tbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmV4cGlyZXMge1N0cmluZ30gLSBJU08gRGF0ZSBmb3JtYXQgb2Ygd2hlbiB0aGUgcGF5bWVudCByZXF1ZXN0IGV4cGlyZXNcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgbWVyY2hhbnQgc2VydmVyIFBheW1lbnQgQWNrXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBzZW5kUGF5bWVudFJlc3BvbnNlKHBhcmFtczogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy9zZW5kUGF5bWVudCcpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcG9saWN5IHJ1bGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvbmRpdGlvbiBjb25kaXRpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBwYXJhbXMuYWN0aW9uIGFjdGlvbiBvYmplY3RcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBjcmVhdGVQb2xpY3lSdWxlKHBhcmFtczogQ3JlYXRlUG9saWN5UnVsZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCcsICd0eXBlJ10sIFsnbWVzc2FnZSddKTtcblxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMuY29uZGl0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogY29uZGl0aW9ucyBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGFjdGlvbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvcG9saWN5L3J1bGUnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHBvbGljeSBydWxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5jb25kaXRpb24gY29uZGl0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gcGFyYW1zLmFjdGlvbiBhY3Rpb24gb2JqZWN0XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgc2V0UG9saWN5UnVsZShwYXJhbXM6IGFueSA9IHt9KSB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCcsICd0eXBlJ10sIFsnbWVzc2FnZSddKTtcblxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMuY29uZGl0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogY29uZGl0aW9ucyBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGFjdGlvbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5wdXQodGhpcy51cmwoJy9wb2xpY3kvcnVsZScpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIFBvbGljeSBSdWxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyByZW1vdmVQb2xpY3lSdWxlKHBhcmFtczogUmVtb3ZlUG9saWN5UnVsZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbJ21lc3NhZ2UnXSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy9wb2xpY3kvcnVsZScpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyByZW1vdmUocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMudXJsKCkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYSBKU09OIHJlcHJlc2VudGFibGUgdmVyc2lvbiBvZiB0aGlzIHdhbGxldFxuICAgKi9cbiAgdG9KU09OKCk6IFdhbGxldERhdGEge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHJhZGluZyBhY2NvdW50IGZyb20gdGhpcyB3YWxsZXRcbiAgICovXG4gIHRvVHJhZGluZ0FjY291bnQoKTogVHJhZGluZ0FjY291bnQge1xuICAgIGlmICh0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnb2ZjJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBjb252ZXJ0IGFuIE9mZmNoYWluIChPRkMpIHdhbGxldCB0byBhIHRyYWRpbmcgYWNjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYWRpbmdBY2NvdW50KHRoaXMuX3dhbGxldC5lbnRlcnByaXNlLCB0aGlzLCB0aGlzLmJpdGdvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBkb3dubG9hZHMgUERGIGtleWNhcmQgZm9yIHdhbGxldCAocmVxdWlyZXMgcmVzcG9uc2UgZnJvbSB3YWxsZXRzLmdlbmVyYXRlV2FsbGV0KVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGlzIGV4YW1wbGUgY29kZSBhbmQgaXMgbm90IHRoZSB2ZXJzaW9uIHVzZWQgb24gYml0Z28uY29tXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogICAqIGpzUERGIC0gYW4gaW5zdGFuY2Ugb2YgdGhlIGpzUERGIGxpYnJhcnlcbiAgICogICAqIFFSQ29kZSAtIGFuIGluc3RhbmNlIG9mIHRoZSBRUmlvdXMgbGlicmFyeVxuICAgKiAgICogdXNlcktleWNoYWluIC0gYSB3YWxsZXQncyBwcml2YXRlIHVzZXIga2V5Y2hhaW5cbiAgICogICAqIGJhY2t1cEtleWNoYWluIC0gYSB3YWxsZXQncyBwcml2YXRlIGJhY2t1cCBrZXljaGFpblxuICAgKiAgICogYml0Z29LZXljaGFpbiAtIGEgd2FsbGV0J3MgcHJpdmF0ZSBiaXRnbyBrZXljaGFpblxuICAgKiAgICogcGFzc3BocmFzZSAtIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiAgICogcGFzc2NvZGVFbmNyeXB0aW9uQ29kZSAtIHRoZSBlbmNyeXB0aW9uIHNlY3JldCB1c2VkIGZvciBCb3ggRFxuICAgKiAgICogYWN0aXZhdGlvbkNvZGUgLSBhIHJhbmRvbWx5IGdlbmVyYXRlZCBzaXgtZGlnaXQgYWN0aXZhdGlvbiBjb2RlXG4gICAqICAgKiB3YWxsZXRLZXlJRCAtIHRoZSBLZXkgSUQgdXNlZCBmb3IgZGVyaXZpbmcgYSBjb2xkIHdhbGxldCdzIHNpZ25pbmcga2V5XG4gICAqICAgKiBiYWNrdXBLZXlJRCAtIHRoZSBLZXkgSUQgdXNlZCBmb3IgZGVyaXZpbmcgYSBjb2xkIHdhbGxldCdzIGJhY2t1cCBrZXlcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBkb3dubG9hZEtleWNhcmQocGFyYW1zOiBEb3dubG9hZEtleWNhcmRPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkb3dubG9hZEtleWNhcmQgZnVuY3Rpb24gaXMgb25seSBjYWxsYWJsZSB3aXRoaW4gYSBicm93c2VyLicpO1xuICAgIH1cblxuICAgIC8vIEdyYWIgcGFyYW1ldGVycyB3aXRoIGRlZmF1bHQgZm9yIGFjdGl2YXRpb25Db2RlXG4gICAgY29uc3Qge1xuICAgICAganNQREYsXG4gICAgICBRUkNvZGUsXG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBwYXNzcGhyYXNlLFxuICAgICAgcGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIHdhbGxldEtleUlELFxuICAgICAgYmFja3VwS2V5SUQsXG4gICAgICBhY3RpdmF0aW9uQ29kZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDkwMDAwMCArIDEwMDAwMCkudG9TdHJpbmcoKSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCFqc1BERiB8fCB0eXBlb2YganNQREYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgaW4gYSB2YWxpZCBqc1BERiBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGtleWNoYWluc1xuICAgIGlmICghdXNlcktleWNoYWluIHx8IHR5cGVvZiB1c2VyS2V5Y2hhaW4gIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdhbGxldCBrZXljaGFpbiBtdXN0IGhhdmUgYSAndXNlcicgcHJvcGVydHlgKTtcbiAgICB9XG5cbiAgICBpZiAoIWJhY2t1cEtleWNoYWluIHx8IHR5cGVvZiBiYWNrdXBLZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFja3VwIGtleWNoYWluIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmICghYml0Z29LZXljaGFpbiB8fCB0eXBlb2YgYml0Z29LZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0Z28ga2V5Y2hhaW4gaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHdhbGxldEtleUlEICYmIHR5cGVvZiB3YWxsZXRLZXlJRCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0S2V5SUQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChiYWNrdXBLZXlJRCAmJiB0eXBlb2YgYmFja3VwS2V5SUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhY2t1cEtleUlEIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBhY3RpdmF0aW9uIGNvZGUgaWYgcHJvdmlkZWRcbiAgICBpZiAodHlwZW9mIGFjdGl2YXRpb25Db2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3RpdmF0aW9uIENvZGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0aW9uQ29kZS5sZW5ndGggIT09IDYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aXZhdGlvbiBjb2RlIG11c3QgYmUgc2l4IGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2luU2hvcnROYW1lID0gdGhpcy5iYXNlQ29pbi50eXBlO1xuICAgIGNvbnN0IGNvaW5OYW1lID0gdGhpcy5iYXNlQ29pbi5nZXRGdWxsTmFtZSgpO1xuICAgIGNvbnN0IHdhbGxldExhYmVsID0gdGhpcy5fd2FsbGV0LmxhYmVsO1xuXG4gICAgY29uc3QgZG9jID0gZHJhd0tleWNhcmQoe1xuICAgICAganNQREYsXG4gICAgICBRUkNvZGUsXG4gICAgICBlbmNyeXB0OiB0aGlzLmJpdGdvLmVuY3J5cHQsXG4gICAgICBjb2luU2hvcnROYW1lLFxuICAgICAgY29pbk5hbWUsXG4gICAgICBhY3RpdmF0aW9uQ29kZSxcbiAgICAgIHdhbGxldExhYmVsLFxuICAgICAgcGFzc3BocmFzZSxcbiAgICAgIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICB3YWxsZXRLZXlJRCxcbiAgICAgIGJhY2t1cEtleUlELFxuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSB0aGUgUERGIG9uIHRoZSB1c2VyJ3MgYnJvd3NlclxuICAgIGRvYy5zYXZlKGBCaXRHbyBLZXljYXJkIGZvciAke3dhbGxldExhYmVsfS5wZGZgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzZXQgb2YgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbnMgZm9yIGEgd2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqICAgICBjb25zb2xpZGF0ZUFkZHJlc3NlcyAtIHRoZXNlIGFyZSB0aGUgb24tY2hhaW4gcmVjZWl2ZSBhZGRyZXNzZXMgd2Ugd2FudCB0byBwaWNrIGEgY29uc29saWRhdGlvbiBhbW91bnQgZnJvbVxuICAgKi9cbiAgYXN5bmMgYnVpbGRBY2NvdW50Q29uc29saWRhdGlvbnMoXG4gICAgcGFyYW1zOiBCdWlsZENvbnNvbGlkYXRpb25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHRbXT4ge1xuICAgIGlmICghdGhpcy5iYXNlQ29pbi5hbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKX0gZG9lcyBub3QgYWxsb3cgYWNjb3VudCBjb25zb2xpZGF0aW9ucy5gKTtcbiAgICB9XG5cbiAgICAvLyBXaGl0ZWxpc3QgcGFyYW1zIHRvIGJ1aWxkIHR4XG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCB0aGlzLnByZWJ1aWxkQ29uc29saWRhdGVBY2NvdW50UGFyYW1zKCkpO1xuICAgIGRlYnVnKCdwcmVidWlsZGluZyBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uOiAlTycsIHdoaXRlbGlzdGVkUGFyYW1zKTtcblxuICAgIGlmIChwYXJhbXMucmVxSWQpIHtcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgY291bGQgcmV0dXJuIDEwMCBidWlsZCB0cmFuc2FjdGlvbnNcbiAgICBjb25zdCBidWlsZFJlc3BvbnNlID0gKGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLmlkKCkgKyAnL2NvbnNvbGlkYXRlQWNjb3VudC9idWlsZCcpKVxuICAgICAgLnNlbmQod2hpdGVsaXN0ZWRQYXJhbXMpXG4gICAgICAucmVzdWx0KCkpIGFzIGFueTtcblxuICAgIC8vIHdlIG5lZWQgdG8gc3RlcCBvdmVyIGVhY2ggcHJlYnVpbGQgbm93IC0gc2hvdWxkIGJlIGluIGFuIGFycmF5IGluIHRoZSBib2R5XG4gICAgY29uc3QgY29uc29saWRhdGlvbnM6IFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHRbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgY29uc29saWRhdGVBY2NvdW50QnVpbGQgb2YgYnVpbGRSZXNwb25zZSkge1xuICAgICAgbGV0IHByZWJ1aWxkOiBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0ID0gKGF3YWl0IHRoaXMuYmFzZUNvaW4ucG9zdFByb2Nlc3NQcmVidWlsZChcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25zb2xpZGF0ZUFjY291bnRCdWlsZCwgeyB3YWxsZXQ6IHRoaXMsIGJ1aWxkUGFyYW1zOiB3aGl0ZWxpc3RlZFBhcmFtcyB9KVxuICAgICAgKSkgYXMgUHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdDtcblxuICAgICAgZGVsZXRlIHByZWJ1aWxkLndhbGxldDtcbiAgICAgIGRlbGV0ZSBwcmVidWlsZC5idWlsZFBhcmFtcztcblxuICAgICAgcHJlYnVpbGQgPSBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgd2FsbGV0SWQ6IHRoaXMuaWQoKSB9KTtcbiAgICAgIGRlYnVnKCdmaW5hbCBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uIHByZWJ1aWxkOiAlTycsIHByZWJ1aWxkKTtcblxuICAgICAgY29uc29saWRhdGlvbnMucHVzaChwcmVidWlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnNvbGlkYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhbmQgc2VuZHMgYSBzZXQgb2YgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbnMgZm9yIGEgd2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqICAgICBwcmVidWlsZFR4ICAgLSB0aGlzIGlzIHRoZSBwcmUtYnVpbGQgY29uc29saWRhdGlvbiB0eC4gdGhpcyBpcyBhIG5vcm1hbGx5IGJ1aWx0IHR4IHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgIGFuIGFkZGl0aW9uYWwgcGFyYW1ldGVyIG9mIGNvbnNvbGlkYXRlSWQuXG4gICAqICAgICB2ZXJpZmljYXRpb24gLSBub3JtYWwga2V5Y2hhaW5zLCBldGMuIGZvciB2ZXJpZmljYXRpb25cbiAgICovXG4gIGFzeW5jIHNlbmRBY2NvdW50Q29uc29saWRhdGlvbihwYXJhbXM6IFByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmJhc2VDb2luLmdldEZ1bGxOYW1lKCl9IGRvZXMgbm90IGFsbG93IGFjY291bnQgY29uc29saWRhdGlvbnMuYCk7XG4gICAgfVxuXG4gICAgLy8gb25lIG9mIGEgc2V0IG9mIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucHJlYnVpbGRUeCA9PT0gJ3N0cmluZycgfHwgcGFyYW1zLnByZWJ1aWxkVHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1aWxkIG9mIGFjY291bnQgY29uc29saWRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wcmVidWlsZFR4LmNvbnNvbGlkYXRlSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgY29uc29saWRhdGlvbiBpZCBvbiBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl93YWxsZXQubXVsdGlzaWdUeXBlID09PSAndHNzJykge1xuICAgICAgaWYgKCFwYXJhbXMucHJlYnVpbGRUeC50eFJlcXVlc3RJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnNvbGlkYXRpb24gcmVxdWVzdCBtaXNzaW5nIHR4UmVxdWVzdElkLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kTWFueVRzcyhwYXJhbXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lZFByZWJ1aWxkID0gKGF3YWl0IHRoaXMucHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSkgYXMgYW55O1xuXG4gICAgLy8gZGVjb3JhdGUgd2l0aCBvdXIgY29uc29saWRhdGlvbiBpZFxuICAgIHNpZ25lZFByZWJ1aWxkLmNvbnNvbGlkYXRlSWQgPSBwYXJhbXMucHJlYnVpbGRUeC5jb25zb2xpZGF0ZUlkO1xuXG4gICAgZGVsZXRlIHNpZ25lZFByZWJ1aWxkLndhbGxldDtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNpZ25lZFByZWJ1aWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW5kIHNlbmRzIGEgc2V0IG9mIGFjY291bnQgY29uc29saWRhdGlvbnMuIFRoaXMgaXMgaW50ZW5kZWQgdG8gZmx1c2ggbWFueSBiYWxhbmNlcyB0byB0aGUgcm9vdCB3YWxsZXQgYmFsYW5jZS5cbiAgICogQHBhcmFtIHBhcmFtcyAtXG4gICAqICAgICBjb25zb2xpZGF0ZUFkZHJlc3NlcyAtIHRoZXNlIGFyZSB0aGUgb24tY2hhaW4gcmVjZWl2ZSBhZGRyZXNzZXMgd2Ugd2FudCB0byBwaWNrIGEgY29uc29saWRhdGlvbiBhbW91bnQgZnJvbVxuICAgKi9cbiAgYXN5bmMgc2VuZEFjY291bnRDb25zb2xpZGF0aW9ucyhwYXJhbXM6IEJ1aWxkQ29uc29saWRhdGlvblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmJhc2VDb2luLmdldEZ1bGxOYW1lKCl9IGRvZXMgbm90IGFsbG93IGFjY291bnQgY29uc29saWRhdGlvbnMuYCk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBnaXZlcyB1cyBhIHNldCBvZiBhY2NvdW50IGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zXG4gICAgY29uc3QgdW5zaWduZWRCdWlsZHMgPSAoYXdhaXQgdGhpcy5idWlsZEFjY291bnRDb25zb2xpZGF0aW9ucyhwYXJhbXMpKSBhcyBhbnk7XG4gICAgaWYgKHVuc2lnbmVkQnVpbGRzICYmIHVuc2lnbmVkQnVpbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxUeHM6IGFueVtdID0gW107XG4gICAgICBjb25zdCBmYWlsZWRUeHMgPSBuZXcgQXJyYXk8RXJyb3I+KCk7XG4gICAgICBmb3IgKGNvbnN0IHVuc2lnbmVkQnVpbGQgb2YgdW5zaWduZWRCdWlsZHMpIHtcbiAgICAgICAgLy8gZm9sZCBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgd2UgdXNlZCB0byBidWlsZCB0aGlzIHRyYW5zYWN0aW9uIGludG8gdGhlIHVuc2lnbmVkQnVpbGRcbiAgICAgICAgY29uc3QgdW5zaWduZWRCdWlsZFdpdGhPcHRpb25zOiBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICB1bnNpZ25lZEJ1aWxkV2l0aE9wdGlvbnMucHJlYnVpbGRUeCA9IHVuc2lnbmVkQnVpbGQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2VuZFR4ID0gYXdhaXQgdGhpcy5zZW5kQWNjb3VudENvbnNvbGlkYXRpb24odW5zaWduZWRCdWlsZFdpdGhPcHRpb25zKTtcbiAgICAgICAgICBzdWNjZXNzZnVsVHhzLnB1c2goc2VuZFR4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZGlyKGUpO1xuICAgICAgICAgIGZhaWxlZFR4cy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NmdWxUeHMsXG4gICAgICAgIGZhaWx1cmU6IGZhaWxlZFR4cyxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyogTUFSSzogVFNTIEhlbHBlcnMgKi9cblxuICAvKipcbiAgICogUHJlYnVpbGRzIGEgdHJhbnNhY3Rpb24gZm9yIGEgVFNTIHdhbGxldC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyBwcmVidWlsZCB0cmFuc2FjdGlvbiBvcHRpb25zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByZWJ1aWxkVHJhbnNhY3Rpb25Uc3MocGFyYW1zOiBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgcmVxSWQgPSBwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuXG4gICAgbGV0IHVuc2lnbmVkVHhSZXF1ZXN0OiBUeFJlcXVlc3Q7XG4gICAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgICAgY2FzZSAndHJhbnNmZXInOlxuICAgICAgICB1bnNpZ25lZFR4UmVxdWVzdCA9IGF3YWl0IHRoaXMudHNzVXRpbHMucHJlYnVpbGRUeFdpdGhJbnRlbnQoe1xuICAgICAgICAgIHJlcUlkLFxuICAgICAgICAgIGludGVudFR5cGU6ICdwYXltZW50JyxcbiAgICAgICAgICBzZXF1ZW5jZUlkOiBwYXJhbXMuc2VxdWVuY2VJZCxcbiAgICAgICAgICBjb21tZW50OiBwYXJhbXMuY29tbWVudCxcbiAgICAgICAgICByZWNpcGllbnRzOiBwYXJhbXMucmVjaXBpZW50cyB8fCBbXSxcbiAgICAgICAgICBtZW1vOiBwYXJhbXMubWVtbyxcbiAgICAgICAgICBub25jZTogcGFyYW1zLm5vbmNlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmFibGV0b2tlbic6XG4gICAgICAgIHVuc2lnbmVkVHhSZXF1ZXN0ID0gYXdhaXQgdGhpcy50c3NVdGlscy5wcmVidWlsZFR4V2l0aEludGVudCh7XG4gICAgICAgICAgcmVxSWQsXG4gICAgICAgICAgaW50ZW50VHlwZTogJ2NyZWF0ZUFjY291bnQnLFxuICAgICAgICAgIHJlY2lwaWVudHM6IHBhcmFtcy5yZWNpcGllbnRzIHx8IFtdLFxuICAgICAgICAgIHRva2VuTmFtZTogcGFyYW1zLnRva2VuTmFtZSxcbiAgICAgICAgICBtZW1vOiBwYXJhbXMubWVtbyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2FjdGlvbiB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICR7cGFyYW1zLnR5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5zaWduZWRUeHMgPSB1bnNpZ25lZFR4UmVxdWVzdC51bnNpZ25lZFR4cztcbiAgICBpZiAodW5zaWduZWRUeHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc2luZ2xlIHVuc2lnbmVkIHR4IGZvciB0eCByZXF1ZXN0IHdpdGggaWQ6ICR7dW5zaWduZWRUeFJlcXVlc3QudHhSZXF1ZXN0SWR9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCB0aGlzLnByZWJ1aWxkV2hpdGVsaXN0ZWRQYXJhbXMoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLmlkKCksXG4gICAgICB3YWxsZXQ6IHRoaXMsXG4gICAgICB0eFJlcXVlc3RJZDogdW5zaWduZWRUeFJlcXVlc3QudHhSZXF1ZXN0SWQsXG4gICAgICB0eEhleDogdW5zaWduZWRUeHNbMF0uc2VyaWFsaXplZFR4SGV4LFxuICAgICAgYnVpbGRQYXJhbXM6IHdoaXRlbGlzdGVkUGFyYW1zLFxuICAgICAgZmVlSW5mbzogdW5zaWduZWRUeHNbMF0uZmVlSW5mbyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24gZnJvbSBhIFRTUyB3YWxsZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgc2lnbmluZyBvcHRpb25zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNpZ25UcmFuc2FjdGlvblRzcyhwYXJhbXM6IFdhbGxldFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBpZiAoIXBhcmFtcy50eFByZWJ1aWxkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4UHJlYnVpbGQgcmVxdWlyZWQgdG8gc2lnbiB0cmFuc2FjdGlvbnMgd2l0aCBUU1MnKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy50eFByZWJ1aWxkLnR4UmVxdWVzdElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4UmVxdWVzdElkIHJlcXVpcmVkIHRvIHNpZ24gdHJhbnNhY3Rpb25zIHdpdGggVFNTJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BydiByZXF1aXJlZCB0byBzaWduIHRyYW5zYWN0aW9ucyB3aXRoIFRTUycpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduZWRUeFJlcXVlc3QgPSBhd2FpdCB0aGlzLnRzc1V0aWxzLnNpZ25UeFJlcXVlc3Qoe1xuICAgICAgICB0eFJlcXVlc3Q6IHBhcmFtcy50eFByZWJ1aWxkLnR4UmVxdWVzdElkLFxuICAgICAgICBwcnY6IHBhcmFtcy5wcnYsXG4gICAgICAgIHJlcUlkOiBwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhSZXF1ZXN0SWQ6IHNpZ25lZFR4UmVxdWVzdC50eFJlcXVlc3RJZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvbiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcywgc2lnbnMsIGFuZCBzZW5kcyBhIHRyYW5zYWN0aW9uIGZyb20gYSBUU1Mgd2FsbGV0LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIHNlbmQgb3B0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZW5kTWFueVRzcyhwYXJhbXM6IFNlbmRNYW55T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcykpIGFzIFNpZ25lZFRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICBpZiAoIXNpZ25lZFRyYW5zYWN0aW9uLnR4UmVxdWVzdElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4UmVxdWVzdElkIG1pc3NpbmcgZnJvbSBzaWduZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50c3NVdGlscy5zZW5kVHhSZXF1ZXN0KHNpZ25lZFRyYW5zYWN0aW9uLnR4UmVxdWVzdElkKTtcbiAgfVxufVxuIl19