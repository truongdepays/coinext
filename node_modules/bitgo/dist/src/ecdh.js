"use strict";
/**
 * @prettier
 *
 * Utility methods for Ellipic-Curve Diffie-Hellman (ECDH) shared secret generation
 *
 * > Elliptic-curve Diffie–Hellman (ECDH) is a key agreement protocol that allows two parties, each having an
 * > elliptic-curve public–private key pair, to establish a shared secret over an insecure channel.
 * > This shared secret may be directly used as a key, or to derive another key. The key, or the derived key, can then
 * > be used to encrypt subsequent communications using a symmetric-key cipher. It is a variant of the Diffie–Hellman
 * > protocol using elliptic-curve cryptography.
 *
 * https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSharedSecret = void 0;
const assert = require("assert");
const secp256k1 = require("secp256k1");
/**
 * Calculate the Elliptic Curve Diffie Hellman
 * @param privateKey HDNode of private key
 * @param publicKey [neutered] HDNode of public key
 * @returns Buffer public key buffer that can be used as shared secret (see note)
 */
function getSharedSecret(privateKey, publicKey) {
    function isBIP32Interface(k) {
        return k.constructor.name === 'BIP32';
    }
    function isECPairInterface(k) {
        return k.constructor.name === 'ECPair';
    }
    if (isBIP32Interface(privateKey)) {
        if (!privateKey.privateKey) {
            throw new Error(`privateNode must be private key`);
        }
        privateKey = privateKey.privateKey;
    }
    else if (isECPairInterface(privateKey)) {
        if (privateKey.privateKey === undefined || !Buffer.isBuffer(privateKey.privateKey)) {
            throw new Error(`unexpected ECPair`);
        }
        privateKey = privateKey.privateKey;
    }
    if (!Buffer.isBuffer(publicKey)) {
        publicKey = publicKey.publicKey;
    }
    if (!Buffer.isBuffer(privateKey) || !Buffer.isBuffer(publicKey)) {
        throw new Error(`invalid state`);
    }
    assert.strictEqual(privateKey.length, 32);
    assert.strictEqual(publicKey.length, 33);
    // FIXME(BG-34386): we should use `secp256k1.ecdh()` in the future
    //                  see discussion here https://github.com/bitcoin-core/secp256k1/issues/352
    const buffer = Buffer.from(secp256k1.publicKeyTweakMul(publicKey, privateKey))
        // remove leading parity bit
        .slice(1);
    assert.strictEqual(buffer.length, 32);
    return buffer;
}
exports.getSharedSecret = getSharedSecret;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lY2RoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7O0dBWUc7OztBQUVILGlDQUFpQztBQUVqQyx1Q0FBdUM7QUFHdkM7Ozs7O0dBS0c7QUFDSCxTQUFnQixlQUFlLENBQzdCLFVBQTBFLEVBQzFFLFNBQXdDO0lBRXhDLFNBQVMsZ0JBQWdCLENBQUMsQ0FBTTtRQUM5QixPQUFPLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQztJQUN4QyxDQUFDO0lBQ0QsU0FBUyxpQkFBaUIsQ0FBQyxDQUFNO1FBQy9CLE9BQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO0lBQ3pDLENBQUM7SUFDRCxJQUFJLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRDtRQUNELFVBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO0tBQ3BDO1NBQU0sSUFBSSxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUN4QyxJQUFJLFVBQVUsQ0FBQyxVQUFVLEtBQUssU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDbEYsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsVUFBVSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUM7S0FDcEM7SUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUMvQixTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQztLQUNqQztJQUVELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUMvRCxNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ2xDO0lBRUQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztJQUV6QyxrRUFBa0U7SUFDbEUsNEZBQTRGO0lBQzVGLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUM1RSw0QkFBNEI7U0FDM0IsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1osTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3RDLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUF4Q0QsMENBd0NDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZHMgZm9yIEVsbGlwaWMtQ3VydmUgRGlmZmllLUhlbGxtYW4gKEVDREgpIHNoYXJlZCBzZWNyZXQgZ2VuZXJhdGlvblxuICpcbiAqID4gRWxsaXB0aWMtY3VydmUgRGlmZmll4oCTSGVsbG1hbiAoRUNESCkgaXMgYSBrZXkgYWdyZWVtZW50IHByb3RvY29sIHRoYXQgYWxsb3dzIHR3byBwYXJ0aWVzLCBlYWNoIGhhdmluZyBhblxuICogPiBlbGxpcHRpYy1jdXJ2ZSBwdWJsaWPigJNwcml2YXRlIGtleSBwYWlyLCB0byBlc3RhYmxpc2ggYSBzaGFyZWQgc2VjcmV0IG92ZXIgYW4gaW5zZWN1cmUgY2hhbm5lbC5cbiAqID4gVGhpcyBzaGFyZWQgc2VjcmV0IG1heSBiZSBkaXJlY3RseSB1c2VkIGFzIGEga2V5LCBvciB0byBkZXJpdmUgYW5vdGhlciBrZXkuIFRoZSBrZXksIG9yIHRoZSBkZXJpdmVkIGtleSwgY2FuIHRoZW5cbiAqID4gYmUgdXNlZCB0byBlbmNyeXB0IHN1YnNlcXVlbnQgY29tbXVuaWNhdGlvbnMgdXNpbmcgYSBzeW1tZXRyaWMta2V5IGNpcGhlci4gSXQgaXMgYSB2YXJpYW50IG9mIHRoZSBEaWZmaWXigJNIZWxsbWFuXG4gKiA+IHByb3RvY29sIHVzaW5nIGVsbGlwdGljLWN1cnZlIGNyeXB0b2dyYXBoeS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbGxpcHRpYy1jdXJ2ZV9EaWZmaWUlRTIlODAlOTNIZWxsbWFuXG4gKi9cblxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBiaXAzMiBmcm9tICdiaXAzMic7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBIRE5vZGUgb2YgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSBwdWJsaWNLZXkgW25ldXRlcmVkXSBIRE5vZGUgb2YgcHVibGljIGtleVxuICogQHJldHVybnMgQnVmZmVyIHB1YmxpYyBrZXkgYnVmZmVyIHRoYXQgY2FuIGJlIHVzZWQgYXMgc2hhcmVkIHNlY3JldCAoc2VlIG5vdGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQoXG4gIHByaXZhdGVLZXk6IGJpcDMyLkJJUDMySW50ZXJmYWNlIHwgdXR4b2xpYi5FQ1BhaXIuRUNQYWlySW50ZXJmYWNlIHwgQnVmZmVyLFxuICBwdWJsaWNLZXk6IGJpcDMyLkJJUDMySW50ZXJmYWNlIHwgQnVmZmVyXG4pOiBCdWZmZXIge1xuICBmdW5jdGlvbiBpc0JJUDMySW50ZXJmYWNlKGs6IGFueSk6IGsgaXMgYmlwMzIuQklQMzJJbnRlcmZhY2Uge1xuICAgIHJldHVybiBrLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCSVAzMic7XG4gIH1cbiAgZnVuY3Rpb24gaXNFQ1BhaXJJbnRlcmZhY2UoazogYW55KTogayBpcyB1dHhvbGliLkVDUGFpci5FQ1BhaXJJbnRlcmZhY2Uge1xuICAgIHJldHVybiBrLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdFQ1BhaXInO1xuICB9XG4gIGlmIChpc0JJUDMySW50ZXJmYWNlKHByaXZhdGVLZXkpKSB7XG4gICAgaWYgKCFwcml2YXRlS2V5LnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZU5vZGUgbXVzdCBiZSBwcml2YXRlIGtleWApO1xuICAgIH1cbiAgICBwcml2YXRlS2V5ID0gcHJpdmF0ZUtleS5wcml2YXRlS2V5O1xuICB9IGVsc2UgaWYgKGlzRUNQYWlySW50ZXJmYWNlKHByaXZhdGVLZXkpKSB7XG4gICAgaWYgKHByaXZhdGVLZXkucHJpdmF0ZUtleSA9PT0gdW5kZWZpbmVkIHx8ICFCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleS5wcml2YXRlS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIEVDUGFpcmApO1xuICAgIH1cbiAgICBwcml2YXRlS2V5ID0gcHJpdmF0ZUtleS5wcml2YXRlS2V5O1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5KSkge1xuICAgIHB1YmxpY0tleSA9IHB1YmxpY0tleS5wdWJsaWNLZXk7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5KSB8fCAhQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc3RhdGVgKTtcbiAgfVxuXG4gIGFzc2VydC5zdHJpY3RFcXVhbChwcml2YXRlS2V5Lmxlbmd0aCwgMzIpO1xuICBhc3NlcnQuc3RyaWN0RXF1YWwocHVibGljS2V5Lmxlbmd0aCwgMzMpO1xuXG4gIC8vIEZJWE1FKEJHLTM0Mzg2KTogd2Ugc2hvdWxkIHVzZSBgc2VjcDI1NmsxLmVjZGgoKWAgaW4gdGhlIGZ1dHVyZVxuICAvLyAgICAgICAgICAgICAgICAgIHNlZSBkaXNjdXNzaW9uIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4tY29yZS9zZWNwMjU2azEvaXNzdWVzLzM1MlxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwocHVibGljS2V5LCBwcml2YXRlS2V5KSlcbiAgICAvLyByZW1vdmUgbGVhZGluZyBwYXJpdHkgYml0XG4gICAgLnNsaWNlKDEpO1xuICBhc3NlcnQuc3RyaWN0RXF1YWwoYnVmZmVyLmxlbmd0aCwgMzIpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuIl19