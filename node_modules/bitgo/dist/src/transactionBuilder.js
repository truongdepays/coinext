"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TransactionBuilder
// A utility for building and signing transactions
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
const bip32 = require("bip32");
const Bluebird = require("bluebird");
const utxolib = require("@bitgo/utxo-lib");
const _ = require("lodash");
const unspents_1 = require("@bitgo/unspents");
const bitcoin_1 = require("./bitcoin");
const debugLib = require("debug");
const debug = debugLib('bitgo:v1:txb');
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_api_1 = require("@bitgo/sdk-api");
//
// TransactionBuilder
// @params:
//   wallet:  a wallet object to send from
//   recipients: array of recipient objects and the amount to send to each e.g. [{address: '38BKDNZbPcLogvVbcx2ekJ9E6Vv94DqDqw', amount: 1500}, {address: '36eL8yQqCn1HMRmVFFo49t2PJ3pai8wQam', amount: 2000}]
//   fee: the fee to use with this transaction.  if not provided, a default, minimum fee will be used.
//   feeRate: the amount of fee per kilobyte - optional - specify either fee, feeRate, or feeTxConfirmTarget but not more than one
//   feeTxConfirmTarget: calculate the fees per kilobyte such that the transaction will be confirmed in this number of blocks
//   maxFeeRate: The maximum fee per kb to use in satoshis, for safety purposes when using dynamic fees
//   minConfirms: the minimum confirmations an output must have before spending
//   forceChangeAtEnd: force the change address to be the last output
//   changeAddress: specify the change address rather than generate a new one
//   noSplitChange: set to true to disable automatic change splitting for purposes of unspent management
//   targetWalletUnspents: specify a number of target unspents to maintain in the wallet (currently defaulted to 8 by the server)
//   validate: extra verification of the change addresses, which is always done server-side and is redundant client-side (defaults true)
//   minUnspentSize: The minimum size in satoshis of unspent to use (to prevent spending unspents worth less than fee added). Defaults to 0.
//   feeSingleKeySourceAddress: Use this single key address to pay fees
//   feeSingleKeyWIF: Use the address based on this private key to pay fees
//   unspentsFetchParams: Extra parameters to use for fetching unspents for this transaction
exports.createTransaction = function (params) {
    const minConfirms = params.minConfirms || 0;
    const validate = params.validate === undefined ? true : params.validate;
    let recipients = [];
    let opReturns = [];
    let extraChangeAmounts = [];
    let estTxSize;
    let travelInfos;
    // Sanity check the arguments passed in
    if (!_.isObject(params.wallet) ||
        (params.fee && !_.isNumber(params.fee)) ||
        (params.feeRate && !_.isNumber(params.feeRate)) ||
        !_.isInteger(minConfirms) ||
        (params.forceChangeAtEnd && !_.isBoolean(params.forceChangeAtEnd)) ||
        (params.changeAddress && !_.isString(params.changeAddress)) ||
        (params.noSplitChange && !_.isBoolean(params.noSplitChange)) ||
        (params.targetWalletUnspents && !_.isInteger(params.targetWalletUnspents)) ||
        (validate && !_.isBoolean(validate)) ||
        (params.enforceMinConfirmsForChange && !_.isBoolean(params.enforceMinConfirmsForChange)) ||
        (params.minUnspentSize && !_.isNumber(params.minUnspentSize)) ||
        (params.maxFeeRate && !_.isNumber(params.maxFeeRate)) ||
        // this should be an array and its length must be at least 1
        (params.unspents && (!Array.isArray(params.unspents) || params.unspents.length < 1)) ||
        (params.feeTxConfirmTarget && !_.isInteger(params.feeTxConfirmTarget)) ||
        (params.instant && !_.isBoolean(params.instant)) ||
        (params.bitgoFee && !_.isObject(params.bitgoFee)) ||
        (params.unspentsFetchParams && !_.isObject(params.unspentsFetchParams))) {
        throw new Error('invalid argument');
    }
    const bitgo = params.wallet.bitgo;
    const constants = bitgo.getConstants();
    const network = bitcoin_1.getNetwork(sdk_core_1.common.Environments[bitgo.getEnv()].network);
    // The user can specify a seperate, single-key wallet for the purposes of paying miner's fees
    // When creating a transaction this can be specified as an input address or the private key in WIF
    let feeSingleKeySourceAddress;
    let feeSingleKeyInputAmount = 0;
    if (params.feeSingleKeySourceAddress) {
        try {
            utxolib.address.fromBase58Check(params.feeSingleKeySourceAddress, network);
            feeSingleKeySourceAddress = params.feeSingleKeySourceAddress;
        }
        catch (e) {
            throw new Error('invalid bitcoin address: ' + params.feeSingleKeySourceAddress);
        }
    }
    if (params.feeSingleKeyWIF) {
        const feeSingleKey = utxolib.ECPair.fromWIF(params.feeSingleKeyWIF, network);
        feeSingleKeySourceAddress = bitcoin_1.getAddressP2PKH(feeSingleKey);
        // If the user specifies both, check to make sure the feeSingleKeySourceAddress corresponds to the address of feeSingleKeyWIF
        if (params.feeSingleKeySourceAddress &&
            params.feeSingleKeySourceAddress !== feeSingleKeySourceAddress) {
            throw new Error('feeSingleKeySourceAddress: ' + params.feeSingleKeySourceAddress +
                ' did not correspond to address of feeSingleKeyWIF: ' + feeSingleKeySourceAddress);
        }
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    let feeParamsDefined = 0;
    if (!_.isUndefined(params.fee)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeRate)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeTxConfirmTarget)) {
        feeParamsDefined++;
    }
    if (feeParamsDefined > 1) {
        throw new Error('cannot specify more than one of fee, feeRate and feeTxConfirmTarget');
    }
    if (_.isUndefined(params.maxFeeRate)) {
        params.maxFeeRate = constants.maxFeeRate;
    }
    // Convert the old format of params.recipients (dictionary of address:amount) to new format: { destinationAddress, amount }
    if (!(params.recipients instanceof Array)) {
        recipients = [];
        Object.keys(params.recipients).forEach(function (destinationAddress) {
            const amount = params.recipients[destinationAddress];
            recipients.push({ address: destinationAddress, amount: amount });
        });
    }
    else {
        recipients = params.recipients;
    }
    if (params.opReturns) {
        if (!(params.opReturns instanceof Array)) {
            opReturns = [];
            Object.keys(params.opReturns).forEach(function (message) {
                const amount = params.opReturns[message];
                opReturns.push({ message, amount });
            });
        }
        else {
            opReturns = params.opReturns;
        }
    }
    if (recipients.length === 0 && opReturns.length === 0) {
        throw new Error('must have at least one recipient');
    }
    let fee = params.fee;
    let feeRate = params.feeRate;
    // Flag indicating whether this class will compute the fee
    const shouldComputeBestFee = (_.isUndefined(fee));
    let totalOutputAmount = 0;
    recipients.forEach(function (recipient) {
        if (_.isString(recipient.address)) {
            try {
                utxolib.address.fromBase58Check(recipient.address, network);
            }
            catch (e) {
                throw new Error('invalid bitcoin address: ' + recipient.address);
            }
            if (!!recipient.script) {
                // A script was provided as well - validate that the address corresponds to that
                if (utxolib.address.toOutputScript(recipient.address, network).toString('hex') !== recipient.script) {
                    throw new Error('both script and address provided but they did not match: ' + recipient.address + ' ' + recipient.script);
                }
            }
        }
        if (!_.isInteger(recipient.amount) || recipient.amount < 0) {
            throw new Error('invalid amount for ' + recipient.address + ': ' + recipient.amount);
        }
        totalOutputAmount += recipient.amount;
    });
    opReturns.forEach(function (opReturn) {
        totalOutputAmount += opReturn.amount;
    });
    let bitgoFeeInfo = params.bitgoFee;
    if (bitgoFeeInfo &&
        (!_.isInteger(bitgoFeeInfo.amount) || !_.isString(bitgoFeeInfo.address))) {
        throw new Error('invalid bitgoFeeInfo');
    }
    // The total amount needed for this transaction.
    let totalAmount = totalOutputAmount + (fee || 0);
    // The list of unspent transactions being used in this transaction.
    let unspents;
    // the total number of unspents on this wallet
    let totalUnspentsCount;
    // the number of unspents we fetched from the server, before filtering
    let fetchedUnspentsCount;
    // The list of unspent transactions being used with zero-confirmations
    let zeroConfUnspentTxIds;
    // The sum of the input values for this transaction.
    let inputAmount;
    let changeOutputs = [];
    // The transaction.
    let transaction = utxolib.bitgo.createTransactionBuilderForNetwork(network);
    const getBitGoFee = function () {
        return Bluebird.try(function () {
            if (bitgoFeeInfo) {
                return;
            }
            return params.wallet.getBitGoFee({ amount: totalOutputAmount, instant: params.instant })
                .then(function (result) {
                if (result && result.fee > 0) {
                    bitgoFeeInfo = {
                        amount: result.fee,
                    };
                }
            });
        })
            .then(function () {
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                totalAmount += bitgoFeeInfo.amount;
            }
        });
    };
    const getBitGoFeeAddress = function () {
        return Bluebird.try(function () {
            // If we don't have bitgoFeeInfo, or address is already set, don't get a new one
            if (!bitgoFeeInfo || bitgoFeeInfo.address) {
                return;
            }
            return bitgo.getBitGoFeeAddress()
                .then(function (result) {
                bitgoFeeInfo.address = result.address;
            });
        });
    };
    // Get a dynamic fee estimate from the BitGo server if feeTxConfirmTarget
    // is specified or if no fee-related params are specified
    const getDynamicFeeRateEstimate = function () {
        if (params.feeTxConfirmTarget || !feeParamsDefined) {
            return bitgo.estimateFee({
                numBlocks: params.feeTxConfirmTarget,
                maxFee: params.maxFeeRate,
                inputs: zeroConfUnspentTxIds,
                txSize: estTxSize,
                cpfpAware: true,
            })
                .then(function (result) {
                const estimatedFeeRate = result.cpfpFeePerKb;
                const minimum = params.instant ? Math.max(constants.minFeeRate, constants.minInstantFeeRate) : constants.minFeeRate;
                // 5 satoshis per byte
                // it is worth noting that the padding only applies when the threshold is crossed, but not when the delta is less than the padding
                const padding = 5000;
                if (estimatedFeeRate < minimum) {
                    console.log(new Date() + ': Error when estimating fee for send from ' + params.wallet.id() + ', it was too low - ' + estimatedFeeRate);
                    feeRate = minimum + padding;
                }
                else if (estimatedFeeRate > params.maxFeeRate) {
                    feeRate = params.maxFeeRate - padding;
                }
                else {
                    feeRate = estimatedFeeRate;
                }
                return feeRate;
            })
                .catch(function (e) {
                // sanity check failed on tx size
                if (_.includes(e.message, 'invalid txSize')) {
                    return Bluebird.reject(e);
                }
                else {
                    // couldn't estimate the fee, proceed using the default
                    feeRate = constants.fallbackFeeRate;
                    console.log('Error estimating fee for send from ' + params.wallet.id() + ': ' + e.message);
                    return Bluebird.resolve();
                }
            });
        }
    };
    // Get the unspents for the sending wallet.
    const getUnspents = function () {
        if (params.unspents) { // we just wanna use custom unspents
            unspents = params.unspents;
            return;
        }
        // Get enough unspents for the requested amount
        const options = _.merge({}, params.unspentsFetchParams || {}, {
            target: totalAmount,
            minSize: params.minUnspentSize || 0,
            instant: params.instant,
            targetWalletUnspents: params.targetWalletUnspents,
        });
        if (params.instant) {
            options.instant = params.instant; // insist on instant unspents only
        }
        return params.wallet.unspentsPaged(options)
            .then(function (results) {
            totalUnspentsCount = results.total;
            fetchedUnspentsCount = results.count;
            unspents = results.unspents.filter(function (u) {
                const confirms = u.confirmations || 0;
                if (!params.enforceMinConfirmsForChange && u.isChange) {
                    return true;
                }
                return confirms >= minConfirms;
            });
            // abort early if there's no viable unspents, because it won't be possible to create the txn later
            if (unspents.length === 0) {
                throw Error('0 unspents available for transaction creation');
            }
            // create array of unconfirmed unspent ID strings of the form "txHash:outputIndex"
            zeroConfUnspentTxIds = _(results.unspents).filter(function (u) {
                return !u.confirmations;
            }).map(function (u) {
                return u.tx_hash + ':' + u.tx_output_n;
            }).value();
            if (_.isEmpty(zeroConfUnspentTxIds)) {
                // we don't want to pass an empty array of inputs to the server, because it assumes if the
                // inputs arguments exists, it contains values
                zeroConfUnspentTxIds = undefined;
            }
            // For backwards compatibility, respect the old splitChangeSize=0 parameter
            if (!params.noSplitChange && params.splitChangeSize !== 0) {
                extraChangeAmounts = results.extraChangeAmounts || [];
            }
        });
    };
    // Get the unspents for the single key fee address
    let feeSingleKeyUnspents = [];
    const getUnspentsForSingleKey = function () {
        if (feeSingleKeySourceAddress) {
            let feeTarget = 0.01e8;
            if (params.instant) {
                feeTarget += totalAmount * 0.001;
            }
            return bitgo.get(bitgo.url('/address/' + feeSingleKeySourceAddress + '/unspents?target=' + feeTarget))
                .then(function (response) {
                if (response.body.total <= 0) {
                    throw new Error('No unspents available in single key fee source');
                }
                feeSingleKeyUnspents = response.body.unspents;
            });
        }
    };
    let minerFeeInfo = {};
    let txInfo = {};
    // Iterate unspents, sum the inputs, and save _inputs with the total
    // input amount and final list of inputs to use with the transaction.
    let feeSingleKeyUnspentsUsed = [];
    const collectInputs = function () {
        if (!unspents.length) {
            throw new Error('no unspents available on wallet');
        }
        inputAmount = 0;
        // Calculate the cost of spending a single input, i.e. the smallest economical unspent value
        return Bluebird.try(function () {
            if (_.isNumber(params.feeRate) || _.isNumber(params.originalFeeRate)) {
                return (!_.isUndefined(params.feeRate) ? params.feeRate : params.originalFeeRate);
            }
            else {
                return bitgo.estimateFee({
                    numBlocks: params.feeTxConfirmTarget,
                    maxFee: params.maxFeeRate,
                })
                    .then(function (feeRateEstimate) {
                    return feeRateEstimate.feePerKb;
                });
            }
        }).then(function (feeRate) {
            // Don't spend inputs that cannot pay for their own cost.
            let minInputValue = 0;
            if (_.isInteger(params.minUnspentSize)) {
                minInputValue = params.minUnspentSize;
            }
            let prunedUnspentCount = 0;
            const originalUnspentCount = unspents.length;
            unspents = _.filter(unspents, function (unspent) {
                const isSegwitInput = !!unspent.witnessScript;
                const currentInputSize = isSegwitInput ? unspents_1.VirtualSizes.txP2shP2wshInputSize : unspents_1.VirtualSizes.txP2shInputSize;
                const feeBasedMinInputValue = (feeRate * currentInputSize) / 1000;
                const currentMinInputValue = Math.max(minInputValue, feeBasedMinInputValue);
                if (currentMinInputValue > unspent.value) {
                    // pruning unspent
                    const pruneDetails = {
                        generalMinInputValue: minInputValue,
                        feeBasedMinInputValue,
                        currentMinInputValue,
                        feeRate,
                        inputSize: currentInputSize,
                        unspent: unspent,
                    };
                    console.log(`pruning unspent: ${JSON.stringify(pruneDetails, null, 4)}`);
                    prunedUnspentCount++;
                    return false;
                }
                return true;
            });
            if (prunedUnspentCount > 0) {
                console.log(`pruned ${prunedUnspentCount} out of ${originalUnspentCount} unspents`);
            }
            if (unspents.length === 0) {
                throw new Error('insufficient funds');
            }
            let segwitInputCount = 0;
            unspents.every(function (unspent) {
                if (unspent.witnessScript) {
                    segwitInputCount++;
                }
                inputAmount += unspent.value;
                transaction.addInput(unspent.tx_hash, unspent.tx_output_n, 0xffffffff);
                return (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount));
            });
            // if paying fees from an external single key wallet, add the inputs
            if (feeSingleKeySourceAddress) {
                // collect the amount used in the fee inputs so we can get change later
                feeSingleKeyInputAmount = 0;
                feeSingleKeyUnspentsUsed = [];
                feeSingleKeyUnspents.every(function (unspent) {
                    feeSingleKeyInputAmount += unspent.value;
                    inputAmount += unspent.value;
                    transaction.addInput(unspent.tx_hash, unspent.tx_output_n);
                    feeSingleKeyUnspentsUsed.push(unspent);
                    // use the fee wallet to pay miner fees and potentially instant fees
                    return (feeSingleKeyInputAmount < (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0)));
                });
            }
            txInfo = {
                nP2shInputs: transaction.tx.ins.length - (feeSingleKeySourceAddress ? 1 : 0) - segwitInputCount,
                nP2shP2wshInputs: segwitInputCount,
                nP2pkhInputs: feeSingleKeySourceAddress ? 1 : 0,
                nOutputs: (recipients.length + 1 + // recipients and change
                    extraChangeAmounts.length + // extra change splitting
                    (bitgoFeeInfo && bitgoFeeInfo.amount > 0 ? 1 : 0) + // add output for bitgo fee
                    (feeSingleKeySourceAddress ? 1 : 0) // add single key source address change
                ),
            };
            estTxSize = estimateTransactionSize({
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs,
            });
        }).then(getDynamicFeeRateEstimate)
            .then(function () {
            minerFeeInfo = exports.calculateMinerFeeInfo({
                bitgo: params.wallet.bitgo,
                feeRate: feeRate,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs,
            });
            if (shouldComputeBestFee) {
                const approximateFee = minerFeeInfo.fee;
                const shouldRecurse = _.isUndefined(fee) || approximateFee > fee;
                fee = approximateFee;
                // Recompute totalAmount from scratch
                totalAmount = fee + totalOutputAmount;
                if (bitgoFeeInfo) {
                    totalAmount += bitgoFeeInfo.amount;
                }
                if (shouldRecurse) {
                    // if fee changed, re-collect inputs
                    inputAmount = 0;
                    transaction = utxolib.bitgo.createTransactionBuilderForNetwork(network);
                    return collectInputs();
                }
            }
            const totalFee = fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
            if (feeSingleKeySourceAddress) {
                const summedSingleKeyUnspents = _.sumBy(feeSingleKeyUnspents, 'value');
                if (totalFee > summedSingleKeyUnspents) {
                    const err = new Error('Insufficient fee amount available in single key fee source: ' + summedSingleKeyUnspents);
                    err.result = {
                        fee: fee,
                        feeRate: feeRate,
                        estimatedSize: minerFeeInfo.size,
                        available: inputAmount,
                        bitgoFee: bitgoFeeInfo,
                        txInfo: txInfo,
                    };
                    return Bluebird.reject(err);
                }
            }
            if (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount)) {
                // The unspents we're using for inputs do not have sufficient value on them to
                // satisfy the user's requested spend amount. That may be because the wallet's balance
                // is simply too low, or it might be that the wallet's balance is sufficient but
                // we didn't fetch enough unspents. Too few unspents could result from the wallet
                // having many small unspents and we hit our limit on the number of inputs we can use
                // in a txn, or it might have been that the filters the user passed in (like minConfirms)
                // disqualified too many of the unspents
                let err;
                if (totalUnspentsCount === fetchedUnspentsCount) {
                    // we fetched every unspent the wallet had, but it still wasn't enough
                    err = new Error('Insufficient funds');
                }
                else {
                    // we weren't able to fetch all the unspents on the wallet
                    err = new Error(`Transaction size too large due to too many unspents. Can send only ${inputAmount} satoshis in this transaction`);
                }
                err.result = {
                    fee: fee,
                    feeRate: feeRate,
                    estimatedSize: minerFeeInfo.size,
                    available: inputAmount,
                    bitgoFee: bitgoFeeInfo,
                    txInfo: txInfo,
                };
                return Bluebird.reject(err);
            }
        });
    };
    // Add the outputs for this transaction.
    const collectOutputs = function () {
        if (minerFeeInfo.size >= 90000) {
            throw new Error('transaction too large: estimated size ' + minerFeeInfo.size + ' bytes');
        }
        const outputs = [];
        recipients.forEach(function (recipient) {
            let script;
            if (_.isString(recipient.address)) {
                script = utxolib.address.toOutputScript(recipient.address, network);
            }
            else if (_.isObject(recipient.script)) {
                script = recipient.script;
            }
            else {
                throw new Error('neither recipient address nor script was provided');
            }
            // validate travelInfo if it exists
            let travelInfo;
            if (!_.isEmpty(recipient.travelInfo)) {
                travelInfo = recipient.travelInfo;
                // Better to avoid trouble now, before tx is created
                bitgo.travelRule().validateTravelInfo(travelInfo);
            }
            outputs.push({
                script: script,
                amount: recipient.amount,
                travelInfo: travelInfo,
            });
        });
        opReturns.forEach(function ({ message, amount }) {
            const script = utxolib.script.fromASM('OP_RETURN ' + Buffer.from(message).toString('hex'));
            outputs.push({ script, amount });
        });
        const getChangeOutputs = function (changeAmount) {
            if (changeAmount < 0) {
                throw new Error('negative change amount: ' + changeAmount);
            }
            const result = [];
            // if we paid fees from a single key wallet, return the fee change first
            if (feeSingleKeySourceAddress) {
                const feeSingleKeyWalletChangeAmount = feeSingleKeyInputAmount - (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0));
                if (feeSingleKeyWalletChangeAmount >= constants.minOutputSize) {
                    result.push({ address: feeSingleKeySourceAddress, amount: feeSingleKeyWalletChangeAmount });
                    changeAmount = changeAmount - feeSingleKeyWalletChangeAmount;
                }
            }
            if (changeAmount < constants.minOutputSize) {
                // Give it to the miners
                return result;
            }
            if (params.wallet.type() === 'safe') {
                return params.wallet.addresses()
                    .then(function (response) {
                    result.push({ address: response.addresses[0].address, amount: changeAmount });
                    return result;
                });
            }
            let extraChangeTotal = _.sum(extraChangeAmounts);
            // Sanity check
            if (extraChangeTotal > changeAmount) {
                extraChangeAmounts = [];
                extraChangeTotal = 0;
            }
            // copy and add remaining change amount
            const allChangeAmounts = extraChangeAmounts.slice(0);
            allChangeAmounts.push(changeAmount - extraChangeTotal);
            // Recursive async func to add all change outputs
            const addChangeOutputs = function () {
                const thisAmount = allChangeAmounts.shift();
                if (!thisAmount) {
                    return result;
                }
                return Bluebird.try(function () {
                    if (params.changeAddress) {
                        // If user passed a change address, use it for all outputs
                        return params.changeAddress;
                    }
                    else {
                        // Otherwise create a new address per output, for privacy
                        // determine if segwit or not
                        const changeChain = params.wallet.getChangeChain(params);
                        return params.wallet.createAddress({ chain: changeChain, validate: validate })
                            .then(function (result) {
                            return result.address;
                        });
                    }
                })
                    .then(function (address) {
                    result.push({ address: address, amount: thisAmount });
                    return addChangeOutputs();
                });
            };
            return addChangeOutputs();
        };
        // Add change output(s) and instant fee output if applicable
        return Bluebird.try(function () {
            return getChangeOutputs(inputAmount - totalAmount);
        })
            .then(function (result) {
            changeOutputs = result;
            const extraOutputs = changeOutputs.concat([]); // copy the array
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                extraOutputs.push(bitgoFeeInfo);
            }
            extraOutputs.forEach(function (output) {
                if (output.address) {
                    output.script =
                        utxolib.address.toOutputScript(output.address, network);
                }
                // decide where to put the outputs - default is to randomize unless forced to end
                const outputIndex = params.forceChangeAtEnd ? outputs.length : _.random(0, outputs.length);
                outputs.splice(outputIndex, 0, output);
            });
            // Add all outputs to the transaction
            outputs.forEach(function (output) {
                transaction.addOutput(output.script, output.amount);
            });
            travelInfos = _(outputs).map(function (output, index) {
                const result = output.travelInfo;
                if (!result) {
                    return undefined;
                }
                result.outputIndex = index;
                return result;
            })
                .filter()
                .value();
        });
    };
    // Serialize the transaction, returning what is needed to sign it
    const serialize = function () {
        // only need to return the unspents that were used and just the chainPath, redeemScript, and instant flag
        const pickedUnspents = _.map(unspents, function (unspent) {
            return _.pick(unspent, ['chainPath', 'redeemScript', 'instant', 'witnessScript', 'script', 'value']);
        });
        const prunedUnspents = _.slice(pickedUnspents, 0, transaction.tx.ins.length - feeSingleKeyUnspentsUsed.length);
        _.each(feeSingleKeyUnspentsUsed, function (feeUnspent) {
            prunedUnspents.push({ redeemScript: false, chainPath: false }); // mark as false to signify a non-multisig address
        });
        const result = {
            transactionHex: transaction.buildIncomplete().toHex(),
            unspents: prunedUnspents,
            fee: fee,
            changeAddresses: changeOutputs.map(function (co) {
                return _.pick(co, ['address', 'path', 'amount']);
            }),
            walletId: params.wallet.id(),
            walletKeychains: params.wallet.keychains,
            feeRate: feeRate,
            instant: params.instant,
            bitgoFee: bitgoFeeInfo,
            estimatedSize: minerFeeInfo.size,
            txInfo: txInfo,
            travelInfos: travelInfos,
        };
        // Add for backwards compatibility
        if (result.instant && bitgoFeeInfo) {
            result.instantFee = _.pick(bitgoFeeInfo, ['amount', 'address']);
        }
        return result;
    };
    return Bluebird.try(function () {
        return getBitGoFee();
    })
        .then(function () {
        return Bluebird.all([getBitGoFeeAddress(), getUnspents(), getUnspentsForSingleKey()]);
    })
        .then(collectInputs)
        .then(collectOutputs)
        .then(serialize);
};
/**
 * Estimate the size of a transaction in bytes based on the number of
 * inputs and outputs present.
 * @params params {
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns size: estimated size of the transaction in bytes
 */
const estimateTransactionSize = function (params) {
    if (!_.isInteger(params.nP2shInputs) || params.nP2shInputs < 0) {
        throw new Error('expecting positive nP2shInputs');
    }
    if (!_.isInteger(params.nP2pkhInputs) || params.nP2pkhInputs < 0) {
        throw new Error('expecting positive nP2pkhInputs to be numeric');
    }
    if (!_.isInteger(params.nP2shP2wshInputs) || params.nP2shP2wshInputs < 0) {
        throw new Error('expecting positive nP2shP2wshInputs to be numeric');
    }
    if ((params.nP2shInputs + params.nP2shP2wshInputs) < 1) {
        throw new Error('expecting at least one nP2shInputs or nP2shP2wshInputs');
    }
    if (!_.isInteger(params.nOutputs) || params.nOutputs < 1) {
        throw new Error('expecting positive nOutputs');
    }
    const estimatedSize = unspents_1.VirtualSizes.txP2shInputSize * params.nP2shInputs +
        unspents_1.VirtualSizes.txP2shP2wshInputSize * (params.nP2shP2wshInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhInputSizeUncompressedKey * (params.nP2pkhInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhOutputSize * params.nOutputs +
        // if the tx contains at least one segwit input, the tx overhead is increased by 1
        unspents_1.VirtualSizes.txOverheadSize + (params.nP2shP2wshInputs > 0 ? 1 : 0);
    return estimatedSize;
};
/**
 * Calculate the fee and estimated size in bytes for a transaction.
 * @params params {
 *   bitgo: bitgo object
 *   feeRate: satoshis per kilobyte
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns {
 *   size: estimated size of the transaction in bytes
 *   fee: estimated fee in satoshis for the transaction
 *   feeRate: fee rate that was used to estimate the fee for the transaction
 * }
 */
exports.calculateMinerFeeInfo = function (params) {
    const feeRateToUse = params.feeRate || params.bitgo.getConstants().fallbackFeeRate;
    const estimatedSize = estimateTransactionSize(params);
    return {
        size: estimatedSize,
        fee: Math.ceil(estimatedSize * feeRateToUse / 1000),
        feeRate: feeRateToUse,
    };
};
/*
 * Given a transaction hex, unspent information (chain path and redeem scripts), and the keychain xprv,
 * perform key derivation and sign the inputs in the transaction based on the unspent information provided
 *
 * @params:
 *  transactionHex serialized form of the transaction in hex
 *  unspents array of unspent information, where each unspent is a chainPath and redeemScript with the same
 *  index as the inputs in the transactionHex
 *  keychain Keychain containing the xprv to sign with. For legacy support of safe wallets, keychain can
 also be a WIF private key.
 *  signingKey private key in WIF for safe wallets, when keychain is unavailable
 *  validate client-side signature verification - can be disabled for improved performance (signatures
 *           are still validated server-side).
 *  feeSingleKeyWIF Use the address based on this private key to pay fees
 * @returns {*}
 */
exports.signTransaction = function (params) {
    let keychain = params.keychain; // duplicate so as to not mutate below
    const validate = (params.validate === undefined) ? true : params.validate;
    let privKey;
    if (!_.isString(params.transactionHex)) {
        throw new Error('expecting the transaction hex as a string');
    }
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if (!_.isBoolean(validate)) {
        throw new Error('expecting validate to be a boolean');
    }
    let network = bitcoin_1.getNetwork();
    const enableBCH = (_.isBoolean(params.forceBCH) && params.forceBCH === true);
    if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
        if (_.isString(params.signingKey)) {
            privKey = utxolib.ECPair.fromWIF(params.signingKey, network);
            keychain = undefined;
        }
        else {
            throw new Error('expecting the keychain object with xprv');
        }
    }
    let feeSingleKey;
    if (params.feeSingleKeyWIF) {
        feeSingleKey = utxolib.ECPair.fromWIF(params.feeSingleKeyWIF, network);
    }
    debug('Network: %O', network);
    if (enableBCH) {
        debug('Enabling BCH…');
        network = utxolib.networks.bitcoincash;
        debug('New network: %O', network);
    }
    const transaction = utxolib.bitgo.createTransactionFromHex(params.transactionHex, network);
    if (transaction.ins.length !== params.unspents.length) {
        throw new Error('length of unspents array should equal to the number of transaction inputs');
    }
    // decorate transaction with input values for TransactionBuilder instantiation
    const isUtxoTx = _.isObject(transaction) && Array.isArray(transaction.ins);
    const areValidUnspents = _.isObject(params) && Array.isArray(params.unspents);
    if (isUtxoTx && areValidUnspents) {
        // extend the transaction inputs with the values
        const inputValues = _.map(params.unspents, (u => _.pick(u, 'value')));
        transaction.ins.map((currentItem, index) => _.extend(currentItem, inputValues[index]));
    }
    let rootExtKey;
    if (keychain) {
        rootExtKey = bip32.fromBase58(keychain.xprv);
    }
    const txb = utxolib.bitgo.createTransactionBuilderFromTransaction(transaction);
    for (let index = 0; index < txb.tx.ins.length; ++index) {
        const currentUnspent = params.unspents[index];
        if (currentUnspent.redeemScript === false) {
            // this is the input from a single key fee address
            if (!feeSingleKey) {
                throw new Error('single key address used in input but feeSingleKeyWIF not provided');
            }
            if (enableBCH) {
                feeSingleKey.network = network;
            }
            txb.sign(index, feeSingleKey);
            continue;
        }
        if (currentUnspent.witnessScript && enableBCH) {
            throw new Error('BCH does not support segwit inputs');
        }
        const chainPath = currentUnspent.chainPath;
        if (rootExtKey) {
            const { walletSubPath = '/0/0' } = keychain;
            const path = sdk_api_1.sanitizeLegacyPath(keychain.path + walletSubPath + chainPath);
            privKey = rootExtKey.derivePath(path);
        }
        privKey.network = network;
        // subscript is the part of the output script after the OP_CODESEPARATOR.
        // Since we are only ever signing p2sh outputs, which do not have
        // OP_CODESEPARATORS, it is always the output script.
        const subscript = Buffer.from(currentUnspent.redeemScript, 'hex');
        currentUnspent.validationScript = subscript;
        // In order to sign with bitcoinjs-lib, we must use its transaction
        // builder, confusingly named the same exact thing as our transaction
        // builder, but with inequivalent behavior.
        try {
            const witnessScript = currentUnspent.witnessScript ? Buffer.from(currentUnspent.witnessScript, 'hex') : undefined;
            const sigHash = utxolib.bitgo.getDefaultSigHash(network);
            txb.sign(index, privKey, subscript, sigHash, currentUnspent.value, witnessScript);
        }
        catch (e) {
            // we need to know what's causing this
            e.result = {
                unspent: currentUnspent,
            };
            e.message = `Failed to sign input #${index} - ${e.message} - ${JSON.stringify(e.result, null, 4)} - \n${e.stack}`;
            debug('input sign failed: %s', e.message);
            return Bluebird.reject(e);
        }
    }
    const partialTransaction = txb.buildIncomplete();
    if (validate) {
        partialTransaction.ins.forEach((input, index) => {
            const signatureCount = utxolib.bitgo.getSignatureVerifications(partialTransaction, index, params.unspents[index].value).filter(v => v.signedBy !== undefined).length;
            if (signatureCount < 1) {
                throw new Error('expected at least one valid signature');
            }
            if (params.fullLocalSigning && signatureCount < 2) {
                throw new Error('fullLocalSigning set: expected at least two valid signatures');
            }
        });
    }
    return Bluebird.resolve({
        transactionHex: partialTransaction.toHex(),
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUg7R0FDRztBQUNILEVBQUU7QUFDRixxQkFBcUI7QUFDckIsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUVGLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsMkNBQTJDO0FBQzNDLDRCQUE0QjtBQUM1Qiw4Q0FBK0M7QUFDL0MsdUNBQXdEO0FBQ3hELGtDQUFtQztBQUNuQyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDdkMsOENBQXlDO0FBQ3pDLDRDQUFvRDtBQXVCcEQsRUFBRTtBQUNGLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsMENBQTBDO0FBQzFDLDhNQUE4TTtBQUM5TSxzR0FBc0c7QUFDdEcsa0lBQWtJO0FBQ2xJLDZIQUE2SDtBQUM3SCx1R0FBdUc7QUFDdkcsK0VBQStFO0FBQy9FLHFFQUFxRTtBQUNyRSw2RUFBNkU7QUFDN0Usd0dBQXdHO0FBQ3hHLGlJQUFpSTtBQUNqSSx3SUFBd0k7QUFDeEksNElBQTRJO0FBQzVJLHVFQUF1RTtBQUN2RSwyRUFBMkU7QUFDM0UsNEZBQTRGO0FBQzVGLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxVQUFVLE1BQU07SUFDMUMsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7SUFDNUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUN4RSxJQUFJLFVBQVUsR0FBOEUsRUFBRSxDQUFDO0lBQy9GLElBQUksU0FBUyxHQUEyQyxFQUFFLENBQUM7SUFDM0QsSUFBSSxrQkFBa0IsR0FB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QUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2xILEtBQUssQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDMUMsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzNCO0tBQ0Y7SUFFRCxNQUFNLGtCQUFrQixHQUFHLEdBQUcsQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUVqRCxJQUFJLFFBQVEsRUFBRTtRQUNaLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDOUMsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsQ0FDNUQsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUN4RCxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQy9DLElBQUksY0FBYyxHQUFHLENBQUMsRUFBRTtnQkFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO2FBQzFEO1lBQ0QsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLElBQUksY0FBYyxHQUFHLENBQUMsRUFBRTtnQkFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO2FBQ2pGO1FBQ0gsQ0FBQyxDQUFDLENBQUM7S0FDSjtJQUVELE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUN0QixjQUFjLEVBQUUsa0JBQWtCLENBQUMsS0FBSyxFQUFFO0tBQzNDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGhpZGRlblxuICovXG5cbi8qKlxuICovXG4vL1xuLy8gVHJhbnNhY3Rpb25CdWlsZGVyXG4vLyBBIHV0aWxpdHkgZm9yIGJ1aWxkaW5nIGFuZCBzaWduaW5nIHRyYW5zYWN0aW9uc1xuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIGJpcDMyIGZyb20gJ2JpcDMyJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFZpcnR1YWxTaXplcyB9IGZyb20gJ0BiaXRnby91bnNwZW50cyc7XG5pbXBvcnQgeyBnZXRBZGRyZXNzUDJQS0gsIGdldE5ldHdvcmsgfSBmcm9tICcuL2JpdGNvaW4nO1xuaW1wb3J0IGRlYnVnTGliID0gcmVxdWlyZSgnZGVidWcnKTtcbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYxOnR4YicpO1xuaW1wb3J0IHsgY29tbW9uIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IHNhbml0aXplTGVnYWN5UGF0aCB9IGZyb20gJ0BiaXRnby9zZGstYXBpJztcblxuaW50ZXJmYWNlIEJhc2VPdXRwdXQge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgdHJhdmVsSW5mbz86IGFueTtcbn1cblxuaW50ZXJmYWNlIEFkZHJlc3NPdXRwdXQgZXh0ZW5kcyBCYXNlT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2NyaXB0T3V0cHV0IGV4dGVuZHMgQmFzZU91dHB1dCB7XG4gIHNjcmlwdDogQnVmZmVyO1xufVxuXG50eXBlIE91dHB1dCA9IEFkZHJlc3NPdXRwdXQgfCBTY3JpcHRPdXRwdXQ7XG5cbmludGVyZmFjZSBCaXRHb1Vuc3BlbnQge1xuICB2YWx1ZTogbnVtYmVyO1xuICB0eF9oYXNoOiBCdWZmZXI7XG4gIHR4X291dHB1dF9uOiBudW1iZXI7XG59XG5cbi8vXG4vLyBUcmFuc2FjdGlvbkJ1aWxkZXJcbi8vIEBwYXJhbXM6XG4vLyAgIHdhbGxldDogIGEgd2FsbGV0IG9iamVjdCB0byBzZW5kIGZyb21cbi8vICAgcmVjaXBpZW50czogYXJyYXkgb2YgcmVjaXBpZW50IG9iamVjdHMgYW5kIHRoZSBhbW91bnQgdG8gc2VuZCB0byBlYWNoIGUuZy4gW3thZGRyZXNzOiAnMzhCS0ROWmJQY0xvZ3ZWYmN4MmVrSjlFNlZ2OTREcURxdycsIGFtb3VudDogMTUwMH0sIHthZGRyZXNzOiAnMzZlTDh5UXFDbjFITVJtVkZGbzQ5dDJQSjNwYWk4d1FhbScsIGFtb3VudDogMjAwMH1dXG4vLyAgIGZlZTogdGhlIGZlZSB0byB1c2Ugd2l0aCB0aGlzIHRyYW5zYWN0aW9uLiAgaWYgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQsIG1pbmltdW0gZmVlIHdpbGwgYmUgdXNlZC5cbi8vICAgZmVlUmF0ZTogdGhlIGFtb3VudCBvZiBmZWUgcGVyIGtpbG9ieXRlIC0gb3B0aW9uYWwgLSBzcGVjaWZ5IGVpdGhlciBmZWUsIGZlZVJhdGUsIG9yIGZlZVR4Q29uZmlybVRhcmdldCBidXQgbm90IG1vcmUgdGhhbiBvbmVcbi8vICAgZmVlVHhDb25maXJtVGFyZ2V0OiBjYWxjdWxhdGUgdGhlIGZlZXMgcGVyIGtpbG9ieXRlIHN1Y2ggdGhhdCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBjb25maXJtZWQgaW4gdGhpcyBudW1iZXIgb2YgYmxvY2tzXG4vLyAgIG1heEZlZVJhdGU6IFRoZSBtYXhpbXVtIGZlZSBwZXIga2IgdG8gdXNlIGluIHNhdG9zaGlzLCBmb3Igc2FmZXR5IHB1cnBvc2VzIHdoZW4gdXNpbmcgZHluYW1pYyBmZWVzXG4vLyAgIG1pbkNvbmZpcm1zOiB0aGUgbWluaW11bSBjb25maXJtYXRpb25zIGFuIG91dHB1dCBtdXN0IGhhdmUgYmVmb3JlIHNwZW5kaW5nXG4vLyAgIGZvcmNlQ2hhbmdlQXRFbmQ6IGZvcmNlIHRoZSBjaGFuZ2UgYWRkcmVzcyB0byBiZSB0aGUgbGFzdCBvdXRwdXRcbi8vICAgY2hhbmdlQWRkcmVzczogc3BlY2lmeSB0aGUgY2hhbmdlIGFkZHJlc3MgcmF0aGVyIHRoYW4gZ2VuZXJhdGUgYSBuZXcgb25lXG4vLyAgIG5vU3BsaXRDaGFuZ2U6IHNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0b21hdGljIGNoYW5nZSBzcGxpdHRpbmcgZm9yIHB1cnBvc2VzIG9mIHVuc3BlbnQgbWFuYWdlbWVudFxuLy8gICB0YXJnZXRXYWxsZXRVbnNwZW50czogc3BlY2lmeSBhIG51bWJlciBvZiB0YXJnZXQgdW5zcGVudHMgdG8gbWFpbnRhaW4gaW4gdGhlIHdhbGxldCAoY3VycmVudGx5IGRlZmF1bHRlZCB0byA4IGJ5IHRoZSBzZXJ2ZXIpXG4vLyAgIHZhbGlkYXRlOiBleHRyYSB2ZXJpZmljYXRpb24gb2YgdGhlIGNoYW5nZSBhZGRyZXNzZXMsIHdoaWNoIGlzIGFsd2F5cyBkb25lIHNlcnZlci1zaWRlIGFuZCBpcyByZWR1bmRhbnQgY2xpZW50LXNpZGUgKGRlZmF1bHRzIHRydWUpXG4vLyAgIG1pblVuc3BlbnRTaXplOiBUaGUgbWluaW11bSBzaXplIGluIHNhdG9zaGlzIG9mIHVuc3BlbnQgdG8gdXNlICh0byBwcmV2ZW50IHNwZW5kaW5nIHVuc3BlbnRzIHdvcnRoIGxlc3MgdGhhbiBmZWUgYWRkZWQpLiBEZWZhdWx0cyB0byAwLlxuLy8gICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzOiBVc2UgdGhpcyBzaW5nbGUga2V5IGFkZHJlc3MgdG8gcGF5IGZlZXNcbi8vICAgZmVlU2luZ2xlS2V5V0lGOiBVc2UgdGhlIGFkZHJlc3MgYmFzZWQgb24gdGhpcyBwcml2YXRlIGtleSB0byBwYXkgZmVlc1xuLy8gICB1bnNwZW50c0ZldGNoUGFyYW1zOiBFeHRyYSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgZmV0Y2hpbmcgdW5zcGVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbmV4cG9ydHMuY3JlYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGNvbnN0IG1pbkNvbmZpcm1zID0gcGFyYW1zLm1pbkNvbmZpcm1zIHx8IDA7XG4gIGNvbnN0IHZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuICBsZXQgcmVjaXBpZW50czogeyBhZGRyZXNzOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyOyBzY3JpcHQ/OiBzdHJpbmc7IHRyYXZlbEluZm8/OiBhbnk7IH1bXSA9IFtdO1xuICBsZXQgb3BSZXR1cm5zOiB7IG1lc3NhZ2U6IHN0cmluZzsgYW1vdW50OiBudW1iZXI7IH1bXSA9IFtdO1xuICBsZXQgZXh0cmFDaGFuZ2VBbW91bnRzOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgZXN0VHhTaXplOiBudW1iZXI7XG4gIGxldCB0cmF2ZWxJbmZvcztcblxuICAvLyBTYW5pdHkgY2hlY2sgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy53YWxsZXQpIHx8XG4gIChwYXJhbXMuZmVlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWUpKSB8fFxuICAocGFyYW1zLmZlZVJhdGUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpKSB8fFxuICAhXy5pc0ludGVnZXIobWluQ29uZmlybXMpIHx8XG4gIChwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmZvcmNlQ2hhbmdlQXRFbmQpKSB8fFxuICAocGFyYW1zLmNoYW5nZUFkZHJlc3MgJiYgIV8uaXNTdHJpbmcocGFyYW1zLmNoYW5nZUFkZHJlc3MpKSB8fFxuICAocGFyYW1zLm5vU3BsaXRDaGFuZ2UgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5ub1NwbGl0Q2hhbmdlKSkgfHxcbiAgKHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyAmJiAhXy5pc0ludGVnZXIocGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzKSkgfHxcbiAgKHZhbGlkYXRlICYmICFfLmlzQm9vbGVhbih2YWxpZGF0ZSkpIHx8XG4gIChwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlKSkgfHxcbiAgKHBhcmFtcy5taW5VbnNwZW50U2l6ZSAmJiAhXy5pc051bWJlcihwYXJhbXMubWluVW5zcGVudFNpemUpKSB8fFxuICAocGFyYW1zLm1heEZlZVJhdGUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLm1heEZlZVJhdGUpKSB8fFxuICAvLyB0aGlzIHNob3VsZCBiZSBhbiBhcnJheSBhbmQgaXRzIGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IDFcbiAgKHBhcmFtcy51bnNwZW50cyAmJiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnVuc3BlbnRzKSB8fCBwYXJhbXMudW5zcGVudHMubGVuZ3RoIDwgMSkpIHx8XG4gIChwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0ICYmICFfLmlzSW50ZWdlcihwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0KSkgfHxcbiAgKHBhcmFtcy5pbnN0YW50ICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaW5zdGFudCkpIHx8XG4gIChwYXJhbXMuYml0Z29GZWUgJiYgIV8uaXNPYmplY3QocGFyYW1zLmJpdGdvRmVlKSkgfHxcbiAgKHBhcmFtcy51bnNwZW50c0ZldGNoUGFyYW1zICYmICFfLmlzT2JqZWN0KHBhcmFtcy51bnNwZW50c0ZldGNoUGFyYW1zKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBiaXRnbyA9IHBhcmFtcy53YWxsZXQuYml0Z287XG4gIGNvbnN0IGNvbnN0YW50cyA9IGJpdGdvLmdldENvbnN0YW50cygpO1xuICBjb25zdCBuZXR3b3JrID0gZ2V0TmV0d29yayhjb21tb24uRW52aXJvbm1lbnRzW2JpdGdvLmdldEVudigpXS5uZXR3b3JrKTtcblxuICAvLyBUaGUgdXNlciBjYW4gc3BlY2lmeSBhIHNlcGVyYXRlLCBzaW5nbGUta2V5IHdhbGxldCBmb3IgdGhlIHB1cnBvc2VzIG9mIHBheWluZyBtaW5lcidzIGZlZXNcbiAgLy8gV2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIHRoaXMgY2FuIGJlIHNwZWNpZmllZCBhcyBhbiBpbnB1dCBhZGRyZXNzIG9yIHRoZSBwcml2YXRlIGtleSBpbiBXSUZcbiAgbGV0IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M7XG4gIGxldCBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA9IDA7XG4gIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICB1dHhvbGliLmFkZHJlc3MuZnJvbUJhc2U1OENoZWNrKHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPSBwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYml0Y29pbiBhZGRyZXNzOiAnICsgcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5V0lGKSB7XG4gICAgY29uc3QgZmVlU2luZ2xlS2V5ID0gdXR4b2xpYi5FQ1BhaXIuZnJvbVdJRihwYXJhbXMuZmVlU2luZ2xlS2V5V0lGLCBuZXR3b3JrIGFzIHV0eG9saWIuQml0Y29pbkpTTmV0d29yayk7XG4gICAgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA9IGdldEFkZHJlc3NQMlBLSChmZWVTaW5nbGVLZXkpO1xuICAgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllcyBib3RoLCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgY29ycmVzcG9uZHMgdG8gdGhlIGFkZHJlc3Mgb2YgZmVlU2luZ2xlS2V5V0lGXG4gICAgaWYgKHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzICYmXG4gICAgcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgIT09IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzczogJyArIHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzICtcbiAgICAgICcgZGlkIG5vdCBjb3JyZXNwb25kIHRvIGFkZHJlc3Mgb2YgZmVlU2luZ2xlS2V5V0lGOiAnICsgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVjaXBpZW50cyBtdXN0IGJlIGFycmF5IG9mIHsgYWRkcmVzczogYWJjLCBhbW91bnQ6IDEwMDAwMCB9IG9iamVjdHMnKTtcbiAgfVxuXG4gIGxldCBmZWVQYXJhbXNEZWZpbmVkID0gMDtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWUpKSB7XG4gICAgZmVlUGFyYW1zRGVmaW5lZCsrO1xuICB9XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWVSYXRlKSkge1xuICAgIGZlZVBhcmFtc0RlZmluZWQrKztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0KSkge1xuICAgIGZlZVBhcmFtc0RlZmluZWQrKztcbiAgfVxuXG4gIGlmIChmZWVQYXJhbXNEZWZpbmVkID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgbW9yZSB0aGFuIG9uZSBvZiBmZWUsIGZlZVJhdGUgYW5kIGZlZVR4Q29uZmlybVRhcmdldCcpO1xuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLm1heEZlZVJhdGUpKSB7XG4gICAgcGFyYW1zLm1heEZlZVJhdGUgPSBjb25zdGFudHMubWF4RmVlUmF0ZTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgdGhlIG9sZCBmb3JtYXQgb2YgcGFyYW1zLnJlY2lwaWVudHMgKGRpY3Rpb25hcnkgb2YgYWRkcmVzczphbW91bnQpIHRvIG5ldyBmb3JtYXQ6IHsgZGVzdGluYXRpb25BZGRyZXNzLCBhbW91bnQgfVxuICBpZiAoIShwYXJhbXMucmVjaXBpZW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHJlY2lwaWVudHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMucmVjaXBpZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZGVzdGluYXRpb25BZGRyZXNzKSB7XG4gICAgICBjb25zdCBhbW91bnQgPSBwYXJhbXMucmVjaXBpZW50c1tkZXN0aW5hdGlvbkFkZHJlc3NdO1xuICAgICAgcmVjaXBpZW50cy5wdXNoKHsgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLCBhbW91bnQ6IGFtb3VudCB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZWNpcGllbnRzID0gcGFyYW1zLnJlY2lwaWVudHM7XG4gIH1cblxuICBpZiAocGFyYW1zLm9wUmV0dXJucykge1xuICAgIGlmICghKHBhcmFtcy5vcFJldHVybnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIG9wUmV0dXJucyA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zLm9wUmV0dXJucykuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBwYXJhbXMub3BSZXR1cm5zW21lc3NhZ2VdO1xuICAgICAgICBvcFJldHVybnMucHVzaCh7IG1lc3NhZ2UsIGFtb3VudCB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcFJldHVybnMgPSBwYXJhbXMub3BSZXR1cm5zO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZWNpcGllbnRzLmxlbmd0aCA9PT0gMCAmJiBvcFJldHVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHJlY2lwaWVudCcpO1xuICB9XG5cbiAgbGV0IGZlZSA9IHBhcmFtcy5mZWU7XG4gIGxldCBmZWVSYXRlID0gcGFyYW1zLmZlZVJhdGU7XG5cbiAgLy8gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBjbGFzcyB3aWxsIGNvbXB1dGUgdGhlIGZlZVxuICBjb25zdCBzaG91bGRDb21wdXRlQmVzdEZlZSA9IChfLmlzVW5kZWZpbmVkKGZlZSkpO1xuXG4gIGxldCB0b3RhbE91dHB1dEFtb3VudCA9IDA7XG5cbiAgcmVjaXBpZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNpcGllbnQpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhyZWNpcGllbnQuYWRkcmVzcykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHV0eG9saWIuYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2socmVjaXBpZW50LmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYml0Y29pbiBhZGRyZXNzOiAnICsgcmVjaXBpZW50LmFkZHJlc3MpO1xuICAgICAgfVxuICAgICAgaWYgKCEhcmVjaXBpZW50LnNjcmlwdCkge1xuICAgICAgICAvLyBBIHNjcmlwdCB3YXMgcHJvdmlkZWQgYXMgd2VsbCAtIHZhbGlkYXRlIHRoYXQgdGhlIGFkZHJlc3MgY29ycmVzcG9uZHMgdG8gdGhhdFxuICAgICAgICBpZiAodXR4b2xpYi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHJlY2lwaWVudC5hZGRyZXNzLCBuZXR3b3JrKS50b1N0cmluZygnaGV4JykgIT09IHJlY2lwaWVudC5zY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggc2NyaXB0IGFuZCBhZGRyZXNzIHByb3ZpZGVkIGJ1dCB0aGV5IGRpZCBub3QgbWF0Y2g6ICcgKyByZWNpcGllbnQuYWRkcmVzcyArICcgJyArIHJlY2lwaWVudC5zY3JpcHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghXy5pc0ludGVnZXIocmVjaXBpZW50LmFtb3VudCkgfHwgcmVjaXBpZW50LmFtb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbW91bnQgZm9yICcgKyByZWNpcGllbnQuYWRkcmVzcyArICc6ICcgKyByZWNpcGllbnQuYW1vdW50KTtcbiAgICB9XG4gICAgdG90YWxPdXRwdXRBbW91bnQgKz0gcmVjaXBpZW50LmFtb3VudDtcbiAgfSk7XG5cbiAgb3BSZXR1cm5zLmZvckVhY2goZnVuY3Rpb24gKG9wUmV0dXJuKSB7XG4gICAgdG90YWxPdXRwdXRBbW91bnQgKz0gb3BSZXR1cm4uYW1vdW50O1xuICB9KTtcblxuICBsZXQgYml0Z29GZWVJbmZvID0gcGFyYW1zLmJpdGdvRmVlO1xuICBpZiAoYml0Z29GZWVJbmZvICYmXG4gICghXy5pc0ludGVnZXIoYml0Z29GZWVJbmZvLmFtb3VudCkgfHwgIV8uaXNTdHJpbmcoYml0Z29GZWVJbmZvLmFkZHJlc3MpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRnb0ZlZUluZm8nKTtcbiAgfVxuXG4gIC8vIFRoZSB0b3RhbCBhbW91bnQgbmVlZGVkIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgdG90YWxBbW91bnQgPSB0b3RhbE91dHB1dEFtb3VudCArIChmZWUgfHwgMCk7XG5cbiAgLy8gVGhlIGxpc3Qgb2YgdW5zcGVudCB0cmFuc2FjdGlvbnMgYmVpbmcgdXNlZCBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgdW5zcGVudHM7XG5cbiAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiB1bnNwZW50cyBvbiB0aGlzIHdhbGxldFxuICBsZXQgdG90YWxVbnNwZW50c0NvdW50O1xuXG4gIC8vIHRoZSBudW1iZXIgb2YgdW5zcGVudHMgd2UgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIsIGJlZm9yZSBmaWx0ZXJpbmdcbiAgbGV0IGZldGNoZWRVbnNwZW50c0NvdW50O1xuXG4gIC8vIFRoZSBsaXN0IG9mIHVuc3BlbnQgdHJhbnNhY3Rpb25zIGJlaW5nIHVzZWQgd2l0aCB6ZXJvLWNvbmZpcm1hdGlvbnNcbiAgbGV0IHplcm9Db25mVW5zcGVudFR4SWRzO1xuXG4gIC8vIFRoZSBzdW0gb2YgdGhlIGlucHV0IHZhbHVlcyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgbGV0IGlucHV0QW1vdW50O1xuXG4gIGxldCBjaGFuZ2VPdXRwdXRzOiBPdXRwdXRbXSA9IFtdO1xuXG4gIC8vIFRoZSB0cmFuc2FjdGlvbi5cbiAgbGV0IHRyYW5zYWN0aW9uID0gdXR4b2xpYi5iaXRnby5jcmVhdGVUcmFuc2FjdGlvbkJ1aWxkZXJGb3JOZXR3b3JrKG5ldHdvcmspO1xuXG4gIGNvbnN0IGdldEJpdEdvRmVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGJpdGdvRmVlSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5nZXRCaXRHb0ZlZSh7IGFtb3VudDogdG90YWxPdXRwdXRBbW91bnQsIGluc3RhbnQ6IHBhcmFtcy5pbnN0YW50IH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5mZWUgPiAwKSB7XG4gICAgICAgICAgICBiaXRnb0ZlZUluZm8gPSB7XG4gICAgICAgICAgICAgIGFtb3VudDogcmVzdWx0LmZlZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYml0Z29GZWVJbmZvICYmIGJpdGdvRmVlSW5mby5hbW91bnQgPiAwKSB7XG4gICAgICAgICAgdG90YWxBbW91bnQgKz0gYml0Z29GZWVJbmZvLmFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0Qml0R29GZWVBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBiaXRnb0ZlZUluZm8sIG9yIGFkZHJlc3MgaXMgYWxyZWFkeSBzZXQsIGRvbid0IGdldCBhIG5ldyBvbmVcbiAgICAgIGlmICghYml0Z29GZWVJbmZvIHx8IGJpdGdvRmVlSW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaXRnby5nZXRCaXRHb0ZlZUFkZHJlc3MoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgYml0Z29GZWVJbmZvLmFkZHJlc3MgPSByZXN1bHQuYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2V0IGEgZHluYW1pYyBmZWUgZXN0aW1hdGUgZnJvbSB0aGUgQml0R28gc2VydmVyIGlmIGZlZVR4Q29uZmlybVRhcmdldFxuICAvLyBpcyBzcGVjaWZpZWQgb3IgaWYgbm8gZmVlLXJlbGF0ZWQgcGFyYW1zIGFyZSBzcGVjaWZpZWRcbiAgY29uc3QgZ2V0RHluYW1pY0ZlZVJhdGVFc3RpbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCB8fCAhZmVlUGFyYW1zRGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGJpdGdvLmVzdGltYXRlRmVlKHtcbiAgICAgICAgbnVtQmxvY2tzOiBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0LFxuICAgICAgICBtYXhGZWU6IHBhcmFtcy5tYXhGZWVSYXRlLFxuICAgICAgICBpbnB1dHM6IHplcm9Db25mVW5zcGVudFR4SWRzLFxuICAgICAgICB0eFNpemU6IGVzdFR4U2l6ZSxcbiAgICAgICAgY3BmcEF3YXJlOiB0cnVlLFxuICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbnN0IGVzdGltYXRlZEZlZVJhdGUgPSByZXN1bHQuY3BmcEZlZVBlcktiO1xuICAgICAgICAgIGNvbnN0IG1pbmltdW0gPSBwYXJhbXMuaW5zdGFudCA/IE1hdGgubWF4KGNvbnN0YW50cy5taW5GZWVSYXRlLCBjb25zdGFudHMubWluSW5zdGFudEZlZVJhdGUpIDogY29uc3RhbnRzLm1pbkZlZVJhdGU7XG4gICAgICAgICAgLy8gNSBzYXRvc2hpcyBwZXIgYnl0ZVxuICAgICAgICAgIC8vIGl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHRoZSBwYWRkaW5nIG9ubHkgYXBwbGllcyB3aGVuIHRoZSB0aHJlc2hvbGQgaXMgY3Jvc3NlZCwgYnV0IG5vdCB3aGVuIHRoZSBkZWx0YSBpcyBsZXNzIHRoYW4gdGhlIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBwYWRkaW5nID0gNTAwMDtcbiAgICAgICAgICBpZiAoZXN0aW1hdGVkRmVlUmF0ZSA8IG1pbmltdW0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ldyBEYXRlKCkgKyAnOiBFcnJvciB3aGVuIGVzdGltYXRpbmcgZmVlIGZvciBzZW5kIGZyb20gJyArIHBhcmFtcy53YWxsZXQuaWQoKSArICcsIGl0IHdhcyB0b28gbG93IC0gJyArIGVzdGltYXRlZEZlZVJhdGUpO1xuICAgICAgICAgICAgZmVlUmF0ZSA9IG1pbmltdW0gKyBwYWRkaW5nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXN0aW1hdGVkRmVlUmF0ZSA+IHBhcmFtcy5tYXhGZWVSYXRlKSB7XG4gICAgICAgICAgICBmZWVSYXRlID0gcGFyYW1zLm1heEZlZVJhdGUgLSBwYWRkaW5nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZWVSYXRlID0gZXN0aW1hdGVkRmVlUmF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZlZVJhdGU7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBzYW5pdHkgY2hlY2sgZmFpbGVkIG9uIHR4IHNpemVcbiAgICAgICAgICBpZiAoXy5pbmNsdWRlcyhlLm1lc3NhZ2UsICdpbnZhbGlkIHR4U2l6ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY291bGRuJ3QgZXN0aW1hdGUgdGhlIGZlZSwgcHJvY2VlZCB1c2luZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgZmVlUmF0ZSA9IGNvbnN0YW50cy5mYWxsYmFja0ZlZVJhdGU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgZXN0aW1hdGluZyBmZWUgZm9yIHNlbmQgZnJvbSAnICsgcGFyYW1zLndhbGxldC5pZCgpICsgJzogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gR2V0IHRoZSB1bnNwZW50cyBmb3IgdGhlIHNlbmRpbmcgd2FsbGV0LlxuICBjb25zdCBnZXRVbnNwZW50cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmIChwYXJhbXMudW5zcGVudHMpIHsgLy8gd2UganVzdCB3YW5uYSB1c2UgY3VzdG9tIHVuc3BlbnRzXG4gICAgICB1bnNwZW50cyA9IHBhcmFtcy51bnNwZW50cztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgZW5vdWdoIHVuc3BlbnRzIGZvciB0aGUgcmVxdWVzdGVkIGFtb3VudFxuICAgIGNvbnN0IG9wdGlvbnMgPSBfLm1lcmdlKHt9LCBwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcyB8fCB7fSwge1xuICAgICAgdGFyZ2V0OiB0b3RhbEFtb3VudCxcbiAgICAgIG1pblNpemU6IHBhcmFtcy5taW5VbnNwZW50U2l6ZSB8fCAwLFxuICAgICAgaW5zdGFudDogcGFyYW1zLmluc3RhbnQsIC8vIGluc2lzdCBvbiBpbnN0YW50IHVuc3BlbnRzIG9ubHlcbiAgICAgIHRhcmdldFdhbGxldFVuc3BlbnRzOiBwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMsXG4gICAgfSk7XG4gICAgaWYgKHBhcmFtcy5pbnN0YW50KSB7XG4gICAgICBvcHRpb25zLmluc3RhbnQgPSBwYXJhbXMuaW5zdGFudDsgLy8gaW5zaXN0IG9uIGluc3RhbnQgdW5zcGVudHMgb25seVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXMud2FsbGV0LnVuc3BlbnRzUGFnZWQob3B0aW9ucylcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIHRvdGFsVW5zcGVudHNDb3VudCA9IHJlc3VsdHMudG90YWw7XG4gICAgICAgIGZldGNoZWRVbnNwZW50c0NvdW50ID0gcmVzdWx0cy5jb3VudDtcbiAgICAgICAgdW5zcGVudHMgPSByZXN1bHRzLnVuc3BlbnRzLmZpbHRlcihmdW5jdGlvbiAodSkge1xuICAgICAgICAgIGNvbnN0IGNvbmZpcm1zID0gdS5jb25maXJtYXRpb25zIHx8IDA7XG4gICAgICAgICAgaWYgKCFwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlICYmIHUuaXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uZmlybXMgPj0gbWluQ29uZmlybXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFib3J0IGVhcmx5IGlmIHRoZXJlJ3Mgbm8gdmlhYmxlIHVuc3BlbnRzLCBiZWNhdXNlIGl0IHdvbid0IGJlIHBvc3NpYmxlIHRvIGNyZWF0ZSB0aGUgdHhuIGxhdGVyXG4gICAgICAgIGlmICh1bnNwZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignMCB1bnNwZW50cyBhdmFpbGFibGUgZm9yIHRyYW5zYWN0aW9uIGNyZWF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYXJyYXkgb2YgdW5jb25maXJtZWQgdW5zcGVudCBJRCBzdHJpbmdzIG9mIHRoZSBmb3JtIFwidHhIYXNoOm91dHB1dEluZGV4XCJcbiAgICAgICAgemVyb0NvbmZVbnNwZW50VHhJZHMgPSBfKHJlc3VsdHMudW5zcGVudHMpLmZpbHRlcihmdW5jdGlvbiAodSkge1xuICAgICAgICAgIHJldHVybiAhdS5jb25maXJtYXRpb25zO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICByZXR1cm4gdS50eF9oYXNoICsgJzonICsgdS50eF9vdXRwdXRfbjtcbiAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgaWYgKF8uaXNFbXB0eSh6ZXJvQ29uZlVuc3BlbnRUeElkcykpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBwYXNzIGFuIGVtcHR5IGFycmF5IG9mIGlucHV0cyB0byB0aGUgc2VydmVyLCBiZWNhdXNlIGl0IGFzc3VtZXMgaWYgdGhlXG4gICAgICAgIC8vIGlucHV0cyBhcmd1bWVudHMgZXhpc3RzLCBpdCBjb250YWlucyB2YWx1ZXNcbiAgICAgICAgICB6ZXJvQ29uZlVuc3BlbnRUeElkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgcmVzcGVjdCB0aGUgb2xkIHNwbGl0Q2hhbmdlU2l6ZT0wIHBhcmFtZXRlclxuICAgICAgICBpZiAoIXBhcmFtcy5ub1NwbGl0Q2hhbmdlICYmIHBhcmFtcy5zcGxpdENoYW5nZVNpemUgIT09IDApIHtcbiAgICAgICAgICBleHRyYUNoYW5nZUFtb3VudHMgPSByZXN1bHRzLmV4dHJhQ2hhbmdlQW1vdW50cyB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB1bnNwZW50cyBmb3IgdGhlIHNpbmdsZSBrZXkgZmVlIGFkZHJlc3NcbiAgbGV0IGZlZVNpbmdsZUtleVVuc3BlbnRzOiBCaXRHb1Vuc3BlbnRbXSA9IFtdO1xuICBjb25zdCBnZXRVbnNwZW50c0ZvclNpbmdsZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgbGV0IGZlZVRhcmdldCA9IDAuMDFlODtcbiAgICAgIGlmIChwYXJhbXMuaW5zdGFudCkge1xuICAgICAgICBmZWVUYXJnZXQgKz0gdG90YWxBbW91bnQgKiAwLjAwMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaXRnby5nZXQoYml0Z28udXJsKCcvYWRkcmVzcy8nICsgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyArICcvdW5zcGVudHM/dGFyZ2V0PScgKyBmZWVUYXJnZXQpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuYm9keS50b3RhbCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuc3BlbnRzIGF2YWlsYWJsZSBpbiBzaW5nbGUga2V5IGZlZSBzb3VyY2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHMgPSByZXNwb25zZS5ib2R5LnVuc3BlbnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IG1pbmVyRmVlSW5mbzogYW55ID0ge307XG4gIGxldCB0eEluZm86IGFueSA9IHt9O1xuXG4gIC8vIEl0ZXJhdGUgdW5zcGVudHMsIHN1bSB0aGUgaW5wdXRzLCBhbmQgc2F2ZSBfaW5wdXRzIHdpdGggdGhlIHRvdGFsXG4gIC8vIGlucHV0IGFtb3VudCBhbmQgZmluYWwgbGlzdCBvZiBpbnB1dHMgdG8gdXNlIHdpdGggdGhlIHRyYW5zYWN0aW9uLlxuICBsZXQgZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkOiBCaXRHb1Vuc3BlbnRbXSA9IFtdO1xuXG4gIGNvbnN0IGNvbGxlY3RJbnB1dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF1bnNwZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdW5zcGVudHMgYXZhaWxhYmxlIG9uIHdhbGxldCcpO1xuICAgIH1cbiAgICBpbnB1dEFtb3VudCA9IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvc3Qgb2Ygc3BlbmRpbmcgYSBzaW5nbGUgaW5wdXQsIGkuZS4gdGhlIHNtYWxsZXN0IGVjb25vbWljYWwgdW5zcGVudCB2YWx1ZVxuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoXy5pc051bWJlcihwYXJhbXMuZmVlUmF0ZSkgfHwgXy5pc051bWJlcihwYXJhbXMub3JpZ2luYWxGZWVSYXRlKSkge1xuICAgICAgICByZXR1cm4gKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWVSYXRlKSA/IHBhcmFtcy5mZWVSYXRlIDogcGFyYW1zLm9yaWdpbmFsRmVlUmF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYml0Z28uZXN0aW1hdGVGZWUoe1xuICAgICAgICAgIG51bUJsb2NrczogcGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCxcbiAgICAgICAgICBtYXhGZWU6IHBhcmFtcy5tYXhGZWVSYXRlLFxuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmZWVSYXRlRXN0aW1hdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWVSYXRlRXN0aW1hdGUuZmVlUGVyS2I7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZmVlUmF0ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3BlbmQgaW5wdXRzIHRoYXQgY2Fubm90IHBheSBmb3IgdGhlaXIgb3duIGNvc3QuXG4gICAgICBsZXQgbWluSW5wdXRWYWx1ZSA9IDA7XG4gICAgICBpZiAoXy5pc0ludGVnZXIocGFyYW1zLm1pblVuc3BlbnRTaXplKSkge1xuICAgICAgICBtaW5JbnB1dFZhbHVlID0gcGFyYW1zLm1pblVuc3BlbnRTaXplO1xuICAgICAgfVxuXG4gICAgICBsZXQgcHJ1bmVkVW5zcGVudENvdW50ID0gMDtcbiAgICAgIGNvbnN0IG9yaWdpbmFsVW5zcGVudENvdW50ID0gdW5zcGVudHMubGVuZ3RoO1xuICAgICAgdW5zcGVudHMgPSBfLmZpbHRlcih1bnNwZW50cywgZnVuY3Rpb24gKHVuc3BlbnQpIHtcbiAgICAgICAgY29uc3QgaXNTZWd3aXRJbnB1dCA9ICEhdW5zcGVudC53aXRuZXNzU2NyaXB0O1xuICAgICAgICBjb25zdCBjdXJyZW50SW5wdXRTaXplID0gaXNTZWd3aXRJbnB1dCA/IFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSA6IFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemU7XG4gICAgICAgIGNvbnN0IGZlZUJhc2VkTWluSW5wdXRWYWx1ZSA9IChmZWVSYXRlICogY3VycmVudElucHV0U2l6ZSkgLyAxMDAwO1xuICAgICAgICBjb25zdCBjdXJyZW50TWluSW5wdXRWYWx1ZSA9IE1hdGgubWF4KG1pbklucHV0VmFsdWUsIGZlZUJhc2VkTWluSW5wdXRWYWx1ZSk7XG4gICAgICAgIGlmIChjdXJyZW50TWluSW5wdXRWYWx1ZSA+IHVuc3BlbnQudmFsdWUpIHtcbiAgICAgICAgICAvLyBwcnVuaW5nIHVuc3BlbnRcbiAgICAgICAgICBjb25zdCBwcnVuZURldGFpbHMgPSB7XG4gICAgICAgICAgICBnZW5lcmFsTWluSW5wdXRWYWx1ZTogbWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIGZlZUJhc2VkTWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRNaW5JbnB1dFZhbHVlLFxuICAgICAgICAgICAgZmVlUmF0ZSxcbiAgICAgICAgICAgIGlucHV0U2l6ZTogY3VycmVudElucHV0U2l6ZSxcbiAgICAgICAgICAgIHVuc3BlbnQ6IHVuc3BlbnQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgcHJ1bmluZyB1bnNwZW50OiAke0pTT04uc3RyaW5naWZ5KHBydW5lRGV0YWlscywgbnVsbCwgNCl9YCk7XG4gICAgICAgICAgcHJ1bmVkVW5zcGVudENvdW50Kys7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcnVuZWRVbnNwZW50Q291bnQgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBwcnVuZWQgJHtwcnVuZWRVbnNwZW50Q291bnR9IG91dCBvZiAke29yaWdpbmFsVW5zcGVudENvdW50fSB1bnNwZW50c2ApO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdWZmaWNpZW50IGZ1bmRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgc2Vnd2l0SW5wdXRDb3VudCA9IDA7XG4gICAgICB1bnNwZW50cy5ldmVyeShmdW5jdGlvbiAodW5zcGVudCkge1xuICAgICAgICBpZiAodW5zcGVudC53aXRuZXNzU2NyaXB0KSB7XG4gICAgICAgICAgc2Vnd2l0SW5wdXRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0QW1vdW50ICs9IHVuc3BlbnQudmFsdWU7XG4gICAgICAgIHRyYW5zYWN0aW9uLmFkZElucHV0KHVuc3BlbnQudHhfaGFzaCwgdW5zcGVudC50eF9vdXRwdXRfbiwgMHhmZmZmZmZmZik7XG5cbiAgICAgICAgcmV0dXJuIChpbnB1dEFtb3VudCA8IChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gdG90YWxPdXRwdXRBbW91bnQgOiB0b3RhbEFtb3VudCkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIHBheWluZyBmZWVzIGZyb20gYW4gZXh0ZXJuYWwgc2luZ2xlIGtleSB3YWxsZXQsIGFkZCB0aGUgaW5wdXRzXG4gICAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgICAvLyBjb2xsZWN0IHRoZSBhbW91bnQgdXNlZCBpbiB0aGUgZmVlIGlucHV0cyBzbyB3ZSBjYW4gZ2V0IGNoYW5nZSBsYXRlclxuICAgICAgICBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA9IDA7XG4gICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZCA9IFtdO1xuICAgICAgICBmZWVTaW5nbGVLZXlVbnNwZW50cy5ldmVyeShmdW5jdGlvbiAodW5zcGVudCkge1xuICAgICAgICAgIGZlZVNpbmdsZUtleUlucHV0QW1vdW50ICs9IHVuc3BlbnQudmFsdWU7XG4gICAgICAgICAgaW5wdXRBbW91bnQgKz0gdW5zcGVudC52YWx1ZTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRJbnB1dCh1bnNwZW50LnR4X2hhc2gsIHVuc3BlbnQudHhfb3V0cHV0X24pO1xuICAgICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZC5wdXNoKHVuc3BlbnQpO1xuICAgICAgICAgIC8vIHVzZSB0aGUgZmVlIHdhbGxldCB0byBwYXkgbWluZXIgZmVlcyBhbmQgcG90ZW50aWFsbHkgaW5zdGFudCBmZWVzXG4gICAgICAgICAgcmV0dXJuIChmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA8IChmZWUgKyAoYml0Z29GZWVJbmZvID8gYml0Z29GZWVJbmZvLmFtb3VudCA6IDApKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0eEluZm8gPSB7XG4gICAgICAgIG5QMnNoSW5wdXRzOiB0cmFuc2FjdGlvbi50eC5pbnMubGVuZ3RoIC0gKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCkgLSBzZWd3aXRJbnB1dENvdW50LFxuICAgICAgICBuUDJzaFAyd3NoSW5wdXRzOiBzZWd3aXRJbnB1dENvdW50LFxuICAgICAgICBuUDJwa2hJbnB1dHM6IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCxcbiAgICAgICAgbk91dHB1dHM6IChcbiAgICAgICAgICByZWNpcGllbnRzLmxlbmd0aCArIDEgKyAvLyByZWNpcGllbnRzIGFuZCBjaGFuZ2VcbiAgICAgICAgZXh0cmFDaGFuZ2VBbW91bnRzLmxlbmd0aCArIC8vIGV4dHJhIGNoYW5nZSBzcGxpdHRpbmdcbiAgICAgICAgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCA/IDEgOiAwKSArIC8vIGFkZCBvdXRwdXQgZm9yIGJpdGdvIGZlZVxuICAgICAgICAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IDEgOiAwKSAvLyBhZGQgc2luZ2xlIGtleSBzb3VyY2UgYWRkcmVzcyBjaGFuZ2VcbiAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICAgIGVzdFR4U2l6ZSA9IGVzdGltYXRlVHJhbnNhY3Rpb25TaXplKHtcbiAgICAgICAgblAyc2hJbnB1dHM6IHR4SW5mby5uUDJzaElucHV0cyxcbiAgICAgICAgblAyc2hQMndzaElucHV0czogdHhJbmZvLm5QMnNoUDJ3c2hJbnB1dHMsXG4gICAgICAgIG5QMnBraElucHV0czogdHhJbmZvLm5QMnBraElucHV0cyxcbiAgICAgICAgbk91dHB1dHM6IHR4SW5mby5uT3V0cHV0cyxcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZ2V0RHluYW1pY0ZlZVJhdGVFc3RpbWF0ZSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWluZXJGZWVJbmZvID0gZXhwb3J0cy5jYWxjdWxhdGVNaW5lckZlZUluZm8oe1xuICAgICAgICAgIGJpdGdvOiBwYXJhbXMud2FsbGV0LmJpdGdvLFxuICAgICAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICAgICAgblAyc2hJbnB1dHM6IHR4SW5mby5uUDJzaElucHV0cyxcbiAgICAgICAgICBuUDJzaFAyd3NoSW5wdXRzOiB0eEluZm8ublAyc2hQMndzaElucHV0cyxcbiAgICAgICAgICBuUDJwa2hJbnB1dHM6IHR4SW5mby5uUDJwa2hJbnB1dHMsXG4gICAgICAgICAgbk91dHB1dHM6IHR4SW5mby5uT3V0cHV0cyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVCZXN0RmVlKSB7XG4gICAgICAgICAgY29uc3QgYXBwcm94aW1hdGVGZWUgPSBtaW5lckZlZUluZm8uZmVlO1xuICAgICAgICAgIGNvbnN0IHNob3VsZFJlY3Vyc2UgPSBfLmlzVW5kZWZpbmVkKGZlZSkgfHwgYXBwcm94aW1hdGVGZWUgPiBmZWU7XG4gICAgICAgICAgZmVlID0gYXBwcm94aW1hdGVGZWU7XG4gICAgICAgICAgLy8gUmVjb21wdXRlIHRvdGFsQW1vdW50IGZyb20gc2NyYXRjaFxuICAgICAgICAgIHRvdGFsQW1vdW50ID0gZmVlICsgdG90YWxPdXRwdXRBbW91bnQ7XG4gICAgICAgICAgaWYgKGJpdGdvRmVlSW5mbykge1xuICAgICAgICAgICAgdG90YWxBbW91bnQgKz0gYml0Z29GZWVJbmZvLmFtb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZFJlY3Vyc2UpIHtcbiAgICAgICAgICAvLyBpZiBmZWUgY2hhbmdlZCwgcmUtY29sbGVjdCBpbnB1dHNcbiAgICAgICAgICAgIGlucHV0QW1vdW50ID0gMDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdXR4b2xpYi5iaXRnby5jcmVhdGVUcmFuc2FjdGlvbkJ1aWxkZXJGb3JOZXR3b3JrKG5ldHdvcmspO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RJbnB1dHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3RhbEZlZSA9IGZlZSArIChiaXRnb0ZlZUluZm8gPyBiaXRnb0ZlZUluZm8uYW1vdW50IDogMCk7XG5cbiAgICAgICAgaWYgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBzdW1tZWRTaW5nbGVLZXlVbnNwZW50cyA9IF8uc3VtQnkoZmVlU2luZ2xlS2V5VW5zcGVudHMsICd2YWx1ZScpO1xuICAgICAgICAgIGlmICh0b3RhbEZlZSA+IHN1bW1lZFNpbmdsZUtleVVuc3BlbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IGZlZSBhbW91bnQgYXZhaWxhYmxlIGluIHNpbmdsZSBrZXkgZmVlIHNvdXJjZTogJyArIHN1bW1lZFNpbmdsZUtleVVuc3BlbnRzKTtcbiAgICAgICAgICAgIGVyci5yZXN1bHQgPSB7XG4gICAgICAgICAgICAgIGZlZTogZmVlLFxuICAgICAgICAgICAgICBmZWVSYXRlOiBmZWVSYXRlLFxuICAgICAgICAgICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgICAgICAgICAgYXZhaWxhYmxlOiBpbnB1dEFtb3VudCxcbiAgICAgICAgICAgICAgYml0Z29GZWU6IGJpdGdvRmVlSW5mbyxcbiAgICAgICAgICAgICAgdHhJbmZvOiB0eEluZm8sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dEFtb3VudCA8IChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gdG90YWxPdXRwdXRBbW91bnQgOiB0b3RhbEFtb3VudCkpIHtcbiAgICAgICAgLy8gVGhlIHVuc3BlbnRzIHdlJ3JlIHVzaW5nIGZvciBpbnB1dHMgZG8gbm90IGhhdmUgc3VmZmljaWVudCB2YWx1ZSBvbiB0aGVtIHRvXG4gICAgICAgIC8vIHNhdGlzZnkgdGhlIHVzZXIncyByZXF1ZXN0ZWQgc3BlbmQgYW1vdW50LiBUaGF0IG1heSBiZSBiZWNhdXNlIHRoZSB3YWxsZXQncyBiYWxhbmNlXG4gICAgICAgIC8vIGlzIHNpbXBseSB0b28gbG93LCBvciBpdCBtaWdodCBiZSB0aGF0IHRoZSB3YWxsZXQncyBiYWxhbmNlIGlzIHN1ZmZpY2llbnQgYnV0XG4gICAgICAgIC8vIHdlIGRpZG4ndCBmZXRjaCBlbm91Z2ggdW5zcGVudHMuIFRvbyBmZXcgdW5zcGVudHMgY291bGQgcmVzdWx0IGZyb20gdGhlIHdhbGxldFxuICAgICAgICAvLyBoYXZpbmcgbWFueSBzbWFsbCB1bnNwZW50cyBhbmQgd2UgaGl0IG91ciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGlucHV0cyB3ZSBjYW4gdXNlXG4gICAgICAgIC8vIGluIGEgdHhuLCBvciBpdCBtaWdodCBoYXZlIGJlZW4gdGhhdCB0aGUgZmlsdGVycyB0aGUgdXNlciBwYXNzZWQgaW4gKGxpa2UgbWluQ29uZmlybXMpXG4gICAgICAgIC8vIGRpc3F1YWxpZmllZCB0b28gbWFueSBvZiB0aGUgdW5zcGVudHNcbiAgICAgICAgICBsZXQgZXJyO1xuICAgICAgICAgIGlmICh0b3RhbFVuc3BlbnRzQ291bnQgPT09IGZldGNoZWRVbnNwZW50c0NvdW50KSB7XG4gICAgICAgICAgLy8gd2UgZmV0Y2hlZCBldmVyeSB1bnNwZW50IHRoZSB3YWxsZXQgaGFkLCBidXQgaXQgc3RpbGwgd2Fzbid0IGVub3VnaFxuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgZnVuZHMnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIHdlcmVuJ3QgYWJsZSB0byBmZXRjaCBhbGwgdGhlIHVuc3BlbnRzIG9uIHRoZSB3YWxsZXRcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2l6ZSB0b28gbGFyZ2UgZHVlIHRvIHRvbyBtYW55IHVuc3BlbnRzLiBDYW4gc2VuZCBvbmx5ICR7aW5wdXRBbW91bnR9IHNhdG9zaGlzIGluIHRoaXMgdHJhbnNhY3Rpb25gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyLnJlc3VsdCA9IHtcbiAgICAgICAgICAgIGZlZTogZmVlLFxuICAgICAgICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemU6IG1pbmVyRmVlSW5mby5zaXplLFxuICAgICAgICAgICAgYXZhaWxhYmxlOiBpbnB1dEFtb3VudCxcbiAgICAgICAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICAgICAgICB0eEluZm86IHR4SW5mbyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIHRoZSBvdXRwdXRzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICBjb25zdCBjb2xsZWN0T3V0cHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobWluZXJGZWVJbmZvLnNpemUgPj0gOTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gdG9vIGxhcmdlOiBlc3RpbWF0ZWQgc2l6ZSAnICsgbWluZXJGZWVJbmZvLnNpemUgKyAnIGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0czogT3V0cHV0W10gPSBbXTtcblxuICAgIHJlY2lwaWVudHMuZm9yRWFjaChmdW5jdGlvbiAocmVjaXBpZW50KSB7XG4gICAgICBsZXQgc2NyaXB0O1xuICAgICAgaWYgKF8uaXNTdHJpbmcocmVjaXBpZW50LmFkZHJlc3MpKSB7XG4gICAgICAgIHNjcmlwdCA9IHV0eG9saWIuYWRkcmVzcy50b091dHB1dFNjcmlwdChyZWNpcGllbnQuYWRkcmVzcywgbmV0d29yayk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocmVjaXBpZW50LnNjcmlwdCkpIHtcbiAgICAgICAgc2NyaXB0ID0gcmVjaXBpZW50LnNjcmlwdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVpdGhlciByZWNpcGllbnQgYWRkcmVzcyBub3Igc2NyaXB0IHdhcyBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZGF0ZSB0cmF2ZWxJbmZvIGlmIGl0IGV4aXN0c1xuICAgICAgbGV0IHRyYXZlbEluZm87XG4gICAgICBpZiAoIV8uaXNFbXB0eShyZWNpcGllbnQudHJhdmVsSW5mbykpIHtcbiAgICAgICAgdHJhdmVsSW5mbyA9IHJlY2lwaWVudC50cmF2ZWxJbmZvO1xuICAgICAgICAvLyBCZXR0ZXIgdG8gYXZvaWQgdHJvdWJsZSBub3csIGJlZm9yZSB0eCBpcyBjcmVhdGVkXG4gICAgICAgIGJpdGdvLnRyYXZlbFJ1bGUoKS52YWxpZGF0ZVRyYXZlbEluZm8odHJhdmVsSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICBhbW91bnQ6IHJlY2lwaWVudC5hbW91bnQsXG4gICAgICAgIHRyYXZlbEluZm86IHRyYXZlbEluZm8sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG9wUmV0dXJucy5mb3JFYWNoKGZ1bmN0aW9uICh7IG1lc3NhZ2UsIGFtb3VudCB9KSB7XG4gICAgICBjb25zdCBzY3JpcHQgPSB1dHhvbGliLnNjcmlwdC5mcm9tQVNNKCdPUF9SRVRVUk4gJyArIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICBvdXRwdXRzLnB1c2goeyBzY3JpcHQsIGFtb3VudCB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoYW5nZU91dHB1dHMgPSBmdW5jdGlvbiAoY2hhbmdlQW1vdW50OiBudW1iZXIpOiBPdXRwdXRbXSB8IEJsdWViaXJkPE91dHB1dFtdPiB7XG4gICAgICBpZiAoY2hhbmdlQW1vdW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZ2F0aXZlIGNoYW5nZSBhbW91bnQ6ICcgKyBjaGFuZ2VBbW91bnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IE91dHB1dFtdID0gW107XG4gICAgICAvLyBpZiB3ZSBwYWlkIGZlZXMgZnJvbSBhIHNpbmdsZSBrZXkgd2FsbGV0LCByZXR1cm4gdGhlIGZlZSBjaGFuZ2UgZmlyc3RcbiAgICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudCA9IGZlZVNpbmdsZUtleUlucHV0QW1vdW50IC0gKGZlZSArIChiaXRnb0ZlZUluZm8gPyBiaXRnb0ZlZUluZm8uYW1vdW50IDogMCkpO1xuICAgICAgICBpZiAoZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50ID49IGNvbnN0YW50cy5taW5PdXRwdXRTaXplKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goeyBhZGRyZXNzOiBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzLCBhbW91bnQ6IGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudCB9KTtcbiAgICAgICAgICBjaGFuZ2VBbW91bnQgPSBjaGFuZ2VBbW91bnQgLSBmZWVTaW5nbGVLZXlXYWxsZXRDaGFuZ2VBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUFtb3VudCA8IGNvbnN0YW50cy5taW5PdXRwdXRTaXplKSB7XG4gICAgICAgIC8vIEdpdmUgaXQgdG8gdGhlIG1pbmVyc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLndhbGxldC50eXBlKCkgPT09ICdzYWZlJykge1xuICAgICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5hZGRyZXNzZXMoKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBhZGRyZXNzOiByZXNwb25zZS5hZGRyZXNzZXNbMF0uYWRkcmVzcywgYW1vdW50OiBjaGFuZ2VBbW91bnQgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0cmFDaGFuZ2VUb3RhbCA9IF8uc3VtKGV4dHJhQ2hhbmdlQW1vdW50cyk7XG4gICAgICAvLyBTYW5pdHkgY2hlY2tcbiAgICAgIGlmIChleHRyYUNoYW5nZVRvdGFsID4gY2hhbmdlQW1vdW50KSB7XG4gICAgICAgIGV4dHJhQ2hhbmdlQW1vdW50cyA9IFtdO1xuICAgICAgICBleHRyYUNoYW5nZVRvdGFsID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gY29weSBhbmQgYWRkIHJlbWFpbmluZyBjaGFuZ2UgYW1vdW50XG4gICAgICBjb25zdCBhbGxDaGFuZ2VBbW91bnRzID0gZXh0cmFDaGFuZ2VBbW91bnRzLnNsaWNlKDApO1xuICAgICAgYWxsQ2hhbmdlQW1vdW50cy5wdXNoKGNoYW5nZUFtb3VudCAtIGV4dHJhQ2hhbmdlVG90YWwpO1xuXG4gICAgICAvLyBSZWN1cnNpdmUgYXN5bmMgZnVuYyB0byBhZGQgYWxsIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjb25zdCBhZGRDaGFuZ2VPdXRwdXRzID0gZnVuY3Rpb24gKCk6IE91dHB1dFtdIHwgQmx1ZWJpcmQ8T3V0cHV0W10+IHtcbiAgICAgICAgY29uc3QgdGhpc0Ftb3VudCA9IGFsbENoYW5nZUFtb3VudHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKCF0aGlzQW1vdW50KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmNoYW5nZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIC8vIElmIHVzZXIgcGFzc2VkIGEgY2hhbmdlIGFkZHJlc3MsIHVzZSBpdCBmb3IgYWxsIG91dHB1dHNcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuY2hhbmdlQWRkcmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBhZGRyZXNzIHBlciBvdXRwdXQsIGZvciBwcml2YWN5XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgc2Vnd2l0IG9yIG5vdFxuICAgICAgICAgICAgY29uc3QgY2hhbmdlQ2hhaW4gPSBwYXJhbXMud2FsbGV0LmdldENoYW5nZUNoYWluKHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5jcmVhdGVBZGRyZXNzKHsgY2hhaW46IGNoYW5nZUNoYWluLCB2YWxpZGF0ZTogdmFsaWRhdGUgfSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGFkZHJlc3M6IGFkZHJlc3MsIGFtb3VudDogdGhpc0Ftb3VudCB9KTtcbiAgICAgICAgICAgIHJldHVybiBhZGRDaGFuZ2VPdXRwdXRzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWRkQ2hhbmdlT3V0cHV0cygpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgY2hhbmdlIG91dHB1dChzKSBhbmQgaW5zdGFudCBmZWUgb3V0cHV0IGlmIGFwcGxpY2FibGVcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRDaGFuZ2VPdXRwdXRzKGlucHV0QW1vdW50IC0gdG90YWxBbW91bnQpO1xuICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGNoYW5nZU91dHB1dHMgPSByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGV4dHJhT3V0cHV0cyA9IGNoYW5nZU91dHB1dHMuY29uY2F0KFtdKTsgLy8gY29weSB0aGUgYXJyYXlcbiAgICAgICAgaWYgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCkge1xuICAgICAgICAgIGV4dHJhT3V0cHV0cy5wdXNoKGJpdGdvRmVlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFPdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgIGlmICgob3V0cHV0IGFzIEFkZHJlc3NPdXRwdXQpLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIChvdXRwdXQgYXMgU2NyaXB0T3V0cHV0KS5zY3JpcHQgPVxuICAgICAgICAgICAgdXR4b2xpYi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KChvdXRwdXQgYXMgQWRkcmVzc091dHB1dCkuYWRkcmVzcywgbmV0d29yayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZGVjaWRlIHdoZXJlIHRvIHB1dCB0aGUgb3V0cHV0cyAtIGRlZmF1bHQgaXMgdG8gcmFuZG9taXplIHVubGVzcyBmb3JjZWQgdG8gZW5kXG4gICAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCA/IG91dHB1dHMubGVuZ3RoIDogXy5yYW5kb20oMCwgb3V0cHV0cy5sZW5ndGgpO1xuICAgICAgICAgIG91dHB1dHMuc3BsaWNlKG91dHB1dEluZGV4LCAwLCBvdXRwdXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgYWxsIG91dHB1dHMgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT3V0cHV0KChvdXRwdXQgYXMgU2NyaXB0T3V0cHV0KS5zY3JpcHQsIG91dHB1dC5hbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmF2ZWxJbmZvcyA9IF8ob3V0cHV0cykubWFwKGZ1bmN0aW9uIChvdXRwdXQsIGluZGV4KSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3V0cHV0LnRyYXZlbEluZm87XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5vdXRwdXRJbmRleCA9IGluZGV4O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcigpXG4gICAgICAgICAgLnZhbHVlKCk7XG4gICAgICB9KTtcbiAgfTtcblxuICAvLyBTZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uLCByZXR1cm5pbmcgd2hhdCBpcyBuZWVkZWQgdG8gc2lnbiBpdFxuICBjb25zdCBzZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gb25seSBuZWVkIHRvIHJldHVybiB0aGUgdW5zcGVudHMgdGhhdCB3ZXJlIHVzZWQgYW5kIGp1c3QgdGhlIGNoYWluUGF0aCwgcmVkZWVtU2NyaXB0LCBhbmQgaW5zdGFudCBmbGFnXG4gICAgY29uc3QgcGlja2VkVW5zcGVudHM6IGFueSA9IF8ubWFwKHVuc3BlbnRzLCBmdW5jdGlvbiAodW5zcGVudCkge1xuICAgICAgcmV0dXJuIF8ucGljayh1bnNwZW50LCBbJ2NoYWluUGF0aCcsICdyZWRlZW1TY3JpcHQnLCAnaW5zdGFudCcsICd3aXRuZXNzU2NyaXB0JywgJ3NjcmlwdCcsICd2YWx1ZSddKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcnVuZWRVbnNwZW50cyA9IF8uc2xpY2UocGlja2VkVW5zcGVudHMsIDAsIHRyYW5zYWN0aW9uLnR4Lmlucy5sZW5ndGggLSBmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQubGVuZ3RoKTtcbiAgICBfLmVhY2goZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkLCBmdW5jdGlvbiAoZmVlVW5zcGVudCkge1xuICAgICAgcHJ1bmVkVW5zcGVudHMucHVzaCh7IHJlZGVlbVNjcmlwdDogZmFsc2UsIGNoYWluUGF0aDogZmFsc2UgfSk7IC8vIG1hcmsgYXMgZmFsc2UgdG8gc2lnbmlmeSBhIG5vbi1tdWx0aXNpZyBhZGRyZXNzXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7XG4gICAgICB0cmFuc2FjdGlvbkhleDogdHJhbnNhY3Rpb24uYnVpbGRJbmNvbXBsZXRlKCkudG9IZXgoKSxcbiAgICAgIHVuc3BlbnRzOiBwcnVuZWRVbnNwZW50cyxcbiAgICAgIGZlZTogZmVlLFxuICAgICAgY2hhbmdlQWRkcmVzc2VzOiBjaGFuZ2VPdXRwdXRzLm1hcChmdW5jdGlvbiAoY28pIHtcbiAgICAgICAgcmV0dXJuIF8ucGljayhjbywgWydhZGRyZXNzJywgJ3BhdGgnLCAnYW1vdW50J10pO1xuICAgICAgfSksXG4gICAgICB3YWxsZXRJZDogcGFyYW1zLndhbGxldC5pZCgpLFxuICAgICAgd2FsbGV0S2V5Y2hhaW5zOiBwYXJhbXMud2FsbGV0LmtleWNoYWlucyxcbiAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCxcbiAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgIHR4SW5mbzogdHhJbmZvLFxuICAgICAgdHJhdmVsSW5mb3M6IHRyYXZlbEluZm9zLFxuICAgIH07XG5cbiAgICAvLyBBZGQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHJlc3VsdC5pbnN0YW50ICYmIGJpdGdvRmVlSW5mbykge1xuICAgICAgcmVzdWx0Lmluc3RhbnRGZWUgPSBfLnBpY2soYml0Z29GZWVJbmZvLCBbJ2Ftb3VudCcsICdhZGRyZXNzJ10pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEJpdEdvRmVlKCk7XG4gIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEJsdWViaXJkLmFsbChbZ2V0Qml0R29GZWVBZGRyZXNzKCksIGdldFVuc3BlbnRzKCksIGdldFVuc3BlbnRzRm9yU2luZ2xlS2V5KCldKTtcbiAgICB9KVxuICAgIC50aGVuKGNvbGxlY3RJbnB1dHMpXG4gICAgLnRoZW4oY29sbGVjdE91dHB1dHMpXG4gICAgLnRoZW4oc2VyaWFsaXplKTtcbn07XG5cblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgc2l6ZSBvZiBhIHRyYW5zYWN0aW9uIGluIGJ5dGVzIGJhc2VkIG9uIHRoZSBudW1iZXIgb2ZcbiAqIGlucHV0cyBhbmQgb3V0cHV0cyBwcmVzZW50LlxuICogQHBhcmFtcyBwYXJhbXMge1xuICogICBuUDJzaElucHV0czogbnVtYmVyIG9mIFAyU0ggKG11bHRpc2lnKSBpbnB1dHNcbiAqICAgblAycGtoSW5wdXRzOiBudW1iZXIgb2YgUDJQS0ggKHNpbmdsZSBzaWcpIGlucHV0c1xuICogICBuT3V0cHV0czogbnVtYmVyIG9mIG91dHB1dHNcbiAqIH1cbiAqXG4gKiBAcmV0dXJucyBzaXplOiBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gYnl0ZXNcbiAqL1xuY29uc3QgZXN0aW1hdGVUcmFuc2FjdGlvblNpemUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5QMnNoSW5wdXRzKSB8fCBwYXJhbXMublAyc2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAyc2hJbnB1dHMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJwa2hJbnB1dHMpIHx8IHBhcmFtcy5uUDJwa2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAycGtoSW5wdXRzIHRvIGJlIG51bWVyaWMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzKSB8fCBwYXJhbXMublAyc2hQMndzaElucHV0cyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuUDJzaFAyd3NoSW5wdXRzIHRvIGJlIG51bWVyaWMnKTtcbiAgfVxuICBpZiAoKHBhcmFtcy5uUDJzaElucHV0cyArIHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzKSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhdCBsZWFzdCBvbmUgblAyc2hJbnB1dHMgb3IgblAyc2hQMndzaElucHV0cycpO1xuICB9XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5PdXRwdXRzKSB8fCBwYXJhbXMubk91dHB1dHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgbk91dHB1dHMnKTtcbiAgfVxuXG5cbiAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiBwYXJhbXMublAyc2hJbnB1dHMgK1xuICBWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hJbnB1dFNpemUgKiAocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgfHwgMCkgK1xuICBWaXJ0dWFsU2l6ZXMudHhQMnBraElucHV0U2l6ZVVuY29tcHJlc3NlZEtleSAqIChwYXJhbXMublAycGtoSW5wdXRzIHx8IDApICtcbiAgVmlydHVhbFNpemVzLnR4UDJwa2hPdXRwdXRTaXplICogcGFyYW1zLm5PdXRwdXRzICtcbiAgLy8gaWYgdGhlIHR4IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBzZWd3aXQgaW5wdXQsIHRoZSB0eCBvdmVyaGVhZCBpcyBpbmNyZWFzZWQgYnkgMVxuICBWaXJ0dWFsU2l6ZXMudHhPdmVyaGVhZFNpemUgKyAocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgPiAwID8gMSA6IDApO1xuXG4gIHJldHVybiBlc3RpbWF0ZWRTaXplO1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZmVlIGFuZCBlc3RpbWF0ZWQgc2l6ZSBpbiBieXRlcyBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqIEBwYXJhbXMgcGFyYW1zIHtcbiAqICAgYml0Z286IGJpdGdvIG9iamVjdFxuICogICBmZWVSYXRlOiBzYXRvc2hpcyBwZXIga2lsb2J5dGVcbiAqICAgblAyc2hJbnB1dHM6IG51bWJlciBvZiBQMlNIIChtdWx0aXNpZykgaW5wdXRzXG4gKiAgIG5QMnBraElucHV0czogbnVtYmVyIG9mIFAyUEtIIChzaW5nbGUgc2lnKSBpbnB1dHNcbiAqICAgbk91dHB1dHM6IG51bWJlciBvZiBvdXRwdXRzXG4gKiB9XG4gKlxuICogQHJldHVybnMge1xuICogICBzaXplOiBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gYnl0ZXNcbiAqICAgZmVlOiBlc3RpbWF0ZWQgZmVlIGluIHNhdG9zaGlzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqICAgZmVlUmF0ZTogZmVlIHJhdGUgdGhhdCB3YXMgdXNlZCB0byBlc3RpbWF0ZSB0aGUgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIH1cbiAqL1xuZXhwb3J0cy5jYWxjdWxhdGVNaW5lckZlZUluZm8gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGNvbnN0IGZlZVJhdGVUb1VzZSA9IHBhcmFtcy5mZWVSYXRlIHx8IHBhcmFtcy5iaXRnby5nZXRDb25zdGFudHMoKS5mYWxsYmFja0ZlZVJhdGU7XG4gIGNvbnN0IGVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZVRyYW5zYWN0aW9uU2l6ZShwYXJhbXMpO1xuXG4gIHJldHVybiB7XG4gICAgc2l6ZTogZXN0aW1hdGVkU2l6ZSxcbiAgICBmZWU6IE1hdGguY2VpbChlc3RpbWF0ZWRTaXplICogZmVlUmF0ZVRvVXNlIC8gMTAwMCksXG4gICAgZmVlUmF0ZTogZmVlUmF0ZVRvVXNlLFxuICB9O1xufTtcblxuLypcbiAqIEdpdmVuIGEgdHJhbnNhY3Rpb24gaGV4LCB1bnNwZW50IGluZm9ybWF0aW9uIChjaGFpbiBwYXRoIGFuZCByZWRlZW0gc2NyaXB0cyksIGFuZCB0aGUga2V5Y2hhaW4geHBydixcbiAqIHBlcmZvcm0ga2V5IGRlcml2YXRpb24gYW5kIHNpZ24gdGhlIGlucHV0cyBpbiB0aGUgdHJhbnNhY3Rpb24gYmFzZWQgb24gdGhlIHVuc3BlbnQgaW5mb3JtYXRpb24gcHJvdmlkZWRcbiAqXG4gKiBAcGFyYW1zOlxuICogIHRyYW5zYWN0aW9uSGV4IHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gaGV4XG4gKiAgdW5zcGVudHMgYXJyYXkgb2YgdW5zcGVudCBpbmZvcm1hdGlvbiwgd2hlcmUgZWFjaCB1bnNwZW50IGlzIGEgY2hhaW5QYXRoIGFuZCByZWRlZW1TY3JpcHQgd2l0aCB0aGUgc2FtZVxuICogIGluZGV4IGFzIHRoZSBpbnB1dHMgaW4gdGhlIHRyYW5zYWN0aW9uSGV4XG4gKiAga2V5Y2hhaW4gS2V5Y2hhaW4gY29udGFpbmluZyB0aGUgeHBydiB0byBzaWduIHdpdGguIEZvciBsZWdhY3kgc3VwcG9ydCBvZiBzYWZlIHdhbGxldHMsIGtleWNoYWluIGNhblxuIGFsc28gYmUgYSBXSUYgcHJpdmF0ZSBrZXkuXG4gKiAgc2lnbmluZ0tleSBwcml2YXRlIGtleSBpbiBXSUYgZm9yIHNhZmUgd2FsbGV0cywgd2hlbiBrZXljaGFpbiBpcyB1bmF2YWlsYWJsZVxuICogIHZhbGlkYXRlIGNsaWVudC1zaWRlIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gLSBjYW4gYmUgZGlzYWJsZWQgZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlIChzaWduYXR1cmVzXG4gKiAgICAgICAgICAgYXJlIHN0aWxsIHZhbGlkYXRlZCBzZXJ2ZXItc2lkZSkuXG4gKiAgZmVlU2luZ2xlS2V5V0lGIFVzZSB0aGUgYWRkcmVzcyBiYXNlZCBvbiB0aGlzIHByaXZhdGUga2V5IHRvIHBheSBmZWVzXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGxldCBrZXljaGFpbiA9IHBhcmFtcy5rZXljaGFpbjsgLy8gZHVwbGljYXRlIHNvIGFzIHRvIG5vdCBtdXRhdGUgYmVsb3dcblxuICBjb25zdCB2YWxpZGF0ZSA9IChwYXJhbXMudmFsaWRhdGUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuICBsZXQgcHJpdktleTtcbiAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50cmFuc2FjdGlvbkhleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdHJhbnNhY3Rpb24gaGV4IGFzIGEgc3RyaW5nJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy51bnNwZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdW5zcGVudHMgYXJyYXknKTtcbiAgfVxuICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHZhbGlkYXRlIHRvIGJlIGEgYm9vbGVhbicpO1xuICB9XG4gIGxldCBuZXR3b3JrID0gZ2V0TmV0d29yaygpO1xuICBjb25zdCBlbmFibGVCQ0ggPSAoXy5pc0Jvb2xlYW4ocGFyYW1zLmZvcmNlQkNIKSAmJiBwYXJhbXMuZm9yY2VCQ0ggPT09IHRydWUpO1xuXG4gIGlmICghXy5pc09iamVjdChrZXljaGFpbikgfHwgIV8uaXNTdHJpbmcoKGtleWNoYWluIGFzIGFueSkueHBydikpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhwYXJhbXMuc2lnbmluZ0tleSkpIHtcbiAgICAgIHByaXZLZXkgPSB1dHhvbGliLkVDUGFpci5mcm9tV0lGKHBhcmFtcy5zaWduaW5nS2V5LCBuZXR3b3JrIGFzIHV0eG9saWIuQml0Y29pbkpTTmV0d29yayk7XG4gICAgICBrZXljaGFpbiA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgdGhlIGtleWNoYWluIG9iamVjdCB3aXRoIHhwcnYnKTtcbiAgICB9XG4gIH1cblxuICBsZXQgZmVlU2luZ2xlS2V5O1xuICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVdJRikge1xuICAgIGZlZVNpbmdsZUtleSA9IHV0eG9saWIuRUNQYWlyLmZyb21XSUYocGFyYW1zLmZlZVNpbmdsZUtleVdJRiwgbmV0d29yayBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmspO1xuICB9XG5cbiAgZGVidWcoJ05ldHdvcms6ICVPJywgbmV0d29yayk7XG5cbiAgaWYgKGVuYWJsZUJDSCkge1xuICAgIGRlYnVnKCdFbmFibGluZyBCQ0jigKYnKTtcbiAgICBuZXR3b3JrID0gdXR4b2xpYi5uZXR3b3Jrcy5iaXRjb2luY2FzaDtcbiAgICBkZWJ1ZygnTmV3IG5ldHdvcms6ICVPJywgbmV0d29yayk7XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvbiA9IHV0eG9saWIuYml0Z28uY3JlYXRlVHJhbnNhY3Rpb25Gcm9tSGV4KHBhcmFtcy50cmFuc2FjdGlvbkhleCwgbmV0d29yayk7XG4gIGlmICh0cmFuc2FjdGlvbi5pbnMubGVuZ3RoICE9PSBwYXJhbXMudW5zcGVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgdW5zcGVudHMgYXJyYXkgc2hvdWxkIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW5wdXRzJyk7XG4gIH1cblxuICAvLyBkZWNvcmF0ZSB0cmFuc2FjdGlvbiB3aXRoIGlucHV0IHZhbHVlcyBmb3IgVHJhbnNhY3Rpb25CdWlsZGVyIGluc3RhbnRpYXRpb25cbiAgY29uc3QgaXNVdHhvVHggPSBfLmlzT2JqZWN0KHRyYW5zYWN0aW9uKSAmJiBBcnJheS5pc0FycmF5KCh0cmFuc2FjdGlvbiBhcyBhbnkpLmlucyk7XG4gIGNvbnN0IGFyZVZhbGlkVW5zcGVudHMgPSBfLmlzT2JqZWN0KHBhcmFtcykgJiYgQXJyYXkuaXNBcnJheSgocGFyYW1zIGFzIGFueSkudW5zcGVudHMpO1xuICBpZiAoaXNVdHhvVHggJiYgYXJlVmFsaWRVbnNwZW50cykge1xuICAgIC8vIGV4dGVuZCB0aGUgdHJhbnNhY3Rpb24gaW5wdXRzIHdpdGggdGhlIHZhbHVlc1xuICAgIGNvbnN0IGlucHV0VmFsdWVzID0gXy5tYXAoKHBhcmFtcyBhcyBhbnkpLnVuc3BlbnRzLCAodSA9PiBfLnBpY2sodSwgJ3ZhbHVlJykpKTtcbiAgICB0cmFuc2FjdGlvbi5pbnMubWFwKChjdXJyZW50SXRlbSwgaW5kZXgpID0+IF8uZXh0ZW5kKGN1cnJlbnRJdGVtLCBpbnB1dFZhbHVlc1tpbmRleF0pKTtcbiAgfVxuXG4gIGxldCByb290RXh0S2V5O1xuICBpZiAoa2V5Y2hhaW4pIHtcbiAgICByb290RXh0S2V5ID0gYmlwMzIuZnJvbUJhc2U1OChrZXljaGFpbi54cHJ2KTtcbiAgfVxuXG4gIGNvbnN0IHR4YiA9IHV0eG9saWIuYml0Z28uY3JlYXRlVHJhbnNhY3Rpb25CdWlsZGVyRnJvbVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHhiLnR4Lmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50VW5zcGVudCA9IHBhcmFtcy51bnNwZW50c1tpbmRleF07XG4gICAgaWYgKGN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGlucHV0IGZyb20gYSBzaW5nbGUga2V5IGZlZSBhZGRyZXNzXG4gICAgICBpZiAoIWZlZVNpbmdsZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbmdsZSBrZXkgYWRkcmVzcyB1c2VkIGluIGlucHV0IGJ1dCBmZWVTaW5nbGVLZXlXSUYgbm90IHByb3ZpZGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVCQ0gpIHtcbiAgICAgICAgZmVlU2luZ2xlS2V5Lm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgfVxuXG4gICAgICB0eGIuc2lnbihpbmRleCwgZmVlU2luZ2xlS2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VW5zcGVudC53aXRuZXNzU2NyaXB0ICYmIGVuYWJsZUJDSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCQ0ggZG9lcyBub3Qgc3VwcG9ydCBzZWd3aXQgaW5wdXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhaW5QYXRoID0gY3VycmVudFVuc3BlbnQuY2hhaW5QYXRoO1xuICAgIGlmIChyb290RXh0S2V5KSB7XG4gICAgICBjb25zdCB7IHdhbGxldFN1YlBhdGggPSAnLzAvMCcgfSA9IGtleWNoYWluO1xuICAgICAgY29uc3QgcGF0aCA9IHNhbml0aXplTGVnYWN5UGF0aChrZXljaGFpbi5wYXRoICsgd2FsbGV0U3ViUGF0aCArIGNoYWluUGF0aCk7XG4gICAgICBwcml2S2V5ID0gcm9vdEV4dEtleS5kZXJpdmVQYXRoKHBhdGgpO1xuICAgIH1cblxuICAgIHByaXZLZXkubmV0d29yayA9IG5ldHdvcms7XG5cbiAgICAvLyBzdWJzY3JpcHQgaXMgdGhlIHBhcnQgb2YgdGhlIG91dHB1dCBzY3JpcHQgYWZ0ZXIgdGhlIE9QX0NPREVTRVBBUkFUT1IuXG4gICAgLy8gU2luY2Ugd2UgYXJlIG9ubHkgZXZlciBzaWduaW5nIHAyc2ggb3V0cHV0cywgd2hpY2ggZG8gbm90IGhhdmVcbiAgICAvLyBPUF9DT0RFU0VQQVJBVE9SUywgaXQgaXMgYWx3YXlzIHRoZSBvdXRwdXQgc2NyaXB0LlxuICAgIGNvbnN0IHN1YnNjcmlwdCA9IEJ1ZmZlci5mcm9tKGN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCwgJ2hleCcpO1xuICAgIGN1cnJlbnRVbnNwZW50LnZhbGlkYXRpb25TY3JpcHQgPSBzdWJzY3JpcHQ7XG5cbiAgICAvLyBJbiBvcmRlciB0byBzaWduIHdpdGggYml0Y29pbmpzLWxpYiwgd2UgbXVzdCB1c2UgaXRzIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgY29uZnVzaW5nbHkgbmFtZWQgdGhlIHNhbWUgZXhhY3QgdGhpbmcgYXMgb3VyIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgYnV0IHdpdGggaW5lcXVpdmFsZW50IGJlaGF2aW9yLlxuICAgIHRyeSB7XG4gICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gY3VycmVudFVuc3BlbnQud2l0bmVzc1NjcmlwdCA/IEJ1ZmZlci5mcm9tKGN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHQsICdoZXgnKSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHNpZ0hhc2ggPSB1dHhvbGliLmJpdGdvLmdldERlZmF1bHRTaWdIYXNoKG5ldHdvcmspO1xuICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaCwgY3VycmVudFVuc3BlbnQudmFsdWUsIHdpdG5lc3NTY3JpcHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHdlIG5lZWQgdG8ga25vdyB3aGF0J3MgY2F1c2luZyB0aGlzXG4gICAgICBlLnJlc3VsdCA9IHtcbiAgICAgICAgdW5zcGVudDogY3VycmVudFVuc3BlbnQsXG4gICAgICB9O1xuICAgICAgZS5tZXNzYWdlID0gYEZhaWxlZCB0byBzaWduIGlucHV0ICMke2luZGV4fSAtICR7ZS5tZXNzYWdlfSAtICR7SlNPTi5zdHJpbmdpZnkoZS5yZXN1bHQsIG51bGwsIDQpfSAtIFxcbiR7ZS5zdGFja31gO1xuICAgICAgZGVidWcoJ2lucHV0IHNpZ24gZmFpbGVkOiAlcycsIGUubWVzc2FnZSk7XG4gICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhcnRpYWxUcmFuc2FjdGlvbiA9IHR4Yi5idWlsZEluY29tcGxldGUoKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBwYXJ0aWFsVHJhbnNhY3Rpb24uaW5zLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSB1dHhvbGliLmJpdGdvLmdldFNpZ25hdHVyZVZlcmlmaWNhdGlvbnMoXG4gICAgICAgIHBhcnRpYWxUcmFuc2FjdGlvbiwgaW5kZXgsIHBhcmFtcy51bnNwZW50c1tpbmRleF0udmFsdWVcbiAgICAgICkuZmlsdGVyKHYgPT4gdi5zaWduZWRCeSAhPT0gdW5kZWZpbmVkKS5sZW5ndGg7XG4gICAgICBpZiAoc2lnbmF0dXJlQ291bnQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5mdWxsTG9jYWxTaWduaW5nICYmIHNpZ25hdHVyZUNvdW50IDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bGxMb2NhbFNpZ25pbmcgc2V0OiBleHBlY3RlZCBhdCBsZWFzdCB0d28gdmFsaWQgc2lnbmF0dXJlcycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe1xuICAgIHRyYW5zYWN0aW9uSGV4OiBwYXJ0aWFsVHJhbnNhY3Rpb24udG9IZXgoKSxcbiAgfSk7XG59O1xuIl19