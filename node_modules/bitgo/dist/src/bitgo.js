"use strict";
//
// BitGo JavaScript SDK
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitGo = void 0;
const superagent = require("superagent");
const utxolib = require("@bitgo/utxo-lib");
const bip32 = require("bip32");
const bitcoinMessage = require("bitcoinjs-message");
const PendingApprovals = require('./pendingapprovals');
const shamir = require("secrets.js-grempe");
const pjson = require("../package.json");
const _ = require("lodash");
const config = require("./config");
const debugLib = require("debug");
const TransactionBuilder = require('./transactionBuilder');
const Blockchain = require('./blockchain');
const Keychains = require('./keychains');
const TravelRule = require('./travelRule');
const Wallet = require("./wallet");
const Wallets = require('./wallets');
const Markets = require('./markets');
const coinFactory_1 = require("./v2/coinFactory");
const ecdh_1 = require("./ecdh");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_api_1 = require("@bitgo/sdk-api");
const debug = debugLib('bitgo:index');
if (!process.browser) {
    debug('enabling superagent-proxy wrapper');
    require('superagent-proxy')(superagent);
}
class BitGo extends sdk_api_1.BitGoAPI {
    /**
     * Constructor for BitGo Object
     */
    constructor(params = {}) {
        super(params);
        if (!sdk_core_1.common.validateParams(params, [], ['clientId', 'clientSecret', 'refreshToken', 'accessToken', 'userAgent', 'customRootURI', 'customBitcoinNetwork', 'serverXpub', 'stellarFederationServerUrl']) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        if ((!params.clientId) !== (!params.clientSecret)) {
            throw new Error('invalid argument - must provide both client id and secret');
        }
        this._version = pjson.version;
        this._keychains = null;
        this._wallets = null;
    }
    /**
     * Create a basecoin object
     * @param coinName
     */
    coin(coinName) {
        return coinFactory_1.GlobalCoinFactory.getInstance(this, coinName);
    }
    /**
     * Create a basecoin object for a virtual token
     * @param tokenName
     */
    async token(tokenName) {
        await this.fetchConstants();
        return this.coin(tokenName);
    }
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    verifyAddress(params = {}) {
        sdk_core_1.common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        const networkName = sdk_core_1.common.Environments[this.getEnv()].network;
        const network = utxolib.networks[networkName];
        let address;
        try {
            address = utxolib.address.fromBase58Check(params.address, network);
        }
        catch (e) {
            return false;
        }
        return address.version === network.pubKeyHash || address.version === network.scriptHash;
    }
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    splitSecret({ seed, passwords, m }) {
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        const n = passwords.length;
        const secrets = shamir.share(seed, n, m);
        const shards = _.zipWith(secrets, passwords, (shard, password) => {
            return this.encrypt({ input: shard, password });
        });
        const node = bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            m,
            n,
            seedShares: shards,
        };
    }
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    reconstituteSecret({ shards, passwords }) {
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const seed = shamir.combine(secrets);
        const node = bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed,
        };
    }
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    verifyShards({ shards, passwords, m, xpub }) {
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        const generateCombinations = (array, m, entryIndices = []) => {
            let combinations = [];
            if (entryIndices.length === m) {
                const currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            let entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (let i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                const currentEntryIndices = [...entryIndices, i];
                const newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = [...combinations, ...newCombinations];
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const secretCombinations = generateCombinations(secrets, m);
        const seeds = secretCombinations.map((currentCombination) => {
            return shamir.combine(currentCombination);
        });
        const uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        const seed = _.first(uniqueSeeds);
        const node = bip32.fromSeed(Buffer.from(seed, 'hex'));
        const restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    }
    /**
     * @deprecated - use `getSharedSecret()`
     */
    getECDHSecret({ otherPubKeyHex, eckey }) {
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        return ecdh_1.getSharedSecret(eckey, Buffer.from(otherPubKeyHex, 'hex')).toString('hex');
    }
    /**
     * Gets the user's private keychain, used for receiving shares
     */
    async getECDHSharingKeychain() {
        const result = await this.get(this.url('/user/settings')).result();
        if (!result.settings.ecdhKeychain) {
            return new Error('ecdh keychain not found for user');
        }
        return this.keychains().get({ xpub: result.settings.ecdhKeychain });
    }
    /**
     * Get bitcoin market data
     *
     * @deprecated
     */
    markets() {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    }
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    // cb-compat
    async market() {
        return this.get(this.url('/market/latest')).result();
    }
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     * @deprecated
     */
    async yesterday() {
        return this.get(this.url('/market/yesterday')).result();
    }
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @returns {*}
     * @deprecated
     */
    async registerPushToken(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['pushToken', 'operatingSystem'], []);
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices')).send(postParams).result();
    }
    /**
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @deprecated
     */
    verifyPushToken(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.pushVerificationToken)) {
            throw new Error('required string pushVerificationToken');
        }
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, 'pushVerificationToken');
        return this.post(this.url('/devices/verify')).send(postParams).result();
    }
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    async authenticateWithAuthCode(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.authCode)) {
            throw new Error('required string authCode');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const authCode = params.authCode;
        if (this._token) {
            throw new Error('already logged in');
        }
        const request = this.post(this._baseUrl + '/oauth/token');
        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
        const body = await request
            .send({
            grant_type: 'authorization_code',
            code: authCode,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        this._user = await this.me();
        return body;
    }
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     */
    async changePassword({ oldPassword, newPassword }) {
        if (!_.isString(oldPassword)) {
            throw new Error('expected string oldPassword');
        }
        if (!_.isString(newPassword)) {
            throw new Error('expected string newPassword');
        }
        const user = this.user();
        if (typeof user !== 'object' || !user.username) {
            throw new Error('missing required object user');
        }
        const validation = await this.verifyPassword({ password: oldPassword });
        if (!validation) {
            throw new Error('the provided oldPassword is incorrect');
        }
        // it doesn't matter which coin we choose because the v2 updatePassword functions updates all v2 keychains
        // we just need to choose a coin that exists in the current environment
        const coin = sdk_core_1.common.Environments[this.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
        const updateKeychainPasswordParams = { oldPassword, newPassword };
        const v1KeychainUpdatePWResult = await this.keychains().updatePassword(updateKeychainPasswordParams);
        const v2Keychains = await this.coin(coin).keychains().updatePassword(updateKeychainPasswordParams);
        const updatePasswordParams = {
            keychains: v1KeychainUpdatePWResult.keychains,
            v2_keychains: v2Keychains,
            version: v1KeychainUpdatePWResult.version,
            oldPassword: this.calculateHMAC(user.username, oldPassword),
            password: this.calculateHMAC(user.username, newPassword),
        };
        return this.post(this.url('/user/changepassword')).send(updatePasswordParams).result();
    }
    /**
     * Get the blockchain object.
     * @deprecated
     */
    blockchain() {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    }
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    keychains() {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    }
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    wallets() {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    }
    /**
     * Get the travel rule object
     * @deprecated
     */
    travelRule() {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    }
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    pendingApprovals() {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    }
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    newWalletObject(walletParams) {
        return new Wallet(this, walletParams);
    }
    /**
     * Get all the address labels on all of the user's wallets
     *
     * @deprecated
     */
    async labels() {
        return this.get(this.url('/labels')).result('labels');
    }
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    async estimateFee(params = {}) {
        const queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee')).query(queryParams).result();
    }
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @deprecated
     */
    async instantGuarantee(params) {
        if (!_.isString(params.id)) {
            throw new Error('required string id');
        }
        const body = await this.get(this.url('/instant/' + params.id)).result();
        if (!body.guarantee) {
            throw new Error('no guarantee found in response body');
        }
        if (!body.signature) {
            throw new Error('no signature found in guarantee response body');
        }
        const signingAddress = sdk_core_1.common.Environments[this.getEnv()].signingAddress;
        const signatureBuffer = Buffer.from(body.signature, 'hex');
        const prefix = utxolib.networks[sdk_core_1.common.Environments[this.getEnv()].network].messagePrefix;
        const isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
        if (!isValidSignature) {
            throw new Error('incorrect signature');
        }
        return body;
    }
    /**
     * Get a target address for payment of a BitGo fee
     * @deprecated
     */
    async getBitGoFeeAddress() {
        return this.post(this.url('/billing/address')).send({}).result();
    }
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    async getWalletAddress({ address }) {
        return this.get(this.url(`/walletaddress/${address}`)).result();
    }
    /**
     * Fetch list of user webhooks
     *
     * @returns {*}
     * @deprecated
     */
    async listWebhooks() {
        return this.get(this.url('/webhooks')).result();
    }
    /**
     * Add new user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async addWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks')).send(params).result();
    }
    /**
     * Remove user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async removeWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks')).send(params).result();
    }
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @returns {*}
     */
    async listWebhookNotifications(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications')).query(query).result();
    }
    /**
     * Simulate a user webhook
     *
     * @param params
     * @returns {*}
     */
    async simulateWebhook(params) {
        sdk_core_1.common.validateParams(params, ['webhookId', 'blockId'], []);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url(`/webhooks/${params.webhookId}/simulate`))
            .send(params)
            .result();
    }
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @return {Object} The client constants object
     */
    getConstants() {
        // kick off a fresh request for the client constants
        this.fetchConstants().catch(function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, config.defaultConstants(this.getEnv()), sdk_api_1.BitGoAPI._constants[this.getEnv()]);
    }
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @return {any}
     */
    async calculateMinerFeeInfo(params) {
        return TransactionBuilder.calculateMinerFeeInfo(params);
    }
}
exports.BitGo = BitGo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z28uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z28udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLEVBQUU7QUFDRix1QkFBdUI7QUFDdkIsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFOzs7QUFFRix5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQixvREFBcUQ7QUFFckQsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUN2RCw0Q0FBNkM7QUFDN0MseUNBQTBDO0FBRTFDLDRCQUE0QjtBQUM1QixtQ0FBbUM7QUFFbkMsa0NBQWtDO0FBRWxDLE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDM0QsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzNDLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN6QyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDM0MsbUNBQW9DO0FBQ3BDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNyQyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDckMsa0RBQXFEO0FBQ3JELGlDQUF5QztBQUN6Qyw4Q0FBeUM7QUFDekMsNENBR3dCO0FBRXhCLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUV0QyxJQUFJLENBQUUsT0FBZSxDQUFDLE9BQU8sRUFBRTtJQUM3QixLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztJQUMzQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztDQUN6QztBQXNHRCxNQUFhLEtBQU0sU0FBUSxrQkFBUTtJQVFqQzs7T0FFRztJQUNILFlBQVksU0FBMEIsRUFB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TSxXQUFXLEdBQVEsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDekMsSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO1NBQzFDO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFB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Q0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2dCQUM3RCxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3BCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxrRkFBa0Y7UUFDbEYsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsa0JBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsS0FBSyxDQUFDLHFCQUFxQixDQUFDLE1BQVc7UUFDckMsT0FBTyxrQkFBa0IsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMxRCxDQUFDO0NBRUY7QUE5cUJELHNCQThxQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gQml0R28gSmF2YVNjcmlwdCBTREtcbi8vXG4vLyBDb3B5cmlnaHQgMjAxNCwgQml0R28sIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuXG5pbXBvcnQgKiBhcyBzdXBlcmFnZW50IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgYmlwMzIgZnJvbSAnYmlwMzInO1xuaW1wb3J0IGJpdGNvaW5NZXNzYWdlID0gcmVxdWlyZSgnYml0Y29pbmpzLW1lc3NhZ2UnKTtcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi92Mi9iYXNlQ29pbic7XG5jb25zdCBQZW5kaW5nQXBwcm92YWxzID0gcmVxdWlyZSgnLi9wZW5kaW5nYXBwcm92YWxzJyk7XG5pbXBvcnQgc2hhbWlyID0gcmVxdWlyZSgnc2VjcmV0cy5qcy1ncmVtcGUnKTtcbmltcG9ydCBwanNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuXG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IFRyYW5zYWN0aW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb25CdWlsZGVyJyk7XG5jb25zdCBCbG9ja2NoYWluID0gcmVxdWlyZSgnLi9ibG9ja2NoYWluJyk7XG5jb25zdCBLZXljaGFpbnMgPSByZXF1aXJlKCcuL2tleWNoYWlucycpO1xuY29uc3QgVHJhdmVsUnVsZSA9IHJlcXVpcmUoJy4vdHJhdmVsUnVsZScpO1xuaW1wb3J0IFdhbGxldCA9IHJlcXVpcmUoJy4vd2FsbGV0Jyk7XG5jb25zdCBXYWxsZXRzID0gcmVxdWlyZSgnLi93YWxsZXRzJyk7XG5jb25zdCBNYXJrZXRzID0gcmVxdWlyZSgnLi9tYXJrZXRzJyk7XG5pbXBvcnQgeyBHbG9iYWxDb2luRmFjdG9yeSB9IGZyb20gJy4vdjIvY29pbkZhY3RvcnknO1xuaW1wb3J0IHsgZ2V0U2hhcmVkU2VjcmV0IH0gZnJvbSAnLi9lY2RoJztcbmltcG9ydCB7IGNvbW1vbiB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQge1xuICBCaXRHb0FQSSxcbiAgQml0R29BUElPcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWFwaSc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOmluZGV4Jyk7XG5cbmlmICghKHByb2Nlc3MgYXMgYW55KS5icm93c2VyKSB7XG4gIGRlYnVnKCdlbmFibGluZyBzdXBlcmFnZW50LXByb3h5IHdyYXBwZXInKTtcbiAgcmVxdWlyZSgnc3VwZXJhZ2VudC1wcm94eScpKHN1cGVyYWdlbnQpO1xufVxuXG5leHBvcnQgdHlwZSBCaXRHb09wdGlvbnMgPSBCaXRHb0FQSU9wdGlvbnM7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXByZWNhdGVkVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0U2VjcmV0T3B0aW9ucyB7XG4gIHNlZWQ6IHN0cmluZztcbiAgcGFzc3dvcmRzOiBzdHJpbmdbXTtcbiAgbTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0U2VjcmV0IHtcbiAgeHB1Yjogc3RyaW5nO1xuICBtOiBudW1iZXI7XG4gIG46IG51bWJlcjtcbiAgc2VlZFNoYXJlczogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY29uc3RpdHV0ZVNlY3JldE9wdGlvbnMge1xuICBzaGFyZHM6IHN0cmluZ1tdO1xuICBwYXNzd29yZHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY29uc3RpdHV0ZWRTZWNyZXQge1xuICB4cHViOiBzdHJpbmc7XG4gIHhwcnY6IHN0cmluZztcbiAgc2VlZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVNoYXJkc09wdGlvbnMge1xuICBzaGFyZHM6IHN0cmluZ1tdO1xuICBwYXNzd29yZHM6IHN0cmluZ1tdO1xuICBtOiBudW1iZXI7XG4gIHhwdWI6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRFY2RoU2VjcmV0T3B0aW9ucyB7XG4gIG90aGVyUHViS2V5SGV4OiBzdHJpbmc7XG4gIGVja2V5OiB1dHhvbGliLkVDUGFpci5FQ1BhaXJJbnRlcmZhY2U7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBDaGFuZ2VQYXNzd29yZE9wdGlvbnMge1xuICBvbGRQYXNzd29yZDogc3RyaW5nO1xuICBuZXdQYXNzd29yZDogc3RyaW5nO1xufVxuXG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFc3RpbWF0ZUZlZU9wdGlvbnMge1xuICBudW1CbG9ja3M/OiBudW1iZXI7XG4gIG1heEZlZT86IG51bWJlcjtcbiAgaW5wdXRzPzogc3RyaW5nW107XG4gIHR4U2l6ZT86IG51bWJlcjtcbiAgY3BmcEF3YXJlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdlYmhvb2tPcHRpb25zIHtcbiAgdXJsOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0V2ViaG9va05vdGlmaWNhdGlvbnNPcHRpb25zIHtcbiAgcHJldklkPzogc3RyaW5nO1xuICBsaW1pdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHb1NpbXVsYXRlV2ViaG9va09wdGlvbnMge1xuICB3ZWJob29rSWQ6IHN0cmluZztcbiAgYmxvY2tJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZU9wdGlvbnMge1xuICBhdXRoQ29kZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyB7XG4gIHB1c2hWZXJpZmljYXRpb25Ub2tlbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0ZXJQdXNoVG9rZW5PcHRpb25zIHtcbiAgcHVzaFRva2VuOiB1bmtub3duO1xuICBvcGVyYXRpbmdTeXN0ZW06IHVua25vd247XG59XG5cbmV4cG9ydCBjbGFzcyBCaXRHbyBleHRlbmRzIEJpdEdvQVBJIHtcbiAgcHJpdmF0ZSBfa2V5Y2hhaW5zOiBhbnk7XG4gIHByaXZhdGUgX3dhbGxldHM6IGFueTtcbiAgcHJpdmF0ZSBfbWFya2V0cz86IGFueTtcbiAgcHJpdmF0ZSBfYmxvY2tjaGFpbj86IGFueTtcbiAgcHJpdmF0ZSBfdHJhdmVsUnVsZT86IGFueTtcbiAgcHJpdmF0ZSBfcGVuZGluZ0FwcHJvdmFscz86IGFueTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIEJpdEdvIE9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBCaXRHb0FQSU9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgaWYgKCFjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydjbGllbnRJZCcsICdjbGllbnRTZWNyZXQnLCAncmVmcmVzaFRva2VuJywgJ2FjY2Vzc1Rva2VuJywgJ3VzZXJBZ2VudCcsICdjdXN0b21Sb290VVJJJywgJ2N1c3RvbUJpdGNvaW5OZXR3b3JrJywgJ3NlcnZlclhwdWInLCAnc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwnXSkgfHxcbiAgICAgIChwYXJhbXMudXNlUHJvZHVjdGlvbiAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnVzZVByb2R1Y3Rpb24pKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCghcGFyYW1zLmNsaWVudElkKSAhPT0gKCFwYXJhbXMuY2xpZW50U2VjcmV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IC0gbXVzdCBwcm92aWRlIGJvdGggY2xpZW50IGlkIGFuZCBzZWNyZXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl92ZXJzaW9uID0gcGpzb24udmVyc2lvbjtcbiAgICB0aGlzLl9rZXljaGFpbnMgPSBudWxsO1xuICAgIHRoaXMuX3dhbGxldHMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhc2Vjb2luIG9iamVjdFxuICAgKiBAcGFyYW0gY29pbk5hbWVcbiAgICovXG4gIGNvaW4oY29pbk5hbWU6IHN0cmluZyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gR2xvYmFsQ29pbkZhY3RvcnkuZ2V0SW5zdGFuY2UodGhpcywgY29pbk5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhc2Vjb2luIG9iamVjdCBmb3IgYSB2aXJ0dWFsIHRva2VuXG4gICAqIEBwYXJhbSB0b2tlbk5hbWVcbiAgICovXG4gIGFzeW5jIHRva2VuKHRva2VuTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCYXNlQ29pbj4ge1xuICAgIGF3YWl0IHRoaXMuZmV0Y2hDb25zdGFudHMoKTtcbiAgICByZXR1cm4gdGhpcy5jb2luKHRva2VuTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IGEgQml0Y29pbiBhZGRyZXNzIGlzIGEgdmFsaWQgYmFzZTU4IGFkZHJlc3NcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBEZXByZWNhdGVkVmVyaWZ5QWRkcmVzc09wdGlvbnMgPSB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbXSk7XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXR3b3JrTmFtZSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yaztcbiAgICBjb25zdCBuZXR3b3JrID0gdXR4b2xpYi5uZXR3b3Jrc1tuZXR3b3JrTmFtZV07XG5cbiAgICBsZXQgYWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgYWRkcmVzcyA9IHV0eG9saWIuYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2socGFyYW1zLmFkZHJlc3MsIG5ldHdvcmspO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkcmVzcy52ZXJzaW9uID09PSBuZXR3b3JrLnB1YktleUhhc2ggfHwgYWRkcmVzcy52ZXJzaW9uID09PSBuZXR3b3JrLnNjcmlwdEhhc2g7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgYSBzZWNyZXQgaW50byBzaGFyZHMgdXNpbmcgU2hhbWlyIFNlY3JldCBTaGFyaW5nLlxuICAgKiBAcGFyYW0gc2VlZCBBIGhleGFkZWNpbWFsIHNlY3JldCB0byBzcGxpdFxuICAgKiBAcGFyYW0gcGFzc3dvcmRzIEFuIGFycmF5IG9mIHRoZSBwYXNzd29yZHMgdXNlZCB0byBlbmNyeXB0IGVhY2ggc2hhcmVcbiAgICogQHBhcmFtIG0gVGhlIHRocmVzaG9sZCBudW1iZXIgb2Ygc2hhcmRzIG5lY2Vzc2FyeSB0byByZWNvbnN0aXR1dGUgdGhlIHNlY3JldFxuICAgKi9cbiAgc3BsaXRTZWNyZXQoeyBzZWVkLCBwYXNzd29yZHMsIG0gfTogU3BsaXRTZWNyZXRPcHRpb25zKTogU3BsaXRTZWNyZXQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghXy5pc0ludGVnZXIobSkgfHwgbSA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMicpO1xuICAgIH1cblxuICAgIGlmIChwYXNzd29yZHMubGVuZ3RoIDwgbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgYXJyYXkgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYW4gbScpO1xuICAgIH1cblxuICAgIGNvbnN0IG4gPSBwYXNzd29yZHMubGVuZ3RoO1xuICAgIGNvbnN0IHNlY3JldHM6IHN0cmluZ1tdID0gc2hhbWlyLnNoYXJlKHNlZWQsIG4sIG0pO1xuICAgIGNvbnN0IHNoYXJkcyA9IF8uemlwV2l0aChzZWNyZXRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IG5vZGUgPSBiaXAzMi5mcm9tU2VlZChCdWZmZXIuZnJvbShzZWVkLCAnaGV4JykpO1xuICAgIHJldHVybiB7XG4gICAgICB4cHViOiBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKSxcbiAgICAgIG0sXG4gICAgICBuLFxuICAgICAgc2VlZFNoYXJlczogc2hhcmRzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVjb25zdGl0dXRlIGEgc2VjcmV0IHdoaWNoIHdhcyBzaGFyZGVkIHdpdGggYHNwbGl0U2VjcmV0YC5cbiAgICogQHBhcmFtIHNoYXJkc1xuICAgKiBAcGFyYW0gcGFzc3dvcmRzXG4gICAqL1xuICByZWNvbnN0aXR1dGVTZWNyZXQoeyBzaGFyZHMsIHBhc3N3b3JkcyB9OiBSZWNvbnN0aXR1dGVTZWNyZXRPcHRpb25zKTogUmVjb25zdGl0dXRlZFNlY3JldCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXJkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhc3N3b3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcmRzLmxlbmd0aCAhPT0gcGFzc3dvcmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgYW5kIHBhc3N3b3JkcyBhcnJheXMgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjcmV0cyA9IF8uemlwV2l0aChzaGFyZHMsIHBhc3N3b3JkcywgKHNoYXJkLCBwYXNzd29yZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdCh7IGlucHV0OiBzaGFyZCwgcGFzc3dvcmQgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VlZDogc3RyaW5nID0gc2hhbWlyLmNvbWJpbmUoc2VjcmV0cyk7XG4gICAgY29uc3Qgbm9kZSA9IGJpcDMyLmZyb21TZWVkKEJ1ZmZlci5mcm9tKHNlZWQsICdoZXgnKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhwdWI6IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpIGFzIHN0cmluZyxcbiAgICAgIHhwcnY6IG5vZGUudG9CYXNlNTgoKSBhcyBzdHJpbmcsXG4gICAgICBzZWVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHNoYXJkc1xuICAgKiBAcGFyYW0gcGFzc3dvcmRzXG4gICAqIEBwYXJhbSBtXG4gICAqIEBwYXJhbSB4cHViIE9wdGlvbmFsIHhwdWIgdG8gdmVyaWZ5IHRoZSByZXN1bHRzIGFnYWluc3RcbiAgICovXG4gIHZlcmlmeVNoYXJkcyh7IHNoYXJkcywgcGFzc3dvcmRzLCBtLCB4cHViIH06IFZlcmlmeVNoYXJkc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIGEgZ2l2ZW4gYXJyYXkncyB2YWx1ZXMgZ2l2ZW4gc3Vic2V0IHNpemUgbVxuICAgICAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgd2hvc2UgdmFsdWVzIGFyZSB0byBiZSBhcnJhbmdlZCBpbiBhbGwgY29tYmluYXRpb25zXG4gICAgICogQHBhcmFtIG0gVGhlIHNpemUgb2YgZWFjaCBzdWJzZXRcbiAgICAgKiBAcGFyYW0gZW50cnlJbmRpY2VzIFJlY3Vyc2l2ZWx5IHRyYWlsaW5nIHNldCBvZiBjdXJyZW50bHkgY2hvc2VuIGFycmF5IGluZGljZXMgZm9yIHRoZSBjb21iaW5hdGlvbiBzdWJzZXQgdW5kZXIgY29uc3RydWN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGNvbnN0IGdlbmVyYXRlQ29tYmluYXRpb25zID0gKGFycmF5OiBzdHJpbmdbXSwgbTogbnVtYmVyLCBlbnRyeUluZGljZXM6IG51bWJlcltdID0gW10pOiBzdHJpbmdbXVtdID0+IHtcbiAgICAgIGxldCBjb21iaW5hdGlvbnM6IHN0cmluZ1tdW10gPSBbXTtcblxuICAgICAgaWYgKGVudHJ5SW5kaWNlcy5sZW5ndGggPT09IG0pIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbWJpbmF0aW9uID0gXy5hdChhcnJheSwgZW50cnlJbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIFtjdXJyZW50Q29tYmluYXRpb25dO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgaGlnaGVzdCBpbmRleFxuICAgICAgbGV0IGVudHJ5SW5kZXggPSBfLmxhc3QoZW50cnlJbmRpY2VzKTtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBjdXJyZW50bHkgbm8gaW5kaWNlcywgYXNzdW1lIC0xXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChlbnRyeUluZGV4KSkge1xuICAgICAgICBlbnRyeUluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gZW50cnlJbmRleCArIDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGN1cnJlbnQgaW5kZXggdG8gdGhlIHRyYWlsaW5nIGluZGljZXNcbiAgICAgICAgY29uc3QgY3VycmVudEVudHJ5SW5kaWNlcyA9IFsuLi5lbnRyeUluZGljZXMsIGldO1xuICAgICAgICBjb25zdCBuZXdDb21iaW5hdGlvbnMgPSBnZW5lcmF0ZUNvbWJpbmF0aW9ucyhhcnJheSwgbSwgY3VycmVudEVudHJ5SW5kaWNlcyk7XG4gICAgICAgIGNvbWJpbmF0aW9ucyA9IFsuLi5jb21iaW5hdGlvbnMsIC4uLm5ld0NvbWJpbmF0aW9uc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21iaW5hdGlvbnM7XG4gICAgfTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFyZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXJkcy5sZW5ndGggIT09IHBhc3N3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIGFuZCBwYXNzd29yZHMgYXJyYXlzIG11c3QgaGF2ZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3JldHMgPSBfLnppcFdpdGgoc2hhcmRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlY3JldENvbWJpbmF0aW9ucyA9IGdlbmVyYXRlQ29tYmluYXRpb25zKHNlY3JldHMsIG0pO1xuICAgIGNvbnN0IHNlZWRzID0gc2VjcmV0Q29tYmluYXRpb25zLm1hcCgoY3VycmVudENvbWJpbmF0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gc2hhbWlyLmNvbWJpbmUoY3VycmVudENvbWJpbmF0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCB1bmlxdWVTZWVkcyA9IF8udW5pcShzZWVkcyk7XG4gICAgaWYgKHVuaXF1ZVNlZWRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWVkID0gXy5maXJzdCh1bmlxdWVTZWVkcyk7XG4gICAgY29uc3Qgbm9kZSA9IGJpcDMyLmZyb21TZWVkKEJ1ZmZlci5mcm9tKHNlZWQsICdoZXgnKSk7XG4gICAgY29uc3QgcmVzdG9yZWRYcHViID0gbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoeHB1YikpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyh4cHViKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hwdWIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3RvcmVkWHB1YiAhPT0geHB1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgLSB1c2UgYGdldFNoYXJlZFNlY3JldCgpYFxuICAgKi9cbiAgZ2V0RUNESFNlY3JldCh7IG90aGVyUHViS2V5SGV4LCBlY2tleSB9OiBHZXRFY2RoU2VjcmV0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKG90aGVyUHViS2V5SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdGhlclB1YktleUhleCBzdHJpbmcgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzT2JqZWN0KGVja2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlY2tleSBvYmplY3QgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U2hhcmVkU2VjcmV0KGVja2V5LCBCdWZmZXIuZnJvbShvdGhlclB1YktleUhleCwgJ2hleCcpKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlcidzIHByaXZhdGUga2V5Y2hhaW4sIHVzZWQgZm9yIHJlY2VpdmluZyBzaGFyZXNcbiAgICovXG4gIGFzeW5jIGdldEVDREhTaGFyaW5nS2V5Y2hhaW4oKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2V0dGluZ3MnKSkucmVzdWx0KCk7XG4gICAgaWYgKCFyZXN1bHQuc2V0dGluZ3MuZWNkaEtleWNoYWluKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdlY2RoIGtleWNoYWluIG5vdCBmb3VuZCBmb3IgdXNlcicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXljaGFpbnMoKS5nZXQoeyB4cHViOiByZXN1bHQuc2V0dGluZ3MuZWNkaEtleWNoYWluIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBiaXRjb2luIG1hcmtldCBkYXRhXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBtYXJrZXRzKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9tYXJrZXRzKSB7XG4gICAgICB0aGlzLl9tYXJrZXRzID0gbmV3IE1hcmtldHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXJrZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF0ZXN0IGJpdGNvaW4gcHJpY2VzXG4gICAqIChEZXByZWNhdGVkOiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSkgdXNlIGBiaXRnby5tYXJrZXRzKCkubGF0ZXN0KClgXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICAvLyBjYi1jb21wYXRcbiAgYXN5bmMgbWFya2V0KCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvbWFya2V0L2xhdGVzdCcpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbWFya2V0IGRhdGEgZnJvbSB5ZXN0ZXJkYXlcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYml0Z28ubWFya2V0cygpLnllc3RlcmRheSgpXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyB5ZXN0ZXJkYXkoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQveWVzdGVyZGF5JykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSBvcGVyYXRpbmdTeXN0ZW06IG9uZSBvZiBpb3MsIGFuZHJvaWRcbiAgICogLSBwdXNoVG9rZW46IGhleC1mb3JtYXR0ZWQgdG9rZW4gZm9yIHRoZSByZXNwZWN0aXZlIG5hdGl2ZSBwdXNoIG5vdGlmaWNhdGlvbiBzZXJ2aWNlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgcmVnaXN0ZXJQdXNoVG9rZW4ocGFyYW1zOiBSZWdpc3RlclB1c2hUb2tlbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3B1c2hUb2tlbicsICdvcGVyYXRpbmdTeXN0ZW0nXSwgW10pO1xuXG4gICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgLy8gdGhpcyBkZXZpY2UgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgdG8gYW4gZXh0ZW5zaWJsZSBzZXNzaW9uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBsb2dnZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3N0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydwdXNoVG9rZW4nLCAnb3BlcmF0aW5nU3lzdGVtJ10pO1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL2RldmljZXMnKSkuc2VuZChwb3N0UGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gcHVzaFZlcmlmaWNhdGlvblRva2VuOiB0aGUgdG9rZW4gcmVjZWl2ZWQgdmlhIHB1c2ggbm90aWZpY2F0aW9uIHRvIGNvbmZpcm0gdGhlIGRldmljZSdzIG1vYmlsaXR5XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB2ZXJpZnlQdXNoVG9rZW4ocGFyYW1zOiBWZXJpZnlQdXNoVG9rZW5PcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wdXNoVmVyaWZpY2F0aW9uVG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBwdXNoVmVyaWZpY2F0aW9uVG9rZW4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAvLyB0aGlzIGRldmljZSBoYXMgdG8gYmUgcmVnaXN0ZXJlZCB0byBhbiBleHRlbnNpYmxlIHNlc3Npb25cbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGxvZ2dlZCBpbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCAncHVzaFZlcmlmaWNhdGlvblRva2VuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvZGV2aWNlcy92ZXJpZnknKSkuc2VuZChwb3N0UGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpbiB0byB0aGUgYml0Z28gc3lzdGVtIHVzaW5nIGFuIGF1dGhjb2RlIGdlbmVyYXRlZCB2aWEgT2F1dGhcbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZShwYXJhbXM6IEF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZU9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIG9iamVjdCBwYXJhbXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmF1dGhDb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgYXV0aENvZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudElkIHx8ICF0aGlzLl9jbGllbnRTZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBjbGllbnQgaWQgYW5kIHNlY3JldCBzZXQgZmlyc3QgdG8gdXNlIHRoaXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdXRoQ29kZSA9IHBhcmFtcy5hdXRoQ29kZTtcblxuICAgIGlmICh0aGlzLl90b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHJlYWR5IGxvZ2dlZCBpbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnBvc3QodGhpcy5fYmFzZVVybCArICcvb2F1dGgvdG9rZW4nKTtcbiAgICByZXF1ZXN0LmZvcmNlVjFBdXRoID0gdHJ1ZTsgLy8gT0F1dGggY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdjEgYXV0aGVudGljYXRpb25cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdFxuICAgICAgLnNlbmQoe1xuICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgY29kZTogYXV0aENvZGUsXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5fY2xpZW50SWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG5cbiAgICB0aGlzLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IGJvZHkucmVmcmVzaF90b2tlbjtcbiAgICB0aGlzLl91c2VyID0gYXdhaXQgdGhpcy5tZSgpO1xuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgcGFzc3dvcmQgb2YgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci5cbiAgICogQWxzbyBjaGFuZ2UgYWxsIHYxIGFuZCB2MiBrZXljaGFpbiBwYXNzd29yZHMgaWYgdGhleSBtYXRjaCB0aGVcbiAgICogZ2l2ZW4gb2xkUGFzc3dvcmQuIFJldHVybnMgbm90aGluZyBvbiBzdWNjZXNzLlxuICAgKiBAcGFyYW0gb2xkUGFzc3dvcmQge1N0cmluZ30gLSB0aGUgY3VycmVudCBwYXNzd29yZFxuICAgKiBAcGFyYW0gbmV3UGFzc3dvcmQge1N0cmluZ30gLSB0aGUgbmV3IHBhc3N3b3JkXG4gICAqL1xuICBhc3luYyBjaGFuZ2VQYXNzd29yZCh7IG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9OiBDaGFuZ2VQYXNzd29yZE9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhvbGRQYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG9sZFBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKG5ld1Bhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgbmV3UGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyID0gdGhpcy51c2VyKCk7XG4gICAgaWYgKHR5cGVvZiB1c2VyICE9PSAnb2JqZWN0JyB8fCAhdXNlci51c2VybmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCB1c2VyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IHRoaXMudmVyaWZ5UGFzc3dvcmQoeyBwYXNzd29yZDogb2xkUGFzc3dvcmQgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBwcm92aWRlZCBvbGRQYXNzd29yZCBpcyBpbmNvcnJlY3QnKTtcbiAgICB9XG5cbiAgICAvLyBpdCBkb2Vzbid0IG1hdHRlciB3aGljaCBjb2luIHdlIGNob29zZSBiZWNhdXNlIHRoZSB2MiB1cGRhdGVQYXNzd29yZCBmdW5jdGlvbnMgdXBkYXRlcyBhbGwgdjIga2V5Y2hhaW5zXG4gICAgLy8gd2UganVzdCBuZWVkIHRvIGNob29zZSBhIGNvaW4gdGhhdCBleGlzdHMgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICBjb25zdCBjb2luID0gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5uZXR3b3JrID09PSAnYml0Y29pbicgPyAnYnRjJyA6ICd0YnRjJztcblxuICAgIGNvbnN0IHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMgPSB7IG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9O1xuICAgIGNvbnN0IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdCA9IGF3YWl0IHRoaXMua2V5Y2hhaW5zKCkudXBkYXRlUGFzc3dvcmQodXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyk7XG4gICAgY29uc3QgdjJLZXljaGFpbnMgPSBhd2FpdCB0aGlzLmNvaW4oY29pbikua2V5Y2hhaW5zKCkudXBkYXRlUGFzc3dvcmQodXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyk7XG5cbiAgICBjb25zdCB1cGRhdGVQYXNzd29yZFBhcmFtcyA9IHtcbiAgICAgIGtleWNoYWluczogdjFLZXljaGFpblVwZGF0ZVBXUmVzdWx0LmtleWNoYWlucyxcbiAgICAgIHYyX2tleWNoYWluczogdjJLZXljaGFpbnMsXG4gICAgICB2ZXJzaW9uOiB2MUtleWNoYWluVXBkYXRlUFdSZXN1bHQudmVyc2lvbixcbiAgICAgIG9sZFBhc3N3b3JkOiB0aGlzLmNhbGN1bGF0ZUhNQUModXNlci51c2VybmFtZSwgb2xkUGFzc3dvcmQpLFxuICAgICAgcGFzc3dvcmQ6IHRoaXMuY2FsY3VsYXRlSE1BQyh1c2VyLnVzZXJuYW1lLCBuZXdQYXNzd29yZCksXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2NoYW5nZXBhc3N3b3JkJykpLnNlbmQodXBkYXRlUGFzc3dvcmRQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmxvY2tjaGFpbiBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBibG9ja2NoYWluKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9ibG9ja2NoYWluKSB7XG4gICAgICB0aGlzLl9ibG9ja2NoYWluID0gbmV3IEJsb2NrY2hhaW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIGtleWNoYWlucyBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBrZXljaGFpbnMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2tleWNoYWlucykge1xuICAgICAgdGhpcy5fa2V5Y2hhaW5zID0gbmV3IEtleWNoYWlucyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleWNoYWlucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyB3YWxsZXRzIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHdhbGxldHMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX3dhbGxldHMpIHtcbiAgICAgIHRoaXMuX3dhbGxldHMgPSBuZXcgV2FsbGV0cyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmF2ZWwgcnVsZSBvYmplY3RcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHRyYXZlbFJ1bGUoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX3RyYXZlbFJ1bGUpIHtcbiAgICAgIHRoaXMuX3RyYXZlbFJ1bGUgPSBuZXcgVHJhdmVsUnVsZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RyYXZlbFJ1bGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBlbmRpbmcgYXBwcm92YWxzIHRoYXQgY2FuIGJlIGFwcHJvdmVkLyBvciByZWplY3RlZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcGVuZGluZ0FwcHJvdmFscygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fcGVuZGluZ0FwcHJvdmFscykge1xuICAgICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFscyA9IG5ldyBQZW5kaW5nQXBwcm92YWxzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFscztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBXYWxsZXQgb2JqZWN0LCBpbml0aWFsaXplZCB3aXRoIHRoZSB3YWxsZXQgcGFyYW1zXG4gICAqIENhbiBiZSB1c2VkIHRvIHJlY29uc3RpdHV0ZSBhIHdhbGxldCBmcm9tIGNhY2hlZCBkYXRhXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG5ld1dhbGxldE9iamVjdCh3YWxsZXRQYXJhbXMpOiBhbnkge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMsIHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYWRkcmVzcyBsYWJlbHMgb24gYWxsIG9mIHRoZSB1c2VyJ3Mgd2FsbGV0c1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgbGFiZWxzKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvbGFiZWxzJykpLnJlc3VsdCgnbGFiZWxzJyk7XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGVzIGFwcHJveGltYXRlIGZlZSBwZXIga2IgbmVlZGVkIGZvciBhIHR4IHRvIGdldCBpbnRvIGEgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5udW1CbG9ja3MgdGFyZ2V0IGJsb2NrcyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEZlZSBtYXhpbXVtIGZlZSB3aWxsaW5nIHRvIGJlIHBhaWQgKGZvciBzYWZldHkpXG4gICAqIEBwYXJhbSB7YXJyYXlbc3RyaW5nXX0gcGFyYW1zLmlucHV0cyBsaXN0IG9mIHVuY29uZmlybWVkIHR4SWRzIGZyb20gd2hpY2ggdGhpcyB0cmFuc2FjdGlvbiB1c2VzIGlucHV0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnR4U2l6ZSBlc3RpbWF0ZWQgdHJhbnNhY3Rpb24gc2l6ZSBpbiBieXRlcywgb3B0aW9uYWwgcGFyYW1ldGVyIHVzZWQgZm9yIENQRlAgZXN0aW1hdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuY3BmcEF3YXJlIGZsYWcgaW5kaWNhdGluZyBmZWUgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IENQRlBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlRmVlKHBhcmFtczogRXN0aW1hdGVGZWVPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zOiBhbnkgPSB7IHZlcnNpb246IDEyIH07XG4gICAgaWYgKHBhcmFtcy5udW1CbG9ja3MpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubnVtQmxvY2tzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLm51bUJsb2NrcyA9IHBhcmFtcy5udW1CbG9ja3M7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWF4RmVlKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLm1heEZlZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5tYXhGZWUgPSBwYXJhbXMubWF4RmVlO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmlucHV0cykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5pbnB1dHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMuaW5wdXRzID0gcGFyYW1zLmlucHV0cztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eFNpemUpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudHhTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLnR4U2l6ZSA9IHBhcmFtcy50eFNpemU7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY3BmcEF3YXJlKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5jcGZwQXdhcmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMuY3BmcEF3YXJlID0gcGFyYW1zLmNwZnBBd2FyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy90eC9mZWUnKSkucXVlcnkocXVlcnlQYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBCaXRHbydzIGd1YXJhbnRlZSB1c2luZyBhbiBpbnN0YW50IGlkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGluc3RhbnRHdWFyYW50ZWUocGFyYW1zOiB7IGlkOiBzdHJpbmcgfSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGlkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHRoaXMuZ2V0KHRoaXMudXJsKCcvaW5zdGFudC8nICsgcGFyYW1zLmlkKSkucmVzdWx0KCk7XG4gICAgaWYgKCFib2R5Lmd1YXJhbnRlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBndWFyYW50ZWUgZm91bmQgaW4gcmVzcG9uc2UgYm9keScpO1xuICAgIH1cbiAgICBpZiAoIWJvZHkuc2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHNpZ25hdHVyZSBmb3VuZCBpbiBndWFyYW50ZWUgcmVzcG9uc2UgYm9keScpO1xuICAgIH1cbiAgICBjb25zdCBzaWduaW5nQWRkcmVzcyA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0uc2lnbmluZ0FkZHJlc3M7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmZyb20oYm9keS5zaWduYXR1cmUsICdoZXgnKTtcbiAgICBjb25zdCBwcmVmaXggPSB1dHhvbGliLm5ldHdvcmtzW2NvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29ya10ubWVzc2FnZVByZWZpeDtcbiAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0gYml0Y29pbk1lc3NhZ2UudmVyaWZ5KGJvZHkuZ3VhcmFudGVlLCBzaWduaW5nQWRkcmVzcywgc2lnbmF0dXJlQnVmZmVyLCBwcmVmaXgpO1xuICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc2lnbmF0dXJlJyk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRhcmdldCBhZGRyZXNzIGZvciBwYXltZW50IG9mIGEgQml0R28gZmVlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBnZXRCaXRHb0ZlZUFkZHJlc3MoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvYmlsbGluZy9hZGRyZXNzJykpLnNlbmQoe30pLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYWRkcmVzcyBvYmplY3QgKGluY2x1ZGluZyB0aGUgd2FsbGV0IGlkKSBmb3IgYSBnaXZlbiBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gbG9vayB1cC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGdldFdhbGxldEFkZHJlc3MoeyBhZGRyZXNzIH06IHsgYWRkcmVzczogc3RyaW5nIH0pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3dhbGxldGFkZHJlc3MvJHthZGRyZXNzfWApKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsaXN0IG9mIHVzZXIgd2ViaG9va3NcbiAgICpcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBsaXN0V2ViaG9va3MoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy93ZWJob29rcycpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgYWRkV2ViaG9vayhwYXJhbXM6IFdlYmhvb2tPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHVybCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHJlbW92ZVdlYmhvb2socGFyYW1zOiBXZWJob29rT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy51cmwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB1cmwnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB0eXBlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVsKHRoaXMudXJsKCcvd2ViaG9va3MnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxpc3Qgb2Ygd2ViaG9vayBub3RpZmljYXRpb25zIGZvciB0aGUgdXNlclxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgbGlzdFdlYmhvb2tOb3RpZmljYXRpb25zKHBhcmFtczogTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzL25vdGlmaWNhdGlvbnMnKSkucXVlcnkocXVlcnkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVdlYmhvb2socGFyYW1zOiBCaXRHb1NpbXVsYXRlV2ViaG9va09wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2ViaG9va0lkJywgJ2Jsb2NrSWQnXSwgW10pO1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMud2ViaG9va0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgd2ViaG9va0lkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5ibG9ja0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgYmxvY2tJZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoYC93ZWJob29rcy8ke3BhcmFtcy53ZWJob29rSWR9L3NpbXVsYXRlYCkpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSBnZXQgY29uc3RhbnRzIHdoaWNoIGFyZSByZWxldmFudCB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGhhcyBhIGtub3duIHJhY2UgY29uZGl0aW9uLiBJdCBtYXkgcmV0dXJuIGRpZmZlcmVudCB2YWx1ZXMgb3ZlciB0aW1lLFxuICAgKiBlc3BlY2lhbGx5IGlmIGNhbGxlZCBzaG9ydGx5IGFmdGVyIGNyZWF0aW9uIG9mIHRoZSBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE5ldyBjb2RlIHNob3VsZCBjYWxsIGZldGNoQ29uc3RhbnRzKCkgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xpZW50IGNvbnN0YW50cyBvYmplY3RcbiAgICovXG4gIGdldENvbnN0YW50cygpOiBhbnkge1xuICAgIC8vIGtpY2sgb2ZmIGEgZnJlc2ggcmVxdWVzdCBmb3IgdGhlIGNsaWVudCBjb25zdGFudHNcbiAgICB0aGlzLmZldGNoQ29uc3RhbnRzKCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBjbGllbnQgY29uc3RhbnRzIGZyb20gQml0R28nKTtcbiAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICAvLyB1c2UgZGVmYXVsdENvbnN0YW50cyBhcyB0aGUgYmFja3VwIGZvciBrZXlzIHRoYXQgYXJlIG5vdCBzZXQgaW4gdGhpcy5fY29uc3RhbnRzXG4gICAgcmV0dXJuIF8ubWVyZ2Uoe30sIGNvbmZpZy5kZWZhdWx0Q29uc3RhbnRzKHRoaXMuZ2V0RW52KCkpLCBCaXRHb0FQSS5fY29uc3RhbnRzW3RoaXMuZ2V0RW52KCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWMSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIG1pbmVyIGZlZSBhbW91bnRzLCBnaXZlbiB0aGUgbnVtYmVyIGFuZFxuICAgKiB0eXBlIG9mIHRyYW5zYWN0aW9uIGlucHV0cywgYWxvbmcgd2l0aCBhIGZlZSByYXRlIGluIHNhdG9zaGlzIHBlciB2a0IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBmb3IgbmV3IGNvZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgYXN5bmMgY2FsY3VsYXRlTWluZXJGZWVJbmZvKHBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25CdWlsZGVyLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyhwYXJhbXMpO1xuICB9XG5cbn1cbiJdfQ==