"use strict";
/**
 * @hidden
 */
/**
 */
// Pending Approval Object
// Handles approving, rejecting and getting information on pending approvals
//
// Copyright 2015, BitGo, Inc.  All Rights Reserved.
//
const sdk_core_1 = require("@bitgo/sdk-core");
const utxolib = require("@bitgo/utxo-lib");
const Bluebird = require("bluebird");
const _ = require("lodash");
//
// Constructor
//
const PendingApproval = function (bitgo, pendingApproval, wallet) {
    this.bitgo = bitgo;
    this.pendingApproval = pendingApproval;
    this.wallet = wallet;
};
//
// id
// Get the id of this pending approval.
//
PendingApproval.prototype.id = function () {
    return this.pendingApproval.id;
};
//
// ownerType
// Get the owner type (wallet or enterprise)
// Pending approvals can be approved or modified by different scopes (depending on how they were created)
// If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
// If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
//
PendingApproval.prototype.ownerType = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], [], callback);
    if (this.pendingApproval.walletId) {
        return 'wallet';
    }
    else if (this.pendingApproval.enterprise) {
        return 'enterprise';
    }
    else {
        throw new Error('unexpected pending approval owner: neither walletId nor enterprise was present');
    }
};
//
// walletId
// Get the wallet ID that owns / is associated with the pending approval
//
PendingApproval.prototype.walletId = function () {
    return this.pendingApproval.walletId;
};
//
// enterpriseId
// Get the enterprise ID that owns / is associated with the pending approval
//
PendingApproval.prototype.enterpriseId = function () {
    return this.pendingApproval.enterprise;
};
//
// state
// Get the state of the pending approval
//
PendingApproval.prototype.state = function () {
    return this.pendingApproval.state;
};
//
// creator
// Get the id of the user that performed the action resulting in this pending approval
//
PendingApproval.prototype.creator = function () {
    return this.pendingApproval.creator;
};
//
// type
// Get the type of the pending approval (what it approves)
// Example: transactionRequest, tagUpdateRequest, policyRuleRequest
//
PendingApproval.prototype.type = function () {
    if (!this.pendingApproval.info) {
        throw new Error('pending approval info is not available');
    }
    return this.pendingApproval.info.type;
};
//
// type
// Get information about the pending approval
//
PendingApproval.prototype.info = function () {
    return this.pendingApproval.info;
};
//
// approvalsRequired
// get the number of approvals that are required for this pending approval to be approved.
// Defaults to 1 if approvalsRequired doesn't exist on the object
//
PendingApproval.prototype.approvalsRequired = function () {
    return this.pendingApproval.approvalsRequired || 1;
};
//
// url
// Gets the url for this pending approval
//
PendingApproval.prototype.url = function (extra) {
    extra = extra || '';
    return this.bitgo.url('/pendingapprovals/' + this.id() + extra);
};
//
// get
// Refetches this pending approval and returns it
//
PendingApproval.prototype.get = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], [], callback);
    const self = this;
    return Bluebird.resolve(this.bitgo.get(this.url()).result()).then(function (res) {
        self.pendingApproval = res;
        return self;
    }).nodeify(callback);
};
//
// Helper function to ensure that self.wallet is set
//
PendingApproval.prototype.populateWallet = function () {
    const self = this;
    if (!self.wallet) {
        return self.bitgo.wallets().get({ id: self.info().transactionRequest.sourceWallet })
            .then(function (wallet) {
            if (!wallet) {
                throw new Error('unexpected - unable to get wallet using sourcewallet');
            }
            self.wallet = wallet;
        });
    }
    if (self.wallet.id() !== self.info().transactionRequest.sourceWallet) {
        throw new Error('unexpected source wallet for pending approval');
    }
    return Promise.resolve(); // otherwise returns undefined
};
//
// helper function to recreate and sign a transaction on a wallet
// we should hopefully be able to move this logic server side soon
//
PendingApproval.prototype.recreateAndSignTransaction = function (params, callback) {
    params = _.extend({}, params);
    sdk_core_1.common.validateParams(params, ['txHex'], [], callback);
    const transaction = utxolib.bitgo.createTransactionFromHex(params.txHex, utxolib.networks.bitcoin);
    if (!transaction.outs) {
        throw new Error('transaction had no outputs or failed to parse successfully');
    }
    const network = utxolib.networks[sdk_core_1.common.Environments[this.bitgo.getEnv()].network];
    params.recipients = {};
    const self = this;
    return Bluebird.try(function () {
        if (self.info().transactionRequest.recipients) {
            // recipients object found on the pending approvals - use it
            params.recipients = self.info().transactionRequest.recipients;
            return;
        }
        if (transaction.outs.length <= 2) {
            transaction.outs.forEach(function (out) {
                const outAddress = utxolib.address.fromOutputScript(out.script, network);
                if (self.info().transactionRequest.destinationAddress === outAddress) {
                    // If this is the destination, then spend to it
                    params.recipients[outAddress] = out.value;
                }
            });
            return;
        }
        // This looks like a sendmany
        // Attempt to figure out the outputs by choosing all outputs that were not going back to the wallet as change addresses
        return self.wallet.addresses({ chain: 1, sort: -1, limit: 500 })
            .then(function (result) {
            const changeAddresses = _.keyBy(result.addresses, 'address');
            transaction.outs.forEach(function (out) {
                const outAddress = utxolib.address.fromOutputScript(out.script, network);
                if (!changeAddresses[outAddress]) {
                    // If this is not a change address, then spend to it
                    params.recipients[outAddress] = out.value;
                }
            });
        });
    })
        .then(function () {
        return self.wallet.createAndSignTransaction(params);
    });
};
//
// constructApprovalTx
// constructs/signs a transaction for this pending approval, returning the txHex (but not sending it)
//
PendingApproval.prototype.constructApprovalTx = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], ['walletPassphrase'], callback);
    if (this.type() === 'transactionRequest' && !(params.walletPassphrase || params.xprv)) {
        throw new Error('wallet passphrase or xprv required to approve a transactionRequest');
    }
    if (params.useOriginalFee) {
        if (!_.isBoolean(params.useOriginalFee)) {
            throw new Error('invalid type for useOriginalFeeRate');
        }
        if (params.fee || params.feeRate || params.feeTxConfirmTarget) {
            throw new Error('cannot specify a fee/feerate/feeTxConfirmTarget as well as useOriginalFee');
        }
    }
    const self = this;
    return Bluebird.try(function () {
        if (self.type() === 'transactionRequest') {
            const extendParams = { txHex: self.info().transactionRequest.transaction };
            if (params.useOriginalFee) {
                extendParams.fee = self.info().transactionRequest.fee;
            }
            return self.populateWallet()
                .then(function () {
                return self.recreateAndSignTransaction(_.extend(params, extendParams));
            });
        }
    });
};
//
// approve
// sets the pending approval to an approved state
//
PendingApproval.prototype.approve = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], ['walletPassphrase', 'otp'], callback);
    let canRecreateTransaction = true;
    if (this.type() === 'transactionRequest') {
        if (!params.walletPassphrase && !params.xprv) {
            canRecreateTransaction = false;
        }
        // check the wallet balance and compare it with the transaction amount and fee
        if (_.isUndefined(params.forceRecreate) && _.isObject(_.get(this, 'wallet.wallet'))) {
            const requestedAmount = this.pendingApproval.info.transactionRequest.requestedAmount || 0;
            const walletBalance = this.wallet.wallet.spendableBalance;
            const delta = Math.abs(requestedAmount - walletBalance);
            if (delta <= 10000) {
                // it's a sweep because we're within 10k satoshis of the wallet balance
                canRecreateTransaction = false;
            }
        }
    }
    const self = this;
    return Bluebird.try(function () {
        if (self.type() === 'transactionRequest') {
            if (params.tx) {
                // the approval tx was reconstructed and explicitly specified - pass it through
                return {
                    tx: params.tx,
                };
            }
            // this user may not have spending privileges or a passphrase may not have been passed in
            if (!canRecreateTransaction) {
                return {
                    tx: self.info().transactionRequest.transaction,
                };
            }
            return self.populateWallet()
                .then(function () {
                const recreationParams = _.extend({}, params, { txHex: self.info().transactionRequest.transaction }, self.info().transactionRequest.buildParams);
                // delete the old build params because we want 'recreateAndSign' to recreate the transaction
                delete recreationParams.fee;
                delete recreationParams.unspents;
                delete recreationParams.txInfo;
                delete recreationParams.estimatedSize;
                delete recreationParams.changeAddresses;
                return self.recreateAndSignTransaction(recreationParams);
            });
        }
    })
        .then(function (transaction) {
        const approvalParams = { state: 'approved', otp: params.otp };
        if (transaction) {
            approvalParams.tx = transaction.tx;
        }
        return Bluebird.resolve(self.bitgo.put(self.url()).send(approvalParams).result()).nodeify(callback);
    })
        .catch(function (error) {
        if (!canRecreateTransaction &&
            (error.message.indexOf('could not find unspent output for input') !== -1 ||
                error.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
            throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
        }
        if (_.isUndefined(params.forceRecreate) && error.message.indexOf('could not find unspent output for input') !== -1) {
            // if the unspents can't be found, we must retry with a newly constructed transaction, so we delete the tx and try again
            // deleting params.tx will force the code to reach the 'recreateAndSignTransaction' function
            delete params.tx;
            params.forceRecreate = true;
            self.approve(params, callback);
        }
        else {
            throw error;
        }
    });
};
//
// rejected
// sets the pending approval to a rejected state
//
PendingApproval.prototype.reject = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], [], callback);
    return Bluebird.resolve(this.bitgo.put(this.url()).send({ state: 'rejected' }).result()).nodeify(callback);
};
//
// cancel
// rejects the pending approval
//
PendingApproval.prototype.cancel = function (params, callback) {
    return this.reject(params, callback);
};
module.exports = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ2FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BlbmRpbmdhcHByb3ZhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7QUFFSDtHQUNHO0FBQ0gsMEJBQTBCO0FBQzFCLDRFQUE0RTtBQUM1RSxFQUFFO0FBQ0Ysb0RBQW9EO0FBQ3BELEVBQUU7QUFDRiw4Q0FBeUM7QUFDekMsMkNBQTJDO0FBRTNDLHFDQUFxQztBQUNyQyw0QkFBNEI7QUFFNUIsRUFBRTtBQUNGLGNBQWM7QUFDZCxFQUFFO0FBQ0YsTUFBTSxlQUFlLEdBQUcsVUFBVSxLQUFLLEVBQUUsZUFBZSxFQUFFLE1BQU07SUFDOUQsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDbkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7SUFDdkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDdkIsQ0FBQyxDQUFDO0FBRUYsRUFBRTtBQUNGLEtBQUs7QUFDTCx1Q0FBdUM7QUFDdkMsRUFBRTtBQUNGLGVBQWUsQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzdCLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUM7QUFDakMsQ0FBQyxDQUFDO0FBRUYsRUFBRTtBQUNGLFlBQVk7QUFDWiw0Q0FBNEM7QUFDNUMseUdBQXlHO0FBQ3pHLHNHQUFzRztBQUN0RywrR0FBK0c7QUFDL0csRUFBRTtBQUNGLGVBQWUsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVUsTUFBTSxFQUFFLFFBQVE7SUFDOUQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsaUJBQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFaEQsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRTtRQUNqQyxPQUFPLFFBQVEsQ0FB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LEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDaEM7YUFBTTtZQUNMLE1BQU0sS0FBSyxDQUFDO1NBQ2I7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQztBQUVGLEVBQUU7QUFDRixXQUFXO0FBQ1gsZ0RBQWdEO0FBQ2hELEVBQUU7QUFDRixlQUFlLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFVLE1BQU0sRUFBRSxRQUFRO0lBQzNELE1BQU0sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO0lBQ3RCLGlCQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRWhELE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQ2hFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RCLENBQUMsQ0FBQztBQUVGLEVBQUU7QUFDRixTQUFTO0FBQ1QsK0JBQStCO0FBQy9CLEVBQUU7QUFDRixlQUFlLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFVLE1BQU0sRUFBRSxRQUFRO0lBQzNELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDdkMsQ0FBQyxDQUFDO0FBRUYsaUJBQVMsZUFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbi8vIFBlbmRpbmcgQXBwcm92YWwgT2JqZWN0XG4vLyBIYW5kbGVzIGFwcHJvdmluZywgcmVqZWN0aW5nIGFuZCBnZXR0aW5nIGluZm9ybWF0aW9uIG9uIHBlbmRpbmcgYXBwcm92YWxzXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTUsIEJpdEdvLCBJbmMuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbmltcG9ydCB7IGNvbW1vbiB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcblxuLy9cbi8vIENvbnN0cnVjdG9yXG4vL1xuY29uc3QgUGVuZGluZ0FwcHJvdmFsID0gZnVuY3Rpb24gKGJpdGdvLCBwZW5kaW5nQXBwcm92YWwsIHdhbGxldCkge1xuICB0aGlzLmJpdGdvID0gYml0Z287XG4gIHRoaXMucGVuZGluZ0FwcHJvdmFsID0gcGVuZGluZ0FwcHJvdmFsO1xuICB0aGlzLndhbGxldCA9IHdhbGxldDtcbn07XG5cbi8vXG4vLyBpZFxuLy8gR2V0IHRoZSBpZCBvZiB0aGlzIHBlbmRpbmcgYXBwcm92YWwuXG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVuZGluZ0FwcHJvdmFsLmlkO1xufTtcblxuLy9cbi8vIG93bmVyVHlwZVxuLy8gR2V0IHRoZSBvd25lciB0eXBlICh3YWxsZXQgb3IgZW50ZXJwcmlzZSlcbi8vIFBlbmRpbmcgYXBwcm92YWxzIGNhbiBiZSBhcHByb3ZlZCBvciBtb2RpZmllZCBieSBkaWZmZXJlbnQgc2NvcGVzIChkZXBlbmRpbmcgb24gaG93IHRoZXkgd2VyZSBjcmVhdGVkKVxuLy8gSWYgYSBwZW5kaW5nIGFwcHJvdmFsIGlzIG93bmVkIGJ5IGEgd2FsbGV0LCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgd2FsbGV0XG4vLyBJZiBhIHBlbmRpbmcgYXBwcm92YWwgaXMgb3duZWQgYnkgYW4gZW50ZXJwcmlzZSwgdGhlbiBpdCBjYW4gYmUgYXBwcm92ZWQgYnkgYWRtaW5pc3RyYXRvcnMgb2YgdGhlIGVudGVycHJpc2Vcbi8vXG5QZW5kaW5nQXBwcm92YWwucHJvdG90eXBlLm93bmVyVHlwZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMucGVuZGluZ0FwcHJvdmFsLndhbGxldElkKSB7XG4gICAgcmV0dXJuICd3YWxsZXQnO1xuICB9IGVsc2UgaWYgKHRoaXMucGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2UpIHtcbiAgICByZXR1cm4gJ2VudGVycHJpc2UnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwZW5kaW5nIGFwcHJvdmFsIG93bmVyOiBuZWl0aGVyIHdhbGxldElkIG5vciBlbnRlcnByaXNlIHdhcyBwcmVzZW50Jyk7XG4gIH1cbn07XG5cbi8vXG4vLyB3YWxsZXRJZFxuLy8gR2V0IHRoZSB3YWxsZXQgSUQgdGhhdCBvd25zIC8gaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwZW5kaW5nIGFwcHJvdmFsXG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS53YWxsZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVuZGluZ0FwcHJvdmFsLndhbGxldElkO1xufTtcblxuLy9cbi8vIGVudGVycHJpc2VJZFxuLy8gR2V0IHRoZSBlbnRlcnByaXNlIElEIHRoYXQgb3ducyAvIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVuZGluZyBhcHByb3ZhbFxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUuZW50ZXJwcmlzZUlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wZW5kaW5nQXBwcm92YWwuZW50ZXJwcmlzZTtcbn07XG5cbi8vXG4vLyBzdGF0ZVxuLy8gR2V0IHRoZSBzdGF0ZSBvZiB0aGUgcGVuZGluZyBhcHByb3ZhbFxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBlbmRpbmdBcHByb3ZhbC5zdGF0ZTtcbn07XG5cbi8vXG4vLyBjcmVhdG9yXG4vLyBHZXQgdGhlIGlkIG9mIHRoZSB1c2VyIHRoYXQgcGVyZm9ybWVkIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluIHRoaXMgcGVuZGluZyBhcHByb3ZhbFxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUuY3JlYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVuZGluZ0FwcHJvdmFsLmNyZWF0b3I7XG59O1xuXG4vL1xuLy8gdHlwZVxuLy8gR2V0IHRoZSB0eXBlIG9mIHRoZSBwZW5kaW5nIGFwcHJvdmFsICh3aGF0IGl0IGFwcHJvdmVzKVxuLy8gRXhhbXBsZTogdHJhbnNhY3Rpb25SZXF1ZXN0LCB0YWdVcGRhdGVSZXF1ZXN0LCBwb2xpY3lSdWxlUmVxdWVzdFxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBlbmRpbmdBcHByb3ZhbC5pbmZvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwZW5kaW5nIGFwcHJvdmFsIGluZm8gaXMgbm90IGF2YWlsYWJsZScpO1xuICB9XG4gIHJldHVybiB0aGlzLnBlbmRpbmdBcHByb3ZhbC5pbmZvLnR5cGU7XG59O1xuXG4vL1xuLy8gdHlwZVxuLy8gR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBwZW5kaW5nIGFwcHJvdmFsXG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wZW5kaW5nQXBwcm92YWwuaW5mbztcbn07XG5cbi8vXG4vLyBhcHByb3ZhbHNSZXF1aXJlZFxuLy8gZ2V0IHRoZSBudW1iZXIgb2YgYXBwcm92YWxzIHRoYXQgYXJlIHJlcXVpcmVkIGZvciB0aGlzIHBlbmRpbmcgYXBwcm92YWwgdG8gYmUgYXBwcm92ZWQuXG4vLyBEZWZhdWx0cyB0byAxIGlmIGFwcHJvdmFsc1JlcXVpcmVkIGRvZXNuJ3QgZXhpc3Qgb24gdGhlIG9iamVjdFxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUuYXBwcm92YWxzUmVxdWlyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBlbmRpbmdBcHByb3ZhbC5hcHByb3ZhbHNSZXF1aXJlZCB8fCAxO1xufTtcblxuLy9cbi8vIHVybFxuLy8gR2V0cyB0aGUgdXJsIGZvciB0aGlzIHBlbmRpbmcgYXBwcm92YWxcbi8vXG5QZW5kaW5nQXBwcm92YWwucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uIChleHRyYSkge1xuICBleHRyYSA9IGV4dHJhIHx8ICcnO1xuICByZXR1cm4gdGhpcy5iaXRnby51cmwoJy9wZW5kaW5nYXBwcm92YWxzLycgKyB0aGlzLmlkKCkgKyBleHRyYSk7XG59O1xuXG4vL1xuLy8gZ2V0XG4vLyBSZWZldGNoZXMgdGhpcyBwZW5kaW5nIGFwcHJvdmFsIGFuZCByZXR1cm5zIGl0XG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShcbiAgICB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgpKS5yZXN1bHQoKVxuICApLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHNlbGYucGVuZGluZ0FwcHJvdmFsID0gcmVzO1xuICAgIHJldHVybiBzZWxmO1xuICB9KS5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXQgc2VsZi53YWxsZXQgaXMgc2V0XG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS5wb3B1bGF0ZVdhbGxldCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGlmICghc2VsZi53YWxsZXQpIHtcbiAgICByZXR1cm4gc2VsZi5iaXRnby53YWxsZXRzKCkuZ2V0KHsgaWQ6IHNlbGYuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdC5zb3VyY2VXYWxsZXQgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgLSB1bmFibGUgdG8gZ2V0IHdhbGxldCB1c2luZyBzb3VyY2V3YWxsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLndhbGxldCA9IHdhbGxldDtcbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKHNlbGYud2FsbGV0LmlkKCkgIT09IHNlbGYuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdC5zb3VyY2VXYWxsZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc291cmNlIHdhbGxldCBmb3IgcGVuZGluZyBhcHByb3ZhbCcpO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyAvLyBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcbn07XG5cbi8vXG4vLyBoZWxwZXIgZnVuY3Rpb24gdG8gcmVjcmVhdGUgYW5kIHNpZ24gYSB0cmFuc2FjdGlvbiBvbiBhIHdhbGxldFxuLy8gd2Ugc2hvdWxkIGhvcGVmdWxseSBiZSBhYmxlIHRvIG1vdmUgdGhpcyBsb2dpYyBzZXJ2ZXIgc2lkZSBzb29uXG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS5yZWNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4SGV4J10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb24gPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uRnJvbUhleChwYXJhbXMudHhIZXgsIHV0eG9saWIubmV0d29ya3MuYml0Y29pbik7XG4gIGlmICghdHJhbnNhY3Rpb24ub3V0cykge1xuICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gaGFkIG5vIG91dHB1dHMgb3IgZmFpbGVkIHRvIHBhcnNlIHN1Y2Nlc3NmdWxseScpO1xuICB9XG5cbiAgY29uc3QgbmV0d29yayA9IHV0eG9saWIubmV0d29ya3NbY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5uZXR3b3JrXTtcbiAgcGFyYW1zLnJlY2lwaWVudHMgPSB7fTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5pbmZvKCkudHJhbnNhY3Rpb25SZXF1ZXN0LnJlY2lwaWVudHMpIHtcbiAgICAgIC8vIHJlY2lwaWVudHMgb2JqZWN0IGZvdW5kIG9uIHRoZSBwZW5kaW5nIGFwcHJvdmFscyAtIHVzZSBpdFxuICAgICAgcGFyYW1zLnJlY2lwaWVudHMgPSBzZWxmLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3QucmVjaXBpZW50cztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLm91dHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIGNvbnN0IG91dEFkZHJlc3MgPSB1dHhvbGliLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChvdXQuc2NyaXB0LCBuZXR3b3JrKTtcbiAgICAgICAgaWYgKHNlbGYuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdC5kZXN0aW5hdGlvbkFkZHJlc3MgPT09IG91dEFkZHJlc3MpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBkZXN0aW5hdGlvbiwgdGhlbiBzcGVuZCB0byBpdFxuICAgICAgICAgIHBhcmFtcy5yZWNpcGllbnRzW291dEFkZHJlc3NdID0gb3V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSBzZW5kbWFueVxuICAgIC8vIEF0dGVtcHQgdG8gZmlndXJlIG91dCB0aGUgb3V0cHV0cyBieSBjaG9vc2luZyBhbGwgb3V0cHV0cyB0aGF0IHdlcmUgbm90IGdvaW5nIGJhY2sgdG8gdGhlIHdhbGxldCBhcyBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgcmV0dXJuIHNlbGYud2FsbGV0LmFkZHJlc3Nlcyh7IGNoYWluOiAxLCBzb3J0OiAtMSwgbGltaXQ6IDUwMCB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBjaGFuZ2VBZGRyZXNzZXMgPSBfLmtleUJ5KHJlc3VsdC5hZGRyZXNzZXMsICdhZGRyZXNzJyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgICAgY29uc3Qgb3V0QWRkcmVzcyA9IHV0eG9saWIuYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KG91dC5zY3JpcHQsIG5ldHdvcmspO1xuICAgICAgICAgIGlmICghY2hhbmdlQWRkcmVzc2VzW291dEFkZHJlc3NdKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBjaGFuZ2UgYWRkcmVzcywgdGhlbiBzcGVuZCB0byBpdFxuICAgICAgICAgICAgcGFyYW1zLnJlY2lwaWVudHNbb3V0QWRkcmVzc10gPSBvdXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzZWxmLndhbGxldC5jcmVhdGVBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICB9KTtcbn07XG5cbi8vXG4vLyBjb25zdHJ1Y3RBcHByb3ZhbFR4XG4vLyBjb25zdHJ1Y3RzL3NpZ25zIGEgdHJhbnNhY3Rpb24gZm9yIHRoaXMgcGVuZGluZyBhcHByb3ZhbCwgcmV0dXJuaW5nIHRoZSB0eEhleCAoYnV0IG5vdCBzZW5kaW5nIGl0KVxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUuY29uc3RydWN0QXBwcm92YWxUeCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnd2FsbGV0UGFzc3BocmFzZSddLCBjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMudHlwZSgpID09PSAndHJhbnNhY3Rpb25SZXF1ZXN0JyAmJiAhKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHx8IHBhcmFtcy54cHJ2KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0IHBhc3NwaHJhc2Ugb3IgeHBydiByZXF1aXJlZCB0byBhcHByb3ZlIGEgdHJhbnNhY3Rpb25SZXF1ZXN0Jyk7XG4gIH1cblxuICBpZiAocGFyYW1zLnVzZU9yaWdpbmFsRmVlKSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMudXNlT3JpZ2luYWxGZWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZSBmb3IgdXNlT3JpZ2luYWxGZWVSYXRlJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuZmVlIHx8IHBhcmFtcy5mZWVSYXRlIHx8IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgYSBmZWUvZmVlcmF0ZS9mZWVUeENvbmZpcm1UYXJnZXQgYXMgd2VsbCBhcyB1c2VPcmlnaW5hbEZlZScpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi50eXBlKCkgPT09ICd0cmFuc2FjdGlvblJlcXVlc3QnKSB7XG4gICAgICBjb25zdCBleHRlbmRQYXJhbXM6IGFueSA9IHsgdHhIZXg6IHNlbGYuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdC50cmFuc2FjdGlvbiB9O1xuICAgICAgaWYgKHBhcmFtcy51c2VPcmlnaW5hbEZlZSkge1xuICAgICAgICBleHRlbmRQYXJhbXMuZmVlID0gc2VsZi5pbmZvKCkudHJhbnNhY3Rpb25SZXF1ZXN0LmZlZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnBvcHVsYXRlV2FsbGV0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKF8uZXh0ZW5kKHBhcmFtcywgZXh0ZW5kUGFyYW1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vL1xuLy8gYXBwcm92ZVxuLy8gc2V0cyB0aGUgcGVuZGluZyBhcHByb3ZhbCB0byBhbiBhcHByb3ZlZCBzdGF0ZVxuLy9cblBlbmRpbmdBcHByb3ZhbC5wcm90b3R5cGUuYXBwcm92ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnd2FsbGV0UGFzc3BocmFzZScsICdvdHAnXSwgY2FsbGJhY2spO1xuXG4gIGxldCBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgaWYgKHRoaXMudHlwZSgpID09PSAndHJhbnNhY3Rpb25SZXF1ZXN0Jykge1xuICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgJiYgIXBhcmFtcy54cHJ2KSB7XG4gICAgICBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIHdhbGxldCBiYWxhbmNlIGFuZCBjb21wYXJlIGl0IHdpdGggdGhlIHRyYW5zYWN0aW9uIGFtb3VudCBhbmQgZmVlXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmZvcmNlUmVjcmVhdGUpICYmIF8uaXNPYmplY3QoXy5nZXQodGhpcywgJ3dhbGxldC53YWxsZXQnKSkpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RlZEFtb3VudCA9IHRoaXMucGVuZGluZ0FwcHJvdmFsLmluZm8udHJhbnNhY3Rpb25SZXF1ZXN0LnJlcXVlc3RlZEFtb3VudCB8fCAwO1xuICAgICAgY29uc3Qgd2FsbGV0QmFsYW5jZSA9IHRoaXMud2FsbGV0LndhbGxldC5zcGVuZGFibGVCYWxhbmNlO1xuICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhyZXF1ZXN0ZWRBbW91bnQgLSB3YWxsZXRCYWxhbmNlKTtcbiAgICAgIGlmIChkZWx0YSA8PSAxMDAwMCkge1xuICAgICAgICAvLyBpdCdzIGEgc3dlZXAgYmVjYXVzZSB3ZSdyZSB3aXRoaW4gMTBrIHNhdG9zaGlzIG9mIHRoZSB3YWxsZXQgYmFsYW5jZVxuICAgICAgICBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLnR5cGUoKSA9PT0gJ3RyYW5zYWN0aW9uUmVxdWVzdCcpIHtcbiAgICAgIGlmIChwYXJhbXMudHgpIHtcbiAgICAgICAgLy8gdGhlIGFwcHJvdmFsIHR4IHdhcyByZWNvbnN0cnVjdGVkIGFuZCBleHBsaWNpdGx5IHNwZWNpZmllZCAtIHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR4OiBwYXJhbXMudHgsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgdXNlciBtYXkgbm90IGhhdmUgc3BlbmRpbmcgcHJpdmlsZWdlcyBvciBhIHBhc3NwaHJhc2UgbWF5IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGluXG4gICAgICBpZiAoIWNhblJlY3JlYXRlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eDogc2VsZi5pbmZvKCkudHJhbnNhY3Rpb25SZXF1ZXN0LnRyYW5zYWN0aW9uLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5wb3B1bGF0ZVdhbGxldCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCByZWNyZWF0aW9uUGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcywgeyB0eEhleDogc2VsZi5pbmZvKCkudHJhbnNhY3Rpb25SZXF1ZXN0LnRyYW5zYWN0aW9uIH0sIHNlbGYuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdC5idWlsZFBhcmFtcyk7XG4gICAgICAgICAgLy8gZGVsZXRlIHRoZSBvbGQgYnVpbGQgcGFyYW1zIGJlY2F1c2Ugd2Ugd2FudCAncmVjcmVhdGVBbmRTaWduJyB0byByZWNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICBkZWxldGUgcmVjcmVhdGlvblBhcmFtcy5mZWU7XG4gICAgICAgICAgZGVsZXRlIHJlY3JlYXRpb25QYXJhbXMudW5zcGVudHM7XG4gICAgICAgICAgZGVsZXRlIHJlY3JlYXRpb25QYXJhbXMudHhJbmZvO1xuICAgICAgICAgIGRlbGV0ZSByZWNyZWF0aW9uUGFyYW1zLmVzdGltYXRlZFNpemU7XG4gICAgICAgICAgZGVsZXRlIHJlY3JlYXRpb25QYXJhbXMuY2hhbmdlQWRkcmVzc2VzO1xuICAgICAgICAgIHJldHVybiBzZWxmLnJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHJlY3JlYXRpb25QYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICBjb25zdCBhcHByb3ZhbFBhcmFtczogYW55ID0geyBzdGF0ZTogJ2FwcHJvdmVkJywgb3RwOiBwYXJhbXMub3RwIH07XG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgYXBwcm92YWxQYXJhbXMudHggPSB0cmFuc2FjdGlvbi50eDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKFxuICAgICAgICBzZWxmLmJpdGdvLnB1dChzZWxmLnVybCgpKS5zZW5kKGFwcHJvdmFsUGFyYW1zKS5yZXN1bHQoKVxuICAgICAgKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgICB9KVxuICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiAmJlxuICAgIChcbiAgICAgIGVycm9yLm1lc3NhZ2UuaW5kZXhPZignY291bGQgbm90IGZpbmQgdW5zcGVudCBvdXRwdXQgZm9yIGlucHV0JykgIT09IC0xIHx8XG4gICAgICBlcnJvci5tZXNzYWdlLmluZGV4T2YoJ3RyYW5zYWN0aW9uIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIHRyYW5zYWN0aW9uIGluIHRoZSBzZW5kIHF1ZXVlJykgIT09IC0xKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zcGVudHMgZXhwaXJlZCwgd2FsbGV0IHBhc3NwaHJhc2Ugb3IgeHBydiByZXF1aXJlZCB0byByZWNyZWF0ZSB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmZvcmNlUmVjcmVhdGUpICYmIGVycm9yLm1lc3NhZ2UuaW5kZXhPZignY291bGQgbm90IGZpbmQgdW5zcGVudCBvdXRwdXQgZm9yIGlucHV0JykgIT09IC0xICkge1xuICAgICAgLy8gaWYgdGhlIHVuc3BlbnRzIGNhbid0IGJlIGZvdW5kLCB3ZSBtdXN0IHJldHJ5IHdpdGggYSBuZXdseSBjb25zdHJ1Y3RlZCB0cmFuc2FjdGlvbiwgc28gd2UgZGVsZXRlIHRoZSB0eCBhbmQgdHJ5IGFnYWluXG4gICAgICAvLyBkZWxldGluZyBwYXJhbXMudHggd2lsbCBmb3JjZSB0aGUgY29kZSB0byByZWFjaCB0aGUgJ3JlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uJyBmdW5jdGlvblxuICAgICAgICBkZWxldGUgcGFyYW1zLnR4O1xuICAgICAgICBwYXJhbXMuZm9yY2VSZWNyZWF0ZSA9IHRydWU7XG4gICAgICAgIHNlbGYuYXBwcm92ZShwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuLy9cbi8vIHJlamVjdGVkXG4vLyBzZXRzIHRoZSBwZW5kaW5nIGFwcHJvdmFsIHRvIGEgcmVqZWN0ZWQgc3RhdGVcbi8vXG5QZW5kaW5nQXBwcm92YWwucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoXG4gICAgdGhpcy5iaXRnby5wdXQodGhpcy51cmwoKSkuc2VuZCh7IHN0YXRlOiAncmVqZWN0ZWQnIH0pLnJlc3VsdCgpXG4gICkubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY2FuY2VsXG4vLyByZWplY3RzIHRoZSBwZW5kaW5nIGFwcHJvdmFsXG4vL1xuUGVuZGluZ0FwcHJvdmFsLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5yZWplY3QocGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnQgPSBQZW5kaW5nQXBwcm92YWw7XG4iXX0=