/**
 * @prettier
 */
import { BitGo } from '../bitgo';
import { BaseCoin, SignedTransaction, TransactionPrebuild, VerificationOptions } from './baseCoin';
import { Keychain } from './keychains';
import { TradingAccount } from './trading/tradingAccount';
import { PendingApproval, PendingApprovalData } from './pendingApproval';
import { RequestTracer } from './internal/util';
export interface MaximumSpendableOptions {
    minValue?: number | string;
    maxValue?: number | string;
    minHeight?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    feeRate?: number;
    maxFeeRate?: number;
    recipientAddress?: string;
    limit?: number;
    target?: number;
    plainTarget?: number;
}
export interface MaximumSpendable {
    maximumSpendable: number;
    coin: string;
}
export interface Memo {
    value: string;
    type: string;
}
/**
 * A small set of parameters should be used for building a consolidation transaction:
 * - walletPassphrase - necessary for signing
 * - feeRate
 * - maxFeeRate
 * - validFromBlock
 * - validToBlock
 *
 * What shouldn't be passed (these will be ignored):
 * - recipients
 */
export interface BuildConsolidationTransactionOptions extends PrebuildTransactionOptions {
    consolidateAddresses?: string[];
}
export interface PrebuildTransactionOptions {
    reqId?: RequestTracer;
    recipients?: {
        address: string;
        amount: string | number;
    }[];
    numBlocks?: number;
    maxFeeRate?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    targetWalletUnspents?: number;
    minValue?: number;
    maxValue?: number;
    sequenceId?: string;
    lastLedgerSequence?: number;
    ledgerSequenceDelta?: number;
    gasPrice?: number;
    noSplitChange?: boolean;
    unspents?: any[];
    changeAddress?: string;
    type?: string;
    closeRemainderTo?: string;
    nonParticipation?: boolean;
    validFromBlock?: number;
    validToBlock?: number;
    instant?: boolean;
    memo?: Memo;
    addressType?: string;
    hop?: boolean;
    walletPassphrase?: string;
    reservation?: {
        expireTime?: string;
        pendingApprovalId?: string;
    };
    offlineVerification?: boolean;
    walletContractAddress?: string;
    idfSignedTimestamp?: string;
    idfUserId?: string;
    idfVersion?: number;
    comment?: string;
    [index: string]: unknown;
    tokenName?: string;
    nonce?: string;
}
export interface PrebuildAndSignTransactionOptions extends PrebuildTransactionOptions, WalletSignTransactionOptions {
    prebuildTx?: string | PrebuildTransactionResult;
    verification?: VerificationOptions;
}
export interface PrebuildTransactionResult extends TransactionPrebuild {
    walletId: string;
    consolidateId?: string;
    consolidationDetails?: {
        senderAddressIndex: number;
    };
    feeInfo?: {
        fee?: number;
        feeString?: string;
    };
}
export interface CustomSigningFunction {
    (params: {
        coin: BaseCoin;
        txPrebuild: TransactionPrebuild;
        pubs?: string[];
    }): Promise<SignedTransaction>;
}
export interface WalletSignTransactionOptions {
    reqId?: RequestTracer;
    txPrebuild?: TransactionPrebuild;
    prv?: string;
    pubs?: string[];
    cosignerPub?: string;
    isLastSignature?: boolean;
    customSigningFunction?: CustomSigningFunction;
    [index: string]: unknown;
}
export interface GetUserPrvOptions {
    keychain?: Keychain;
    key?: Keychain;
    prv?: string;
    coldDerivationSeed?: string;
    walletPassphrase?: string;
}
export interface WalletCoinSpecific {
    tokenFlushThresholds?: any;
    addressVersion?: number;
    baseAddress?: string;
    rootAddress?: string;
    customChangeWalletId: string;
}
export interface PaginationOptions {
    prevId?: string;
    limit?: number;
}
export interface GetTransactionOptions extends PaginationOptions {
    txHash?: string;
}
export interface TransfersOptions extends PaginationOptions {
    txHash?: string;
    allTokens?: boolean;
    searchLabel?: string;
    address?: string[] | string;
    dateGte?: string;
    dateLt?: string;
    valueGte?: number;
    valueLt?: number;
    includeHex?: boolean;
    state?: string[] | string;
    type?: string;
}
export interface GetTransferOptions {
    id?: string;
}
export interface TransferBySequenceIdOptions {
    sequenceId?: string;
}
export interface UnspentsOptions extends PaginationOptions {
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    minConfirms?: number;
    target?: number;
    segwit?: boolean;
    chains?: number[];
}
export interface ConsolidateUnspentsOptions extends WalletSignTransactionOptions {
    walletPassphrase?: string;
    xprv?: string;
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    numUnspentsToMake?: number;
    feeTxConfirmTarget?: number;
    limit?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    feeRate?: number;
    maxFeeRate?: number;
    maxFeePercentage?: number;
    comment?: string;
    otp?: string;
    targetAddress?: string;
    [index: string]: unknown;
}
export interface FanoutUnspentsOptions extends WalletSignTransactionOptions {
    walletPassphrase?: string;
    xprv?: string;
    minValue?: number;
    maxValue?: number;
    minHeight?: number;
    maxNumInputsToUse?: number;
    numUnspentsToMake?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    feeRate?: number;
    maxFeeRate?: number;
    maxFeePercentage?: number;
    feeTxConfirmTarget?: number;
    comment?: string;
    otp?: string;
    targetAddress?: string;
    [index: string]: unknown;
}
export interface SweepOptions {
    address?: string;
    walletPassphrase?: string;
    xprv?: string;
    otp?: string;
    feeRate?: number;
    maxFeeRate?: number;
    feeTxConfirmTarget?: number;
    allowPartialSweep?: boolean;
    [index: string]: unknown;
}
export interface FreezeOptions {
    duration?: number;
}
export interface TransferCommentOptions {
    id?: string;
    comment?: string;
}
export interface AddressesOptions extends PaginationOptions {
    mine?: boolean;
    sort?: number;
    labelContains?: string;
    segwit?: boolean;
    chains?: number[];
}
export interface GetAddressOptions {
    address?: string;
    id?: string;
    reqId?: RequestTracer;
}
export interface DeployForwardersOptions {
    address?: string;
    id?: string;
}
export interface FlushForwarderTokenOptions {
    address?: string;
    id?: string;
    tokenName: string;
    gasPrice?: number;
    eip1559?: {
        maxPriorityFeePerGas: number;
        maxFeePerGas: number;
    };
}
export interface CreateAddressOptions {
    chain?: number;
    gasPrice?: number | string;
    count?: number;
    label?: string;
    lowPriority?: boolean;
    forwarderVersion?: number;
    format?: 'base58' | 'cashaddr';
    baseAddress?: string;
    allowSkipVerifyAddress?: boolean;
    derivedAddress?: string;
    index?: number;
}
export interface UpdateAddressOptions {
    label?: string;
    address?: string;
}
export interface SimulateWebhookOptions {
    webhookId?: string;
    transferId?: string;
    pendingApprovalId?: string;
}
export interface ModifyWebhookOptions {
    url?: string;
    type?: string;
}
export interface GetPrvOptions {
    prv?: string;
    walletPassphrase?: string;
}
export interface CreateShareOptions {
    user?: string;
    permissions?: string;
    keychain?: {
        pub?: string;
        encryptedPrv?: string;
        fromPubKey?: string;
        toPubKey?: string;
        path?: string;
    };
    reshare?: boolean;
    message?: string;
    disableEmail?: boolean;
}
export interface ShareWalletOptions {
    email?: string;
    permissions?: string;
    walletPassphrase?: string;
    message?: string;
    reshare?: boolean;
    skipKeychain?: boolean;
    disableEmail?: boolean;
}
export interface RemoveUserOptions {
    userId?: string;
}
export interface AccelerateTransactionOptions {
    cpfpTxIds?: string[];
    cpfpFeeRate?: number;
    noCpfpFeeRate?: boolean;
    maxFee?: number;
    noMaxFee?: boolean;
    recipients?: {
        address: string;
        amount: string;
    }[];
    [index: string]: unknown;
}
export interface SubmitTransactionOptions {
    otp?: string;
    txHex?: string;
    halfSigned?: {
        txHex?: string;
        payload?: string;
        txBase64?: string;
    };
    comment?: string;
    txRequestId?: string;
}
export interface SendOptions {
    address?: string;
    amount?: number | string;
    data?: string;
    feeLimit?: string;
    message?: string;
    walletPassphrase?: string;
    prv?: string;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    custodianTransactionId?: string;
    [index: string]: unknown;
    tokenName?: string;
}
export interface SendManyOptions extends PrebuildAndSignTransactionOptions {
    reqId?: RequestTracer;
    recipients?: {
        address: string;
        amount: string | number;
        feeLimit?: string;
        data?: string;
        tokenName?: string;
    }[];
    numBlocks?: number;
    feeRate?: number;
    maxFeeRate?: number;
    minConfirms?: number;
    enforceMinConfirmsForChange?: boolean;
    targetWalletUnspents?: number;
    message?: string;
    minValue?: number;
    maxValue?: number;
    sequenceId?: string;
    lastLedgerSequence?: number;
    ledgerSequenceDelta?: number;
    gasPrice?: number;
    noSplitChange?: boolean;
    unspents?: string[];
    comment?: string;
    otp?: string;
    changeAddress?: string;
    instant?: boolean;
    memo?: Memo;
    transferId?: number;
    [index: string]: unknown;
}
declare type WalletType = 'backing' | 'cold' | 'custodial' | 'custodialPaired' | 'hot' | 'trading';
export interface WalletData {
    id: string;
    approvalsRequired: number;
    balance: number;
    confirmedBalance: number;
    spendableBalance: number;
    balanceString: string;
    confirmedBalanceString: string;
    spendableBalanceString: string;
    coin: string;
    label: string;
    keys: string[];
    receiveAddress: {
        address: string;
    };
    migratedFrom?: string;
    coinSpecific: WalletCoinSpecific;
    pendingApprovals: PendingApprovalData[];
    enterprise: string;
    customChangeKeySignatures?: {
        user?: string;
        backup?: string;
        bitgo?: string;
    };
    multisigType: 'onchain' | 'tss';
    type?: WalletType;
}
export interface RecoverTokenOptions {
    tokenContractAddress?: string;
    recipient?: string;
    broadcast?: boolean;
    walletPassphrase?: string;
    prv?: string;
}
export interface ChangeFeeOptions {
    txid?: string;
    fee?: string;
}
export interface CreatePolicyRuleOptions {
    id?: string;
    type?: string;
    message?: string;
    condition?: unknown;
    action?: unknown;
}
export interface SetPolicyRuleOptions {
    id?: string;
    type?: string;
    message?: string;
    condition?: unknown;
    action?: unknown;
}
export interface RemovePolicyRuleOptions {
    id?: string;
    message?: string;
}
export interface DownloadKeycardOptions {
    jsPDF?: any;
    QRCode?: any;
    userKeychain?: Keychain;
    backupKeychain?: Keychain;
    bitgoKeychain?: Keychain;
    passphrase?: string;
    passcodeEncryptionCode?: string;
    activationCode?: string;
    walletKeyID?: string;
    backupKeyID?: string;
}
export declare class Wallet {
    readonly bitgo: BitGo;
    readonly baseCoin: BaseCoin;
    private _wallet;
    private readonly tssUtils;
    private readonly _permissions?;
    constructor(bitgo: BitGo, baseCoin: BaseCoin, walletData: any);
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    url(extra?: string): string;
    /**
     * Get this wallet's id
     */
    id(): string;
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    approvalsRequired(): number;
    /**
     * Get the current balance of this wallet
     */
    balance(): number;
    prebuildWhitelistedParams(): string[];
    /**
     * This is a strict sub-set of prebuildWhitelistedParams
     */
    prebuildConsolidateAccountParams(): string[];
    /**
     * Get the confirmed balance of this wallet
     */
    confirmedBalance(): number;
    /**
     * Get the spendable balance of this wallet
     */
    spendableBalance(): number;
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    balanceString(): string;
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    confirmedBalanceString(): string;
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    spendableBalanceString(): string;
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    coin(): string;
    /**
     * Get the label (name) for this wallet
     */
    label(): string;
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    keyIds(): string[];
    /**
     * Get a receive address for this wallet
     */
    receiveAddress(): string;
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    migratedFrom(): string | undefined;
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    tokenFlushThresholds(): any;
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    coinSpecific(): WalletCoinSpecific | undefined;
    /**
     * Get all pending approvals on this wallet
     */
    pendingApprovals(): PendingApproval[];
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @returns {Wallet}
     */
    refresh(params?: Record<string, never>): Promise<Wallet>;
    /**
     * List the transactions for a given wallet
     * @param params
     * @returns {*}
     */
    transactions(params?: PaginationOptions): Promise<any>;
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @returns {*}
     */
    getTransaction(params?: GetTransactionOptions): Promise<any>;
    /**
     * List the transfers for a given wallet
     * @param params
     * @returns {*}
     */
    transfers(params?: TransfersOptions): Promise<any>;
    /**
     * Get transfers on this wallet
     * @param params
     */
    getTransfer(params?: GetTransferOptions): Promise<any>;
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     */
    transferBySequenceId(params?: TransferBySequenceIdOptions): Promise<any>;
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    maximumSpendable(params?: MaximumSpendableOptions): Promise<MaximumSpendable>;
    /**
     * List the unspents for a given wallet
     * @param params
     * @returns {*}
     */
    unspents(params?: UnspentsOptions): Promise<any>;
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    private manageUnspents;
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    consolidateUnspents(params?: ConsolidateUnspentsOptions): Promise<any>;
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.minValue - the minimum value of unspents to use
     * @param {Number} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    fanoutUnspents(params?: FanoutUnspentsOptions): Promise<any>;
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     */
    updateTokenFlushThresholds(thresholds?: any): Promise<any>;
    /**
       * Updates the wallet. Sets flags for deployForwardersManually and flushForwardersManually of the wallet.
       * @param forwarderFlags {Object} - {
         "coinSpecific": {
           [coinName]: {
             "deployForwardersManually": {Boolean},
             "flushForwardersManually": {Boolean}
           }
         }
       }
       */
    updateForwarders(forwarderFlags?: any): Promise<any>;
    /**
     * To manually deploy an ETH address
     *
     * @param {Object} params - parameters object
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @returns {Object} Http response
     */
    deployForwarders(params: DeployForwardersOptions): Promise<any>;
    /**
     * To manually forward tokens from an ETH or CELO address
     *
     * @param {Object} params - parameters object
     * @param {String} params.tokenName - Name of token that needs to be forwarded from the address
     * @param {String} [params.address] -
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @param {String} [params.gasPrice] - Explicit gas price to use when forwarding token from the forwarder contract (ETH and Celo only). If not given, defaults to the current estimated network gas price.
     * @param {String} [params.eip1559] - Specify eip1559 fee parameters in token forwarding transaction.
     * @returns {Object} Http response
     */
    flushForwarderToken(params: FlushForwarderTokenOptions): Promise<any>;
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @returns txHex {String} the txHex of the signed transaction
     */
    sweep(params?: SweepOptions): Promise<any>;
    /**
     * Freeze a given wallet
     * @param params
     * @returns {*}
     */
    freeze(params?: FreezeOptions): Promise<any>;
    /**
     * Update comment of a transfer
     * @param params
     * @returns {*}
     */
    transferComment(params?: TransferCommentOptions): Promise<any>;
    /**
     * List the addresses for a given wallet
     * @param params
     * @returns {*}
     */
    addresses(params?: AddressesOptions): Promise<any>;
    /**
     * Get a single wallet address by its id
     * @param params
     * @returns {*}
     */
    getAddress(params?: GetAddressOptions): Promise<any>;
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Number} params.forwarderVersion The version of address to create, if applicable
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param {String} params.baseAddress base address of the wallet(optional parameter)
     * @param {Boolean} params.allowSkipVerifyAddress When set to false, it throws error if address verification is skipped for any reason. Default is true.
     * @param {String} [params.derivedAddress]  Derived address
     * @param {Number} [params.index] Index of the derived address
     * @param {String} [params.passphrase] passphrase
     * Address verification can be skipped when forwarderVersion is 0 and pendingChainInitialization is true OR
     * if 'coinSpecific' is not part of the response from api call to create address
     */
    createAddress(params?: CreateAddressOptions): Promise<any>;
    /**
     * Update properties on an address
     * @param params
     * @returns {*}
     */
    updateAddress(params?: UpdateAddressOptions): Promise<any>;
    /**
     * List webhooks on this wallet
     * @param params
     */
    listWebhooks(params?: PaginationOptions): Promise<any>;
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @returns {*}
     */
    simulateWebhook(params?: SimulateWebhookOptions): Promise<any>;
    /**
     * Add a webhook to this wallet
     * @param params
     */
    addWebhook(params?: ModifyWebhookOptions): Promise<any>;
    /**
     * Remove a webhook from this wallet
     * @param params
     */
    removeWebhook(params?: ModifyWebhookOptions): Promise<any>;
    /**
     * Gets the user key chain for this wallet
     *
     * The user key chain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     * @param params
     */
    getEncryptedUserKeychain(params?: Record<string, never>): Promise<{
        encryptedPrv: string;
    }>;
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     */
    getPrv(params?: GetPrvOptions): Promise<any>;
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     */
    createShare(params?: CreateShareOptions): Promise<any>;
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @returns {*}
     */
    shareWallet(params?: ShareWalletOptions): Promise<any>;
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @return {*}
     */
    removeUser(params?: RemoveUserOptions): Promise<any>;
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the walletâ€™s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.nonParticipation - (Algorand) Non participating key reg transaction
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} param.transferId - transfer Id to use in transaction (supported by casper)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param {String} params.walletContractAddress - The contract address used as the "to" field of a transaction
     * @returns {*}
     */
    prebuildTransaction(params?: PrebuildTransactionOptions): Promise<PrebuildTransactionResult>;
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @return {*}
     */
    signTransaction(params?: WalletSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    getUserPrv(params?: GetUserPrvOptions): string;
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     */
    prebuildAndSignTransaction(params?: PrebuildAndSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     */
    accelerateTransaction(params?: AccelerateTransactionOptions): Promise<any>;
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     */
    submitTransaction(params?: SubmitTransactionOptions): Promise<any>;
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.custodianTransactionId - [Ethereum/MMI Specific] id of transaction created via metamask
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @returns {*}
     */
    send(params?: SendOptions): Promise<any>;
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @returns {*}
     */
    sendMany(params?: SendManyOptions): Promise<any>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     */
    recoverToken(params?: RecoverTokenOptions): Promise<any>;
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    getFirstPendingTransaction(params?: Record<string, never>): Promise<any>;
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} params.fee The new fee to apply to the denoted transaction
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    changeFee(params?: ChangeFeeOptions): Promise<any>;
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    getPaymentInfo(params?: {
        url?: string;
    }): Promise<any>;
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    sendPaymentResponse(params?: any): Promise<any>;
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    createPolicyRule(params?: CreatePolicyRuleOptions): Promise<any>;
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    setPolicyRule(params?: any): Promise<any>;
    /**
     * Remove Policy Rule
     * @param params
     * @returns {*}
     */
    removePolicyRule(params?: RemovePolicyRuleOptions): Promise<any>;
    /**
     * Remove this wallet
     * @param params
     * @returns {*}
     */
    remove(params?: Record<string, never>): Promise<any>;
    /**
     * Extract a JSON representable version of this wallet
     */
    toJSON(): WalletData;
    /**
     * Create a trading account from this wallet
     */
    toTradingAccount(): TradingAccount;
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    downloadKeycard(params?: DownloadKeycardOptions): void;
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    buildAccountConsolidations(params?: BuildConsolidationTransactionOptions): Promise<PrebuildTransactionResult[]>;
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     prebuildTx   - this is the pre-build consolidation tx. this is a normally built tx with
     *                    an additional parameter of consolidateId.
     *     verification - normal keychains, etc. for verification
     */
    sendAccountConsolidation(params?: PrebuildAndSignTransactionOptions): Promise<any>;
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params -
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    sendAccountConsolidations(params?: BuildConsolidationTransactionOptions): Promise<any>;
    /**
     * Prebuilds a transaction for a TSS wallet.
     *
     * @param params prebuild transaction options
     */
    private prebuildTransactionTss;
    /**
     * Signs a transaction from a TSS wallet.
     *
     * @param params signing options
     */
    private signTransactionTss;
    /**
     * Builds, signs, and sends a transaction from a TSS wallet.
     *
     * @param params send options
     */
    private sendManyTss;
}
export {};
//# sourceMappingURL=wallet.d.ts.map