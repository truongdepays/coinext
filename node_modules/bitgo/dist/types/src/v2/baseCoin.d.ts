/// <reference types="node" />
import { BaseCoin as AccountLibBasecoin } from '@bitgo/account-lib';
import { BitGo } from '../bitgo';
import { RequestTracer } from './internal/util';
import { Wallet, WalletData } from './wallet';
import { Wallets } from './wallets';
import { Markets } from './markets';
import { Webhooks } from './webhooks';
import { PendingApprovals } from './pendingApprovals';
import { Keychain, Keychains } from './keychains';
import { Enterprises } from './enterprises';
import { InitiateRecoveryOptions } from './recovery/initiate';
import { TssUtils } from './internal/tssUtils';
export declare type TransactionType = AccountLibBasecoin.TransactionType;
export interface TransactionRecipient {
    address: string;
    amount: string | number;
    memo?: string;
}
export interface TransactionFee<TAmount = string> {
    fee: TAmount;
    feeRate?: number;
    size?: number;
}
export interface TransactionExplanation<TFee = any, TAmount = any> {
    displayOrder: string[];
    id: string;
    outputs: TransactionRecipient[];
    outputAmount: TAmount;
    changeOutputs: TransactionRecipient[];
    changeAmount: TAmount;
    fee: TFee;
    proxy?: string;
    producers?: string[];
}
export interface KeyPair {
    pub?: string;
    prv: string;
}
export interface BlsKeyPair extends KeyPair {
    secretShares?: string[];
}
export interface VerifyAddressOptions {
    address: string;
    addressType?: string;
    keychains?: {
        pub: string;
    }[];
    error?: string;
    coinSpecific?: AddressCoinSpecific;
    impliedForwarderVersion?: number;
}
export interface TransactionParams {
    recipients?: TransactionRecipient[];
    walletPassphrase?: string;
    type?: string;
}
export interface AddressVerificationData {
    coinSpecific?: AddressCoinSpecific;
    chain?: number;
    index?: number;
}
export interface VerificationOptions {
    disableNetworking?: boolean;
    keychains?: {
        user?: Keychain;
        backup?: Keychain;
        bitgo?: Keychain;
    };
    addresses?: {
        [address: string]: AddressVerificationData;
    };
    allowPaygoOutput?: boolean;
    considerMigratedFromAddressInternal?: boolean;
}
export interface VerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
    txParams: TransactionParams;
    wallet: Wallet;
    verification?: VerificationOptions;
    reqId?: RequestTracer;
}
export interface SupplementGenerateWalletOptions {
    label: string;
    m: number;
    n: number;
    enterprise?: string;
    disableTransactionNotifications?: boolean;
    gasPrice?: number | string;
    eip1559?: {
        maxFeePerGas: number | string;
        maxPriorityFeePerGas?: number | string;
    };
    walletVersion?: number;
    keys: string[];
    isCold: boolean;
    keySignatures?: {
        backup: string;
        bitgo: string;
    };
    rootPrivateKey?: string;
    disableKRSEmail?: boolean;
    multisigType?: 'tss' | 'onchain' | 'blsdkg';
}
export interface FeeEstimateOptions {
    numBlocks?: number;
    hop?: boolean;
    recipient?: string;
    data?: string;
    amount?: string;
}
export interface ExtraPrebuildParamsOptions {
    [index: string]: unknown;
}
export interface PresignTransactionOptions {
    txPrebuild?: TransactionPrebuild;
    walletData: WalletData;
    tssUtils: TssUtils;
    [index: string]: unknown;
}
export interface PrecreateBitGoOptions {
    [index: string]: unknown;
}
export interface VerifyRecoveryTransactionOptions {
    [index: string]: unknown;
}
export interface ParseTransactionOptions {
    [index: string]: unknown;
}
export interface ParsedTransaction {
    [index: string]: unknown;
}
export interface SignTransactionOptions {
    [index: string]: unknown;
}
export interface KeychainsTriplet {
    userKeychain: Keychain;
    backupKeychain: Keychain;
    bitgoKeychain: Keychain;
}
export interface TransactionPrebuild {
    txBase64?: string;
    txHex?: string;
    txInfo?: unknown;
    wallet?: Wallet;
    buildParams?: any;
    consolidateId?: string;
    txRequestId?: string;
}
export interface AddressCoinSpecific {
    outputScript?: string;
    redeemScript?: string;
    witnessScript?: string;
    baseAddress?: string;
    pendingChainInitialization?: boolean;
    forwarderVersion?: number;
}
export interface FullySignedTransaction {
    txHex: string;
}
export interface HalfSignedUtxoTransaction {
    txHex: string;
}
export interface HalfSignedAccountTransaction {
    halfSigned?: {
        txHex?: string;
        payload?: string;
        txBase64?: string;
    };
}
export interface SignedTransactionRequest {
    txRequestId: string;
}
export declare type SignedTransaction = HalfSignedAccountTransaction | HalfSignedUtxoTransaction | FullySignedTransaction | SignedTransactionRequest;
export declare abstract class BaseCoin {
    protected readonly bitgo: BitGo;
    protected readonly _url: string;
    protected readonly _enterprises: Enterprises;
    protected readonly _wallets: Wallets;
    protected readonly _keychains: Keychains;
    protected readonly _webhooks: Webhooks;
    protected readonly _pendingApprovals: PendingApprovals;
    protected readonly _markets: Markets;
    protected static readonly _coinTokenPatternSeparator = ":";
    protected constructor(bitgo: BitGo);
    url(suffix: string): string;
    wallets(): Wallets;
    enterprises(): Enterprises;
    keychains(): Keychains;
    webhooks(): Webhooks;
    pendingApprovals(): PendingApprovals;
    markets(): Markets;
    static get coinTokenPatternSeparator(): string;
    get type(): string;
    /**
     * Name of the chain which supports this coin (eg, 'btc', 'eth')
     */
    abstract getChain(): string;
    /**
     * Name of the coin family (eg. for tbtc, this would be btc)
     */
    abstract getFamily(): string;
    /**
     * Human readable full name for the coin
     */
    abstract getFullName(): string;
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Use `sendMany()` to perform wallet sweep.
     * FIXME(BG-39738): add coin.sweepWallet() instead
     */
    sweepWithSendMany(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    allowsAccountConsolidations(): boolean;
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss(): boolean;
    /**
     * Flag indicating if this coin supports BLS-DKG wallets.
     * @returns {boolean} True if BLS-DKG Wallets can be created for this coin
     */
    supportsBlsDkg(): boolean;
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    abstract getBaseFactor(): number | string;
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits: string | number): string;
    /**
     * Convert a currency amount represented in big units (btc, eth, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits: string | number): string;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: {
        prv: string;
    }, message: string): Promise<Buffer>;
    /**
     * Decompose a raw transaction into useful information.
     * @param options - coin-specific
     */
    explainTransaction(options: Record<string, any>): Promise<TransactionExplanation<any, string | number> | undefined>;
    /**
     * Verify that a transaction prebuild complies with the original intention
     */
    abstract verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * @deprecated use {@see isWalletAddress} instead
     */
    verifyAddress(params: VerifyAddressOptions): boolean;
    /**
     * @param params
     * @return true iff address is a wallet address. Must return false if address is outside wallet.
     */
    abstract isWalletAddress(params: VerifyAddressOptions): boolean;
    /**
     * convert address into desired address format.
     * @param address
     * @param format
     */
    canonicalAddress(address: string, format?: unknown): string;
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions, keychains: KeychainsTriplet): Promise<any>;
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions): Promise<Record<string, unknown>>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    newWalletObject(walletParams: any): Wallet;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @returns {Object} The info returned from the merchant server
     */
    feeEstimate(params: FeeEstimateOptions): Promise<any>;
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }: {
        key: string;
        seed: string;
    }): {
        key: string;
        derivationPath: string;
    };
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    keyIdsForSigning(): number[];
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    /**
     * @deprecated - use getBip32Keys() in conjunction with isValidAddress instead
     */
    initiateRecovery(params: InitiateRecoveryOptions): never;
    abstract parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Generate a key pair on the curve used by the coin
     *
     * @param seed
     */
    abstract generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    abstract isValidPub(pub: string): boolean;
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }: {
        m?: number;
        n?: number;
    }): boolean;
    /**
     * Check if `address` is a plausibly valid address for the given coin.
     *
     * Does not verify that the address belongs to a wallet. For that,
     * use [[verifyAddress]]
     * @param address
     */
    abstract isValidAddress(address: string): boolean;
    /**
     * Sign a transaction
     */
    abstract signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     *
     * @param {String} serializedTx - the unsigned transaction in broadcast format
     * @returns {Promise<Buffer>} - the portion of the transaction that needs to be signed
     */
    getSignablePayload(serializedTx: string): Promise<Buffer>;
}
//# sourceMappingURL=baseCoin.d.ts.map