/**
 * @prettier
 */
/// <reference types="node" />
import * as openpgp from 'openpgp';
import { KeyShare, SignShare, YShare, GShare, PShare } from '@bitgo/account-lib/dist/src/mpc/tss';
import { BaseCoin, KeychainsTriplet } from '../baseCoin';
import { Keychain } from '../keychains';
import { BitGo } from '../../bitgo';
import { MpcUtils } from './mpcUtils';
import { Memo, Wallet } from '..';
import { RequestTracer } from '../internal/util';
interface PrebuildTransactionWithIntentOptions {
    reqId: RequestTracer;
    intentType: string;
    sequenceId?: string;
    recipients: {
        address: string;
        amount: string | number;
    }[];
    comment?: string;
    memo?: Memo;
    tokenName?: string;
    nonce?: string;
}
export interface TxRequest {
    txRequestId: string;
    unsignedTxs: {
        serializedTxHex: string;
        signableHex: string;
        feeInfo?: {
            fee: number;
            feeString: string;
        };
        derivationPath: string;
    }[];
    signatureShares?: SignatureShareRecord[];
}
export declare enum SignatureShareType {
    USER = "user",
    BACKUP = "backup",
    BITGO = "bitgo"
}
export interface SignatureShareRecord {
    from: SignatureShareType;
    to: SignatureShareType;
    share: string;
}
/**
 * Utility functions for TSS work flows.
 */
export declare class TssUtils extends MpcUtils {
    private _wallet?;
    constructor(bitgo: BitGo, baseCoin: BaseCoin, wallet?: Wallet);
    private get wallet();
    /**
     * Creates a Keychain containing the User's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param passphrase - wallet passphrase used to encrypt user's signing materials
     * @param [originalPasscodeEncryptionCode] - optional encryption code needed for wallet password reset for hot wallets
     */
    createUserKeychain(userGpgKey: openpgp.SerializedKeyPair<string>, userKeyShare: KeyShare, backupKeyShare: KeyShare, bitgoKeychain: Keychain, passphrase: string, originalPasscodeEncryptionCode?: string): Promise<Keychain>;
    /**
     * Creates a Keychain containing the Backup party's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - User's TSS Keyshare
     * @param backupKeyShare - Backup's TSS Keyshare
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param passphrase - wallet passphrase used to encrypt user's signing materials
     */
    createBackupKeychain(userGpgKey: openpgp.SerializedKeyPair<string>, userKeyShare: KeyShare, backupKeyShare: KeyShare, bitgoKeychain: Keychain, passphrase: string): Promise<Keychain>;
    /**
     * Creates a Keychain containing BitGo's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     */
    createBitgoKeychain(userGpgKey: openpgp.SerializedKeyPair<string>, userKeyShare: KeyShare, backupKeyShare: KeyShare, enterprise?: string): Promise<Keychain>;
    /**
     * Creates User, Backup, and BitGo TSS Keychains.
     *
     * @param params.passphrase - passphrase used to encrypt signing materials created for User and Backup
     */
    createKeychains(params: {
        passphrase: string;
        enterprise?: string;
        originalPasscodeEncryptionCode?: string;
    }): Promise<KeychainsTriplet>;
    /**
     * Signs the transaction associated to the transaction request.
     *
     * @param txRequest - transaction request object or id
     * @param prv - decrypted private key
     * @param reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    signTxRequest(params: {
        txRequest: string | TxRequest;
        prv: string;
        reqId: RequestTracer;
    }): Promise<TxRequest>;
    /**
     * Builds a tx request from params and verify it
     *
     * @param {PrebuildTransactionWithIntentOptions} params - parameters to build the tx
     * @returns {Promise<TxRequest>} - a built tx request
     */
    prebuildTxWithIntent(params: PrebuildTransactionWithIntentOptions): Promise<TxRequest>;
    /**
     * Creates the User Sign Share containing the User XShare and the User to Bitgo RShare
     *
     * @param {Buffer} signablePayload - the signablePayload as a buffer
     * @param {PShare} pShare - User's signing material
     * @returns {Promise<SignShare>} - User Sign Share
     */
    createUserSignShare(params: {
        signablePayload: Buffer;
        pShare: PShare;
    }): Promise<SignShare>;
    /**
     * Sends a Signature Share
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {SignatureShareRecord} signatureShare - a Signature Share
     * @returns {Promise<SignatureShareRecord>} - a Signature Share
     */
    sendSignatureShare(params: {
        txRequestId: string;
        signatureShare: SignatureShareRecord;
        signerShare?: string;
    }): Promise<SignatureShareRecord>;
    /**
     * Sends the User to Bitgo RShare to Bitgo
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {SignShare} userSignShare - the user Sign Share
     * @param {String} encryptedSignerShare - signer share encrypted to bitgo key
     * @returns {Promise<void>}
     */
    offerUserToBitgoRShare(params: {
        txRequestId: string;
        userSignShare: SignShare;
        encryptedSignerShare: string;
    }): Promise<void>;
    /**
     * Gets the Bitgo to User RShare from Bitgo
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<SignatureShareRecord>} - a Signature Share
     */
    getBitgoToUserRShare(txRequestId: string): Promise<SignatureShareRecord>;
    /**
     * Gets the latest Tx Request by id
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<TxRequest>}
     */
    getTxRequest(txRequestId: string): Promise<TxRequest>;
    /**
     * Call delete signature shares for a txRequest, the endpoint delete the signatures and return them
     *
     * @param {string} txRequestId tx id reference to delete signature shares
     * @returns {SignatureShareRecord[]}
     */
    deleteSignatureShares(txRequestId: string): Promise<SignatureShareRecord[]>;
    /**
     * Creates the User to Bitgo GShare
     *
     * @param {SignShare} userSignShare - the User Sign Share
     * @param {SignatureShareRecord} bitgoToUserRShare - the Bitgo to User RShare
     * @param {YShare} backupToUserYShare - the backup key Y share received during wallet creation
     * @param {Buffer} signablePayload - the signable payload from a tx
     * @returns {Promise<GShare>} - the User to Bitgo GShare
     */
    createUserToBitGoGShare(userSignShare: SignShare, bitgoToUserRShare: SignatureShareRecord, backupToUserYShare: YShare, bitgoToUserYShare: YShare, signablePayload: Buffer): Promise<GShare>;
    /**
     * Sends the User to Bitgo GShare to Bitgo
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {GShare} userToBitgoGShare - the User to Bitgo GShare
     * @returns {Promise<void>}
     */
    sendUserToBitgoGShare(txRequestId: string, userToBitgoGShare: GShare): Promise<void>;
    /**
     * Initialize the send procedure once Bitgo has the User To Bitgo GShare
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<any>}
     */
    sendTxRequest(txRequestId: string): Promise<any>;
    /**
     * Delete signature shares, get the tx request without them from the db and sign it to finally send it.
     *
     * Note : This can be performed in order to reach latest network conditions required on pending approval flow.
     *
     * @param {String} txRequestId - the txRequest Id to make the requests.
     * @param {String} decryptedPrv - decrypted prv to sign the tx request.
     * @param {RequestTracer} reqId id tracer.
     * @returns {Promise<any>}
     */
    recreateTxRequest(txRequestId: string, decryptedPrv: string, reqId: RequestTracer): Promise<TxRequest>;
    /**
     * Get the commonPub portion of the commonKeychain.
     *
     * @param {String} commonKeychain
     * @returns {string}
     */
    static getPublicKeyFromCommonKeychain(commonKeychain: string): string;
}
export {};
//# sourceMappingURL=tssUtils.d.ts.map