/// <reference types="node" />
import BigNumber from 'bignumber.js';
import { BaseCoin, HalfSignedAccountTransaction as BaseHalfSignedTransaction, BlsKeyPair, ParseTransactionOptions, ParsedTransaction, SignTransactionOptions as BaseSignTransactionOptions, VerifyAddressOptions, VerifyTransactionOptions } from '../baseCoin';
import { BitGo } from '../../bitgo';
interface Recipient {
    address: string;
    amount: string;
    data?: string;
}
interface SignFinalOptions {
    txPrebuild: {
        gasPrice: string;
        gasLimit: string;
        recipients: Recipient[];
        halfSigned: {
            expireTime: number;
            contractSequenceId: number;
            backupKeyNonce?: number;
            signature: string;
        };
        nextContractSequenceId?: number;
        backupKeyNonce?: number;
    };
    signingKeyNonce: number;
    walletContractAddress: string;
    prv: string;
    recipients: Recipient[];
}
export interface SignTransactionOptions extends BaseSignTransactionOptions, SignFinalOptions {
    isLastSignature?: boolean;
    expireTime: number;
    sequenceId: number;
    gasLimit: number;
    gasPrice: number;
}
export interface HalfSignedTransaction extends BaseHalfSignedTransaction {
    halfSigned: {
        recipients: Recipient[];
        expireTime: number;
        contractSequenceId: number;
        sequenceId: number;
        txHex?: never;
    };
}
export interface FullySignedTransaction {
    txHex: string;
}
export declare type SignedTransaction = HalfSignedTransaction | FullySignedTransaction;
interface PrecreateBitGoOptions {
    enterprise?: string;
}
interface OfflineVaultTxInfo {
    nextContractSequenceId?: string;
    contractSequenceId?: string;
    tx: string;
    userKey: string;
    backupKey: string;
    coin: string;
    gasPrice: number;
    gasLimit: number;
    recipients: Recipient[];
    walletContractAddress: string;
    amount: string;
    backupKeyNonce: number;
}
export interface RecoverOptions {
    userKey: string;
    backupKey: string;
    walletPassphrase?: string;
    walletContractAddress: string;
    recoveryDestination: string;
}
export interface RecoveryInfo {
    id: string;
    tx: string;
    backupKey?: string;
    coin?: string;
}
export declare class Eth2 extends BaseCoin {
    static createInstance(bitgo: BitGo): BaseCoin;
    /** @inheritDoc */
    supportsBlsDkg(): boolean;
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): string;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Evaluates whether a address string is valid for this coin
     * @param address
     */
    isValidAddress(address: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    getRecoveryGasPrice(): any;
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    getRecoveryGasLimit(): any;
    /**
     * Specifies what key we will need for signing - ETH2 needs the backup, bitgo pubs.
     */
    keyIdsForSigning(): number[];
    /**
     * Query Beaconscan for the balance of an address
     * @param address {String} the ETH address
     * @returns {BigNumber} address balance
     */
    queryAddressBalance(address: string): Promise<BigNumber>;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @returns Promise<number>
     */
    getAddressNonce(address: string): Promise<number>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.recoveryDestination {String} target address to send recovered funds to
     */
    recover(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Etherscan
     */
    recoveryBlockchainExplorerQuery(query: any): Promise<any>;
    /**
     * Generate BLS key pair
     *
     * @param seed - byte array to generate BLS key pair from
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed?: Buffer): BlsKeyPair;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    isWalletAddress(params: VerifyAddressOptions): boolean;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: {
        prv: string;
    }, message: string): Promise<Buffer>;
    aggregateShares(shares: {
        pubShares: string[];
        prvShares: string[];
    }): BlsKeyPair;
}
export {};
//# sourceMappingURL=eth2.d.ts.map