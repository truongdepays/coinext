/// <reference types="node" />
import { BaseCoin as StaticsBaseCoin, CoinFamily } from '@bitgo/statics';
import { BaseCoin, KeyPair, SignedTransaction, TransactionExplanation, VerifyAddressOptions, VerifyTransactionOptions, SignTransactionOptions, TransactionPrebuild as BaseTransactionPrebuild } from '../baseCoin';
import { BitGo } from '../../bitgo';
export interface TransactionFee {
    fee: string;
}
export interface StxTransactionExplanation extends TransactionExplanation {
    memo?: string;
    type?: number;
    contractAddress?: string;
    contractName?: string;
    contractFunction?: string;
    contractFunctionArgs?: {
        type: string;
        value: string;
    }[];
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    publicKeys?: string[];
    feeInfo: TransactionFee;
}
export interface StxSignTransactionOptions extends SignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string | string[];
    pubKeys?: string[];
    numberSignature?: number;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txHex: string;
    source: string;
}
export declare class Stx extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    constructor(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    getChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    getBaseFactor(): string | number;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * Check if address is valid, then make sure it matches the base address.
     *
     * @param {VerifyAddressOptions} params
     * @param {String} params.address - the address to verify
     * @param {String} params.baseAddress - the base address from the wallet
     */
    isWalletAddress(params: VerifyAddressOptions): boolean;
    /**
     * Generate Stacks key pair
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv: string): boolean;
    isValidAddress(address: string): boolean;
    /**
     * Signs stacks transaction
     * @param params
     */
    signTransaction(params: StxSignTransactionOptions): Promise<SignedTransaction>;
    parseTransaction(params: any): Promise<any>;
    /**
     * Explain a Stacks transaction from txHex
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<StxTransactionExplanation | undefined>;
}
//# sourceMappingURL=stx.d.ts.map