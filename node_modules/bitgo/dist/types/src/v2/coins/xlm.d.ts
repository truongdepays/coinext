/// <reference types="node" />
import * as stellar from 'stellar-sdk';
import { BitGo } from '../../bitgo';
import { BaseCoin, TransactionExplanation as BaseTransactionExplanation, KeyPair, VerifyAddressOptions as BaseVerifyAddressOptions, TransactionPrebuild as BaseTransactionPrebuild, ParseTransactionOptions, ParsedTransaction, VerifyTransactionOptions as BaseVerifyTransactionOptions, SignTransactionOptions as BaseSignTransactionOptions, TransactionParams as BaseTransactionParams, ExtraPrebuildParamsOptions } from '../baseCoin';
import { Wallet } from '../wallet';
/**
 * XLM accounts support virtual (muxed) addresses
 * A base address starts with "G" and is tied to the underlying "real" account
 * A muxed address starts with "M" and combines the base address with a 64-bit integer ID in order to provide
 * an alternative to memo ids.
 */
interface AddressDetails {
    baseAddress: string;
    address: string;
    id?: string;
    memoId?: string | undefined;
}
interface Memo {
    type: stellar.MemoType;
    value: string;
}
interface InitiateRecoveryOptions {
    userKey: string;
    backupKey: string;
    recoveryDestination: string;
    krsProvider?: string;
    walletPassphrase?: string;
}
interface RecoveryOptions extends InitiateRecoveryOptions {
    rootAddress?: string;
}
interface RecoveryTransaction {
    tx: string;
    recoveryAmount: number;
    backupKey?: string;
    coin?: string;
}
interface BuildOptions {
    wallet?: Wallet;
    recipients?: Record<string, string>[];
    type?: string;
    walletPassphrase?: string;
    [index: string]: unknown;
}
interface TransactionPrebuild extends BaseTransactionPrebuild {
    txBase64: string;
}
interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
interface HalfSignedTransaction {
    halfSigned: {
        txBase64: string;
    };
}
interface SupplementGenerateWalletOptions {
    rootPrivateKey?: string;
}
interface ExplainTransactionOptions {
    txBase64: string;
}
interface TransactionMemo {
    value?: string;
    type?: string;
}
interface TransactionExplanation extends BaseTransactionExplanation {
    memo: TransactionMemo;
}
interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    rootAddress: string;
}
interface TrustlineOptions {
    token: string;
    action: string;
    limit?: string;
}
interface TransactionParams extends BaseTransactionParams {
    trustlines?: TrustlineOptions[];
}
interface VerifyTransactionOptions extends BaseVerifyTransactionOptions {
    txParams: TransactionParams;
}
export declare class Xlm extends BaseCoin {
    readonly homeDomain: string;
    static readonly tokenPatternSeparator = "-";
    static readonly maxMemoId: string;
    static readonly maxTrustlineLimit: string;
    constructor(bitgo: BitGo);
    static createInstance(bitgo: BitGo): BaseCoin;
    protected getStellarNetwork(): stellar.Networks;
    /**
     * Factor between the base unit and its smallest subdivison
     */
    getBaseFactor(): number;
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain(): string;
    /**
     * Identifier for the coin family
     */
    getFamily(): string;
    /**
     * Complete human-readable name of this coin
     */
    getFullName(): string;
    /**
     * Url at which the stellar federation server can be reached
     */
    getFederationServerUrl(): string;
    /**
     * Url at which horizon can be reached
     */
    getHorizonUrl(): string;
    /**
     * Generate a new key pair on the ed25519 curve
     * @param seed
     * @returns generated pub and prv
     */
    generateKeyPair(seed: Buffer): KeyPair;
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    getPubFromRaw(pub: string): string;
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    getPrvFromRaw(prv: string): string;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv: string): boolean;
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId: string): boolean;
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    isValidMemo({ value, type }: Memo): boolean;
    /**
     * Create instance of stellar.MuxedAccount from M address
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     */
    getMuxedAccount(address: string): stellar.MuxedAccount;
    /**
     * Return boolean indicating whether a muxed address is valid
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     *
     * @param address
     * @returns {boolean}
     */
    isValidMuxedAddress(address: string): boolean;
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    getMinimumReserve(): Promise<number>;
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    getBaseTransactionFee(): Promise<number>;
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address: string): AddressDetails;
    /**
     * Validate and return address with appended memo id or muxed address
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    normalizeAddress({ address, memoId }: AddressDetails): string;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    isValidAddress(address: string): boolean;
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    getTokenNameFromStellarAsset(asset: stellar.Asset): string;
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    isValidStellarUsername(username: string): boolean;
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    getBitGoFederationServer(): stellar.FederationServer;
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    private federationLookup;
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    federationLookupByName(address: string): Promise<stellar.FederationServer.Record>;
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    federationLookupByAccountId(accountId: string): Promise<stellar.FederationServer.Record>;
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    isWalletAddress({ address, rootAddress }: VerifyAddressOptions): boolean;
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions): Promise<BuildOptions>;
    /**
     * @deprecated
     */
    initiateRecovery(params: RecoveryOptions): never;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    recover(params: RecoveryOptions): Promise<RecoveryTransaction>;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<HalfSignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<HalfSignedTransaction>;
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions): Promise<SupplementGenerateWalletOptions>;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    verifySignature(pub: string, message: string | Buffer, signature: Buffer): boolean;
    /**
     * Explain/parse transaction
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyTrustlineTxOperations(operations: stellar.Operation[], txParams: TransactionParams): void;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     */
    verifyTransaction(options: VerifyTransactionOptions): Promise<boolean>;
    /**
     * Derive a hardened child public key from a master key seed using an additional seed for randomness.
     *
     * Due to technical differences between keypairs on the ed25519 curve and the secp256k1 curve,
     * only hardened private key derivation is supported.
     *
     * @param key seed for the master key. Note: Not the public key or encoded private key. This is the raw seed.
     * @param entropySeed random seed which is hashed to generate the derivation path
     */
    deriveKeyWithSeed({ key, seed }: {
        key: string;
        seed: string;
    }): {
        derivationPath: string;
        key: string;
    };
    /**
     * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
     * correct one to use, so we have to be very explicit as to which one we want.
     * @param tx transaction to convert
     */
    protected static txToString: (tx: stellar.Transaction) => string;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
}
export {};
//# sourceMappingURL=xlm.d.ts.map