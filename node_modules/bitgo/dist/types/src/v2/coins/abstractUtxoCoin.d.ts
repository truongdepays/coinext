/// <reference types="node" />
import * as utxolib from '@bitgo/utxo-lib';
import { Unspent } from '@bitgo/utxo-lib/dist/src/bitgo';
import { BitGo } from '../../bitgo';
import { backupKeyRecovery, RecoverParams } from './utxo/recovery/backupKeyRecovery';
import { CrossChainRecoverySigned, CrossChainRecoveryUnsigned } from './utxo/recovery/crossChainRecovery';
import { AddressCoinSpecific, BaseCoin, ExtraPrebuildParamsOptions, KeychainsTriplet, ParseTransactionOptions as BaseParseTransactionOptions, ParsedTransaction as BaseParsedTransaction, PrecreateBitGoOptions, PresignTransactionOptions, SignedTransaction, SignTransactionOptions as BaseSignTransactionOptions, SupplementGenerateWalletOptions, TransactionExplanation as BaseTransactionExplanation, TransactionParams as BaseTransactionParams, TransactionPrebuild as BaseTransactionPrebuild, VerificationOptions, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyTransactionOptions as BaseVerifyTransactionOptions, HalfSignedUtxoTransaction } from '../baseCoin';
import { CustomChangeOptions } from '../internal/parseOutput';
import { RequestTracer } from '../internal/util';
import { Keychain } from '../keychains';
import { Triple } from '../triple';
import { Wallet } from '../wallet';
import ScriptType2Of3 = utxolib.bitgo.outputScripts.ScriptType2Of3;
export interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    chain: number;
    index: number;
}
export interface Output {
    address: string;
    amount: string | number;
    external?: boolean;
    needsCustomChangeKeySignatureVerification?: boolean;
}
export interface TransactionExplanation extends BaseTransactionExplanation<string, number> {
    locktime: number;
    outputs: Output[];
    changeOutputs: Output[];
    /**
     * Number of input signatures per input.
     */
    inputSignatures: number[];
    /**
     * Highest input signature count for the transaction
     */
    signatures: number;
}
export interface TransactionInfo {
    /** Maps txid to txhex. Required for offline signing. */
    txHexes?: Record<string, string>;
    changeAddresses?: string[];
    unspents: Unspent[];
}
export interface ExplainTransactionOptions {
    txHex: string;
    txInfo?: TransactionInfo;
    feeInfo?: string;
    pubs?: Triple<string>;
}
export declare type UtxoNetwork = utxolib.Network;
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txInfo?: TransactionInfo;
    blockHeight?: number;
}
export interface TransactionParams extends BaseTransactionParams {
    walletPassphrase?: string;
    changeAddress?: string;
}
export interface ParseTransactionOptions extends BaseParseTransactionOptions {
    txParams: TransactionParams;
    txPrebuild: TransactionPrebuild;
    wallet: Wallet;
    verification?: VerificationOptions;
    reqId?: RequestTracer;
}
export interface ParsedTransaction extends BaseParsedTransaction {
    keychains: {
        user?: Keychain;
        backup?: Keychain;
        bitgo?: Keychain;
    };
    keySignatures: {
        backupPub?: string;
        bitgoPub?: string;
    };
    outputs: Output[];
    missingOutputs: Output[];
    explicitExternalOutputs: Output[];
    implicitExternalOutputs: Output[];
    changeOutputs: Output[];
    explicitExternalSpendAmount: number;
    implicitExternalSpendAmount: number;
    needsCustomChangeKeySignatureVerification: boolean;
    customChange?: CustomChangeOptions;
}
export interface GenerateAddressOptions {
    addressType?: ScriptType2Of3;
    keychains: {
        pub: string;
        aspKeyId?: string;
    }[];
    threshold?: number;
    chain?: number;
    index?: number;
    segwit?: boolean;
    bech32?: boolean;
}
export interface AddressDetails {
    address: string;
    chain: number;
    index: number;
    coin: string;
    coinSpecific: AddressCoinSpecific;
    addressType?: string;
}
export interface SignTransactionOptions extends BaseSignTransactionOptions {
    /** Transaction prebuild from bitgo server */
    txPrebuild: {
        txHex: string;
        txInfo: TransactionInfo;
    };
    /** xprv of user key or backup key */
    prv: string;
    /** xpubs triple for wallet (user, backup, bitgo) */
    pubs: Triple<string>;
    /** xpub for cosigner (defaults to bitgo) */
    cosignerPub?: string;
    /**
     * When true, creates full-signed transaction without placeholder signatures.
     * When false, creates half-signed transaction with placeholder signatures.
     */
    isLastSignature?: boolean;
}
export interface MultiSigAddress {
    outputScript: Buffer;
    redeemScript?: Buffer;
    witnessScript?: Buffer;
    address: string;
}
export interface RecoverFromWrongChainOptions {
    txid: string;
    recoveryAddress: string;
    wallet: string;
    walletPassphrase?: string;
    xprv?: string;
    /** @deprecated */
    coin?: AbstractUtxoCoin;
    recoveryCoin?: AbstractUtxoCoin;
    signed?: boolean;
}
export interface AddressInfo {
    txCount: number;
    totalBalance: number;
}
export interface VerifyKeySignaturesOptions {
    userKeychain?: Keychain;
    keychainToVerify?: Keychain;
    keySignature?: string;
}
export interface VerifyUserPublicKeyOptions {
    userKeychain?: Keychain;
    disableNetworking: boolean;
    txParams: TransactionParams;
}
export interface VerifyTransactionOptions extends BaseVerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
}
export interface UnspentParams {
    id: string;
    value: number;
    valueString: string;
    address: string;
    blockHeight: number;
}
export declare abstract class AbstractUtxoCoin extends BaseCoin {
    altScriptHash?: number;
    supportAltScriptDestination?: boolean;
    private readonly _network;
    protected constructor(bitgo: BitGo, network: utxolib.Network);
    get network(): utxolib.Network;
    sweepWithSendMany(): boolean;
    /** @deprecated */
    static get validAddressTypes(): ScriptType2Of3[];
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): number;
    /**
     * @deprecated
     */
    getCoinLibrary(): typeof utxolib;
    /**
     * Helper to get the version number for an address
     */
    protected getAddressVersion(address: string): number | undefined;
    /**
     * Helper to get the bech32 prefix for an address
     */
    protected getAddressPrefix(address: string): string | undefined;
    /**
     * Check if an address is valid
     * @param address
     * @param forceAltScriptSupport
     */
    isValidAddress(address: string, forceAltScriptSupport?: boolean): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Get the latest block height
     * @param reqId
     */
    getLatestBlockHeight(reqId?: RequestTracer): Promise<number>;
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     */
    postProcessPrebuild(prebuild: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    protected static findMissingOutputs(expectedOutputs: Output[], actualOutputs: Output[]): Output[];
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    static inferAddressType(addressDetails: {
        chain: number;
    }): ScriptType2Of3 | null;
    createTransactionFromHex(hex: string): utxolib.bitgo.UtxoTransaction;
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @returns {*}
     */
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Decrypt the wallet's user private key and verify that the claimed public key matches
     * @param {VerifyUserPublicKeyOptions} params
     * @return {boolean}
     * @protected
     */
    protected verifyUserPublicKey(params: VerifyUserPublicKeyOptions): boolean;
    /**
     * Verify signatures produced by the user key over the backup and bitgo keys.
     *
     * If set, these signatures ensure that the wallet keys cannot be changed after the wallet has been created.
     * @param {VerifyKeySignaturesOptions} params
     * @return {{backup: boolean, bitgo: boolean}}
     */
    protected verifyKeySignature(params: VerifyKeySignaturesOptions): boolean;
    /**
     * Verify signatures against the user private key over the change wallet extended keys
     * @param {ParsedTransaction} tx
     * @param {Keychain} userKeychain
     * @return {boolean}
     * @protected
     */
    protected verifyCustomChangeKeySignatures(tx: ParsedTransaction, userKeychain: Keychain): boolean;
    /**
     * Get the maximum percentage limit for pay-as-you-go outputs
     *
     * @protected
     */
    protected getPayGoLimit(allowPaygoOutput?: boolean): number;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @returns {boolean}
     */
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    isWalletAddress(params: VerifyAddressOptions): boolean;
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * @param addressType
     * @returns true iff coin supports spending from unspentType
     */
    supportsAddressType(addressType: ScriptType2Of3): boolean;
    /**
     * @param chain
     * @return true iff coin supports spending from chain
     */
    supportsAddressChain(chain: number): boolean;
    keyIdsForSigning(): number[];
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    generateAddress(params: GenerateAddressOptions): AddressDetails;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params - {@see SignTransactionOptions}
     * @returns {Promise<SignedTransaction | HalfSignedUtxoTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction | HalfSignedUtxoTransaction>;
    /**
     * @param unspent
     * @returns {boolean}
     */
    isBitGoTaintedUnspent(unspent: Unspent): boolean;
    /**
     * @deprecated - use utxolib.bitgo.getDefaultSigHash(network) instead
     * @returns {number}
     */
    get defaultSigHashType(): number;
    /**
     * @deprecated - use utxolib.bitcoin.verifySignature() instead
     */
    verifySignature(transaction: any, inputIndex: number, amount: number, verificationSettings?: {
        signatureIndex?: number;
        publicKey?: string;
    }): boolean;
    /**
     * Decompose a raw transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    createMultiSigAddress(addressType: ScriptType2Of3, signatureThreshold: number, keys: Buffer[]): MultiSigAddress;
    /**
     * @deprecated - use {@see backupKeyRecovery}
     * Builds a funds recovery transaction without BitGo
     * @param params - {@see backupKeyRecovery}
     */
    recover(params: RecoverParams): ReturnType<typeof backupKeyRecovery>;
    /**
     * Recover coin that was sent to wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @returns {*}
     */
    recoverFromWrongChain(params: RecoverFromWrongChainOptions): Promise<CrossChainRecoverySigned | CrossChainRecoveryUnsigned>;
    /**
     * Generate bip32 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: Buffer): {
        pub: string;
        prv: string;
    };
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions): Promise<any>;
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    presignTransaction(params: PresignTransactionOptions): Promise<any>;
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions, keychains: KeychainsTriplet): Promise<any>;
    transactionDataAllowed(): boolean;
    valuelessTransferAllowed(): boolean;
}
//# sourceMappingURL=abstractUtxoCoin.d.ts.map