/// <reference types="node" />
import { BitGo } from '../../bitgo';
import { BaseCoin, TransactionExplanation, KeyPair, ParseTransactionOptions, ParsedTransaction, VerifyTransactionOptions, SignedTransaction, SignTransactionOptions as BaseSignTransactionOptions, VerifyAddressOptions, AddressCoinSpecific } from '../baseCoin';
import { TokenManagementType } from '../types';
export interface AlgoAddressCoinSpecifics extends AddressCoinSpecific {
    rootAddress: string;
    bitgoKey: string;
    bitgoPubKey?: string;
    addressVersion: number;
    threshold: number;
}
export interface VerifyAlgoAddressOptions extends VerifyAddressOptions {
    chain: number;
    index: number;
    coin: string;
    wallet: string;
    coinSpecific: AlgoAddressCoinSpecifics;
}
export interface AlgoTransactionExplanation extends TransactionExplanation {
    memo?: string;
    type?: string | number;
    voteKey?: string;
    selectionKey?: string;
    voteFirst?: number;
    voteLast?: number;
    voteKeyDilution?: number;
    tokenId?: number;
    operations?: TransactionOperation[];
}
export interface TransactionOperation {
    type: string;
    coin: string;
}
export interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
export interface TransactionPrebuild {
    txHex: string;
    halfSigned?: {
        txHex: string;
    };
    txInfo: {
        from: string;
        to: string;
        amount: string;
        fee: number;
        firstRound: number;
        lastRound: number;
        genesisID: string;
        genesisHash: string;
        note?: string;
    };
    keys: string[];
    addressVersion: number;
}
export interface FullySignedTransaction {
    txHex: string;
}
export interface HalfSignedTransaction {
    halfSigned: {
        txHex: string;
    };
}
export interface TransactionFee {
    fee: string;
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    publicKeys?: string[];
    feeInfo: TransactionFee;
}
export interface VerifiedTransactionParameters {
    txHex: string;
    addressVersion: number;
    signers: string[];
    prv: string;
    isHalfSigned: boolean;
    numberSigners: number;
}
export declare class Algo extends BaseCoin {
    readonly ENABLE_TOKEN: TokenManagementType;
    readonly DISABLE_TOKEN: TokenManagementType;
    constructor(bitgo: BitGo);
    static createInstance(bitgo: BitGo): BaseCoin;
    getChain(): string;
    getBaseChain(): string;
    getFamily(): string;
    getFullName(): string;
    getBaseFactor(): number | string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    allowsAccountConsolidations(): boolean;
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address: string): boolean;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    keyIdsForSigning(): number[];
    /**
     * Explain/parse transaction
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<AlgoTransactionExplanation | undefined>;
    /**
     * returns if a tx is a token tx
     * @param type {string} - tx type
     * @returns true if it's a token tx
     */
    isTokenTx(type: string): boolean;
    /**
     * Check if a seed is a valid stellar seed
     *
     * @param {String} seed the seed to check
     * @returns {Boolean} true if the input is a Stellar seed
     */
    isStellarSeed(seed: string): boolean;
    /**
     * Convert a stellar seed to an algo seed
     *
     * @param {String} seed the seed to convert
     * @returns {Boolean | null} seed in algo encoding
     */
    convertFromStellarSeed(seed: string): string | null;
    verifySignTransactionParams(params: SignTransactionOptions): VerifiedTransactionParameters;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Check if address can be used to send funds.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    isWalletAddress(params: VerifyAlgoAddressOptions): boolean;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /** @inheritDoc */
    deriveKeyWithSeed({ key, seed }: {
        key: string;
        seed: string;
    }): {
        derivationPath: string;
        key: string;
    };
    decodeTx(txn: Buffer): unknown;
    getAddressFromPublicKey(pubKey: Uint8Array): string;
    /**
     * Stellar and Algorand both use keys on the ed25519 curve, but use different encodings.
     * As the HSM doesn't have explicit support to create Algorand addresses, we use the Stellar
     * keys and re-encode them to the Algorand encoding.
     *
     * This method should only be used when creating Algorand custodial wallets reusing Stellar keys.
     *
     * @param {string} addressOrPubKey a Stellar pubkey or Algorand address
     * @return {*}
     */
    private stellarAddressToAlgoAddress;
}
//# sourceMappingURL=algo.d.ts.map