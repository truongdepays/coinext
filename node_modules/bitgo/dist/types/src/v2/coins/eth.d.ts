/// <reference types="node" />
import { BaseCoin, FeeEstimateOptions, HalfSignedAccountTransaction, KeyPair, ParseTransactionOptions, ParsedTransaction, PresignTransactionOptions as BasePresignTransactionOptions, SignTransactionOptions as BaseSignTransactionOptions, TransactionPrebuild as BaseTransactionPrebuild, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyTransactionOptions, TransactionParams, TransactionRecipient, AddressCoinSpecific } from '../baseCoin';
import { BitGo } from '../../bitgo';
import { Wallet } from '../wallet';
import { BaseCoin as StaticsBaseCoin, EthereumNetwork } from '@bitgo/statics';
import type * as EthTxLib from '@ethereumjs/tx';
import type * as EthCommon from '@ethereumjs/common';
export declare const optionalDeps: {
    readonly ethAbi: any;
    readonly ethUtil: any;
    readonly EthTx: typeof EthTxLib;
    readonly EthCommon: typeof EthCommon;
};
/**
 * The extra parameters to send to platform build route for hop transactions
 */
interface HopParams {
    hopParams: {
        gasPriceMax: number;
        userReqSig: string;
        paymentId: string;
    };
    gasLimit: number;
}
/**
 * The prebuilt hop transaction returned from the HSM
 */
interface HopPrebuild {
    tx: string;
    id: string;
    signature: string;
    paymentId: string;
    gasPrice: number;
    gasLimit: number;
    amount: number;
    recipient: string;
    nonce: number;
    userReqSig: string;
    gasPriceMax: number;
}
interface Recipient {
    address: string;
    amount: string;
    data?: string;
}
interface EIP1559 {
    maxPriorityFeePerGas: number;
    maxFeePerGas: number;
}
interface ReplayProtectionOptions {
    chain: string | number;
    hardfork: string;
}
interface SignFinalOptions {
    txPrebuild: {
        eip1559?: EIP1559;
        replayProtectionOptions?: ReplayProtectionOptions;
        gasPrice?: string;
        gasLimit: string;
        recipients: Recipient[];
        halfSigned: {
            expireTime: number;
            contractSequenceId: number;
            backupKeyNonce?: number;
            signature: string;
        };
        nextContractSequenceId?: number;
        hopTransaction?: string;
        backupKeyNonce?: number;
        isBatch?: boolean;
    };
    signingKeyNonce: number;
    walletContractAddress: string;
    prv: string;
    recipients: Recipient[];
}
export interface SignTransactionOptions extends BaseSignTransactionOptions, SignFinalOptions {
    isLastSignature?: boolean;
    expireTime: number;
    sequenceId: number;
    gasLimit: number;
    gasPrice: number;
}
export interface HalfSignedTransaction extends HalfSignedAccountTransaction {
    halfSigned: {
        recipients: Recipient[];
        expireTime: number;
        contractSequenceId: number;
        sequenceId: number;
        txHex?: never;
    };
}
export interface FullySignedTransaction {
    txHex: string;
}
export declare type SignedTransaction = HalfSignedTransaction | FullySignedTransaction;
interface PrecreateBitGoOptions {
    enterprise?: string;
    newFeeAddress?: string;
}
interface OfflineVaultTxInfo {
    nextContractSequenceId?: string;
    contractSequenceId?: string;
    tx: string;
    userKey: string;
    backupKey: string;
    coin: string;
    gasPrice: number;
    gasLimit: number;
    recipients: Recipient[];
    walletContractAddress: string;
    amount: string;
    backupKeyNonce: number;
    eip1559?: EIP1559;
    replayProtectionOptions?: ReplayProtectionOptions;
}
interface UnformattedTxInfo {
    recipient: Recipient;
}
export interface RecoverOptions {
    userKey: string;
    backupKey: string;
    walletPassphrase?: string;
    walletContractAddress: string;
    recoveryDestination: string;
    krsProvider?: string;
    gasPrice?: number;
    gasLimit?: number;
    eip1559?: EIP1559;
    replayProtectionOptions?: ReplayProtectionOptions;
}
interface BuildTransactionParams {
    to: string;
    nonce?: number;
    value: number;
    data?: Buffer;
    gasPrice?: number;
    gasLimit?: number;
    eip1559?: EIP1559;
    replayProtectionOptions?: ReplayProtectionOptions;
}
export interface RecoveryInfo {
    id: string;
    tx: string;
    backupKey?: string;
    coin?: string;
}
interface RecoverTokenOptions {
    tokenContractAddress: string;
    wallet: Wallet;
    recipient: string;
    broadcast?: boolean;
    walletPassphrase?: string;
    prv?: string;
}
interface GetSendMethodArgsOptions {
    recipient: Recipient;
    expireTime: number;
    contractSequenceId: number;
    signature: string;
}
interface SendMethodArgs {
    name: string;
    type: string;
    value: any;
}
interface HopTransactionBuildOptions {
    wallet: Wallet;
    recipients: Recipient[];
    walletPassphrase: string;
}
interface BuildOptions {
    hop?: boolean;
    wallet?: Wallet;
    recipients?: Recipient[];
    walletPassphrase?: string;
    [index: string]: unknown;
}
interface FeeEstimate {
    gasLimitEstimate: number;
    feeEstimate: number;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    hopTransaction?: HopPrebuild;
    buildParams: {
        recipients: Recipient[];
    };
    recipients: TransactionRecipient[];
    nextContractSequenceId: string;
    gasPrice: number;
    gasLimit: number;
    isBatch: boolean;
    coin: string;
    token?: string;
}
interface EthTransactionParams extends TransactionParams {
    gasPrice?: number;
    gasLimit?: number;
    hopParams?: HopParams;
    hop?: boolean;
}
interface VerifyEthTransactionOptions extends VerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
    txParams: EthTransactionParams;
}
interface PresignTransactionOptions extends TransactionPrebuild, BasePresignTransactionOptions {
    wallet: Wallet;
}
interface RecoverTokenTransaction {
    halfSigned: {
        recipient: Recipient;
        expireTime: number;
        contractSequenceId: number;
        operationHash: string;
        signature: string;
        gasLimit: number;
        gasPrice: number;
        tokenContractAddress: string;
        walletId: string;
    };
}
interface EthAddressCoinSpecifics extends AddressCoinSpecific {
    forwarderVersion: number;
    salt?: string;
}
interface VerifyEthAddressOptions extends BaseVerifyAddressOptions {
    baseAddress: string;
    coinSpecific: EthAddressCoinSpecifics;
    forwarderVersion: number;
}
export declare class Eth extends BaseCoin {
    static hopTransactionSalt: string;
    protected readonly sendMethodName: 'sendMultiSig' | 'sendMultiSigToken';
    readonly staticsCoin?: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    static buildTransaction(params: BuildTransactionParams): EthTxLib.FeeMarketEIP1559Transaction | EthTxLib.Transaction;
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): string;
    getChain(): string;
    getFamily(): string;
    getNetwork(): EthereumNetwork | undefined;
    getFullName(): string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    getRecoveryGasPrice(): any;
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    getRecoveryGasLimit(): any;
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    getDefaultExpireTime(): number;
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @returns {BigNumber} address balance
     */
    queryAddressBalance(address: string): Promise<any>;
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @returns {BigNumber} token balaance in base units
     */
    queryAddressTokenBalance(tokenContractAddress: string, walletContractAddress: string): Promise<any>;
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    getOperation(recipient: Recipient, expireTime: number, contractSequenceId: number): (string | Buffer)[][];
    getOperationSha3ForExecuteAndConfirm(recipients: Recipient[], expireTime: number, contractSequenceId: number): string;
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @returns {Number} sequence ID
     */
    querySequenceId(address: string): Promise<number>;
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    signFinal(params: SignFinalOptions): FullySignedTransaction;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @returns {*}
     */
    getAddressNonce(address: string): Promise<number>;
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param eip1559
     * @param replayProtectionOptions
     * @returns {Promise<OfflineVaultTxInfo>}
     */
    formatForOfflineVault(txInfo: UnformattedTxInfo, ethTx: EthTxLib.Transaction | EthTxLib.FeeMarketEIP1559Transaction, userKey: string, backupKey: string, gasPrice: Buffer, gasLimit: number, eip1559?: EIP1559, replayProtectionOptions?: ReplayProtectionOptions): Promise<OfflineVaultTxInfo>;
    /**
     * Check whether the gas price passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param userGasPrice user defined gas price
     * @returns the gas price to use for this transaction
     */
    setGasPrice(userGasPrice?: number): number;
    /**
     * Check whether gas limit passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param userGasLimit user defined gas limit
     * @returns the gas limit to use for this transaction
     */
    setGasLimit(userGasLimit?: number): number;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     */
    recover(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     */
    recoverToken(params: RecoverTokenOptions): Promise<RecoverTokenTransaction>;
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    getSendMethodArgs(txInfo: GetSendMethodArgsOptions): SendMethodArgs[];
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Etherscan
     */
    recoveryBlockchainExplorerQuery(query: Record<string, string>): Promise<any>;
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    createHopTransactionParams(buildParams: HopTransactionBuildOptions): Promise<HopParams>;
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    validateHopPrebuild(wallet: Wallet, hopPrebuild: HopPrebuild, originalParams?: {
        recipients: Recipient[];
    }): Promise<void>;
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    private static getHopDigest;
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    getExtraPrebuildParams(buildParams: BuildOptions): Promise<BuildOptions>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(params: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    feeEstimate(params: FeeEstimateOptions): Promise<FeeEstimate>;
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Make sure an address is a wallet address and throw an error if it's not.
     * @param {Object} params
     * @param {String} params.address The derived address string on the network
     * @param {Object} params.coinSpecific Coin-specific details for the address such as a forwarderVersion
     * @param {String} params.baseAddress The base address of the wallet on the network
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressVerificationObjectPropertyError}
     * @throws {UnexpectedAddressError}
     * @returns {Boolean} True iff address is a wallet address
     */
    isWalletAddress(params: VerifyEthAddressOptions): boolean;
    verifyCoin(txPrebuild: TransactionPrebuild): boolean;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.wallet Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    verifyTransaction(params: VerifyEthTransactionOptions): Promise<boolean>;
    private isETHAddress;
}
export {};
//# sourceMappingURL=eth.d.ts.map