/// <reference types="node" />
import { BaseCoin, FeeEstimateOptions, FullySignedTransaction, HalfSignedAccountTransaction, KeyPair, ParsedTransaction, ParseTransactionOptions, PresignTransactionOptions as BasePresignTransactionOptions, SignTransactionOptions as BaseSignTransactionOptions, VerifyAddressOptions, VerifyTransactionOptions, TransactionFee, TransactionPrebuild as BaseTransactionPrebuild, TransactionExplanation, TransactionRecipient, TransactionParams } from '../baseCoin';
import { BitGo } from '../../bitgo';
import { BaseCoin as StaticsBaseCoin, CoinFamily } from '@bitgo/statics';
import { Eth } from '@bitgo/account-lib';
import { Wallet } from '../wallet';
interface PrecreateBitGoOptions {
    enterprise?: string;
    newFeeAddress?: string;
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    feeInfo: TransactionFee;
}
interface AvaxcTransactionParams extends TransactionParams {
    gasPrice?: number;
    gasLimit?: number;
    hopParams?: HopParams;
    hop?: boolean;
}
interface VerifyAvaxcTransactionOptions extends VerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
    txParams: AvaxcTransactionParams;
}
interface PresignTransactionOptions extends TransactionPrebuild, BasePresignTransactionOptions {
    wallet: Wallet;
}
interface EIP1559 {
    maxPriorityFeePerGas: number;
    maxFeePerGas: number;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    hopTransaction?: HopPrebuild;
    buildParams: {
        recipients: Recipient[];
    };
    recipients: TransactionRecipient[];
    nextContractSequenceId: string;
    gasPrice: number;
    gasLimit: number;
    isBatch: boolean;
    coin: string;
    token?: string;
}
interface HopTransactionBuildOptions {
    wallet: Wallet;
    recipients: Recipient[];
    walletPassphrase: string;
}
interface Recipient {
    address: string;
    amount: string;
    data?: string;
}
interface BuildOptions {
    hop?: boolean;
    wallet?: Wallet;
    recipients?: Recipient[];
    walletPassphrase?: string;
    [index: string]: unknown;
}
interface FeeEstimate {
    gasLimitEstimate: number;
    feeEstimate: number;
}
/**
 * The extra parameters to send to platform build route for hop transactions
 */
interface HopParams {
    hopParams: {
        gasPriceMax: number;
        userReqSig: string;
        paymentId: string;
    };
    gasLimit: number;
}
/**
 * The prebuilt hop transaction returned from the HSM
 */
interface HopPrebuild {
    tx: string;
    id: string;
    signature: string;
    paymentId: string;
    gasPrice: number;
    gasLimit: number;
    amount: number;
    recipient: string;
    nonce: number;
    userReqSig: string;
    gasPriceMax: number;
}
export interface TxInfo {
    recipients: Recipient[];
    from: string;
    txid: string;
}
export interface EthTransactionFee {
    fee: string;
    gasLimit?: string;
}
export interface TxPreBuild extends BaseTransactionPrebuild {
    txHex: string;
    txInfo: TxInfo;
    feeInfo: EthTransactionFee;
    source: string;
    dataToSign: string;
    nextContractSequenceId?: string;
    expireTime?: number;
    hopTransaction?: string;
    eip1559?: EIP1559;
}
export interface AvaxSignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: TxPreBuild;
    prv: string;
}
export interface HalfSignedTransaction extends HalfSignedAccountTransaction {
    halfSigned: {
        txHex?: never;
        recipients: Recipient[];
        expiration?: number;
        eip1559?: EIP1559;
    };
}
export declare type SignedTransaction = HalfSignedTransaction | FullySignedTransaction;
export declare class AvaxC extends BaseCoin {
    static hopTransactionSalt: string;
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    getBaseFactor(): number;
    getChain(): string;
    /**
     * Get the base chain that the coin exists on.
     */
    getBaseChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    valuelessTransferAllowed(): boolean;
    isValidAddress(address: string): boolean;
    isToken(): boolean;
    generateKeyPair(seed?: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    verifyAddress({ address }: VerifyAddressOptions): boolean;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.wallet Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    verifyTransaction(params: VerifyAvaxcTransactionOptions): Promise<boolean>;
    private static isAVAXCAddress;
    verifyCoin(txPrebuild: TransactionPrebuild): boolean;
    isValidPub(pub: string): boolean;
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params The options with which to recover
     */
    recover(params: any): Promise<any>;
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    protected getTransactionBuilder(): Eth.TransactionBuilder;
    /**
     * Explain a transaction from txHex, overriding BaseCoins
     * @param params The options with which to explain the transaction
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
    /**
     * Above is standard BaseCoins functions
     * ================================================================================================================
     * ================================================================================================================
     * Below is transaction functions
     */
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(params: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    validateHopPrebuild(wallet: Wallet, hopPrebuild: HopPrebuild, originalParams?: {
        recipients: Recipient[];
    }): Promise<void>;
    /**
     * Assemble half-sign prebuilt transaction
     * @param params
     */
    signTransaction(params: AvaxSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    getExtraPrebuildParams(buildParams: BuildOptions): Promise<BuildOptions>;
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    createHopTransactionParams(buildParams: HopTransactionBuildOptions): Promise<HopParams>;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    feeEstimate(params: FeeEstimateOptions): Promise<FeeEstimate>;
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    private static getHopDigest;
    isWalletAddress(params: VerifyAddressOptions): boolean;
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
}
export {};
//# sourceMappingURL=avaxc.d.ts.map