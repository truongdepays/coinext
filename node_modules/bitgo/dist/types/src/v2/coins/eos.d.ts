/// <reference types="node" />
import * as bip32 from 'bip32';
import * as request from 'superagent';
import { BitGo } from '../../bitgo';
import { BaseCoin, TransactionExplanation, KeyPair, ParseTransactionOptions, ParsedTransaction, HalfSignedAccountTransaction as BaseHalfSignedTransaction, SignTransactionOptions as BaseSignTransactionOptions, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyTransactionOptions as BaseVerifyTransactionOptions, VerificationOptions } from '../baseCoin';
import { Wallet } from '../wallet';
import { RequestTracer } from '../internal/util';
interface AddressDetails {
    address: string;
    memoId?: string;
}
export interface EosTx {
    signatures: string[];
    packed_trx: string;
    compression: string;
}
export interface Recipient {
    address: string;
    amount: string;
}
interface EosTransactionHeaders {
    ref_block_prefix: number;
    ref_block_num: number;
    expiration?: string;
}
interface EosTransactionAction {
    account: string;
    name: string;
    authorization: [{
        actor: string;
        permission: string;
    }];
    data: TransferActionData | StakeActionData | VoteActionData;
}
interface EosTransactionPrebuild {
    recipients: Recipient[];
    headers: EosTransactionHeaders;
    txHex: string;
    transaction: EosTx;
    txid: string;
    coin: string;
    token?: string;
}
export interface EosSignTransactionParams extends BaseSignTransactionOptions {
    prv: string;
    txPrebuild: EosTransactionPrebuild;
    recipients: Recipient[];
}
export interface EosVerifyTransactionOptions extends BaseVerifyTransactionOptions {
    txPrebuild: EosTransactionPrebuild;
    txParams: EosSignTransactionParams;
    wallet: Wallet;
    verification?: VerificationOptions;
    reqId?: RequestTracer;
}
export interface EosHalfSigned {
    recipients: Recipient[];
    headers: EosTransactionHeaders;
    txHex: string;
    transaction: EosTx;
    txid: string;
}
export interface EosSignedTransaction extends BaseHalfSignedTransaction {
    halfSigned: EosHalfSigned;
}
interface TransferActionData {
    from: string;
    to: string;
    quantity: string;
    memo?: string;
}
interface StakeActionData {
    address: string;
    amount: string;
    from: string;
    receiver: string;
    transfer: number;
    stake_cpu_quantity: string;
}
interface VoteActionData {
    address: string;
    proxy: string;
    producers: string[];
    voter: string;
}
interface ExplainTransactionOptions {
    transaction: {
        packed_trx: string;
    };
    headers: EosTransactionHeaders;
}
interface RecoveryTransaction {
    transaction: EosTx;
    txid: string;
    recoveryAmount: number;
}
interface RecoveryOptions {
    userKey: string;
    backupKey: string;
    bitgoKey?: string;
    recoveryDestination: string;
    krsProvider?: string;
    walletPassphrase?: string;
    rootAddress?: string;
}
interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    rootAddress: string;
}
export declare class Eos extends BaseCoin {
    static VALID_ADDRESS_CHARS: string[];
    static ADDRESS_LENGTH: number;
    static createInstance(bitgo: BitGo): BaseCoin;
    getChainId(): string;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    getBaseFactor(): number;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Get URLs of some active public nodes
     */
    getPublicNodeUrls(): string[];
    /**
     * Generate secp256k1 key pair
     *
     * @param seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub - the pub to be checked
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    isValidPrv(prv: string): boolean;
    /**
     * Evaluates whether a memo is valid
     *
     * @param value - the memo to be checked
     */
    isValidMemo({ value }: {
        value: string;
    }): boolean;
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId - the memo id to be checked
     */
    isValidMemoId(memoId: string): boolean;
    /**
     * Process address into address and memo id
     * @param address - the address
     */
    getAddressDetails(address: string): AddressDetails;
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits: string | number): string;
    /**
     * Validate and return address with appended memo id
     *
     * @param address
     * @param memoId
     */
    normalizeAddress({ address, memoId }: AddressDetails): string;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address - the address to be checked
     */
    isValidAddress(address: string): boolean;
    /**
     * @param address - the address to verify
     * @param rootAddress - the wallet's root address
     * @return true iff address is a wallet address (based on rootAddress)
     */
    isWalletAddress({ address, rootAddress }: VerifyAddressOptions): boolean;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<EosSignedTransaction>}
     */
    signTransaction(params: EosSignTransactionParams): Promise<EosSignedTransaction>;
    private validateStakeActionData;
    private validateUnstakeActionData;
    private static validateVoteActionData;
    private static createTransactionIdHex;
    /**
     * Deserialize a transaction
     * @param transaction
     * @param headers
     */
    private deserializeTransaction;
    /**
     * Explain/parse transaction
     * @param params - ExplainTransactionOptions
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
    /**
     * @deprecated
     */
    initiateRecovery(params: RecoveryOptions): never;
    /**
     * Make a request to one of the public EOS nodes available
     * @param params.endpoint
     * @param params.payload
     */
    protected getDataFromNode(params: {
        endpoint: string;
        payload?: Record<string, unknown>;
    }): Promise<request.Response>;
    /**
     * Get EOS chain info from a public node
     */
    protected getChainInfoFromNode(): Promise<any>;
    /**
     * Get data specific to an account from a public node
     * @param address
     */
    protected getAccountFromNode({ address }: {
        address: string;
    }): Promise<any>;
    /**
     * Get block data from a public node using its block number or block id
     * @param blockNumOrId
     */
    protected getBlockFromNode({ blockNumOrId }: {
        blockNumOrId: string;
    }): Promise<any>;
    /**
     * Get headers for an EOS tx from a public node
     */
    protected getTransactionHeadersFromNode(): Promise<any>;
    protected getTransferAction({ recipient, sender, amount, memo }: any): EosTransactionAction;
    /**
     * Sign a transaction with a key
     * @param signableTx
     * @param signingKey
     */
    signTx(signableTx: string, signingKey: bip32.BIP32Interface): string;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     */
    recover(params: RecoveryOptions): Promise<RecoveryTransaction>;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params used to build the transaction
     * @param params.txPrebuild the prebuilt transaction
     */
    verifyTransaction(params: EosVerifyTransactionOptions): Promise<any>;
    /**
     * Generate a random EOS address.
     *
     * This is just a random string which abides by the EOS adddress constraints,
     * and is not actually checked for availability on the EOS blockchain.
     *
     * Current EOS address constraints are:
     * * Address must be exactly 12 characters
     * * Address must only contain lowercase letters and numbers 1-5
     * @returns a validly formatted EOS address, which may or may not actually be available on chain.
     */
    generateRandomAddress(params: Record<string, never>): string;
}
export {};
//# sourceMappingURL=eos.d.ts.map