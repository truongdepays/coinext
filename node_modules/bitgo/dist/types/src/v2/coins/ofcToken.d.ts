import { BitGo } from '../../bitgo';
import { CoinConstructor } from '../coinFactory';
import { Ofc } from './ofc';
import { SignTransactionOptions as BaseSignTransactionOptions } from '../baseCoin';
import { SignedTransaction } from './eth';
export interface OfcTokenConfig {
    type: string;
    coin: string;
    decimalPlaces: number;
    name: string;
    backingCoin: string;
    isFiat: boolean;
}
export interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: {
        payload: string;
    };
    prv: string;
}
export declare class OfcToken extends Ofc {
    readonly tokenConfig: OfcTokenConfig;
    constructor(bitgo: BitGo, tokenConfig: OfcTokenConfig);
    get coin(): string;
    get decimalPlaces(): number;
    get name(): string;
    get backingCoin(): string;
    get isFiat(): boolean;
    getChain(): string;
    getFullName(): string;
    getBaseFactor(): string;
    get type(): string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    static createTokenConstructor(config: OfcTokenConfig): CoinConstructor;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Check if an address is valid for this ofc token.
     *
     * These addresses are either bg-<publicid>, where public id is the internal address to send to,
     * or are an address which is valid on the backing coin of this ofc token.
     * @param address address to check for validity
     */
    isValidAddress(address?: string): boolean;
}
//# sourceMappingURL=ofcToken.d.ts.map