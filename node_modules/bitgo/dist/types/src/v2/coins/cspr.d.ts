/// <reference types="node" />
import { BaseCoin, KeyPair, SignedTransaction, VerifyTransactionOptions, SignTransactionOptions as BaseSignTransactionOptions, TransactionPrebuild as BaseTransactionPrebuild, TransactionExplanation, ParseTransactionOptions, ParsedTransaction, VerifyAddressOptions as BaseVerifyAddressOptions } from '../baseCoin';
import { BitGo } from '../../bitgo';
import { BaseCoin as StaticsBaseCoin, CoinFamily } from '@bitgo/statics';
interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txHex: string;
}
export interface TransactionFee {
    gasLimit: string;
    gasPrice: string;
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    feeInfo: TransactionFee;
}
interface SupplementGenerateWalletOptions {
    rootPrivateKey?: string;
}
interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    rootAddress: string;
}
export declare class Cspr extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    constructor(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGo, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    getChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    getBaseFactor(): string | number;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * Check if address is valid, then make sure it matches the root address.
     *
     * @param {VerifyAddressOptions} params address and rootAddress to verify
     */
    isWalletAddress(params: VerifyAddressOptions): boolean;
    /**
     * Generate Casper key pair - BitGo xpub format
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated xpub and xprv
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv: string): boolean;
    /**
     * Return boolean indicating whether input is valid CSPR address
     *
     * @param address the pub to be checked
     * @returns true if the address is valid
     */
    isValidAddress(address: string): boolean;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param {SignTransactionOptions} params data required to rebuild and sign the transaction
     * @param {TransactionPrebuild} params.txPrebuild prebuild object returned by platform
     * @param {String} params.prv user prv used to sign the transaction
     * @returns Bluebird<SignedTransaction>
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Extend walletParams with extra params required for generating a Casper wallet
     *
     * Casper wallets have three three keys, user, backup and bitgo.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root private key is not provided, a random one is generated.
     * The root public key is the basis for the wallet root address.
     */
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions): Promise<SupplementGenerateWalletOptions>;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Explain a Casper transaction from Raw Tx
     *
     * @param {ExplainTransactionOptions} params given explain transaction params
     * @param {String} params.txHex raw transaction
     * @param {String} params.halfSigned.txHex raw half signed transaction
     * @param {TransactionFee} fee fee information
     * @returns Bluebird<TransactionExplanation>
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
}
export {};
//# sourceMappingURL=cspr.d.ts.map