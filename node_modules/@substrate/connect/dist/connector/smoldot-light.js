import { getSpec } from "./specs/index.js";
import { AlreadyDestroyedError, CrashError, JsonRpcDisabledError, } from "./types.js";
let startPromise = null;
const getStart = () => {
    if (startPromise)
        return startPromise;
    startPromise = import("@substrate/smoldot-light").then((sm) => sm.start);
    return startPromise;
};
let clientNumReferences = 0;
let clientPromise = null;
const getClientAndIncRef = () => {
    if (clientPromise) {
        clientNumReferences += 1;
        return clientPromise;
    }
    clientPromise = getStart().then((start) => start({
        forbidTcp: true,
        forbidNonLocalWs: true,
        maxLogLevel: 4 /* no debug/trace messages */,
    }));
    clientNumReferences += 1;
    return clientPromise;
};
const transformErrors = (thunk) => {
    try {
        thunk();
    }
    catch (e) {
        const error = e;
        if ((error === null || error === void 0 ? void 0 : error.name) === "JsonRpcDisabledError")
            throw new JsonRpcDisabledError();
        if ((error === null || error === void 0 ? void 0 : error.name) === "CrashError")
            throw new CrashError(error.message);
        if ((error === null || error === void 0 ? void 0 : error.name) === "AlreadyDestroyedError")
            throw new AlreadyDestroyedError();
        throw new CrashError(e instanceof Error ? e.message : `Unexpected error ${e}`);
    }
};
/**
 * Returns a {ScClient} that connects to chains by executing a light client directly
 * from JavaScript.
 *
 * This is quite expensive in terms of CPU, but it is the only choice when the substrate-connect
 * extension is not installed.
 */
export const createScClient = () => {
    const chains = new Map();
    const addChain = async (chainSpec, jsonRpcCallback) => {
        const client = await getClientAndIncRef();
        try {
            const internalChain = await client.addChain({
                chainSpec,
                potentialRelayChains: [...chains.values()],
                jsonRpcCallback,
            });
            const chain = {
                sendJsonRpc: (rpc) => {
                    transformErrors(() => {
                        internalChain.sendJsonRpc(rpc);
                    });
                },
                remove: () => {
                    if (chains.has(chain)) {
                        chains.delete(chain);
                        if (--clientNumReferences === 0) {
                            clientPromise = null;
                            client.terminate();
                        }
                    }
                    transformErrors(() => {
                        internalChain.remove();
                    });
                },
            };
            chains.set(chain, internalChain);
            return chain;
        }
        catch (error) {
            if (--clientNumReferences === 0) {
                clientPromise = null;
                client.terminate();
            }
            throw error;
        }
    };
    const addWellKnownChain = async (supposedChain, jsonRpcCallback) => {
        // the following line ensures that the http request for the dynamic import
        // of smoldot-light and the request for the dynamic import of the spec
        // happen in parallel
        getClientAndIncRef();
        try {
            const spec = await getSpec(supposedChain);
            return await addChain(spec, jsonRpcCallback);
        }
        finally {
            if (--clientNumReferences === 0) {
                clientPromise === null || clientPromise === void 0 ? void 0 : clientPromise.then((client) => client.terminate());
                clientPromise = null;
            }
        }
    };
    return { addChain, addWellKnownChain };
};
//# sourceMappingURL=smoldot-light.js.map