import { intToBigInt, intToBytes } from '@stacks/common';
import { PostConditionType, FungibleConditionCode, NonFungibleConditionCode, StacksMessageType, } from './constants';
import { BufferArray } from './utils';
import { serializeAssetInfo, deserializeAssetInfo, serializePrincipal, deserializePrincipal, parseAssetInfoString, parsePrincipalString, } from './types';
import { serializeCV, deserializeCV } from './clarity';
import { DeserializationError } from './errors';
export function createSTXPostCondition(principal, conditionCode, amount) {
    if (typeof principal === 'string') {
        principal = parsePrincipalString(principal);
    }
    return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.STX,
        principal,
        conditionCode,
        amount: intToBigInt(amount, false),
    };
}
export function createFungiblePostCondition(principal, conditionCode, amount, assetInfo) {
    if (typeof principal === 'string') {
        principal = parsePrincipalString(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = parseAssetInfoString(assetInfo);
    }
    return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.Fungible,
        principal,
        conditionCode,
        amount: intToBigInt(amount, false),
        assetInfo,
    };
}
export function createNonFungiblePostCondition(principal, conditionCode, assetInfo, assetName) {
    if (typeof principal === 'string') {
        principal = parsePrincipalString(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = parseAssetInfoString(assetInfo);
    }
    return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.NonFungible,
        principal,
        conditionCode,
        assetInfo,
        assetName,
    };
}
export function serializePostCondition(postCondition) {
    const bufferArray = new BufferArray();
    bufferArray.appendByte(postCondition.conditionType);
    bufferArray.push(serializePrincipal(postCondition.principal));
    if (postCondition.conditionType === PostConditionType.Fungible ||
        postCondition.conditionType === PostConditionType.NonFungible) {
        bufferArray.push(serializeAssetInfo(postCondition.assetInfo));
    }
    if (postCondition.conditionType === PostConditionType.NonFungible) {
        bufferArray.push(serializeCV(postCondition.assetName));
    }
    bufferArray.appendByte(postCondition.conditionCode);
    if (postCondition.conditionType === PostConditionType.STX ||
        postCondition.conditionType === PostConditionType.Fungible) {
        bufferArray.push(intToBytes(postCondition.amount, false, 8));
    }
    return bufferArray.concatBuffer();
}
export function deserializePostCondition(bufferReader) {
    const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {
        throw new DeserializationError(`Could not read ${n} as PostConditionType`);
    });
    const principal = deserializePrincipal(bufferReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case PostConditionType.STX:
            conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {
                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
            return {
                type: StacksMessageType.PostCondition,
                conditionType: PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case PostConditionType.Fungible:
            assetInfo = deserializeAssetInfo(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {
                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
            return {
                type: StacksMessageType.PostCondition,
                conditionType: PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case PostConditionType.NonFungible:
            assetInfo = deserializeAssetInfo(bufferReader);
            const assetName = deserializeCV(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {
                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: StacksMessageType.PostCondition,
                conditionType: PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}
//# sourceMappingURL=postcondition.js.map