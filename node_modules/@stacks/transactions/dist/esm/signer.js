import { isSingleSig } from './authorization';
import { cloneDeep } from './utils';
import { AuthType } from './constants';
import { SigningError } from './errors';
export class TransactionSigner {
    constructor(transaction) {
        this.transaction = transaction;
        this.sigHash = transaction.signBegin();
        this.originDone = false;
        this.checkOversign = true;
        this.checkOverlap = true;
    }
    static createSponsorSigner(transaction, spendingCondition) {
        if (transaction.auth.authType != AuthType.Sponsored) {
            throw new SigningError('Cannot add sponsor to non-sponsored transaction');
        }
        const tx = cloneDeep(transaction);
        tx.setSponsor(spendingCondition);
        const originSigHash = tx.verifyOrigin();
        const signer = new this(tx);
        signer.originDone = true;
        signer.sigHash = originSigHash;
        signer.checkOversign = true;
        signer.checkOverlap = true;
        return signer;
    }
    signOrigin(privateKey) {
        if (this.checkOverlap && this.originDone) {
            throw new SigningError('Cannot sign origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new SigningError('"transaction.auth.spendingCondition" is undefined');
        }
        if (!isSingleSig(this.transaction.auth.spendingCondition)) {
            const spendingCondition = this.transaction.auth.spendingCondition;
            if (this.checkOversign &&
                spendingCondition.fields.length >= spendingCondition.signaturesRequired) {
                throw new Error('Origin would have too many signatures');
            }
        }
        const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
        this.sigHash = nextSighash;
    }
    appendOrigin(publicKey) {
        if (this.checkOverlap && this.originDone) {
            throw Error('Cannot append public key to origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new Error('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new Error('"transaction.auth.spendingCondition" is undefined');
        }
        this.transaction.appendPubkey(publicKey);
    }
    signSponsor(privateKey) {
        if (this.transaction.auth === undefined) {
            throw new SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.sponsorSpendingCondition === undefined) {
            throw new SigningError('"transaction.auth.spendingCondition" is undefined');
        }
        const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
        this.sigHash = nextSighash;
        this.originDone = true;
    }
    getTxInComplete() {
        return cloneDeep(this.transaction);
    }
    resume(transaction) {
        this.transaction = cloneDeep(transaction);
        this.sigHash = transaction.signBegin();
    }
}
//# sourceMappingURL=signer.js.map