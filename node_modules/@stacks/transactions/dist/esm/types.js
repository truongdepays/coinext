import { Buffer } from '@stacks/common';
import { MAX_STRING_LENGTH_BYTES, MEMO_MAX_LENGTH_BYTES, AddressHashMode, AddressVersion, TransactionVersion, StacksMessageType, PostConditionPrincipalID, } from './constants';
import { serializePublicKey, deserializePublicKey, isCompressed } from './keys';
import { BufferArray, intToHexString, hexStringToInt, exceedsMaxLengthBytes, hashP2PKH, rightPadHexToLength, hashP2SH, } from './utils';
import { c32addressDecode, c32address } from 'c32check';
import { serializePostCondition, deserializePostCondition } from './postcondition';
import { deserializePayload, serializePayload } from './payload';
import { DeserializationError } from './errors';
import { deserializeTransactionAuthField, deserializeMessageSignature, serializeMessageSignature, serializeTransactionAuthField, } from './authorization';
export function serializeStacksMessage(message) {
    switch (message.type) {
        case StacksMessageType.Address:
            return serializeAddress(message);
        case StacksMessageType.Principal:
            return serializePrincipal(message);
        case StacksMessageType.LengthPrefixedString:
            return serializeLPString(message);
        case StacksMessageType.MemoString:
            return serializeMemoString(message);
        case StacksMessageType.AssetInfo:
            return serializeAssetInfo(message);
        case StacksMessageType.PostCondition:
            return serializePostCondition(message);
        case StacksMessageType.PublicKey:
            return serializePublicKey(message);
        case StacksMessageType.LengthPrefixedList:
            return serializeLPList(message);
        case StacksMessageType.Payload:
            return serializePayload(message);
        case StacksMessageType.TransactionAuthField:
            return serializeTransactionAuthField(message);
        case StacksMessageType.MessageSignature:
            return serializeMessageSignature(message);
    }
}
export function deserializeStacksMessage(bufferReader, type, listType) {
    switch (type) {
        case StacksMessageType.Address:
            return deserializeAddress(bufferReader);
        case StacksMessageType.Principal:
            return deserializePrincipal(bufferReader);
        case StacksMessageType.LengthPrefixedString:
            return deserializeLPString(bufferReader);
        case StacksMessageType.MemoString:
            return deserializeMemoString(bufferReader);
        case StacksMessageType.AssetInfo:
            return deserializeAssetInfo(bufferReader);
        case StacksMessageType.PostCondition:
            return deserializePostCondition(bufferReader);
        case StacksMessageType.PublicKey:
            return deserializePublicKey(bufferReader);
        case StacksMessageType.Payload:
            return deserializePayload(bufferReader);
        case StacksMessageType.LengthPrefixedList:
            if (!listType) {
                throw new DeserializationError('No List Type specified');
            }
            return deserializeLPList(bufferReader, listType);
        case StacksMessageType.MessageSignature:
            return deserializeMessageSignature(bufferReader);
        default:
            throw new Error('Could not recognize StacksMessageType');
    }
}
export function createAddress(c32AddressString) {
    const addressData = c32addressDecode(c32AddressString);
    return {
        type: StacksMessageType.Address,
        version: addressData[0],
        hash160: addressData[1],
    };
}
export function createEmptyAddress() {
    return {
        type: StacksMessageType.Address,
        version: AddressVersion.MainnetSingleSig,
        hash160: '0'.repeat(40),
    };
}
export function addressFromVersionHash(version, hash) {
    return { type: StacksMessageType.Address, version, hash160: hash };
}
export function addressHashModeToVersion(hashMode, txVersion) {
    switch (hashMode) {
        case AddressHashMode.SerializeP2PKH:
            switch (txVersion) {
                case TransactionVersion.Mainnet:
                    return AddressVersion.MainnetSingleSig;
                case TransactionVersion.Testnet:
                    return AddressVersion.TestnetSingleSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        case AddressHashMode.SerializeP2SH:
        case AddressHashMode.SerializeP2WPKH:
        case AddressHashMode.SerializeP2WSH:
            switch (txVersion) {
                case TransactionVersion.Mainnet:
                    return AddressVersion.MainnetMultiSig;
                case TransactionVersion.Testnet:
                    return AddressVersion.TestnetMultiSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        default:
            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);
    }
}
export function addressFromHashMode(hashMode, txVersion, data) {
    const version = addressHashModeToVersion(hashMode, txVersion);
    return addressFromVersionHash(version, data);
}
export function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
        throw Error('Invalid number of public keys');
    }
    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
        if (publicKeys.length !== 1 || numSigs !== 1) {
            throw Error('Invalid number of public keys or signatures');
        }
    }
    if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {
        for (let i = 0; i < publicKeys.length; i++) {
            if (!isCompressed(publicKeys[i])) {
                throw Error('Public keys must be compressed for segwit');
            }
        }
    }
    switch (hashMode) {
        case AddressHashMode.SerializeP2PKH:
            return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));
        case AddressHashMode.SerializeP2SH:
            return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));
        default:
            throw Error(`Not yet implemented: address construction using public keys for hash mode: ${hashMode}`);
    }
}
export function addressToString(address) {
    return c32address(address.version, address.hash160).toString();
}
export function serializeAddress(address) {
    const bufferArray = new BufferArray();
    bufferArray.appendHexString(intToHexString(address.version, 1));
    bufferArray.appendHexString(address.hash160);
    return bufferArray.concatBuffer();
}
export function deserializeAddress(bufferReader) {
    const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));
    const data = bufferReader.readBuffer(20).toString('hex');
    return { type: StacksMessageType.Address, version, hash160: data };
}
export function parsePrincipalString(principalString) {
    if (principalString.includes('.')) {
        const [address, contractName] = principalString.split('.');
        return createContractPrincipal(address, contractName);
    }
    else {
        return createStandardPrincipal(principalString);
    }
}
export function createStandardPrincipal(addressString) {
    const addr = createAddress(addressString);
    return {
        type: StacksMessageType.Principal,
        prefix: PostConditionPrincipalID.Standard,
        address: addr,
    };
}
export function createContractPrincipal(addressString, contractName) {
    const addr = createAddress(addressString);
    const name = createLPString(contractName);
    return {
        type: StacksMessageType.Principal,
        prefix: PostConditionPrincipalID.Contract,
        address: addr,
        contractName: name,
    };
}
export function serializePrincipal(principal) {
    const bufferArray = new BufferArray();
    bufferArray.push(Buffer.from([principal.prefix]));
    bufferArray.push(serializeAddress(principal.address));
    if (principal.prefix === PostConditionPrincipalID.Contract) {
        bufferArray.push(serializeLPString(principal.contractName));
    }
    return bufferArray.concatBuffer();
}
export function deserializePrincipal(bufferReader) {
    const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {
        throw new DeserializationError('Unexpected Principal payload type: ${n}');
    });
    const address = deserializeAddress(bufferReader);
    if (prefix === PostConditionPrincipalID.Standard) {
        return { type: StacksMessageType.Principal, prefix, address };
    }
    const contractName = deserializeLPString(bufferReader);
    return {
        type: StacksMessageType.Principal,
        prefix,
        address,
        contractName,
    };
}
export function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
    const prefixLength = lengthPrefixBytes || 1;
    const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;
    if (exceedsMaxLengthBytes(content, maxLength)) {
        throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);
    }
    return {
        type: StacksMessageType.LengthPrefixedString,
        content,
        lengthPrefixBytes: prefixLength,
        maxLengthBytes: maxLength,
    };
}
export function serializeLPString(lps) {
    const bufferArray = new BufferArray();
    const contentBuffer = Buffer.from(lps.content);
    const length = contentBuffer.byteLength;
    bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));
    bufferArray.push(contentBuffer);
    return bufferArray.concatBuffer();
}
export function deserializeLPString(bufferReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));
    const content = bufferReader.readBuffer(length).toString();
    return createLPString(content, prefixBytes, maxLength !== null && maxLength !== void 0 ? maxLength : 128);
}
export function codeBodyString(content) {
    return createLPString(content, 4, 100000);
}
export function createMemoString(content) {
    if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {
        throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);
    }
    return { type: StacksMessageType.MemoString, content };
}
export function serializeMemoString(memoString) {
    const bufferArray = new BufferArray();
    const contentBuffer = Buffer.from(memoString.content);
    const paddedContent = rightPadHexToLength(contentBuffer.toString('hex'), MEMO_MAX_LENGTH_BYTES * 2);
    bufferArray.push(Buffer.from(paddedContent, 'hex'));
    return bufferArray.concatBuffer();
}
export function deserializeMemoString(bufferReader) {
    const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();
    return { type: StacksMessageType.MemoString, content };
}
export function parseAssetInfoString(id) {
    const [assetAddress, assetContractName, assetTokenName] = id.split(/\.|::/);
    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
    return assetInfo;
}
export function createAssetInfo(addressString, contractName, assetName) {
    return {
        type: StacksMessageType.AssetInfo,
        address: createAddress(addressString),
        contractName: createLPString(contractName),
        assetName: createLPString(assetName),
    };
}
export function serializeAssetInfo(info) {
    const bufferArray = new BufferArray();
    bufferArray.push(serializeAddress(info.address));
    bufferArray.push(serializeLPString(info.contractName));
    bufferArray.push(serializeLPString(info.assetName));
    return bufferArray.concatBuffer();
}
export function deserializeAssetInfo(bufferReader) {
    return {
        type: StacksMessageType.AssetInfo,
        address: deserializeAddress(bufferReader),
        contractName: deserializeLPString(bufferReader),
        assetName: deserializeLPString(bufferReader),
    };
}
export function createLPList(values, lengthPrefixBytes) {
    return {
        type: StacksMessageType.LengthPrefixedList,
        lengthPrefixBytes: lengthPrefixBytes || 4,
        values,
    };
}
export function serializeLPList(lpList) {
    const list = lpList.values;
    const bufferArray = new BufferArray();
    bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));
    for (let index = 0; index < list.length; index++) {
        bufferArray.push(serializeStacksMessage(list[index]));
    }
    return bufferArray.concatBuffer();
}
export function deserializeLPList(bufferReader, type, lengthPrefixBytes) {
    const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));
    const l = [];
    for (let index = 0; index < length; index++) {
        switch (type) {
            case StacksMessageType.Address:
                l.push(deserializeAddress(bufferReader));
                break;
            case StacksMessageType.LengthPrefixedString:
                l.push(deserializeLPString(bufferReader));
                break;
            case StacksMessageType.MemoString:
                l.push(deserializeMemoString(bufferReader));
                break;
            case StacksMessageType.AssetInfo:
                l.push(deserializeAssetInfo(bufferReader));
                break;
            case StacksMessageType.PostCondition:
                l.push(deserializePostCondition(bufferReader));
                break;
            case StacksMessageType.PublicKey:
                l.push(deserializePublicKey(bufferReader));
                break;
            case StacksMessageType.TransactionAuthField:
                l.push(deserializeTransactionAuthField(bufferReader));
                break;
        }
    }
    return createLPList(l, lengthPrefixBytes);
}
//# sourceMappingURL=types.js.map