"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SponsoredAuthorization = exports.StandardAuthorization = exports.Authorization = exports.nextVerification = exports.nextSignature = exports.makeSigHashPreSign = exports.deserializeSpendingCondition = exports.serializeSpendingCondition = exports.deserializeMultiSigSpendingCondition = exports.deserializeSingleSigSpendingCondition = exports.serializeMultiSigSpendingCondition = exports.serializeSingleSigSpendingCondition = exports.isSingleSig = exports.createMultiSigSpendingCondition = exports.createSingleSigSpendingCondition = exports.deserializeTransactionAuthField = exports.serializeTransactionAuthField = exports.createTransactionAuthField = exports.deserializeMessageSignature = exports.serializeMessageSignature = exports.emptyMessageSignature = exports.createMessageSignature = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const types_1 = require("./types");
const keys_1 = require("./keys");
const errors_1 = require("./errors");
class Deserializable {
    static deserialize(bufferReader) {
        const message = new this();
        message.deserialize(bufferReader);
        return message;
    }
}
function createMessageSignature(signature) {
    const length = common_1.Buffer.from(signature, 'hex').byteLength;
    if (length != constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
        throw Error('Invalid signature');
    }
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: signature,
    };
}
exports.createMessageSignature = createMessageSignature;
function emptyMessageSignature() {
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: common_1.Buffer.alloc(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),
    };
}
exports.emptyMessageSignature = emptyMessageSignature;
function serializeMessageSignature(messageSignature) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString(messageSignature.data);
    return bufferArray.concatBuffer();
}
exports.serializeMessageSignature = serializeMessageSignature;
function deserializeMessageSignature(bufferReader) {
    return createMessageSignature(bufferReader.readBuffer(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));
}
exports.deserializeMessageSignature = deserializeMessageSignature;
var AuthFieldType;
(function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
    AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
    AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
    AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (AuthFieldType = {}));
function createTransactionAuthField(pubKeyEncoding, contents) {
    return {
        pubKeyEncoding,
        type: constants_1.StacksMessageType.TransactionAuthField,
        contents,
    };
}
exports.createTransactionAuthField = createTransactionAuthField;
function serializeTransactionAuthField(field) {
    const bufferArray = new utils_1.BufferArray();
    switch (field.contents.type) {
        case constants_1.StacksMessageType.PublicKey:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);
                bufferArray.push(keys_1.serializePublicKey(field.contents));
            }
            else {
                bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);
                bufferArray.push(keys_1.serializePublicKey(keys_1.compressPublicKey(field.contents.data)));
            }
            break;
        case constants_1.StacksMessageType.MessageSignature:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bufferArray.appendByte(AuthFieldType.SignatureCompressed);
            }
            else {
                bufferArray.appendByte(AuthFieldType.SignatureUncompressed);
            }
            bufferArray.push(serializeMessageSignature(field.contents));
            break;
    }
    return bufferArray.concatBuffer();
}
exports.serializeTransactionAuthField = serializeTransactionAuthField;
function deserializeTransactionAuthField(bufferReader) {
    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as AuthFieldType`);
    });
    switch (authFieldType) {
        case AuthFieldType.PublicKeyCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, keys_1.deserializePublicKey(bufferReader));
        case AuthFieldType.PublicKeyUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, keys_1.deserializePublicKey(bufferReader));
        case AuthFieldType.SignatureCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));
        case AuthFieldType.SignatureUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));
        default:
            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
    }
}
exports.deserializeTransactionAuthField = deserializeTransactionAuthField;
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
    const signer = types_1.addressFromPublicKeys(0, hashMode, 1, [keys_1.createStacksPublicKey(pubKey)]).hash160;
    const keyEncoding = keys_1.isCompressed(keys_1.createStacksPublicKey(pubKey))
        ? constants_1.PubKeyEncoding.Compressed
        : constants_1.PubKeyEncoding.Uncompressed;
    return {
        hashMode,
        signer,
        nonce: common_1.intToBigInt(nonce, false),
        fee: common_1.intToBigInt(fee, false),
        keyEncoding,
        signature: emptyMessageSignature(),
    };
}
exports.createSingleSigSpendingCondition = createSingleSigSpendingCondition;
function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
    const stacksPublicKeys = pubKeys.map(keys_1.createStacksPublicKey);
    const signer = types_1.addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;
    return {
        hashMode,
        signer,
        nonce: common_1.intToBigInt(nonce, false),
        fee: common_1.intToBigInt(fee, false),
        fields: [],
        signaturesRequired: numSigs,
    };
}
exports.createMultiSigSpendingCondition = createMultiSigSpendingCondition;
function isSingleSig(condition) {
    return 'signature' in condition;
}
exports.isSingleSig = isSingleSig;
function clearCondition(condition) {
    const cloned = utils_1.cloneDeep(condition);
    cloned.nonce = 0;
    cloned.fee = 0;
    if (isSingleSig(cloned)) {
        cloned.signature = emptyMessageSignature();
    }
    else {
        cloned.fields = [];
    }
    return Object.assign(Object.assign({}, cloned), { nonce: BigInt(0), fee: BigInt(0) });
}
function serializeSingleSigSpendingCondition(condition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(condition.hashMode);
    bufferArray.appendHexString(condition.signer);
    bufferArray.push(common_1.intToBytes(condition.nonce, false, 8));
    bufferArray.push(common_1.intToBytes(condition.fee, false, 8));
    bufferArray.appendByte(condition.keyEncoding);
    bufferArray.push(serializeMessageSignature(condition.signature));
    return bufferArray.concatBuffer();
}
exports.serializeSingleSigSpendingCondition = serializeSingleSigSpendingCondition;
function serializeMultiSigSpendingCondition(condition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(condition.hashMode);
    bufferArray.appendHexString(condition.signer);
    bufferArray.push(common_1.intToBytes(condition.nonce, false, 8));
    bufferArray.push(common_1.intToBytes(condition.fee, false, 8));
    const fields = types_1.createLPList(condition.fields);
    bufferArray.push(types_1.serializeLPList(fields));
    const numSigs = common_1.Buffer.alloc(2);
    numSigs.writeUInt16BE(condition.signaturesRequired, 0);
    bufferArray.push(numSigs);
    return bufferArray.concatBuffer();
}
exports.serializeMultiSigSpendingCondition = serializeMultiSigSpendingCondition;
function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {
    const signer = bufferReader.readBuffer(20).toString('hex');
    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
    const keyEncoding = bufferReader.readUInt8Enum(constants_1.PubKeyEncoding, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as PubKeyEncoding`);
    });
    const signature = deserializeMessageSignature(bufferReader);
    return {
        hashMode,
        signer,
        nonce,
        fee,
        keyEncoding,
        signature,
    };
}
exports.deserializeSingleSigSpendingCondition = deserializeSingleSigSpendingCondition;
function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {
    const signer = bufferReader.readBuffer(20).toString('hex');
    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
    const fields = types_1.deserializeLPList(bufferReader, constants_1.StacksMessageType.TransactionAuthField)
        .values;
    const signaturesRequired = bufferReader.readUInt16BE();
    return {
        hashMode,
        signer,
        nonce,
        fee,
        fields,
        signaturesRequired,
    };
}
exports.deserializeMultiSigSpendingCondition = deserializeMultiSigSpendingCondition;
function serializeSpendingCondition(condition) {
    if (isSingleSig(condition)) {
        return serializeSingleSigSpendingCondition(condition);
    }
    else {
        return serializeMultiSigSpendingCondition(condition);
    }
}
exports.serializeSpendingCondition = serializeSpendingCondition;
function deserializeSpendingCondition(bufferReader) {
    const hashMode = bufferReader.readUInt8Enum(constants_1.AddressHashMode, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as AddressHashMode`);
    });
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        return deserializeSingleSigSpendingCondition(hashMode, bufferReader);
    }
    else {
        return deserializeMultiSigSpendingCondition(hashMode, bufferReader);
    }
}
exports.deserializeSpendingCondition = deserializeSpendingCondition;
function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
    const hashLength = 32 + 1 + 8 + 8;
    const sigHash = curSigHash +
        common_1.Buffer.from([authType]).toString('hex') +
        common_1.intToBytes(fee, false, 8).toString('hex') +
        common_1.intToBytes(nonce, false, 8).toString('hex');
    if (common_1.Buffer.from(sigHash, 'hex').byteLength !== hashLength) {
        throw Error('Invalid signature hash length');
    }
    return utils_1.txidFromData(common_1.Buffer.from(sigHash, 'hex'));
}
exports.makeSigHashPreSign = makeSigHashPreSign;
function makeSigHashPostSign(curSigHash, pubKey, signature) {
    const hashLength = 32 + 1 + constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
    const pubKeyEncoding = keys_1.isCompressed(pubKey)
        ? constants_1.PubKeyEncoding.Compressed
        : constants_1.PubKeyEncoding.Uncompressed;
    const sigHash = curSigHash + utils_1.leftPadHex(pubKeyEncoding.toString(16)) + signature.data;
    const sigHashBuffer = common_1.Buffer.from(sigHash, 'hex');
    if (sigHashBuffer.byteLength > hashLength) {
        throw Error('Invalid signature hash length');
    }
    return utils_1.txidFromData(sigHashBuffer);
}
function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
    const signature = keys_1.signWithKey(privateKey, sigHashPreSign);
    const publicKey = keys_1.getPublicKey(privateKey);
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
        nextSig: signature,
        nextSigHash,
    };
}
exports.nextSignature = nextSignature;
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
    const publicKey = keys_1.createStacksPublicKey(keys_1.publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
        pubKey: publicKey,
        nextSigHash,
    };
}
exports.nextVerification = nextVerification;
function newInitialSigHash() {
    const spendingCondition = createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, '', 0, 0);
    spendingCondition.signer = types_1.createEmptyAddress().hash160;
    spendingCondition.keyEncoding = constants_1.PubKeyEncoding.Compressed;
    spendingCondition.signature = emptyMessageSignature();
    return spendingCondition;
}
function verify(condition, initialSigHash, authType) {
    if (isSingleSig(condition)) {
        return verifySingleSig(condition, initialSigHash, authType);
    }
    else {
        return '';
    }
}
function verifySingleSig(condition, initialSigHash, authType) {
    const { nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);
    return nextSigHash;
}
class Authorization extends Deserializable {
    constructor(authType, spendingConditions, sponsorSpendingCondition) {
        super();
        this.authType = authType;
        if (spendingConditions) {
            this.spendingCondition = Object.assign(Object.assign({}, spendingConditions), { nonce: common_1.intToBigInt(spendingConditions.nonce, false), fee: common_1.intToBigInt(spendingConditions.fee, false) });
        }
        if (sponsorSpendingCondition) {
            this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: common_1.intToBigInt(sponsorSpendingCondition.nonce, false), fee: common_1.intToBigInt(sponsorSpendingCondition.fee, false) });
        }
    }
    intoInitialSighashAuth() {
        if (this.spendingCondition) {
            switch (this.authType) {
                case constants_1.AuthType.Standard:
                    return new Authorization(constants_1.AuthType.Standard, clearCondition(this.spendingCondition));
                case constants_1.AuthType.Sponsored:
                    return new Authorization(constants_1.AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());
                default:
                    throw new errors_1.SigningError('Unexpected authorization type for signing');
            }
        }
        throw new Error('Authorization missing SpendingCondition');
    }
    setFee(amount) {
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                this.spendingCondition.fee = common_1.intToBigInt(amount, false);
                break;
            case constants_1.AuthType.Sponsored:
                this.sponsorSpendingCondition.fee = common_1.intToBigInt(amount, false);
                break;
        }
    }
    getFee() {
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                return this.spendingCondition.fee;
            case constants_1.AuthType.Sponsored:
                return this.sponsorSpendingCondition.fee;
            default:
                return BigInt(0);
        }
    }
    setNonce(nonce) {
        this.spendingCondition.nonce = common_1.intToBigInt(nonce, false);
    }
    setSponsorNonce(nonce) {
        this.sponsorSpendingCondition.nonce = common_1.intToBigInt(nonce, false);
    }
    setSponsor(sponsorSpendingCondition) {
        this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: common_1.intToBigInt(sponsorSpendingCondition.nonce, false), fee: common_1.intToBigInt(sponsorSpendingCondition.fee, false) });
    }
    verifyOrigin(initialSigHash) {
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                return verify(this.spendingCondition, initialSigHash, constants_1.AuthType.Standard);
            case constants_1.AuthType.Sponsored:
                return verify(this.spendingCondition, initialSigHash, constants_1.AuthType.Standard);
            default:
                throw new errors_1.SigningError('Invalid origin auth type');
        }
    }
    serialize() {
        const bufferArray = new utils_1.BufferArray();
        if (this.authType === undefined) {
            throw new errors_1.SerializationError('"authType" is undefined');
        }
        bufferArray.appendByte(this.authType);
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                if (this.spendingCondition === undefined) {
                    throw new errors_1.SerializationError('"spendingCondition" is undefined');
                }
                bufferArray.push(serializeSpendingCondition(this.spendingCondition));
                break;
            case constants_1.AuthType.Sponsored:
                if (this.spendingCondition === undefined) {
                    throw new errors_1.SerializationError('"spendingCondition" is undefined');
                }
                if (this.sponsorSpendingCondition === undefined) {
                    throw new errors_1.SerializationError('"spendingCondition" is undefined');
                }
                bufferArray.push(serializeSpendingCondition(this.spendingCondition));
                bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));
                break;
            default:
                throw new errors_1.SerializationError(`Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`);
        }
        return bufferArray.concatBuffer();
    }
    deserialize(bufferReader) {
        this.authType = bufferReader.readUInt8Enum(constants_1.AuthType, n => {
            throw new errors_1.DeserializationError(`Could not parse ${n} as AuthType`);
        });
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                this.spendingCondition = deserializeSpendingCondition(bufferReader);
                break;
            case constants_1.AuthType.Sponsored:
                this.spendingCondition = deserializeSpendingCondition(bufferReader);
                this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);
                break;
            default:
                throw new errors_1.DeserializationError(`Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`);
        }
    }
}
exports.Authorization = Authorization;
class StandardAuthorization extends Authorization {
    constructor(spendingCondition) {
        super(constants_1.AuthType.Standard, spendingCondition);
    }
}
exports.StandardAuthorization = StandardAuthorization;
class SponsoredAuthorization extends Authorization {
    constructor(originSpendingCondition, sponsorSpendingCondition) {
        let sponsorSC = sponsorSpendingCondition;
        if (!sponsorSC) {
            sponsorSC = createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0);
        }
        super(constants_1.AuthType.Sponsored, originSpendingCondition, sponsorSC);
    }
}
exports.SponsoredAuthorization = SponsoredAuthorization;
//# sourceMappingURL=authorization.js.map