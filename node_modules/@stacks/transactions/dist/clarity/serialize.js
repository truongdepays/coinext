"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeCV = void 0;
const common_1 = require("@stacks/common");
const types_1 = require("../types");
const _1 = require(".");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const constants_1 = require("../constants");
const bn_js_1 = __importDefault(require("bn.js"));
function bufferWithTypeID(typeId, buffer) {
    const id = common_1.Buffer.from([typeId]);
    return common_1.Buffer.concat([id, buffer]);
}
function serializeBoolCV(value) {
    return common_1.Buffer.from([value.type]);
}
function serializeOptionalCV(cv) {
    if (cv.type === _1.ClarityType.OptionalNone) {
        return common_1.Buffer.from([cv.type]);
    }
    else {
        return bufferWithTypeID(cv.type, serializeCV(cv.value));
    }
}
function serializeBufferCV(cv) {
    const length = common_1.Buffer.alloc(4);
    length.writeUInt32BE(cv.buffer.length, 0);
    return bufferWithTypeID(cv.type, common_1.Buffer.concat([length, cv.buffer]));
}
function serializeIntCV(cv) {
    const buffer = new bn_js_1.default(cv.value.toString())
        .toTwos(constants_1.CLARITY_INT_SIZE)
        .toArrayLike(common_1.Buffer, 'be', constants_1.CLARITY_INT_BYTE_SIZE);
    return bufferWithTypeID(cv.type, buffer);
}
function serializeUIntCV(cv) {
    const buffer = new bn_js_1.default(cv.value.toString()).toArrayLike(common_1.Buffer, 'be', constants_1.CLARITY_INT_BYTE_SIZE);
    return bufferWithTypeID(cv.type, buffer);
}
function serializeStandardPrincipalCV(cv) {
    return bufferWithTypeID(cv.type, types_1.serializeAddress(cv.address));
}
function serializeContractPrincipalCV(cv) {
    return bufferWithTypeID(cv.type, common_1.Buffer.concat([types_1.serializeAddress(cv.address), types_1.serializeLPString(cv.contractName)]));
}
function serializeResponseCV(cv) {
    return bufferWithTypeID(cv.type, serializeCV(cv.value));
}
function serializeListCV(cv) {
    const buffers = new utils_1.BufferArray();
    const length = common_1.Buffer.alloc(4);
    length.writeUInt32BE(cv.list.length, 0);
    buffers.push(length);
    for (const value of cv.list) {
        const serializedValue = serializeCV(value);
        buffers.push(serializedValue);
    }
    return bufferWithTypeID(cv.type, buffers.concatBuffer());
}
function serializeTupleCV(cv) {
    const buffers = new utils_1.BufferArray();
    const length = common_1.Buffer.alloc(4);
    length.writeUInt32BE(Object.keys(cv.data).length, 0);
    buffers.push(length);
    const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {
        const bufA = common_1.Buffer.from(a);
        const bufB = common_1.Buffer.from(b);
        return bufA.compare(bufB);
    });
    for (const key of lexicographicOrder) {
        const nameWithLength = types_1.createLPString(key);
        buffers.push(types_1.serializeLPString(nameWithLength));
        const serializedValue = serializeCV(cv.data[key]);
        buffers.push(serializedValue);
    }
    return bufferWithTypeID(cv.type, buffers.concatBuffer());
}
function serializeStringCV(cv, encoding) {
    const buffers = new utils_1.BufferArray();
    const str = common_1.Buffer.from(cv.data, encoding);
    const len = common_1.Buffer.alloc(4);
    len.writeUInt32BE(str.length, 0);
    buffers.push(len);
    buffers.push(str);
    return bufferWithTypeID(cv.type, buffers.concatBuffer());
}
function serializeStringAsciiCV(cv) {
    return serializeStringCV(cv, 'ascii');
}
function serializeStringUtf8CV(cv) {
    return serializeStringCV(cv, 'utf8');
}
function serializeCV(value) {
    switch (value.type) {
        case _1.ClarityType.BoolTrue:
        case _1.ClarityType.BoolFalse:
            return serializeBoolCV(value);
        case _1.ClarityType.OptionalNone:
        case _1.ClarityType.OptionalSome:
            return serializeOptionalCV(value);
        case _1.ClarityType.Buffer:
            return serializeBufferCV(value);
        case _1.ClarityType.UInt:
            return serializeUIntCV(value);
        case _1.ClarityType.Int:
            return serializeIntCV(value);
        case _1.ClarityType.PrincipalStandard:
            return serializeStandardPrincipalCV(value);
        case _1.ClarityType.PrincipalContract:
            return serializeContractPrincipalCV(value);
        case _1.ClarityType.ResponseOk:
        case _1.ClarityType.ResponseErr:
            return serializeResponseCV(value);
        case _1.ClarityType.List:
            return serializeListCV(value);
        case _1.ClarityType.Tuple:
            return serializeTupleCV(value);
        case _1.ClarityType.StringASCII:
            return serializeStringAsciiCV(value);
        case _1.ClarityType.StringUTF8:
            return serializeStringUtf8CV(value);
        default:
            throw new errors_1.SerializationError('Unable to serialize. Invalid Clarity Value.');
    }
}
exports.serializeCV = serializeCV;
//# sourceMappingURL=serialize.js.map