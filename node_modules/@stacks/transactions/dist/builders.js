"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sponsorTransaction = exports.callReadOnlyFunction = exports.makeContractNonFungiblePostCondition = exports.makeStandardNonFungiblePostCondition = exports.makeContractFungiblePostCondition = exports.makeStandardFungiblePostCondition = exports.makeContractSTXPostCondition = exports.makeStandardSTXPostCondition = exports.makeContractCall = exports.makeUnsignedContractCall = exports.estimateContractFunctionCall = exports.makeContractDeploy = exports.estimateContractDeploy = exports.makeSTXTokenTransfer = exports.makeUnsignedSTXTokenTransfer = exports.getAbi = exports.broadcastRawTransaction = exports.broadcastTransaction = exports.estimateTransfer = exports.getNonce = void 0;
const common_1 = require("@stacks/common");
const transaction_1 = require("./transaction");
const network_1 = require("@stacks/network");
const payload_1 = require("./payload");
const authorization_1 = require("./authorization");
const keys_1 = require("./keys");
const signer_1 = require("./signer");
const postcondition_1 = require("./postcondition");
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_1 = require("./utils");
const common_2 = require("@stacks/common");
const contract_abi_1 = require("./contract-abi");
const c32check_1 = require("c32check");
async function getNonce(address, network) {
    const defaultNetwork = new network_1.StacksMainnet();
    const url = network
        ? network.getAccountApiUrl(address)
        : defaultNetwork.getAccountApiUrl(address);
    const response = await common_2.fetchPrivate(url);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseText = await response.text();
    const result = JSON.parse(responseText);
    return BigInt(result.nonce);
}
exports.getNonce = getNonce;
async function estimateTransfer(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.TokenTransfer) {
        throw new Error(`Transaction fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.TokenTransfer]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const defaultNetwork = new network_1.StacksMainnet();
    const url = network
        ? network.getTransferFeeEstimateApiUrl()
        : defaultNetwork.getTransferFeeEstimateApiUrl();
    const response = await common_2.fetchPrivate(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = BigInt(transaction.serialize().byteLength);
    const feeRate = BigInt(feeRateResult);
    return feeRate * txBytes;
}
exports.estimateTransfer = estimateTransfer;
async function broadcastTransaction(transaction, network, attachment) {
    const rawTx = transaction.serialize();
    const url = network.getBroadcastApiUrl();
    return broadcastRawTransaction(rawTx, url, attachment);
}
exports.broadcastTransaction = broadcastTransaction;
async function broadcastRawTransaction(rawTx, url, attachment) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },
        body: attachment
            ? JSON.stringify({
                tx: rawTx.toString('hex'),
                attachment: attachment.toString('hex'),
            })
            : rawTx,
    };
    const response = await common_2.fetchPrivate(url, options);
    if (!response.ok) {
        try {
            return (await response.json());
        }
        catch (e) {
            throw Error(`Failed to broadcast transaction: ${e.message}`);
        }
    }
    const text = await response.text();
    const txid = text.replace(/["]+/g, '');
    const isValidTxId = utils_1.validateTxId(txid);
    if (isValidTxId) {
        return {
            txid: txid,
        };
    }
    else {
        throw new Error(text);
    }
}
exports.broadcastRawTransaction = broadcastRawTransaction;
async function getAbi(address, contractName, network) {
    const options = {
        method: 'GET',
    };
    const url = network.getAbiApiUrl(address, contractName);
    const response = await common_2.fetchPrivate(url, options);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return JSON.parse(await response.text());
}
exports.getAbi = getAbi;
async function makeUnsignedSTXTokenTransfer(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        memo: '',
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = payload_1.createTokenTransferPayload(options.recipient, options.amount, options.memo);
    let authorization = null;
    let spendingCondition = null;
    if ('publicKey' in options) {
        spendingCondition = authorization_1.createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = authorization_1.createMultiSigSpendingCondition(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = new authorization_1.SponsoredAuthorization(spendingCondition);
    }
    else {
        authorization = new authorization_1.StandardAuthorization(spendingCondition);
    }
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = types_1.createLPList(postConditions);
    const transaction = new transaction_1.StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const txFee = await estimateTransfer(transaction, options.network);
        transaction.setFee(txFee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = c32check_1.c32address(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedSTXTokenTransfer = makeUnsignedSTXTokenTransfer;
async function makeSTXTokenTransfer(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = keys_1.publicKeyToString(keys_1.getPublicKey(keys_1.createStacksPrivateKey(txOptions.senderKey)));
        const options = utils_1.omit(txOptions, 'senderKey');
        const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({ publicKey }, options));
        const privKey = keys_1.createStacksPrivateKey(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = utils_1.omit(txOptions, 'signerKeys');
        const transaction = await makeUnsignedSTXTokenTransfer(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = keys_1.pubKeyfromPrivKey(key);
            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));
            signer.signOrigin(keys_1.createStacksPrivateKey(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin(keys_1.publicKeyFromBuffer(common_1.Buffer.from(key, 'hex')));
        }
        return transaction;
    }
}
exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
async function estimateContractDeploy(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.SmartContract) {
        throw new Error(`Contract deploy fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.SmartContract]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const defaultNetwork = new network_1.StacksMainnet();
    const url = network
        ? network.getTransferFeeEstimateApiUrl()
        : defaultNetwork.getTransferFeeEstimateApiUrl();
    const response = await common_2.fetchPrivate(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = common_1.intToBigInt(transaction.serialize().byteLength, false);
    const feeRate = common_1.intToBigInt(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractDeploy = estimateContractDeploy;
async function makeContractDeploy(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = payload_1.createSmartContractPayload(options.contractName, options.codeBody);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const privKey = keys_1.createStacksPrivateKey(options.senderKey);
    const pubKey = keys_1.getPublicKey(privKey);
    let authorization = null;
    const spendingCondition = authorization_1.createSingleSigSpendingCondition(addressHashMode, keys_1.publicKeyToString(pubKey), options.nonce, options.fee);
    if (options.sponsored) {
        authorization = new authorization_1.SponsoredAuthorization(spendingCondition);
    }
    else {
        authorization = new authorization_1.StandardAuthorization(spendingCondition);
    }
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = types_1.createLPList(postConditions);
    const transaction = new transaction_1.StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const txFee = await estimateContractDeploy(transaction, options.network);
        transaction.setFee(txFee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = keys_1.publicKeyToAddress(addressVersion, pubKey);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    if (options.senderKey) {
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
    }
    return transaction;
}
exports.makeContractDeploy = makeContractDeploy;
async function estimateContractFunctionCall(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.ContractCall) {
        throw new Error(`Contract call fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.ContractCall]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const defaultNetwork = new network_1.StacksMainnet();
    const url = network
        ? network.getTransferFeeEstimateApiUrl()
        : defaultNetwork.getTransferFeeEstimateApiUrl();
    const response = await common_2.fetchPrivate(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = common_1.intToBigInt(transaction.serialize().byteLength, false);
    const feeRate = common_1.intToBigInt(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractFunctionCall = estimateContractFunctionCall;
async function makeUnsignedContractCall(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = payload_1.createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
    if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {
        let abi;
        if (typeof options.validateWithAbi === 'boolean') {
            if (options === null || options === void 0 ? void 0 : options.network) {
                abi = await getAbi(options.contractAddress, options.contractName, options.network);
            }
            else {
                throw new Error('Network option must be provided in order to validate with ABI');
            }
        }
        else {
            abi = options.validateWithAbi;
        }
        contract_abi_1.validateContractCall(payload, abi);
    }
    let spendingCondition = null;
    let authorization = null;
    if ('publicKey' in options) {
        spendingCondition = authorization_1.createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = authorization_1.createMultiSigSpendingCondition(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = new authorization_1.SponsoredAuthorization(spendingCondition);
    }
    else {
        authorization = new authorization_1.StandardAuthorization(spendingCondition);
    }
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = types_1.createLPList(postConditions);
    const transaction = new transaction_1.StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const txFee = await estimateContractFunctionCall(transaction, options.network);
        transaction.setFee(txFee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = c32check_1.c32address(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractCall = makeUnsignedContractCall;
async function makeContractCall(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = keys_1.publicKeyToString(keys_1.getPublicKey(keys_1.createStacksPrivateKey(txOptions.senderKey)));
        const options = utils_1.omit(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractCall(Object.assign({ publicKey }, options));
        const privKey = keys_1.createStacksPrivateKey(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = utils_1.omit(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractCall(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = keys_1.pubKeyfromPrivKey(key);
            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));
            signer.signOrigin(keys_1.createStacksPrivateKey(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin(keys_1.publicKeyFromBuffer(common_1.Buffer.from(key, 'hex')));
        }
        return transaction;
    }
}
exports.makeContractCall = makeContractCall;
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return postcondition_1.createSTXPostCondition(types_1.createStandardPrincipal(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return postcondition_1.createSTXPostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return postcondition_1.createFungiblePostCondition(types_1.createStandardPrincipal(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return postcondition_1.createFungiblePostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
    return postcondition_1.createNonFungiblePostCondition(types_1.createStandardPrincipal(address), conditionCode, assetInfo, assetName);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
    return postcondition_1.createNonFungiblePostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
async function callReadOnlyFunction(readOnlyFunctionOptions) {
    const defaultOptions = {
        network: new network_1.StacksMainnet(),
    };
    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
    const { contractName, contractAddress, functionName, functionArgs, network, senderAddress } = options;
    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
    const args = functionArgs.map(arg => utils_1.cvToHex(arg));
    const body = JSON.stringify({
        sender: senderAddress,
        arguments: args,
    });
    const response = await common_2.fetchPrivate(url, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return response.json().then(responseJson => utils_1.parseReadOnlyResponse(responseJson));
}
exports.callReadOnlyFunction = callReadOnlyFunction;
async function sponsorTransaction(sponsorOptions) {
    var _a;
    const defaultOptions = {
        fee: 0,
        sponsorNonce: 0,
        sponsorAddressHashmode: constants_1.AddressHashMode.SerializeP2PKH,
    };
    const options = Object.assign(defaultOptions, sponsorOptions);
    const network = (_a = sponsorOptions.network) !== null && _a !== void 0 ? _a : (options.transaction.version === constants_1.TransactionVersion.Mainnet
        ? new network_1.StacksMainnet()
        : new network_1.StacksTestnet());
    const sponsorPubKey = keys_1.pubKeyfromPrivKey(options.sponsorPrivateKey);
    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {
        let txFee = BigInt(0);
        switch (options.transaction.payload.payloadType) {
            case constants_1.PayloadType.TokenTransfer:
                txFee = await estimateTransfer(options.transaction, network);
                break;
            case constants_1.PayloadType.SmartContract:
                txFee = await estimateContractDeploy(options.transaction, network);
                break;
            case constants_1.PayloadType.ContractCall:
                txFee = await estimateContractFunctionCall(options.transaction, network);
                break;
            default:
                throw new Error(`Sponsored transactions not supported for transaction type ${constants_1.PayloadType[options.transaction.payload.payloadType]}`);
        }
        options.transaction.setFee(txFee);
        options.fee = txFee;
    }
    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = keys_1.publicKeyToAddress(addressVersion, sponsorPubKey);
        const sponsorNonce = await getNonce(senderAddress, network);
        options.sponsorNonce = sponsorNonce;
    }
    const sponsorSpendingCondition = authorization_1.createSingleSigSpendingCondition(options.sponsorAddressHashmode, keys_1.publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);
    options.transaction.setSponsor(sponsorSpendingCondition);
    const privKey = keys_1.createStacksPrivateKey(options.sponsorPrivateKey);
    const signer = signer_1.TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
    signer.signSponsor(privKey);
    return options.transaction;
}
exports.sponsorTransaction = sponsorTransaction;
//# sourceMappingURL=builders.js.map