/// <reference types="node" />
import { IntegerType } from '@stacks/common';
import { AuthType, MultiSigHashMode, PubKeyEncoding, SingleSigHashMode, StacksMessageType } from './constants';
import { StacksPrivateKey, StacksPublicKey } from './keys';
import { BufferReader } from './bufferReader';
declare abstract class Deserializable {
    abstract serialize(): Buffer;
    abstract deserialize(bufferReader: BufferReader): void;
    static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T;
}
export interface MessageSignature {
    readonly type: StacksMessageType.MessageSignature;
    data: string;
}
export declare function createMessageSignature(signature: string): MessageSignature;
export declare function emptyMessageSignature(): MessageSignature;
export declare function serializeMessageSignature(messageSignature: MessageSignature): Buffer;
export declare function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature;
export declare type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;
export interface TransactionAuthField {
    type: StacksMessageType.TransactionAuthField;
    pubKeyEncoding: PubKeyEncoding;
    contents: TransactionAuthFieldContents;
}
export declare function createTransactionAuthField(pubKeyEncoding: PubKeyEncoding, contents: TransactionAuthFieldContents): TransactionAuthField;
export declare function serializeTransactionAuthField(field: TransactionAuthField): Buffer;
export declare function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField;
export interface SingleSigSpendingCondition {
    hashMode: SingleSigHashMode;
    signer: string;
    nonce: bigint;
    fee: bigint;
    keyEncoding: PubKeyEncoding;
    signature: MessageSignature;
}
export interface SingleSigSpendingConditionOpts extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {
    nonce: IntegerType;
    fee: IntegerType;
}
export interface MultiSigSpendingCondition {
    hashMode: MultiSigHashMode;
    signer: string;
    nonce: bigint;
    fee: bigint;
    fields: TransactionAuthField[];
    signaturesRequired: number;
}
export interface MultiSigSpendingConditionOpts extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {
    nonce: IntegerType;
    fee: IntegerType;
}
export declare type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;
export declare type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;
export declare function createSingleSigSpendingCondition(hashMode: SingleSigHashMode, pubKey: string, nonce: IntegerType, fee: IntegerType): SingleSigSpendingCondition;
export declare function createMultiSigSpendingCondition(hashMode: MultiSigHashMode, numSigs: number, pubKeys: string[], nonce: IntegerType, fee: IntegerType): MultiSigSpendingCondition;
export declare function isSingleSig(condition: SpendingConditionOpts): condition is SingleSigSpendingConditionOpts;
export declare function serializeSingleSigSpendingCondition(condition: SingleSigSpendingConditionOpts): Buffer;
export declare function serializeMultiSigSpendingCondition(condition: MultiSigSpendingConditionOpts): Buffer;
export declare function deserializeSingleSigSpendingCondition(hashMode: SingleSigHashMode, bufferReader: BufferReader): SingleSigSpendingCondition;
export declare function deserializeMultiSigSpendingCondition(hashMode: MultiSigHashMode, bufferReader: BufferReader): MultiSigSpendingCondition;
export declare function serializeSpendingCondition(condition: SpendingConditionOpts): Buffer;
export declare function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition;
export declare function makeSigHashPreSign(curSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType): string;
export declare function nextSignature(curSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType, privateKey: StacksPrivateKey): {
    nextSig: MessageSignature;
    nextSigHash: string;
};
export declare function nextVerification(initialSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType, pubKeyEncoding: PubKeyEncoding, signature: MessageSignature): {
    pubKey: StacksPublicKey;
    nextSigHash: string;
};
export declare class Authorization extends Deserializable {
    authType?: AuthType;
    spendingCondition?: SpendingCondition;
    sponsorSpendingCondition?: SpendingCondition;
    constructor(authType?: AuthType, spendingConditions?: SpendingConditionOpts, sponsorSpendingCondition?: SpendingConditionOpts);
    intoInitialSighashAuth(): Authorization;
    setFee(amount: IntegerType): void;
    getFee(): bigint;
    setNonce(nonce: IntegerType): void;
    setSponsorNonce(nonce: IntegerType): void;
    setSponsor(sponsorSpendingCondition: SpendingConditionOpts): void;
    verifyOrigin(initialSigHash: string): string;
    serialize(): Buffer;
    deserialize(bufferReader: BufferReader): void;
}
export declare class StandardAuthorization extends Authorization {
    constructor(spendingCondition: SpendingConditionOpts);
}
export declare class SponsoredAuthorization extends Authorization {
    constructor(originSpendingCondition: SpendingConditionOpts, sponsorSpendingCondition?: SpendingConditionOpts);
}
export {};
